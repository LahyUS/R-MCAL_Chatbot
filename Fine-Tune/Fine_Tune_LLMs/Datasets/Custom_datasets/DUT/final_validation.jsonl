{"Input": "/ #if (ADC_FUNCTIONALITY_MODE != ADC_POLLING) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" #if (ADC0_SG0_ISR_API == STD_ON) /* Defines the CAT2 interrupt mapping */ #if defined (Os_ADC0_SG0_CAT2_ISR) || (ADC_ISR_CATEGORY_2 == STD_ON) ISR(ADC0_SG0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ADC_CODE_FAST) ADC0_SG0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif /* defined (Os_ADC0_SG0_CAT2_ISR) || (ADC_ISR_CATEGORY_2 == STD_ON) */ { #if (ADC_INTERRUPT_CONSISTENCY_CHECK == STD_ON) /* Check whether the EIMK bit of EIC is set */ if (ADC_EIC_EIMK == (uint8)((ADC_EIC_ADC0_BASEADDR)[ADC_SCANGROUP_0] & ADC_EIC_EIMK)) /* PRQA S 0303 # JV-01 */ { /* Reporting to DEM that interrupt from unknown source */ ADC_DEM_REPORT_ERROR(ADC_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } else #endif /* (ADC_INTERRUPT_CONSISTENCY_CHECK == STD_ON) */ { /* HW unit 0 and SGx unit 0 */ Adc_Isr(Adc_GpHwUnitIndex[ADC_HWUNIT_0], Adc_GpSgUnitIndex[(ADC_HWUNIT_0 * ADC_NUM_SCANGROUP) + ADC_SCANGROUP_0]); /* PRQA S 2824 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '23 = ADCA_SG3_ISR'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Offset', 'Value': '3'], 'Input_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_ADC0_Test[CURRENT_TEST.Offset]', 'Value': '-'], 'Input_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_ADC1_Test[CURRENT_TEST.Offset]', 'Value': '-'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_ADC2_Test[CURRENT_TEST.Offset]', 'Value': '-'], 'Input_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_ADC3_Test[CURRENT_TEST.Offset]', 'Value': '-'], 'Input_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_ADCA_Test[CURRENT_TEST.Offset]', 'Value': '0x0000'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitIndex', 'Value': '&map_Adc_GpHwUnitIndex[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'map_Adc_GpHwUnitIndex[0 to 4]', 'Value': '[4] = 0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitIndex', 'Value': '&map_Adc_GpSgUnitIndex[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'map_Adc_GpSgUnitIndex[0 to 25]', 'Value': '[23] = 0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '0'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '0'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_AdcInit(const uint8 LucHwUnitIndex) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; /* Initialize the local variable for HW unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Read the user base configuration address of the HW unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; /* PRQA S 2814 # JV-01 */ /* Initialize the device-specific hardware registers of the ADC */ LpAdcRegisters->usADCXnDFASENTSGER = ADC_WORD_ZERO; /* PRQA S 2814 # JV-01 */ LpAdcRegisters->ucADCXnSDVCLMINTER = ADC_BYTE_ZERO; LpAdcRegisters->ulADCXnSGDIAGPCCR0 = ADC_DWORD_ZERO; LpAdcRegisters->ulADCXnSGDIAGPCCR1 = ADC_DWORD_ZERO; LpAdcRegisters->ucADCXnSGDIAGVCR0 = ADC_BYTE_ZERO; LpAdcRegisters->ucADCXnSGDIAGVCR1 = ADC_BYTE_ZERO; LpAdcRegisters->ucADCXnSGDIAGVCR2 = ADC_BYTE_ZERO; LpAdcRegisters->ucADCXnSTPDCR0 = ADC_BYTE_ZERO; LpAdcRegisters->ucADCXnSTPDCR1 = ADC_BYTE_ZERO; LpAdcRegisters->ucADCXnSTPDCR2 = ADC_BYTE_ZERO; LpAdcRegisters->ulADCXnSGDIAGCR = ADC_DWORD_ZERO; #if (ADC_ENABLE_ADC_TSEL == STD_ON) /* Check if HW unit has ADC trigger selection register */ if (NULL_PTR != LpHwUnitConfig->pSgTriggReg) { /* Initialization of ADC trigger selection register */ Adc_HwTriggerInit(LucHwUnitIndex); } /* else: No action required */ #endif /* (ADC_ENABLE_ADC_TSEL == STD_ON) */ #if (ADC_TRACK_AND_HOLD == STD_ON) /* Check if HW unit has Track and Hold groups */ if ((uint8)0U != LpHwUnitConfig->ucTrackHoldEnable) { /* Initialization of Track and Hold */ Adc_TrackHoldInit(LucHwUnitIndex); } /* else: No action required */ #endif /* Check if HW unit has wait time configuration */ if (ADC_WAITTIME_DISABLED != LpHwUnitConfig->ucWaitTimeIndex) { /* Initialization of wait time configuration */ Adc_SetWaitTime(LucHwUnitIndex); } /* else: No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '6'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0 to 10] = &map_pHwUnitBaseAddress[0]'], 'Input_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'usADCXnDFASENTSGER', 'Value': '0x0000'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSDVCLMINTER', 'Value': '0x00'], 'Input_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnSGDIAGPCCR0', 'Value': '0x00000000'], 'Input_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnSGDIAGPCCR1', 'Value': '0x00000000'], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGDIAGVCR0', 'Value': '0x00'], 'Input_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGDIAGVCR1', 'Value': '0x00'], 'Input_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGDIAGVCR2', 'Value': '0x00'], 'Input_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSTPDCR0', 'Value': '0x00'], 'Input_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSTPDCR1', 'Value': '0x00'], 'Input_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSTPDCR2', 'Value': '0x00'], 'Input_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnSGDIAGCR', 'Value': '0x00000000'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pSgTriggReg', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucTrackHoldEnable', 'Value': '0x02'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucWaitTimeIndex', 'Value': '0x04']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'usADCXnDFASENTSGER', 'Value': 'ADC_WORD_ZERO'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSDVCLMINTER', 'Value': 'ADC_BYTE_ZERO'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnSGDIAGPCCR0', 'Value': 'ADC_DWORD_ZERO'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnSGDIAGPCCR1', 'Value': 'ADC_DWORD_ZERO'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGDIAGVCR0', 'Value': 'ADC_BYTE_ZERO'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGDIAGVCR1', 'Value': 'ADC_BYTE_ZERO'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGDIAGVCR2', 'Value': 'ADC_BYTE_ZERO'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSTPDCR0', 'Value': 'ADC_BYTE_ZERO'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSTPDCR1', 'Value': 'ADC_BYTE_ZERO'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSTPDCR2', 'Value': 'ADC_BYTE_ZERO'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnSGDIAGCR', 'Value': 'ADC_DWORD_ZERO'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '6'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '6'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) || \\ (ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) #if ((ADC_FUNCTIONALITY_MODE != ADC_POLLING) || (ADC_READ_GROUP_API == STD_ON) || (ADC_ENABLE_DMA_MODE == STD_ON)) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(boolean, ADC_CODE_FAST) Adc_CheckError(const Adc_GroupType LddGroup) { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) || \\ (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; #endif #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON)) P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; #endif uint8 LucHwUnitIndex; #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON)) uint8 LucErrorVirCh; uint8 LucPhysCh; #endif #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON)) uint8 LucStartVirCh; uint8 LucEndVirCh; #endif #if ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) uint8 LucIderValue; #if (ADC_ENABLE_PWM_DIAG == STD_ON) uint8 LucChannelToGroupIndex; #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #endif #if (ADC_ENABLE_OVERWRITE_ERR == STD_ON) uint8 LucOwerValue; #endif #if (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) uint8 LucSgUnitId; uint8 LucTocerValue; #endif #if (ADC_ENABLE_LIMIT_CHECK == STD_ON) uint32 LulVclmsrValue; uint32 LulRegSel; uint32 LulBitLoc; #endif boolean LblErrorFlag; /* Get the pointer to the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the hardware unit index to which the group belongs */ LucHwUnitIndex = LpGroup->ucHwUnitIndex; /* PRQA S 2814 # JV-01 */ /* Get the pointer to the hardware unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) || \\ (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) /* Get the pointer to the runtime data of the group */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #endif /* Initialize the error flag */ LblErrorFlag = ADC_FALSE; #if ((ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) /* Check if error interrupt is enabled */ if (ADC_TRUE == LpHwUnitConfig->blInterruptErr) /* PRQA S 2814 # JV-01 */ { #if (((((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON)) && \\ (ADC_ENABLE_ERR_INT == STD_ON)) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) /* Read and clear conversion error flag from error interrupt */ LblErrorFlag = LpGroupData->blConvError; /* PRQA S 2814 # JV-01 */ if (ADC_TRUE == LblErrorFlag) { LpGroupData->blConvError = ADC_FALSE; } /* else: No action required */ #endif } else #endif /* ((ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) */ { #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON)) /* Get the base register address of the hardware unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; #endif /* Get the error status */ #if ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) LucIderValue = LpAdcRegisters->ucADCXnIDER; /* PRQA S 2814 # JV-01 */ #endif #if (ADC_ENABLE_OVERWRITE_ERR == STD_ON) LucOwerValue = LpAdcRegisters->ucADCXnOWER; /* PRQA S 2814 # JV-01 */ #endif #if (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) LucTocerValue = LpAdcRegisters->ucADCXnTOCER; #endif #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON)) #if ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF) && (ADC_ENABLE_PWM_DIAG == STD_ON)) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Set the group channel range to PWM-Diag channel */ LucStartVirCh = ADC_ADCX_IDER_IDECAP_PWD; LucEndVirCh = ADC_ADCX_IDER_IDECAP_PWD; } else #endif /* ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF) && (ADC_ENABLE_PWM_DIAG == STD_ON)) */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Get the virtual channel information of the group */ if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) { LucStartVirCh = LpGroup->ucStartVirChPtr + LpGroupData->ucChannelsCompleted; LucEndVirCh = LucStartVirCh; } else #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ { LucStartVirCh = LpGroup->ucStartVirChPtr; LucEndVirCh = (uint8)(LucStartVirCh + LpGroupData->ucChannelCount - ADC_BYTE_ONE); } #endif /* (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON)) */ #if ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) /* Check the Id error status */ if (ADC_BYTE_ZERO != (uint8)(LucIderValue & ADC_ADCX_IDER_IDE)) { /* Get the virtual channel captured due to an Id error */ LucErrorVirCh = (uint8)(LucIderValue & ADC_ADCX_IDER_IDECAP); if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Set the conversion error status */ LblErrorFlag = ADC_TRUE; #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Get the channel from the group channel configuration as PWM-Diag has no virtual channel */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; LucPhysCh = (uint8)(Adc_GpChannelToGroup[LucChannelToGroupIndex] & ADC_CHANNEL_ID_MASK); /* PRQA S 2824 # JV-01 */ } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Get and store the physical channel where the Id error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ } LpGroupData->ucChannelIdError = LucPhysCh; /* Clear Id error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_IDEC; } /* end of if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) */ /* else: No action required */ } /* end of if (ADC_BYTE_ZERO != (uint8)(LucIderValue & ADC_ADCX_IDER_IDE)) */ /* else: No action required */ #endif /* ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) */ #if (ADC_ENABLE_OVERWRITE_ERR == STD_ON) /* Check the overwrite error status */ if (ADC_BYTE_ZERO != (uint8)(LucOwerValue & ADC_ADCX_OWER_OWE)) { /* Get the virtual channel captured due to an overwrite error */ LucErrorVirCh = (uint8)(LucOwerValue & ADC_ADCX_OWER_OWECAP); if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Get and store the channel where the overwrite error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ LpGroupData->ucChannelOverwritten = LucPhysCh; /* Clear error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_OWEC; } /* else: No action required */ } /* else: No action required */ #endif /* (ADC_ENABLE_OVERWRITE_ERR == STD_ON) */ #if (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) /* Get the SG unit Id of the group */ LucSgUnitId = Adc_GpSgUnitConfig[LpGroup->ucSgUnitIndex].ucSgUnitId; /* PRQA S 2824 # JV-01 */ /* Check the trigger overlap check status */ if (ADC_BYTE_ZERO != (uint8)(LucTocerValue & (uint8)(ADC_ADCX_TOCER_TOCESG_LSB << LucSgUnitId))) { /* Set the error status */ LpGroupData->blTriggerOverlapped = ADC_TRUE; /* Clear error status */ LpAdcRegisters->ddADCXnECR = (Adc_ErrClearRegType)(ADC_ADCX_ECR_TOCESGC_LSB << LucSgUnitId); } /* else: No action required */ #endif /* (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) */ #if (ADC_ENABLE_LIMIT_CHECK == STD_ON) if (ADC_TRUE == LpGroup->blLimitCheckEnabled) { /* Get the values of upper/lower limit check error status registers */ LulRegSel = ((uint32)LpGroup->ucStartVirChPtr >> ADC_ADCX_VCLMSR_HIGH_SHIFT) & ADC_ADCX_VCLMSR_HIGH_MASK; LulBitLoc = (uint32)LpGroup->ucStartVirChPtr & ADC_ADCX_VCLMSR_LOW_MASK; LulVclmsrValue = LpAdcRegisters->aaADCXnVCLMSR[LulRegSel] & (1UL << LulBitLoc); /* PRQA S 2814 # JV-01 */ if (0UL != LulVclmsrValue) { /* Set the conversion error status */ LblErrorFlag = ADC_TRUE; /* Get and store the physical channel where the limit check error occurred */ LucErrorVirCh = LpGroup->ucStartVirChPtr; LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ LpGroupData->ucChannelLimitError = LucPhysCh; /* Clear error status */ LpAdcRegisters->aaADCXnVCLMSCR[LulRegSel] = LulVclmsrValue; } /* else: No action required */ } /* end of if (ADC_TRUE == LpGroup->blLimitCheckEnabled) */ /* else: No action required */ #endif /* (ADC_ENABLE_LIMIT_CHECK == STD_ON) */ } return LblErrorFlag; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..254', 'Name': 'LddGroup', 'Value': '1'], 'Input_Param_001': ['Type': 'Variable', 'Range': 'LucHwUnitIndex', 'Name': 'x', 'Value': ''], 'Input_Param_002': ['Type': 'Variable', 'Range': 'LddGroup', 'Name': 'y', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': 'LucSgUnitIndex', 'Name': 'z', 'Value': ''], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blInterruptErr', 'Value': 'ADC_TRUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blLimitCheckEnabled', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'E2x: 0..3\\nU2Ax: 0..2', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'E2x: 0..19\\nU2Ax: 0..14', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'E2x: 0..39\\nU2Ax: 0..63', 'Name': 'ucStartVirChPtr', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': 'E2x: 1..40\\nU2Ax: 1..64\\nLimitCheck: 1', 'Name': 'ucChannelCount', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '0..(ucChannelCount - 1)', 'Name': 'ucChannelsCompleted', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blConvError', 'Value': 'ADC_TRUE'], 'Input_Param_023': ['Type': 'Register', 'Range': '0x00000000..0xFFFFFFFF', 'Name': 'aaADCXnVCLMSR[ADC_VCLM_1]', 'Value': '-'], 'Input_Param_024': ['Type': 'Register', 'Range': 'E2x: 0x00000000..0x000000FF\\nU2Ax: 0x00000000..0xFFFFFFFF', 'Name': 'aaADCXnVCLMSR[ADC_VCLM_2]', 'Value': '-'], 'Input_Param_025': ['Type': 'Register', 'Range': '0x00, 0x80..0xBF', 'Name': 'ucADCXnIDER', 'Value': '-'], 'Input_Param_026': ['Type': 'Register', 'Range': '0x00, 0x80..0xBF', 'Name': 'ucADCXnOWER', 'Value': '-'], 'Input_Param_027': ['Type': 'Register', 'Range': '0x00, 0x02..0x3E', 'Name': 'ucADCXnTOCER', 'Value': '-'], 'Input_Param_028': ['Type': 'Array', 'Range': 'E2x: 0x00..0x1F\\nU2Ax: 0x00..0x21', 'Name': 'aaADCXnVCR[0 to 63]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblErrorFlag', 'Value': 'ADC_TRUE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': 'ADC_FALSE'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelIdError', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelOverwritten', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blTriggerOverlapped', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelLimitError', 'Value': '-'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': '-'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'aaADCXnVCLMSCR[0 to 1]', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) || \\ (ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) #if ((ADC_FUNCTIONALITY_MODE != ADC_POLLING) || (ADC_READ_GROUP_API == STD_ON) || (ADC_ENABLE_DMA_MODE == STD_ON)) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(boolean, ADC_CODE_FAST) Adc_CheckError(const Adc_GroupType LddGroup) { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) || \\ (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; #endif #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON)) P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; #endif uint8 LucHwUnitIndex; #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON)) uint8 LucErrorVirCh; uint8 LucPhysCh; #endif #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON)) uint8 LucStartVirCh; uint8 LucEndVirCh; #endif #if ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) uint8 LucIderValue; #if (ADC_ENABLE_PWM_DIAG == STD_ON) uint8 LucChannelToGroupIndex; #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #endif #if (ADC_ENABLE_OVERWRITE_ERR == STD_ON) uint8 LucOwerValue; #endif #if (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) uint8 LucSgUnitId; uint8 LucTocerValue; #endif #if (ADC_ENABLE_LIMIT_CHECK == STD_ON) uint32 LulVclmsrValue; uint32 LulRegSel; uint32 LulBitLoc; #endif boolean LblErrorFlag; /* Get the pointer to the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the hardware unit index to which the group belongs */ LucHwUnitIndex = LpGroup->ucHwUnitIndex; /* PRQA S 2814 # JV-01 */ /* Get the pointer to the hardware unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) || \\ (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) /* Get the pointer to the runtime data of the group */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #endif /* Initialize the error flag */ LblErrorFlag = ADC_FALSE; #if ((ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) /* Check if error interrupt is enabled */ if (ADC_TRUE == LpHwUnitConfig->blInterruptErr) /* PRQA S 2814 # JV-01 */ { #if (((((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON)) && \\ (ADC_ENABLE_ERR_INT == STD_ON)) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) /* Read and clear conversion error flag from error interrupt */ LblErrorFlag = LpGroupData->blConvError; /* PRQA S 2814 # JV-01 */ if (ADC_TRUE == LblErrorFlag) { LpGroupData->blConvError = ADC_FALSE; } /* else: No action required */ #endif } else #endif /* ((ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) */ { #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON) || \\ (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON)) /* Get the base register address of the hardware unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; #endif /* Get the error status */ #if ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) LucIderValue = LpAdcRegisters->ucADCXnIDER; /* PRQA S 2814 # JV-01 */ #endif #if (ADC_ENABLE_OVERWRITE_ERR == STD_ON) LucOwerValue = LpAdcRegisters->ucADCXnOWER; /* PRQA S 2814 # JV-01 */ #endif #if (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) LucTocerValue = LpAdcRegisters->ucADCXnTOCER; #endif #if (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON)) #if ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF) && (ADC_ENABLE_PWM_DIAG == STD_ON)) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Set the group channel range to PWM-Diag channel */ LucStartVirCh = ADC_ADCX_IDER_IDECAP_PWD; LucEndVirCh = ADC_ADCX_IDER_IDECAP_PWD; } else #endif /* ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF) && (ADC_ENABLE_PWM_DIAG == STD_ON)) */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Get the virtual channel information of the group */ if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) { LucStartVirCh = LpGroup->ucStartVirChPtr + LpGroupData->ucChannelsCompleted; LucEndVirCh = LucStartVirCh; } else #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ { LucStartVirCh = LpGroup->ucStartVirChPtr; LucEndVirCh = (uint8)(LucStartVirCh + LpGroupData->ucChannelCount - ADC_BYTE_ONE); } #endif /* (((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON)) */ #if ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) /* Check the Id error status */ if (ADC_BYTE_ZERO != (uint8)(LucIderValue & ADC_ADCX_IDER_IDE)) { /* Get the virtual channel captured due to an Id error */ LucErrorVirCh = (uint8)(LucIderValue & ADC_ADCX_IDER_IDECAP); if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Set the conversion error status */ LblErrorFlag = ADC_TRUE; #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Get the channel from the group channel configuration as PWM-Diag has no virtual channel */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; LucPhysCh = (uint8)(Adc_GpChannelToGroup[LucChannelToGroupIndex] & ADC_CHANNEL_ID_MASK); /* PRQA S 2824 # JV-01 */ } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Get and store the physical channel where the Id error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ } LpGroupData->ucChannelIdError = LucPhysCh; /* Clear Id error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_IDEC; } /* end of if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) */ /* else: No action required */ } /* end of if (ADC_BYTE_ZERO != (uint8)(LucIderValue & ADC_ADCX_IDER_IDE)) */ /* else: No action required */ #endif /* ((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) */ #if (ADC_ENABLE_OVERWRITE_ERR == STD_ON) /* Check the overwrite error status */ if (ADC_BYTE_ZERO != (uint8)(LucOwerValue & ADC_ADCX_OWER_OWE)) { /* Get the virtual channel captured due to an overwrite error */ LucErrorVirCh = (uint8)(LucOwerValue & ADC_ADCX_OWER_OWECAP); if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Get and store the channel where the overwrite error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ LpGroupData->ucChannelOverwritten = LucPhysCh; /* Clear error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_OWEC; } /* else: No action required */ } /* else: No action required */ #endif /* (ADC_ENABLE_OVERWRITE_ERR == STD_ON) */ #if (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) /* Get the SG unit Id of the group */ LucSgUnitId = Adc_GpSgUnitConfig[LpGroup->ucSgUnitIndex].ucSgUnitId; /* PRQA S 2824 # JV-01 */ /* Check the trigger overlap check status */ if (ADC_BYTE_ZERO != (uint8)(LucTocerValue & (uint8)(ADC_ADCX_TOCER_TOCESG_LSB << LucSgUnitId))) { /* Set the error status */ LpGroupData->blTriggerOverlapped = ADC_TRUE; /* Clear error status */ LpAdcRegisters->ddADCXnECR = (Adc_ErrClearRegType)(ADC_ADCX_ECR_TOCESGC_LSB << LucSgUnitId); } /* else: No action required */ #endif /* (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) */ #if (ADC_ENABLE_LIMIT_CHECK == STD_ON) if (ADC_TRUE == LpGroup->blLimitCheckEnabled) { /* Get the values of upper/lower limit check error status registers */ LulRegSel = ((uint32)LpGroup->ucStartVirChPtr >> ADC_ADCX_VCLMSR_HIGH_SHIFT) & ADC_ADCX_VCLMSR_HIGH_MASK; LulBitLoc = (uint32)LpGroup->ucStartVirChPtr & ADC_ADCX_VCLMSR_LOW_MASK; LulVclmsrValue = LpAdcRegisters->aaADCXnVCLMSR[LulRegSel] & (1UL << LulBitLoc); /* PRQA S 2814 # JV-01 */ if (0UL != LulVclmsrValue) { /* Set the conversion error status */ LblErrorFlag = ADC_TRUE; /* Get and store the physical channel where the limit check error occurred */ LucErrorVirCh = LpGroup->ucStartVirChPtr; LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ LpGroupData->ucChannelLimitError = LucPhysCh; /* Clear error status */ LpAdcRegisters->aaADCXnVCLMSCR[LulRegSel] = LulVclmsrValue; } /* else: No action required */ } /* end of if (ADC_TRUE == LpGroup->blLimitCheckEnabled) */ /* else: No action required */ #endif /* (ADC_ENABLE_LIMIT_CHECK == STD_ON) */ } return LblErrorFlag; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..254', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': 'LucHwUnitIndex', 'Name': 'x', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'LddGroup', 'Name': 'y', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': 'LucSgUnitIndex', 'Name': 'z', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blInterruptErr', 'Value': 'ADC_FALSE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': 'ADC_GROUP_REPL_ABORT_RESTART'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blLimitCheckEnabled', 'Value': 'ADC_FALSE'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'E2x: 0..3\\nU2Ax: 0..2', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'E2x: 0..19\\nU2Ax: 0..14', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'E2x: 0..39\\nU2Ax: 0..63', 'Name': 'ucStartVirChPtr', 'Value': '0x00'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': 'E2x: 1..40\\nU2Ax: 1..64\\nLimitCheck: 1', 'Name': 'ucChannelCount', 'Value': '64'], 'Input_Param_021': ['Type': 'Variable', 'Range': '0..(ucChannelCount - 1)', 'Name': 'ucChannelsCompleted', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blConvError', 'Value': '-'], 'Input_Param_023': ['Type': 'Register', 'Range': '0x00000000..0xFFFFFFFF', 'Name': 'aaADCXnVCLMSR[ADC_VCLM_1]', 'Value': '-'], 'Input_Param_024': ['Type': 'Register', 'Range': 'E2x: 0x00000000..0x000000FF\\nU2Ax: 0x00000000..0xFFFFFFFF', 'Name': 'aaADCXnVCLMSR[ADC_VCLM_2]', 'Value': '-'], 'Input_Param_025': ['Type': 'Register', 'Range': '0x00, 0x80..0xBF', 'Name': 'ucADCXnIDER', 'Value': '0x00'], 'Input_Param_026': ['Type': 'Register', 'Range': '0x00, 0x80..0xBF', 'Name': 'ucADCXnOWER', 'Value': '0xBE'], 'Input_Param_027': ['Type': 'Register', 'Range': '0x00, 0x02..0x3E', 'Name': 'ucADCXnTOCER', 'Value': '0x00'], 'Input_Param_028': ['Type': 'Array', 'Range': 'E2x: 0x00..0x1F\\nU2Ax: 0x00..0x21', 'Name': 'aaADCXnVCR[0 to 63]', 'Value': '[62] =0x0000001F']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblErrorFlag', 'Value': 'ADC_FALSE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelIdError', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelOverwritten', 'Value': '0x1F'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blTriggerOverlapped', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelLimitError', 'Value': '-'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': 'ADC_ADCX_ECR_OWEC'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'aaADCXnVCLMSCR[0 to 1]', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_PARITY_ERR == STD_ON) #if ((ADC_FUNCTIONALITY_MODE != ADC_POLLING) || (ADC_READ_GROUP_API == STD_ON) || (ADC_ENABLE_DMA_MODE == STD_ON)) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(boolean, ADC_CODE_FAST) Adc_CheckParity(const Adc_GroupType LddGroup) { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; uint8 LucPerValue; uint8 LucErrorVirCh; uint8 LucStartVirCh; uint8 LucEndVirCh; uint8 LucPhysCh; boolean LblErrorFlag; #if (ADC_ENABLE_PWM_DIAG == STD_ON) uint8 LucChannelToGroupIndex; #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ /* Get the pointer to the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the base register address of the hardware unit */ LpAdcRegisters = Adc_GpHwUnitConfig[LpGroup->ucHwUnitIndex].pHwUnitBaseAddress; /* PRQA S 2814, 2824 # JV-01, JV-01 */ /* Get the pointer to the runtime data of the group */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Initialize the error flag */ LblErrorFlag = ADC_FALSE; /* Check the parity error status */ LucPerValue = LpAdcRegisters->ucADCXnPER; /* PRQA S 2814 # JV-01 */ if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) { #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Set the group channel range to PWM-Diag channel */ LucStartVirCh = ADC_ADCX_PER_PECAP_PWD; LucEndVirCh = ADC_ADCX_PER_PECAP_PWD; } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) { /* Set the group channel range to the current virtual channel of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr + LpGroupData->ucChannelsCompleted; /* PRQA S 2814 # JV-01 */ LucEndVirCh = LucStartVirCh; } else #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ { /* Set the group channel range to the virtual channel range of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr; LucEndVirCh = (uint8)(LucStartVirCh + LpGroupData->ucChannelCount - ADC_BYTE_ONE); /* PRQA S 2814 # JV-01 */ } /* Get the virtual channel captured due to an parity error */ LucErrorVirCh = (uint8)(LucPerValue & ADC_ADCX_PER_PECAP); if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Set the conversion error status */ LblErrorFlag = ADC_TRUE; #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_ADCX_PER_PECAP_PWD == LucErrorVirCh) { /* Get the channel from the group channel configuration as PWM-Diag has no virtual channel */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; LucPhysCh = (uint8)(Adc_GpChannelToGroup[LucChannelToGroupIndex] & ADC_CHANNEL_ID_MASK); /* PRQA S 2824 # JV-01 */ } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Get and store the physical channel where the parity error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ } LpGroupData->ucChannelParityError = LucPhysCh; /* Clear parity error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_PEC; } /* end of if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) */ /* else: No action required */ } /* end of if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) */ /* else: No action required */ return LblErrorFlag; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..254', 'Name': 'LddGroup', 'Value': '254'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'x', 'Value': '254'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'E2x: 0..3\\nU2x: 0..2', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'y', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress_2[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_012': ['Type': 'Register', 'Range': '0x00, 0x80..0xBF(U2Ax), 0xF0(PWM-Diag)\\n0x80..0xA7(E2x)', 'Name': 'ucADCXnPER', 'Value': '-'], 'Input_Param_013': ['Type': 'Register', 'Range': '0x00, 0x80..0xBF(U2Ax), 0xF0(PWM-Diag)\\n0x80..0xA7(E2x)', 'Name': 'ucADCXnPER', 'Value': '0xA7'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': 'ADC_GROUP_REPL_SUSPEND_RESUME'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0..39 E2x\\n0..63 U2Ax', 'Name': 'ucStartVirChPtr', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '0..39 (E2x)\\n0..63 (U2Ax)', 'Name': 'ucChannelsCompleted', 'Value': '39'], 'Input_Param_017': ['Type': 'Variable', 'Range': '1..40 (E2x)\\n1..64 (U2Ax)', 'Name': 'ucChannelCount', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '0x00..0x1F', 'Name': 'aaADCXnVCR[0 to 39]', 'Value': '-'], 'Input_Param_019': ['Type': 'Array', 'Range': '0x00..0x21', 'Name': 'aaADCXnVCR[0 to 63]', 'Value': '[0 to 63] = 0xFFFFFFFF'], 'Input_Param_020': ['Type': 'Variable', 'Range': '0x00..0x1F, 0xFF (E2x)\\n0x00..0x21, 0xFF (U2Ax)', 'Name': 'ucChannelParityError', 'Value': '0xFF'], 'Input_Param_021': ['Type': 'Register', 'Range': '0x00', 'Name': 'ddADCXnECR', 'Value': '-'], 'Input_Param_022': ['Type': 'Register', 'Range': '0x00', 'Name': 'ddADCXnECR', 'Value': '0xFF']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelParityError', 'Value': '0x3F'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': '0x02'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblErrorFlag', 'Value': 'ADC_TRUE'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, ADC_PRIVATE_CODE) Adc_ConfigureGroupForConversion(const Adc_GroupType LddGroup) { P2CONST(Adc_HwSgUnitType, AUTOMATIC, ADC_CONFIG_DATA) LpSgUnitConfig; /* Pointer to the hardware unit configuration */ P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2VAR(volatile Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; P2VAR(volatile Adc_SGRegType, AUTOMATIC, REGSPACE) LpSGRegisters; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) uint32 LulBufferOffset; #endif uint8 LucChannelToGroupIndex; uint8 LucLoopCount; uint8 LucRegValues; uint8 LucHwUnitIndex; uint8 LucChannelCount; uint8 LucSgUnitId; uint8 LucSgUnitIndex; uint8 LucChannelIndex; uint8 LucScanCount; /* Read the HW unit of the group */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit index to which the channel group is mapped */ LucSgUnitIndex = LpGroup->ucSgUnitIndex; /* PRQA S 2814 # JV-01 */ /* Read the HW Unit to which the group belongs */ LucHwUnitIndex = LpGroup->ucHwUnitIndex; /* Initialize the local variable for HW unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit which is configured for this group */ LpSgUnitConfig = &Adc_GpSgUnitConfig[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit to which the group is configured */ LucSgUnitId = LpSgUnitConfig->ucSgUnitId; /* PRQA S 2814 # JV-01 */ /* Initialize HW RAM data to a local pointer */ LpSgUnitData = &Adc_GpSgUnitRamData[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Initialize Group RAM data to a local pointer */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_DISABLE_CHANNEL == STD_ON) /* Get the no of channels configured for the requested group */ LucChannelCount = LpGroup->ucChannelCount - LpGroupData->ucNoOfDisabledChannels; /* PRQA S 2814 # JV-01 */ #else /* Get the no of channels configured for the requested group */ LucChannelCount = LpGroup->ucChannelCount; #endif /* Read the user base configuration address of the HW unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; /* PRQA S 2814 # JV-01 */ /* Initialize the error status */ #if (((((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON)) && \\ (ADC_ENABLE_ERR_INT == STD_ON)) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) LpGroupData->blConvError = ADC_FALSE; /* PRQA S 2814 # JV-01 */ #endif #if (ADC_ENABLE_ID_ERR == STD_ON) LpGroupData->ucChannelIdError = ADC_INVALID_CHANNELID; #endif #if (ADC_ENABLE_OVERWRITE_ERR == STD_ON) LpGroupData->ucChannelOverwritten = ADC_INVALID_CHANNELID; #endif #if (ADC_ENABLE_LIMIT_CHECK == STD_ON) LpGroupData->ucChannelLimitError = ADC_INVALID_CHANNELID; #endif #if (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) LpGroupData->blTriggerOverlapped = ADC_FALSE; #endif #if (ADC_ENABLE_PARITY_ERR == STD_ON) LpGroupData->ucChannelParityError = ADC_INVALID_CHANNELID; #endif /* Clear error status and parity error */ #if (ADC_ENABLE_ERR == STD_ON) LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_CLEAR_ALL; /* PRQA S 2814 # JV-01 */ #endif #if (ADC_ENABLE_PARITY_ERR == STD_ON) LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_PEC; #endif #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Dummy read ADCXnPWDDIR register to clear WFLAG */ (void)Adc_PwmDiagReadData(LddGroup); } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Loop all channels of group */ for (LucLoopCount = ADC_BYTE_ZERO; LucLoopCount < LucChannelCount; LucLoopCount++) { /* Get the actual channel index */ LucChannelIndex = LpGroup->ucStartVirChPtr + LucLoopCount; /* Dummy read to clear ADCXnDIRj.WFLG bit to avoid data overwrite */ (void)LpAdcRegisters->aaADCXnDIR[LucChannelIndex]; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } } EXECUTE_SYNCP(); /* Initialize the number of channels present in the group */ LpGroupData->ucChannelCount = LucChannelCount; /* PRQA S 2814 # JV-01 */ /* Initialize the number of ISR need to be skipped */ LpGroupData->ucIsrSkipCount = ADC_BYTE_ZERO; #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Check for group popped from queue if the sample are completed? */ if (LpGroupData->ucSamplesCompleted == LpGroup->ddNumberofSamples) { /* Initialize the number of conversion rounds to zero */ /* Initialize the group's buffer pointer to the result buffer pointer */ LpGroupData->pBuffer = LpGroupData->pChannelBuffer; } else { /* Initialize the group's buffer pointer from the sample which was suspended or aborted */ LpGroupData->pBuffer = &LpGroupData->pChannelBuffer[LpGroupData->ucSamplesCompleted]; /* PRQA S 0404 # JV-01 */ } #else /* Initialize the number of conversion rounds to zero */ LpGroupData->ucSamplesCompleted = ADC_BYTE_ZERO; /* Initialize the group's buffer pointer to the result buffer pointer */ LpGroupData->pBuffer = LpGroupData->pChannelBuffer; #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ /* Set the flag indicating Group is not read so far */ LpGroupData->blResultRead = ADC_TRUE; #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Check if the group uses suspend/resume feature */ if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) { /* Initialize the group's buffer pointer from the channel which was suspended */ LulBufferOffset = (uint32)LpGroup->ddNumberofSamples * (uint32)LpGroupData->ucChannelsCompleted; /* PRQA S 3384 # JV-02 */ LpGroupData->pBuffer = &LpGroupData->pBuffer[LulBufferOffset]; /* Initialize the number of ISR need to be skipped */ LpGroupData->ucIsrSkipCount = LpGroupData->ucChannelsCompleted; } else { /* Initialize the number of conversion completed channels */ LpGroupData->ucChannelsCompleted = ADC_BYTE_ZERO; } #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ LpSGRegisters = &LpAdcRegisters->aaADCXnSG[LucSgUnitId]; /* PRQA S 2934 # JV-01 */ /* Suppose the scan count is 0 (continuous or once per trigger) */ LucScanCount = (uint8)0U; #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_STREAMING == STD_ON)) /* Check if the requested group is configured as SW triggered and linear streaming and using multicycle scan mode */ if ((LddGroup < Adc_GucMaxSwTriggGroups) && (ADC_ACCESS_MODE_STREAMING == LpGroup->enGroupAccessMode) && (ADC_STREAM_BUFFER_LINEAR == LpGroup->enStreamBufferMode) && ((uint8)0U == LpGroup->ucScanMode)) { #if (ADC_ENABLE_ADTIMER == STD_ON) /* Check if AD timer is not used */ if (ADC_FALSE == LpGroup->blAdcEnableAdTimerTriggMode) #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ { /* Set the scan count to number of samples, for SW triggered linear streaming with DMA or no error detection */ LucScanCount = LpGroup->ddNumberofSamples - LpGroupData->ucSamplesCompleted - (uint8)1U; } /* else: No action required */ } /* else: No action required */ #endif /* ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_STREAMING == STD_ON)) */ LpSGRegisters->ucADCXnSGMCYCRx = LucScanCount; /* PRQA S 2844 # JV-01 */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) LpSgUnitData->ddCurrentPriority = LpGroup->ddGroupPriority; /* PRQA S 2814 # JV-01 */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ /* Update the SG unit ram data with the current group information */ LpSgUnitData->ddCurrentConvGroup = LddGroup; /* PRQA S 2814 # JV-01 */ #if (ADC_FUNCTIONALITY_MODE != ADC_POLLING) /* Check if the Group is mapped for HW configured for interrupt mode */ if (ADC_INTERRUPT_MODE == LpSgUnitConfig->enFunctionalityModeType) { /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_INTERRUPT_CONTROL_PROTECTION); #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Disable interrupt for SG unit since there is no interrupt at the end of conversion for PWM-Diag */ Adc_DisableConvertInterrupt(LucHwUnitIndex, LucSgUnitIndex); } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #if (ADC_ENABLE_DMA_MODE == STD_ON) if (ADC_TRUE == LpGroup->blEnableDmaTransfer) { /* Disable interrupt for SG unit to which the group is mapped. */ Adc_DisableConvertInterrupt(LucHwUnitIndex, LucSgUnitIndex); } else #endif /* (ADC_ENABLE_DMA_MODE == STD_ON) */ { /* Enable interrupt for SG unit to which group is mapped. */ Adc_EnableConvertInterrupt(LucHwUnitIndex, LucSgUnitIndex); } /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_INTERRUPT_CONTROL_PROTECTION); } /* end of if (ADC_INTERRUPT_MODE == LpSgUnitConfig->enFunctionalityModeType) */ /* else: No action required */ #endif /* (ADC_FUNCTIONALITY_MODE != ADC_POLLING) */ #if (ADC_ENABLE_DMA_MODE == STD_ON) if (ADC_TRUE == LpGroup->blEnableDmaTransfer) { /* Enable DMA transfer */ Adc_DmaEnable(LddGroup); } /* else: No action required */ #endif /* (ADC_ENABLE_DMA_MODE == STD_ON) */ #if (ADC_ENABLE_SELF_DIAG_PIN_LVL == STD_ON) /* Check if Group Configured for Pin Level Diagnostic. */ if (ADC_SELF_DIAG_PIN_LVL == LpGroup->enAdcSelfDiagMode) { /* Set value for \"ADCXnTDCR\" Register */ LpAdcRegisters->ucADCXnTDCR = LpGroup->ucAdcSelfdiagpinlevelMask; } else { /* Clear \"ADCXnTDCR\" Register */ LpAdcRegisters->ucADCXnTDCR = ADC_BYTE_ZERO; } #endif /* (ADC_ENABLE_SELF_DIAG_PIN_LVL == STD_ON) */ #if (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) /* Check if self-diagnosis is wiring-break detection mode 1 (same as ADC_SELF_DIAG_WIRE_BRK for E2x) */ if (ADC_SELF_DIAG_WIRE_BRK_MODE1 == LpGroup->enAdcSelfDiagMode) { #if (ADC_IP_ADCH == STD_ON) /* Setting of Wiring-break Detection Self-Diagnosis Enable */ LpAdcRegisters->ddADCXnODCR = ADC_ADCX_ODCR_ODDE | ADC_ADCX_ODCR_ODE | (Adc_WireBreakRegType)LpGroup->ucAdcSelfDiagWireBreakPulseWidth; #else /* Set \"ADCXnODCR\" Register */ LpAdcRegisters->ddADCXnODCR = (Adc_WireBreakRegType)LpGroup->ucAdcSelfDiagWireBreakPulseWidth; #endif /* (ADC_IP_ADCH == STD_ON) */ } else { /* Clear \"ADCXnODCR\" Register */ LpAdcRegisters->ddADCXnODCR = ADC_ADCX_ODCR_INIT_VALUE; } #endif /* (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) */ #if (ADC_ENABLE_WIRE_BRK == STD_ON) #if (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) if (ADC_SELF_DIAG_OFF == LpGroup->enAdcSelfDiagMode) #endif /* (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) */ { if (ADC_TRUE == LpGroup->blAdcEnableWiringBreakDetection) { #if (ADC_IP_ADCH == STD_ON) /* Set Wiring-break Detection Enable */ LpAdcRegisters->ddADCXnODCR = ADC_ADCX_ODCR_ODE | (Adc_WireBreakRegType)LpGroup->ucAdcSelfDiagWireBreakPulseWidth; #else LpAdcRegisters->ddADCXnODCR = (Adc_WireBreakRegType)LpGroup->ucAdcSelfDiagWireBreakPulseWidth; #endif /* (ADC_IP_ADCH == STD_ON) */ } else { /* Clear \"ADCXnODCR\" Register */ LpAdcRegisters->ddADCXnODCR = ADC_ADCX_ODCR_INIT_VALUE; } } /* end of if (ADC_SELF_DIAG_OFF == LpGroup->enAdcSelfDiagMode) */ /* else: No action required */ #endif /* (ADC_ENABLE_WIRE_BRK == STD_ON) */ /* Check whether group status is ADC_IDLE or \"ADC_STREAM_COMPLETED and implicitly stopped group\" */ if ((ADC_IDLE == LpGroupData->enGroupStatus) || ((ADC_TRUE == LpGroup->blImplicitlyStopped) && (ADC_STREAM_COMPLETED == LpGroupData->enGroupStatus))) { /* Set the group status as busy */ Adc_SetStatus(LddGroup, ADC_BUSY); } /* else: No action required */ #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Enable the trigger of PWM-Diag */ Adc_PwmDiagEnable(LddGroup); } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Set the virtual channel start pointer and end pointer */ LpSGRegisters->usADCXnSGVCPRx = (uint16)((uint32)LpGroup->ucStartVirChPtr | (((uint32)LpGroup->ucStartVirChPtr + (uint32)LucChannelCount - 1UL) << ADC_SHIFT_BYTE)); /* PRQA S 3383, 3384 # JV-08, JV-03 */ /* Initialize the virtual channels with the channel groups configured for requested group. */ /* Get the index of 1st channel, configured for the requested group */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; /* Re-Initialize the channel count to actual configured no of channels */ LucChannelCount = LpGroup->ucChannelCount; /* Get the actual first channel index */ LucChannelIndex = LpGroup->ucStartVirChPtr; /* Map the physical channels to the virtual channels */ for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < LucChannelCount; LucLoopCount++) { #if (ADC_ENABLE_DISABLE_CHANNEL == STD_ON) /* Check if the channel is enabled */ if (ADC_TRUE == Adc_GpChannelToDisableEnable[LucChannelToGroupIndex]) /* PRQA S 2824 # JV-01 */ #endif /* (ADC_ENABLE_DISABLE_CHANNEL == STD_ON) */ { /* Map the physical channels to the virtual channels */ LpAdcRegisters->aaADCXnVCR[LucChannelIndex] = Adc_GpChannelToGroup[LucChannelToGroupIndex]; /* PRQA S 2824, 2844 # JV-01, JV-01 */ /* Get the next channel index */ LucChannelIndex++; /* PRQA S 3383 # JV-06 */ } /* else: No action required */ LucChannelToGroupIndex++; /* PRQA S 3383 # JV-06 */ } /* end of for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < LucChannelCount; LucLoopCount++) */ #if (ADC_TRACK_AND_HOLD == STD_ON) if (ADC_TH_DISABLED != LpGroup->ucTrackAndHoldGroup) { /* Enable Track and Hold and start/enable SG */ Adc_TrackHoldEnable(LddGroup); } else #endif /* (ADC_TRACK_AND_HOLD == STD_ON) */ { /* Configure the hardware unit with the group's operation mode */ LucRegValues = LpGroup->ucScanMode; /* Update to generate output when the scan for SGx ends */ LucRegValues |= ADC_ADCX_SGCR_ADIE; #if (ADC_ENABLE_ADTIMER == STD_ON) /* Check if the requested group has AD Timer Trigger */ if (ADC_TRUE == LpGroup->blAdcEnableAdTimerTriggMode) { /* Enable the SG unit to start the conversion on trigger */ LucRegValues |= ADC_ADCX_SGCR_TRGMD_ADTIMER; /* Set the Register ADCXnADTIPRx and ADCXnADTPRRx */ LpSGRegisters->ulADCXnADTIPRx = LpGroup->ulAdcTimerPhaseDelay; LpSGRegisters->ulADCXnADTPRRx = LpGroup->ulAdcTimerPeriod; /* Check if the requested group is SW triggered */ if (LddGroup < Adc_GucMaxSwTriggGroups) { /* Enable the SG unit to start the conversion for SW triggered group */ LpSGRegisters->ucADCXnSGCRx = LucRegValues; /* Start the AD Timer */ LpSGRegisters->ucADCXnADTSTCRx = ADC_ADCX_ADTSTCR_ADTST; } else { /* Enable the SG unit to start the conversion for HW triggered group */ LucRegValues |= ADC_ADCX_SGCR_TRGMD_HW; LpSGRegisters->ucADCXnSGCRx = LucRegValues; } } /* end of if (ADC_TRUE == LpGroup->blAdcEnableAdTimerTriggMode) */ else #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ { /* Check if the requested group is SW triggered */ if (LddGroup < Adc_GucMaxSwTriggGroups) { /* Initiate conversion for SW triggered group */ LpSGRegisters->ucADCXnSGCRx = LucRegValues; LpSGRegisters->ucADCXnSGSTCRx = ADC_ADCX_SGSTCR_SGST; } else { /* Enable the SG unit to start the conversion for HW triggered group */ LucRegValues |= ADC_ADCX_SGCR_TRGMD_HW; LpSGRegisters->ucADCXnSGCRx = LucRegValues; } } } } /* Change SG unit status to active */ Adc_GaaHwUnitData[LucHwUnitIndex].ucSgUnitStatus |= (uint8)(1U << LucSgUnitId); /* PRQA S 2844 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '3'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ddNumberofSamples', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': 'ADC_GROUP_REPL_SUSPEND_RESUME'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'ADC_ACCESS_MODE_SINGLE\\nADC_ACCESS_MODE_STREAMING', 'Name': 'enGroupAccessMode', 'Value': 'ADC_ACCESS_MODE_STREAMING'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_STREAM_BUFFER_LINEAR\\nADC_STREAM_BUFFER_CIRCULAR', 'Name': 'enStreamBufferMode', 'Value': 'ADC_STREAM_BUFFER_LINEAR'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blEnableDmaTransfer', 'Value': 'ADC_FALSE'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_TRUE'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0x00, 0x20', 'Name': 'ucScanMode', 'Value': '0x00'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '1'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucStartVirChPtr', 'Value': '0x00'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'enAdcSelfDiagMode', 'Value': 'ADC_SELF_DIAG_CONV_CKT'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucAdcSelfdiagpinlevelMask', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucAdcSelfDiagWireBreakPulseWidth', 'Value': '0x02'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blAdcEnableWiringBreakDetection', 'Value': 'ADC_TRUE'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blAdcEnableAdTimerTriggMode', 'Value': 'ADC_FALSE'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulAdcTimerPhaseDelay', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulAdcTimerPeriod', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '0x00'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'aaADCXnDIR[0 to 2]', 'Value': '[0 to 2] = 0x0000'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '3'], 'Input_Param_028': ['Type': 'Variable', 'Range': 'ADC_INTERRUPT_MODE\\nADC_POLLING_MODE\\nADC_POLLING_INTERRUPT_MODE', 'Name': 'enFunctionalityModeType', 'Value': 'ADC_POLLING_MODE'], 'Input_Param_029': ['Type': 'Variable', 'Range': 'ucSgUnitId', 'Name': 'x', 'Value': ''], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToDisableEnable', 'Value': '&map_Adc_GpChannelToDisableEnable[0]'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToDisableEnable[0]', 'Value': 'ADC_TRUE'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToDisableEnable[1]', 'Value': 'ADC_FALSE'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToDisableEnable[2]', 'Value': 'ADC_TRUE'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '&map_Adc_GpChannelToGroup[0]'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '0x00000001'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[1]', 'Value': '0x00000002'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[2]', 'Value': '0x00000003'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '0'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitStatus', 'Value': '0'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfDisabledChannels', 'Value': '1'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelBuffer', 'Value': '&map_pChannelBuffer[0]'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '0'], 'Input_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': '0'], 'Input_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': '-'], 'Input_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelIdError', 'Value': '-'], 'Input_Param_048': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelOverwritten', 'Value': 'ADC_INVALID_CHANNELID'], 'Input_Param_049': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelLimitError', 'Value': 'ADC_INVALID_CHANNELID'], 'Input_Param_050': ['Type': 'Variable', 'Range': '', 'Name': 'blTriggerOverlapped', 'Value': '-'], 'Input_Param_051': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelParityError', 'Value': '-'], 'Input_Param_052': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,\\nADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': 'ADC_IDLE'], 'Input_Param_053': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnSG[x].usADCXnSGVCPRx', 'Value': '0x0100'], 'Input_Param_054': ['Type': 'Variable', 'Range': '', 'Name': 'ucTrackAndHoldGroup', 'Value': '-'], 'Input_Param_055': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelBuffer[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentPriority', 'Value': '1'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '0'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'blResultRead', 'Value': 'ADC_TRUE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitStatus', 'Value': '8'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '2'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pBuffer', 'Value': '&map_pChannelBuffer[0]'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': 'ADC_COUNT_BYTE_INIT'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': 'ADC_FALSE'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelIdError', 'Value': 'ADC_INVALID_CHANNELID'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelOverwritten', 'Value': 'ADC_INVALID_CHANNELID'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelLimitError', 'Value': 'ADC_INVALID_CHANNELID'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'blTriggerOverlapped', 'Value': 'ADC_FALSE'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelParityError', 'Value': 'ADC_INVALID_CHANNELID'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucIsrSkipCount', 'Value': 'ADC_COUNT_BYTE_INIT'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[0]', 'Value': '0x00000001'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[1]', 'Value': '0x00000003'], 'Output_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[2]', 'Value': '-'], 'Output_Param_018': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': 'ADC_ADCX_ECR_CLEAR_ALL'], 'Output_Param_019': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnTDCR', 'Value': 'ADC_REG_BYTE_INIT'], 'Output_Param_020': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnODCR', 'Value': 'ADC_ADCX_ODCR_INIT_VALUE'], 'Output_Param_021': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnADTIPRx', 'Value': '-'], 'Output_Param_022': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnADTPRRx', 'Value': '-'], 'Output_Param_023': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnADTSTCRx', 'Value': '-'], 'Output_Param_024': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGSTCRx', 'Value': '-'], 'Output_Param_025': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGCRx', 'Value': '0x11'], 'Output_Param_026': ['Type': 'Register', 'Range': '', 'Name': 'usADCXnSGVCPRx', 'Value': '0x0100'], 'Output_Param_027': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGMCYCRx', 'Value': '0x00'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_029': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '-'], 'Output_Param_034': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenStatusType', 'Value': 'ADC_BUSY'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_040': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, ADC_PRIVATE_CODE) Adc_ConfigureGroupForConversion(const Adc_GroupType LddGroup) { P2CONST(Adc_HwSgUnitType, AUTOMATIC, ADC_CONFIG_DATA) LpSgUnitConfig; /* Pointer to the hardware unit configuration */ P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2VAR(volatile Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; P2VAR(volatile Adc_SGRegType, AUTOMATIC, REGSPACE) LpSGRegisters; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) uint32 LulBufferOffset; #endif uint8 LucChannelToGroupIndex; uint8 LucLoopCount; uint8 LucRegValues; uint8 LucHwUnitIndex; uint8 LucChannelCount; uint8 LucSgUnitId; uint8 LucSgUnitIndex; uint8 LucChannelIndex; uint8 LucScanCount; /* Read the HW unit of the group */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit index to which the channel group is mapped */ LucSgUnitIndex = LpGroup->ucSgUnitIndex; /* PRQA S 2814 # JV-01 */ /* Read the HW Unit to which the group belongs */ LucHwUnitIndex = LpGroup->ucHwUnitIndex; /* Initialize the local variable for HW unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit which is configured for this group */ LpSgUnitConfig = &Adc_GpSgUnitConfig[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit to which the group is configured */ LucSgUnitId = LpSgUnitConfig->ucSgUnitId; /* PRQA S 2814 # JV-01 */ /* Initialize HW RAM data to a local pointer */ LpSgUnitData = &Adc_GpSgUnitRamData[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Initialize Group RAM data to a local pointer */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_DISABLE_CHANNEL == STD_ON) /* Get the no of channels configured for the requested group */ LucChannelCount = LpGroup->ucChannelCount - LpGroupData->ucNoOfDisabledChannels; /* PRQA S 2814 # JV-01 */ #else /* Get the no of channels configured for the requested group */ LucChannelCount = LpGroup->ucChannelCount; #endif /* Read the user base configuration address of the HW unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; /* PRQA S 2814 # JV-01 */ /* Initialize the error status */ #if (((((ADC_ENABLE_ID_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_LIMIT_CHECK == STD_ON)) && \\ (ADC_ENABLE_ERR_INT == STD_ON)) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) LpGroupData->blConvError = ADC_FALSE; /* PRQA S 2814 # JV-01 */ #endif #if (ADC_ENABLE_ID_ERR == STD_ON) LpGroupData->ucChannelIdError = ADC_INVALID_CHANNELID; #endif #if (ADC_ENABLE_OVERWRITE_ERR == STD_ON) LpGroupData->ucChannelOverwritten = ADC_INVALID_CHANNELID; #endif #if (ADC_ENABLE_LIMIT_CHECK == STD_ON) LpGroupData->ucChannelLimitError = ADC_INVALID_CHANNELID; #endif #if (ADC_ENABLE_TRIGGER_OVERLAP_ERR == STD_ON) LpGroupData->blTriggerOverlapped = ADC_FALSE; #endif #if (ADC_ENABLE_PARITY_ERR == STD_ON) LpGroupData->ucChannelParityError = ADC_INVALID_CHANNELID; #endif /* Clear error status and parity error */ #if (ADC_ENABLE_ERR == STD_ON) LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_CLEAR_ALL; /* PRQA S 2814 # JV-01 */ #endif #if (ADC_ENABLE_PARITY_ERR == STD_ON) LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_PEC; #endif #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Dummy read ADCXnPWDDIR register to clear WFLAG */ (void)Adc_PwmDiagReadData(LddGroup); } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Loop all channels of group */ for (LucLoopCount = ADC_BYTE_ZERO; LucLoopCount < LucChannelCount; LucLoopCount++) { /* Get the actual channel index */ LucChannelIndex = LpGroup->ucStartVirChPtr + LucLoopCount; /* Dummy read to clear ADCXnDIRj.WFLG bit to avoid data overwrite */ (void)LpAdcRegisters->aaADCXnDIR[LucChannelIndex]; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } } EXECUTE_SYNCP(); /* Initialize the number of channels present in the group */ LpGroupData->ucChannelCount = LucChannelCount; /* PRQA S 2814 # JV-01 */ /* Initialize the number of ISR need to be skipped */ LpGroupData->ucIsrSkipCount = ADC_BYTE_ZERO; #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Check for group popped from queue if the sample are completed? */ if (LpGroupData->ucSamplesCompleted == LpGroup->ddNumberofSamples) { /* Initialize the number of conversion rounds to zero */ /* Initialize the group's buffer pointer to the result buffer pointer */ LpGroupData->pBuffer = LpGroupData->pChannelBuffer; } else { /* Initialize the group's buffer pointer from the sample which was suspended or aborted */ LpGroupData->pBuffer = &LpGroupData->pChannelBuffer[LpGroupData->ucSamplesCompleted]; /* PRQA S 0404 # JV-01 */ } #else /* Initialize the number of conversion rounds to zero */ LpGroupData->ucSamplesCompleted = ADC_BYTE_ZERO; /* Initialize the group's buffer pointer to the result buffer pointer */ LpGroupData->pBuffer = LpGroupData->pChannelBuffer; #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ /* Set the flag indicating Group is not read so far */ LpGroupData->blResultRead = ADC_TRUE; #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Check if the group uses suspend/resume feature */ if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) { /* Initialize the group's buffer pointer from the channel which was suspended */ LulBufferOffset = (uint32)LpGroup->ddNumberofSamples * (uint32)LpGroupData->ucChannelsCompleted; /* PRQA S 3384 # JV-02 */ LpGroupData->pBuffer = &LpGroupData->pBuffer[LulBufferOffset]; /* Initialize the number of ISR need to be skipped */ LpGroupData->ucIsrSkipCount = LpGroupData->ucChannelsCompleted; } else { /* Initialize the number of conversion completed channels */ LpGroupData->ucChannelsCompleted = ADC_BYTE_ZERO; } #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ LpSGRegisters = &LpAdcRegisters->aaADCXnSG[LucSgUnitId]; /* PRQA S 2934 # JV-01 */ /* Suppose the scan count is 0 (continuous or once per trigger) */ LucScanCount = (uint8)0U; #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_STREAMING == STD_ON)) /* Check if the requested group is configured as SW triggered and linear streaming and using multicycle scan mode */ if ((LddGroup < Adc_GucMaxSwTriggGroups) && (ADC_ACCESS_MODE_STREAMING == LpGroup->enGroupAccessMode) && (ADC_STREAM_BUFFER_LINEAR == LpGroup->enStreamBufferMode) && ((uint8)0U == LpGroup->ucScanMode)) { #if (ADC_ENABLE_ADTIMER == STD_ON) /* Check if AD timer is not used */ if (ADC_FALSE == LpGroup->blAdcEnableAdTimerTriggMode) #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ { /* Set the scan count to number of samples, for SW triggered linear streaming with DMA or no error detection */ LucScanCount = LpGroup->ddNumberofSamples - LpGroupData->ucSamplesCompleted - (uint8)1U; } /* else: No action required */ } /* else: No action required */ #endif /* ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_STREAMING == STD_ON)) */ LpSGRegisters->ucADCXnSGMCYCRx = LucScanCount; /* PRQA S 2844 # JV-01 */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) LpSgUnitData->ddCurrentPriority = LpGroup->ddGroupPriority; /* PRQA S 2814 # JV-01 */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ /* Update the SG unit ram data with the current group information */ LpSgUnitData->ddCurrentConvGroup = LddGroup; /* PRQA S 2814 # JV-01 */ #if (ADC_FUNCTIONALITY_MODE != ADC_POLLING) /* Check if the Group is mapped for HW configured for interrupt mode */ if (ADC_INTERRUPT_MODE == LpSgUnitConfig->enFunctionalityModeType) { /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_INTERRUPT_CONTROL_PROTECTION); #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Disable interrupt for SG unit since there is no interrupt at the end of conversion for PWM-Diag */ Adc_DisableConvertInterrupt(LucHwUnitIndex, LucSgUnitIndex); } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #if (ADC_ENABLE_DMA_MODE == STD_ON) if (ADC_TRUE == LpGroup->blEnableDmaTransfer) { /* Disable interrupt for SG unit to which the group is mapped. */ Adc_DisableConvertInterrupt(LucHwUnitIndex, LucSgUnitIndex); } else #endif /* (ADC_ENABLE_DMA_MODE == STD_ON) */ { /* Enable interrupt for SG unit to which group is mapped. */ Adc_EnableConvertInterrupt(LucHwUnitIndex, LucSgUnitIndex); } /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_INTERRUPT_CONTROL_PROTECTION); } /* end of if (ADC_INTERRUPT_MODE == LpSgUnitConfig->enFunctionalityModeType) */ /* else: No action required */ #endif /* (ADC_FUNCTIONALITY_MODE != ADC_POLLING) */ #if (ADC_ENABLE_DMA_MODE == STD_ON) if (ADC_TRUE == LpGroup->blEnableDmaTransfer) { /* Enable DMA transfer */ Adc_DmaEnable(LddGroup); } /* else: No action required */ #endif /* (ADC_ENABLE_DMA_MODE == STD_ON) */ #if (ADC_ENABLE_SELF_DIAG_PIN_LVL == STD_ON) /* Check if Group Configured for Pin Level Diagnostic. */ if (ADC_SELF_DIAG_PIN_LVL == LpGroup->enAdcSelfDiagMode) { /* Set value for \"ADCXnTDCR\" Register */ LpAdcRegisters->ucADCXnTDCR = LpGroup->ucAdcSelfdiagpinlevelMask; } else { /* Clear \"ADCXnTDCR\" Register */ LpAdcRegisters->ucADCXnTDCR = ADC_BYTE_ZERO; } #endif /* (ADC_ENABLE_SELF_DIAG_PIN_LVL == STD_ON) */ #if (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) /* Check if self-diagnosis is wiring-break detection mode 1 (same as ADC_SELF_DIAG_WIRE_BRK for E2x) */ if (ADC_SELF_DIAG_WIRE_BRK_MODE1 == LpGroup->enAdcSelfDiagMode) { #if (ADC_IP_ADCH == STD_ON) /* Setting of Wiring-break Detection Self-Diagnosis Enable */ LpAdcRegisters->ddADCXnODCR = ADC_ADCX_ODCR_ODDE | ADC_ADCX_ODCR_ODE | (Adc_WireBreakRegType)LpGroup->ucAdcSelfDiagWireBreakPulseWidth; #else /* Set \"ADCXnODCR\" Register */ LpAdcRegisters->ddADCXnODCR = (Adc_WireBreakRegType)LpGroup->ucAdcSelfDiagWireBreakPulseWidth; #endif /* (ADC_IP_ADCH == STD_ON) */ } else { /* Clear \"ADCXnODCR\" Register */ LpAdcRegisters->ddADCXnODCR = ADC_ADCX_ODCR_INIT_VALUE; } #endif /* (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) */ #if (ADC_ENABLE_WIRE_BRK == STD_ON) #if (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) if (ADC_SELF_DIAG_OFF == LpGroup->enAdcSelfDiagMode) #endif /* (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) */ { if (ADC_TRUE == LpGroup->blAdcEnableWiringBreakDetection) { #if (ADC_IP_ADCH == STD_ON) /* Set Wiring-break Detection Enable */ LpAdcRegisters->ddADCXnODCR = ADC_ADCX_ODCR_ODE | (Adc_WireBreakRegType)LpGroup->ucAdcSelfDiagWireBreakPulseWidth; #else LpAdcRegisters->ddADCXnODCR = (Adc_WireBreakRegType)LpGroup->ucAdcSelfDiagWireBreakPulseWidth; #endif /* (ADC_IP_ADCH == STD_ON) */ } else { /* Clear \"ADCXnODCR\" Register */ LpAdcRegisters->ddADCXnODCR = ADC_ADCX_ODCR_INIT_VALUE; } } /* end of if (ADC_SELF_DIAG_OFF == LpGroup->enAdcSelfDiagMode) */ /* else: No action required */ #endif /* (ADC_ENABLE_WIRE_BRK == STD_ON) */ /* Check whether group status is ADC_IDLE or \"ADC_STREAM_COMPLETED and implicitly stopped group\" */ if ((ADC_IDLE == LpGroupData->enGroupStatus) || ((ADC_TRUE == LpGroup->blImplicitlyStopped) && (ADC_STREAM_COMPLETED == LpGroupData->enGroupStatus))) { /* Set the group status as busy */ Adc_SetStatus(LddGroup, ADC_BUSY); } /* else: No action required */ #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) { /* Enable the trigger of PWM-Diag */ Adc_PwmDiagEnable(LddGroup); } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Set the virtual channel start pointer and end pointer */ LpSGRegisters->usADCXnSGVCPRx = (uint16)((uint32)LpGroup->ucStartVirChPtr | (((uint32)LpGroup->ucStartVirChPtr + (uint32)LucChannelCount - 1UL) << ADC_SHIFT_BYTE)); /* PRQA S 3383, 3384 # JV-08, JV-03 */ /* Initialize the virtual channels with the channel groups configured for requested group. */ /* Get the index of 1st channel, configured for the requested group */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; /* Re-Initialize the channel count to actual configured no of channels */ LucChannelCount = LpGroup->ucChannelCount; /* Get the actual first channel index */ LucChannelIndex = LpGroup->ucStartVirChPtr; /* Map the physical channels to the virtual channels */ for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < LucChannelCount; LucLoopCount++) { #if (ADC_ENABLE_DISABLE_CHANNEL == STD_ON) /* Check if the channel is enabled */ if (ADC_TRUE == Adc_GpChannelToDisableEnable[LucChannelToGroupIndex]) /* PRQA S 2824 # JV-01 */ #endif /* (ADC_ENABLE_DISABLE_CHANNEL == STD_ON) */ { /* Map the physical channels to the virtual channels */ LpAdcRegisters->aaADCXnVCR[LucChannelIndex] = Adc_GpChannelToGroup[LucChannelToGroupIndex]; /* PRQA S 2824, 2844 # JV-01, JV-01 */ /* Get the next channel index */ LucChannelIndex++; /* PRQA S 3383 # JV-06 */ } /* else: No action required */ LucChannelToGroupIndex++; /* PRQA S 3383 # JV-06 */ } /* end of for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < LucChannelCount; LucLoopCount++) */ #if (ADC_TRACK_AND_HOLD == STD_ON) if (ADC_TH_DISABLED != LpGroup->ucTrackAndHoldGroup) { /* Enable Track and Hold and start/enable SG */ Adc_TrackHoldEnable(LddGroup); } else #endif /* (ADC_TRACK_AND_HOLD == STD_ON) */ { /* Configure the hardware unit with the group's operation mode */ LucRegValues = LpGroup->ucScanMode; /* Update to generate output when the scan for SGx ends */ LucRegValues |= ADC_ADCX_SGCR_ADIE; #if (ADC_ENABLE_ADTIMER == STD_ON) /* Check if the requested group has AD Timer Trigger */ if (ADC_TRUE == LpGroup->blAdcEnableAdTimerTriggMode) { /* Enable the SG unit to start the conversion on trigger */ LucRegValues |= ADC_ADCX_SGCR_TRGMD_ADTIMER; /* Set the Register ADCXnADTIPRx and ADCXnADTPRRx */ LpSGRegisters->ulADCXnADTIPRx = LpGroup->ulAdcTimerPhaseDelay; LpSGRegisters->ulADCXnADTPRRx = LpGroup->ulAdcTimerPeriod; /* Check if the requested group is SW triggered */ if (LddGroup < Adc_GucMaxSwTriggGroups) { /* Enable the SG unit to start the conversion for SW triggered group */ LpSGRegisters->ucADCXnSGCRx = LucRegValues; /* Start the AD Timer */ LpSGRegisters->ucADCXnADTSTCRx = ADC_ADCX_ADTSTCR_ADTST; } else { /* Enable the SG unit to start the conversion for HW triggered group */ LucRegValues |= ADC_ADCX_SGCR_TRGMD_HW; LpSGRegisters->ucADCXnSGCRx = LucRegValues; } } /* end of if (ADC_TRUE == LpGroup->blAdcEnableAdTimerTriggMode) */ else #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ { /* Check if the requested group is SW triggered */ if (LddGroup < Adc_GucMaxSwTriggGroups) { /* Initiate conversion for SW triggered group */ LpSGRegisters->ucADCXnSGCRx = LucRegValues; LpSGRegisters->ucADCXnSGSTCRx = ADC_ADCX_SGSTCR_SGST; } else { /* Enable the SG unit to start the conversion for HW triggered group */ LucRegValues |= ADC_ADCX_SGCR_TRGMD_HW; LpSGRegisters->ucADCXnSGCRx = LucRegValues; } } } } /* Change SG unit status to active */ Adc_GaaHwUnitData[LucHwUnitIndex].ucSgUnitStatus |= (uint8)(1U << LucSgUnitId); /* PRQA S 2844 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '31'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '3'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ddNumberofSamples', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': 'ADC_GROUP_REPL_ABORT_RESTART'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'ADC_ACCESS_MODE_SINGLE\\nADC_ACCESS_MODE_STREAMING', 'Name': 'enGroupAccessMode', 'Value': 'ADC_ACCESS_MODE_STREAMING'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_STREAM_BUFFER_LINEAR\\nADC_STREAM_BUFFER_CIRCULAR', 'Name': 'enStreamBufferMode', 'Value': 'ADC_STREAM_BUFFER_CIRCULAR'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blEnableDmaTransfer', 'Value': 'ADC_TRUE'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_FALSE'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0x00, 0x20', 'Name': 'ucScanMode', 'Value': '0x00'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '1'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucStartVirChPtr', 'Value': '0x00'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'enAdcSelfDiagMode', 'Value': 'ADC_SELF_DIAG_OFF'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucAdcSelfdiagpinlevelMask', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucAdcSelfDiagWireBreakPulseWidth', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blAdcEnableWiringBreakDetection', 'Value': 'ADC_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blAdcEnableAdTimerTriggMode', 'Value': 'ADC_FALSE'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulAdcTimerPhaseDelay', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulAdcTimerPeriod', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '0x00'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'aaADCXnDIR[0 to 2]', 'Value': '[0 to 2] = 0x0000'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '0'], 'Input_Param_028': ['Type': 'Variable', 'Range': 'ADC_INTERRUPT_MODE\\nADC_POLLING_MODE\\nADC_POLLING_INTERRUPT_MODE', 'Name': 'enFunctionalityModeType', 'Value': 'ADC_INTERRUPT_MODE'], 'Input_Param_029': ['Type': 'Variable', 'Range': 'ucSgUnitId', 'Name': 'x', 'Value': ''], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToDisableEnable', 'Value': '&map_Adc_GpChannelToDisableEnable[0]'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToDisableEnable[0]', 'Value': 'ADC_TRUE'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToDisableEnable[1]', 'Value': 'ADC_FALSE'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToDisableEnable[2]', 'Value': 'ADC_TRUE'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '&map_Adc_GpChannelToGroup[0]'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '0x00000001'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[1]', 'Value': '0x00000002'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[2]', 'Value': '0x00000003'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '63'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitStatus', 'Value': '0'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfDisabledChannels', 'Value': '1'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelBuffer', 'Value': '&map_pChannelBuffer[0]'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '0'], 'Input_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': '0'], 'Input_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': '-'], 'Input_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelIdError', 'Value': '-'], 'Input_Param_048': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelOverwritten', 'Value': '-'], 'Input_Param_049': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelLimitError', 'Value': '-'], 'Input_Param_050': ['Type': 'Variable', 'Range': '', 'Name': 'blTriggerOverlapped', 'Value': 'ADC_FALSE'], 'Input_Param_051': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelParityError', 'Value': '-'], 'Input_Param_052': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,\\nADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': 'ADC_IDLE'], 'Input_Param_053': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnSG[x].usADCXnSGVCPRx', 'Value': '0x0100'], 'Input_Param_054': ['Type': 'Variable', 'Range': '', 'Name': 'ucTrackAndHoldGroup', 'Value': 'ADC_TH_DISABLED'], 'Input_Param_055': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelBuffer[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentPriority', 'Value': '1'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '31'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'blResultRead', 'Value': 'ADC_TRUE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitStatus', 'Value': '1'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '2'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pBuffer', 'Value': '&map_pChannelBuffer[0]'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': 'ADC_COUNT_BYTE_INIT'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': 'ADC_FALSE'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelIdError', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelOverwritten', 'Value': 'ADC_INVALID_CHANNELID'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelLimitError', 'Value': 'ADC_INVALID_CHANNELID'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'blTriggerOverlapped', 'Value': 'ADC_FALSE'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelParityError', 'Value': 'ADC_INVALID_CHANNELID'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucIsrSkipCount', 'Value': 'ADC_COUNT_BYTE_INIT'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[0]', 'Value': '0x00000001'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[1]', 'Value': '0x00000003'], 'Output_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[2]', 'Value': '-'], 'Output_Param_018': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': 'ADC_ADCX_ECR_CLEAR_ALL'], 'Output_Param_019': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnTDCR', 'Value': 'ADC_REG_BYTE_INIT'], 'Output_Param_020': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnODCR', 'Value': 'ADC_ADCX_ODCR_INIT_VALUE'], 'Output_Param_021': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnADTIPRx', 'Value': '-'], 'Output_Param_022': ['Type': 'Register', 'Range': '', 'Name': 'ulADCXnADTPRRx', 'Value': '-'], 'Output_Param_023': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnADTSTCRx', 'Value': '-'], 'Output_Param_024': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGSTCRx', 'Value': 'ADC_ADCX_SGSTCR_SGST'], 'Output_Param_025': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGCRx', 'Value': '0x10'], 'Output_Param_026': ['Type': 'Register', 'Range': '', 'Name': 'usADCXnSGVCPRx', 'Value': '0x0100'], 'Output_Param_027': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnSGMCYCRx', 'Value': 'ADC_BYTE_ZERO'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_029': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'Called'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '0'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '0'], 'Output_Param_034': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'Called'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '31'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '31'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenStatusType', 'Value': 'ADC_BUSY'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_040': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON) #define ADC_START_SEC_PUBLIC_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PUBLIC_CODE) Adc_DisableGroupNotification(Adc_GroupType Group) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Check if the ADC Module is not initialized */ if (ADC_UNINITIALIZED == Adc_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_GROUP_NOTIFICATION_SID, ADC_E_UNINIT); } /* Check if the requested group is invalid group ID */ else if (Group >= Adc_GucNoOfGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_GROUP_NOTIFICATION_SID, ADC_E_PARAM_GROUP); } /* Check if no valid notification function is configured */ else if (NULL_PTR == Adc_GpGroupConfig[Group].pGroupNotificationPointer) /* PRQA S 2824 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_GROUP_NOTIFICATION_SID, ADC_E_NOTIF_CAPABILITY); } else #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Store the disabled notification into RAM */ Adc_GpGroupRamData[Group].blNotifyStatus = ADC_FALSE; /* PRQA S 2824 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': '-', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..255', 'Name': 'Group', 'Value': '1'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ADC_UNINITIALIZED\\nADC_INITIALIZED', 'Name': 'Adc_GblDriverStatus', 'Value': 'ADC_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '1..254', 'Name': 'Adc_GucNoOfGroups', 'Value': '255'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!NULL_PTR', 'Name': 'pGroupNotificationPointer', 'Value': '&dummy_IoHwAb_Adc_Notification_Group0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blNotifyStatus', 'Value': 'ADC_FALSE'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_HW_TRIGGER_API == STD_ON) #define ADC_START_SEC_PUBLIC_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PUBLIC_CODE) Adc_DisableHardwareTrigger(Adc_GroupType Group) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) boolean LblDetErrFlag; /* Initialize the Det error flag to ADC_FALSE */ LblDetErrFlag = ADC_FALSE; #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Check if the ADC Module is not initialized */ if (ADC_UNINITIALIZED == Adc_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_HARDWARE_TRIGGER_SID, ADC_E_UNINIT); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* Check if the requested group is invalid group ID */ else if (Group >= Adc_GucNoOfGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_HARDWARE_TRIGGER_SID, ADC_E_PARAM_GROUP); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* Check if requested group is SW triggered group */ else if (Group < Adc_GucMaxSwTriggGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_HARDWARE_TRIGGER_SID, ADC_E_WRONG_TRIGG_SRC); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } else #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Check if HW trigger was not enabled for requested group */ if (ADC_FALSE == Adc_GpGroupRamData[Group].blHwTriggStatus) /* PRQA S 2824 # JV-01 */ { /* Report Error to DET */ ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_HARDWARE_TRIGGER_SID, ADC_E_IDLE); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* else: No action required */ } /* Check if no errors were detected */ if (ADC_FALSE == LblDetErrFlag) #endif /* ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) */ { /* Check if HW trigger was enabled for requested group */ if (ADC_TRUE == Adc_GpGroupRamData[Group].blHwTriggStatus) /* PRQA S 2824 # JV-01 */ { /* Disable the hardware trigger */ Adc_HwDisableHardwareTrigger(Group); } /* else: No action required */ } /* else: No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': '-', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..254', 'Name': 'Group', 'Value': '254'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ADC_INITIALIZED\\nADC_UNINITIALIZED', 'Name': 'Adc_GblDriverStatus', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '1..255', 'Name': 'Adc_GucNoOfGroups', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0..255', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blHwTriggStatus', 'Value': 'ADC_FALSE']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ADC_MODULE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ADC_INSTANCE_ID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ADC_DISABLE_HARDWARE_TRIGGER_SID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ADC_E_IDLE'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_HW_TRIGGER_API == STD_ON) #define ADC_START_SEC_PUBLIC_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PUBLIC_CODE) Adc_DisableHardwareTrigger(Adc_GroupType Group) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) boolean LblDetErrFlag; /* Initialize the Det error flag to ADC_FALSE */ LblDetErrFlag = ADC_FALSE; #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Check if the ADC Module is not initialized */ if (ADC_UNINITIALIZED == Adc_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_HARDWARE_TRIGGER_SID, ADC_E_UNINIT); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* Check if the requested group is invalid group ID */ else if (Group >= Adc_GucNoOfGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_HARDWARE_TRIGGER_SID, ADC_E_PARAM_GROUP); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* Check if requested group is SW triggered group */ else if (Group < Adc_GucMaxSwTriggGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_HARDWARE_TRIGGER_SID, ADC_E_WRONG_TRIGG_SRC); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } else #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Check if HW trigger was not enabled for requested group */ if (ADC_FALSE == Adc_GpGroupRamData[Group].blHwTriggStatus) /* PRQA S 2824 # JV-01 */ { /* Report Error to DET */ ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_DISABLE_HARDWARE_TRIGGER_SID, ADC_E_IDLE); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* else: No action required */ } /* Check if no errors were detected */ if (ADC_FALSE == LblDetErrFlag) #endif /* ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) */ { /* Check if HW trigger was enabled for requested group */ if (ADC_TRUE == Adc_GpGroupRamData[Group].blHwTriggStatus) /* PRQA S 2824 # JV-01 */ { /* Disable the hardware trigger */ Adc_HwDisableHardwareTrigger(Group); } /* else: No action required */ } /* else: No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': '-', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..254', 'Name': 'Group', 'Value': '95'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ADC_INITIALIZED\\nADC_UNINITIALIZED', 'Name': 'Adc_GblDriverStatus', 'Value': 'ADC_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '1..255', 'Name': 'Adc_GucNoOfGroups', 'Value': '127'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0..255', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '63'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blHwTriggStatus', 'Value': 'ADC_TRUE']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '95'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_DEINIT_API == STD_ON) #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_DmaDeInit(void) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_DmaConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpSGmDmaConfig; P2VAR(volatile Adc_DmaRegisters, AUTOMATIC, REGSPACE) LpDmaRegisters; uint8 LucLoopCount; #if (ADC_IP_ADCK == STD_ON) uint32 LulLoopCount; uint32 LulShift; uint32 LulGroupSelect; #endif /* (ADC_IP_ADCK == STD_ON) */ #if (ADC_FUNCTIONALITY_MODE != ADC_POLLING) P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2CONST(Adc_HwSgUnitType, AUTOMATIC, ADC_CONFIG_DATA) LpSgUnitConfig; uint8 LucSgLoopCount; uint8 LucSgUnitCount; uint8 LucDeInitPosition; LucDeInitPosition = ADC_VAL_BYTE_INIT; #endif /* (ADC_FUNCTIONALITY_MODE != ADC_POLLING) */ for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < Adc_GucMaxDmaChannels; LucLoopCount++) { /* Get the pointer to DMA configuration */ LpSGmDmaConfig = &Adc_GpDmaUnitConfig[LucLoopCount]; /* PRQA S 2824 # JV-01 */ LpDmaRegisters = LpSGmDmaConfig->pDmaRegBaseaddress; /* PRQA S 2814 # JV-01 */ /* De-initialize DMA registers */ LpDmaRegisters->ulDMAjCHFCRn = /* PRQA S 2814 # JV-01 */ ADC_DMA_CHFCR_TEC | ADC_DMA_CHFCR_DSEC | ADC_DMA_CHFCR_CAEC | ADC_DMA_CHFCR_DRQC | ADC_DMA_CHFCR_OVFC; LpDmaRegisters->usDMAjCHCRn &= ADC_DMA_CHCR_CAEE; LpDmaRegisters->ulDMAjSARn = ADC_DMA_SAR_INIT; LpDmaRegisters->ulDMAjDARn = ADC_DMA_DAR_INIT; LpDmaRegisters->ulDMAjTSRn = ADC_DMA_TSR_INIT; LpDmaRegisters->ulDMAjTMRn &= ADC_DMA_TMR_PRI_MASK; LpDmaRegisters->ulDMAjGIAIn = ADC_DMA_GIAI_INIT; LpDmaRegisters->ulDMAjGOAIn = ADC_DMA_GOAI_INIT; LpDmaRegisters->ulDMAjSIAIn = ADC_DMA_SIAI_INIT; LpDmaRegisters->ulDMAjSOAIn = ADC_DMA_SOAI_INIT; LpDmaRegisters->ulDMAjSGCRn = ADC_DMA_SGCR_INIT; LpDmaRegisters->ulDMAjRSn = ADC_DMA_RS_INIT; LpDmaRegisters->ulDMAjDPPTRn = ADC_DMA_DPPTR_INIT; LpDmaRegisters->ulDMAjDPCRn = ADC_DMA_DPCR_INIT; /* Perform synchronization for SDMAC */ (void)LpDmaRegisters->ulDMAjDPCRn; EXECUTE_SYNCP(); } /* end of for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < Adc_GucMaxDmaChannels; LucLoopCount++) */ #if (ADC_FUNCTIONALITY_MODE != ADC_POLLING) for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < (uint8)ADC_MAX_HW_UNITS; LucLoopCount++) /* PRQA S 2877 # JV-01 */ { /* Initialize the local variable for HW unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucLoopCount]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit count */ LucSgUnitCount = LpHwUnitConfig->ucSgUnitCount; /* PRQA S 2814 # JV-01 */ for (LucSgLoopCount = ADC_COUNT_BYTE_INIT; LucSgLoopCount < LucSgUnitCount; LucSgLoopCount++) { LpSgUnitConfig = &Adc_GpSgUnitConfig[LucDeInitPosition]; /* PRQA S 2824 # JV-01 */ /* Check SG use DMA and interrupt mode or not */ if ((ADC_INTERRUPT_MODE == LpSgUnitConfig->enFunctionalityModeType) && /* PRQA S 2814 # JV-01 */ (ADC_DMA_CHANNEL_OFF != LpSgUnitConfig->ucDmaChannelIndex)) { /* Get the pointer to the DMA configuration */ LpSGmDmaConfig = &Adc_GpDmaUnitConfig[LpSgUnitConfig->ucDmaChannelIndex]; /* Disable DMA interrupt for SG unit and perform synchronization for INTC2 */ RH850_SV_SET_ICR_SYNCP(8, LpSGmDmaConfig->pDmaEicRegaddress, ADC_EIC_EIMK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ } /* else: No action required */ /* DeInitPosition is increase */ LucDeInitPosition++; /* PRQA S 3383 # JV-01 */ } /* end of for (LucSgLoopCount = ADC_COUNT_BYTE_INIT; LucSgLoopCount < LucSgUnitCount; LucSgLoopCount++) */ } /* end of for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < (uint8)ADC_MAX_HW_UNITS; LucLoopCount++) */ #endif /* (ADC_FUNCTIONALITY_MODE != ADC_POLLING) */ #if ((ADC_IP_ADCH == STD_ON) || (ADC_IP_ADCJ == STD_ON)) /* Clear DMA Transfer Request Group Selection */ ADC_DMACSEL0_0 = ADC_DMACSEL0_INIT; /* PRQA S 0303 # JV-01 */ ADC_DMACSEL0_1 = ADC_DMACSEL0_INIT; /* PRQA S 0303 # JV-01 */ ADC_DMACSEL1_0 = ADC_DMACSEL1_INIT; /* PRQA S 0303 # JV-01 */ ADC_DMACSEL1_1 = ADC_DMACSEL1_INIT; /* PRQA S 0303 # JV-01 */ /* Perform synchronization for DMATRGSEL */ (void)ADC_DMACSEL1_1; /* PRQA S 0303 # JV-01 */ EXECUTE_SYNCP(); #endif /* ((ADC_IP_ADCH == STD_ON) || (ADC_IP_ADCJ == STD_ON)) */ #if (ADC_IP_ADCK == STD_ON) for (LulLoopCount = 0UL; LulLoopCount < (uint32)Adc_GucMaxDmaChannels; LulLoopCount++) { /* Get the pointer to DMA configuration */ LpSGmDmaConfig = &Adc_GpDmaUnitConfig[LulLoopCount]; /* De-initialize the DMA transfer request selection register */ LulShift = (LpSGmDmaConfig->ulDmaResourceValue & ADC_DMA_CSEL_SHIFT_MASK) << 1U; /* PRQA S 2814 # JV-01 */ LulGroupSelect = *LpSGmDmaConfig->pDMACSEL; /* PRQA S 2814 # JV-01 */ LulGroupSelect &= ~(ADC_DMA_CSEL_MASK << LulShift); if (ADC_BYTE_ZERO != LpSGmDmaConfig->ucDmaUnit) { LulGroupSelect |= ADC_DMACSEL1_INIT & (ADC_DMA_CSEL_MASK << LulShift); } /* else: No action required */ *LpSGmDmaConfig->pDMACSEL = LulGroupSelect; } /* end of for (LulLoopCount = 0UL; LulLoopCount < (uint32)Adc_GucMaxDmaChannels; LulLoopCount++) */ /* Perform dummy read and synchronization for DMATRGSEL */ (void)*Adc_GpDmaUnitConfig[0].pDMACSEL; /* PRQA S 2814 # JV-01 */ EXECUTE_SYNCP(); #endif /* (ADC_IP_ADCK == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'ADC_MAX_HW_UNITS', 'Value': '1'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxDmaChannels', 'Value': '1'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpDmaUnitConfig', 'Value': '&map_Adc_GpDmaUnitConfig[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'pDmaRegBaseaddress', 'Value': '[0] = &map_pDmaRegBaseaddress[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucDmaUnit', 'Value': '~ADC_BYTE_ZERO'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '[0..4]', 'Name': 'ucSgUnitCount', 'Value': '[0] = 4'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': 'ADC_INTERRUPT_MODE\\nADC_POLLING_MODE\\nADC_POLLING_INTERRUPT_MODE', 'Name': 'enFunctionalityModeType', 'Value': '[0] = ADC_INTERRUPT_MODE'], 'Input_Param_009': ['Type': 'Array', 'Range': 'E2x: [0..19]\\nU2x: [0..14]', 'Name': 'ucDmaChannelIndex', 'Value': '[0] = 0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulDmaResourceValue', 'Value': '0x01'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucDmaRequestGroup', 'Value': '0x02'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pDMACSEL', 'Value': '&map_pDMACSEL[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDMACSEL[0]', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pDmaEicRegaddress', 'Value': '&map_pDmaEicRegaddress[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pDmaEicRegaddress', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pDmaEicRegaddress', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDmaEicRegaddress[0]', 'Value': '0xFF'], 'Input_Param_018': ['Type': 'Register', 'Range': '', 'Name': 'usDMAjCHCRn', 'Value': '0xFCF8'], 'Input_Param_019': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjTMRn', 'Value': '0xFFFF']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjCHFCRn', 'Value': 'ADC_DMA_CHFCR_TEC | ADC_DMA_CHFCR_DSEC | ADC_DMA_CHFCR_CAEC | ADC_DMA_CHFCR_DRQC | ADC_DMA_CHFCR_OVFC'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'usDMAjCHCRn', 'Value': '0xFCF8 & ADC_DMA_CHCR_CAEE'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjSARn', 'Value': 'ADC_DMA_SAR_INIT'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjDARn', 'Value': 'ADC_DMA_DAR_INIT'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjTSRn', 'Value': 'ADC_DMA_TSR_INIT'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjTMRn', 'Value': '0xFFFF & ADC_DMA_TMR_PRI_MASK'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjGIAIn', 'Value': 'ADC_DMA_GIAI_INIT'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjGOAIn', 'Value': 'ADC_DMA_GOAI_INIT'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjSIAIn', 'Value': 'ADC_DMA_SIAI_INIT'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjSOAIn', 'Value': 'ADC_DMA_SOAI_INIT'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjSGCRn', 'Value': 'ADC_DMA_SGCR_INIT'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjRSn', 'Value': 'ADC_DMA_RS_INIT'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjDPPTRn', 'Value': 'ADC_DMA_DPPTR_INIT'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'ulDMAjDPCRn', 'Value': 'ADC_DMA_DPCR_INIT'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL0_0_Test', 'Value': '-'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL0_1_Test', 'Value': '-'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL1_0_Test', 'Value': '-'], 'Output_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL1_1_Test', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDmaEicRegaddress[0]', 'Value': '0xFF'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDMACSEL[0]', 'Value': '-'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" FUNC(void, ADC_PRIVATE_CODE) Adc_DmaInit(void) /* PRQA S 1532 # JV-01 */ { #if (ADC_FUNCTIONALITY_MODE != ADC_POLLING) P2CONST(Adc_DmaConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpSGmDmaConfig; uint8 LucLoopCount; P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2CONST(Adc_HwSgUnitType, AUTOMATIC, ADC_CONFIG_DATA) LpSgUnitConfig; uint8 LucSgUnitCount; uint8 LucSgLoopCount; uint8 LucInitialPosition; #endif /* (ADC_FUNCTIONALITY_MODE != ADC_POLLING) */ #if (ADC_IP_ADCK == STD_ON) uint32 LulLoopCount; uint32 LulShift; uint32 LulGroupSelect; #endif /* (ADC_IP_ADCK == STD_ON) */ #if ((ADC_IP_ADCH == STD_ON) || (ADC_IP_ADCJ == STD_ON)) /* Set DMA Transfer Request Group Selection */ ADC_DMACSEL0_0 &= ~ADC_REQUESTGROUP00_MASK; /* PRQA S 0303 # JV-01 */ ADC_DMACSEL0_1 &= ~ADC_REQUESTGROUP01_MASK; /* PRQA S 0303 # JV-01 */ ADC_DMACSEL1_0 &= ~ADC_REQUESTGROUP10_MASK; /* PRQA S 0303 # JV-01 */ ADC_DMACSEL1_1 &= ~ADC_REQUESTGROUP11_MASK; /* PRQA S 0303 # JV-01 */ /* Perform synchronization for DMATRGSEL */ (void)ADC_DMACSEL1_1; /* PRQA S 0303 # JV-01 */ EXECUTE_SYNCP(); #endif /* ((ADC_IP_ADCH == STD_ON) || (ADC_IP_ADCJ == STD_ON)) */ #if (ADC_IP_ADCK == STD_ON) for (LulLoopCount = 0UL; LulLoopCount < (uint32)Adc_GucMaxDmaChannels; LulLoopCount++) { /* Get the pointer to DMA configuration */ LpSGmDmaConfig = &Adc_GpDmaUnitConfig[LulLoopCount]; /* PRQA S 2824 # JV-01 */ /* Configure the DMA Transfer Request Group Selection Register */ LulShift = (LpSGmDmaConfig->ulDmaResourceValue & ADC_DMA_CSEL_SHIFT_MASK) << 1U; /* PRQA S 2814 # JV-01 */ LulGroupSelect = *LpSGmDmaConfig->pDMACSEL; /* PRQA S 2814 # JV-01 */ LulGroupSelect &= ~(ADC_DMA_CSEL_MASK << LulShift); LulGroupSelect |= (uint32)LpSGmDmaConfig->ucDmaRequestGroup << LulShift; *LpSGmDmaConfig->pDMACSEL = LulGroupSelect; } /* end of for (LulLoopCount = 0UL; LulLoopCount < (uint32)Adc_GucMaxDmaChannels; LulLoopCount++) */ /* Perform dummy read and synchronization for DMATRGSEL */ (void)*Adc_GpDmaUnitConfig[0].pDMACSEL; /* PRQA S 2814 # JV-01 */ EXECUTE_SYNCP(); #endif /* (ADC_IP_ADCK == STD_ON) */ #if (ADC_FUNCTIONALITY_MODE != ADC_POLLING) LucInitialPosition = ADC_VAL_BYTE_INIT; for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < (uint8)ADC_MAX_HW_UNITS; LucLoopCount++) /* PRQA S 2877 # JV-01 */ { /* Initialize the local variable for HW unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucLoopCount]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit count */ LucSgUnitCount = LpHwUnitConfig->ucSgUnitCount; /* PRQA S 2814 # JV-01 */ for (LucSgLoopCount = ADC_COUNT_BYTE_INIT; LucSgLoopCount < LucSgUnitCount; LucSgLoopCount++) { LpSgUnitConfig = &Adc_GpSgUnitConfig[LucInitialPosition]; /* PRQA S 2824 # JV-01 */ /* Check SG use DMA and interrupt mode or not */ if ((ADC_INTERRUPT_MODE == LpSgUnitConfig->enFunctionalityModeType) && /* PRQA S 2814 # JV-01 */ (ADC_DMA_CHANNEL_OFF != LpSgUnitConfig->ucDmaChannelIndex)) { /* Get the pointer to DMA configuration */ LpSGmDmaConfig = &Adc_GpDmaUnitConfig[LpSgUnitConfig->ucDmaChannelIndex]; /* PRQA S 2824 # JV-01 */ /* Enable DMA channel interrupt and perform synchronization for INTC2 */ RH850_SV_CLEAR_ICR_SYNCP(8, LpSGmDmaConfig->pDmaEicRegaddress, (uint8)~ADC_EIC_EIMK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ } /* else: No action required */ /* InitPosition is incrementation */ LucInitialPosition++; /* PRQA S 3383 # JV-01 */ } /* end of for (LucSgLoopCount = ADC_COUNT_BYTE_INIT; LucSgLoopCount < LucSgUnitCount; LucSgLoopCount++) */ } /* end of for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < (uint8)ADC_MAX_HW_UNITS; LucLoopCount++) */ #endif /* (ADC_FUNCTIONALITY_MODE != ADC_POLLING) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'ADC_MAX_HW_UNITS', 'Value': '3'], 'Input_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL0_0_Test', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL0_1_Test', 'Value': '0x01'], 'Input_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL1_0_Test', 'Value': '0x10'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL1_1_Test', 'Value': '0x11'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '[0..4]', 'Name': 'ucSgUnitCount', 'Value': '[0 to 2] = 2'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': 'ADC_INTERRUPT_MODE\\nADC_POLLING_MODE\\nADC_POLLING_INTERRUPT_MODE', 'Name': 'enFunctionalityModeType', 'Value': '[0 to 2] = ADC_POLLING_MODE'], 'Input_Param_009': ['Type': 'Array', 'Range': 'E2x: 0..19\\nU2x: 0..14', 'Name': 'ucDmaChannelIndex', 'Value': '[0 to 2] = 7'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxDmaChannels', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpDmaUnitConfig', 'Value': '&map_Adc_GpDmaUnitConfig[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulDmaResourceValue', 'Value': '0x01'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucDmaRequestGroup', 'Value': '0x02'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pDMACSEL', 'Value': '&map_pDMACSEL[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDMACSEL[0]', 'Value': '0x01'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pDmaEicRegaddress', 'Value': '&map_pDmaEicRegaddress[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pDmaEicRegaddress', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pDmaEicRegaddress', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDmaEicRegaddress[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL0_0_Test', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL0_1_Test', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL1_0_Test', 'Value': '-'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ADC_DMACSEL1_1_Test', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDmaEicRegaddress[0]', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDMACSEL[0]', 'Value': '0x09'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_DMA_MODE == STD_ON) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_CODE_FAST) Adc_DmaIsr(const uint8 LucHwUnitIndex, const uint8 LucSgUnitIndex) /* PRQA S 1505 # JV-01 */ { P2VAR(volatile Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; #if (ADC_ENABLE_ADTIMER == STD_ON) P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ /* Local variable to store the group number */ Adc_GroupType LddGroup; uint8 LucSgUnitId; #if (((ADC_ENABLE_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || \\ (ADC_ENABLE_LIMIT_CHECK == STD_ON) || (ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR == STD_ON)) boolean LblErrorFlag; #endif #if (ADC_ENABLE_STREAMING == STD_ON) uint8 LucFirstHalf; #endif /* (ADC_ENABLE_STREAMING == STD_ON) */ boolean LblDmaTimedOut; boolean LblHwTimedOut; boolean LblDataAvailable; boolean LblConversionCompleted; #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && \\ ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) || (ADC_ENABLE_QUEUING == STD_ON))) uint8 LddNextGroup; #endif /* Initialize DMA transfer completion flag to ADC_TRUE */ LblDataAvailable = ADC_TRUE; /* Initialize timeout flags to ADC_FALSE */ LblDmaTimedOut = ADC_FALSE; LblHwTimedOut = ADC_FALSE; /* Initialize the conversion completed flag */ LblConversionCompleted = ADC_FALSE; /* Get the pointer to the SG unit runtime data */ LpSgUnitData = &Adc_GpSgUnitRamData[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the current conversion group number */ LddGroup = LpSgUnitData->ddCurrentConvGroup; /* PRQA S 2814 # JV-01 */ /* Get the pointer to the group runtime data */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the pointer to the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit Id */ LucSgUnitId = Adc_GpSgUnitConfig[LucSgUnitIndex].ucSgUnitId; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_ADTIMER == STD_ON) /* Get the base register address of the hardware unit */ LpAdcRegisters = Adc_GpHwUnitConfig[LucHwUnitIndex].pHwUnitBaseAddress; /* PRQA S 2824 # JV-01 */ #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #if (ADC_FUNCTIONALITY_MODE != ADC_INTERRUPT) if (ADC_POLLING_MODE == Adc_GpSgUnitConfig[LucSgUnitIndex].enFunctionalityModeType) /* PRQA S 2824 # JV-01 */ { /* Check DMA completion status when called in polling mode */ LblDataAvailable = Adc_DmaGetTransferStatus(LddGroup); } /* else: No action required */ if (ADC_TRUE == LblDataAvailable) #endif /* (ADC_FUNCTIONALITY_MODE != ADC_INTERRUPT) */ { /* Clear DMA transfer end flag */ Adc_DmaClearInterruptFlag(LddGroup); #if (((ADC_ENABLE_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || \\ (ADC_ENABLE_LIMIT_CHECK == STD_ON) || (ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR_INT == STD_ON)) /* Get and check the error status including the parity error when using the error interrupt */ LblErrorFlag = Adc_CheckError(LddGroup); if (ADC_TRUE == LblErrorFlag) { /* Clear the read data available flag */ LblDataAvailable = ADC_FALSE; } /* else: No action required */ #endif #if (ADC_ENABLE_PARITY_ERR == STD_ON) #if (ADC_ENABLE_PARITY_ERR_INT == STD_ON) /* Check if error interrupt is disabled */ if (ADC_FALSE == Adc_GpHwUnitConfig[LucHwUnitIndex].blInterruptErr) /* PRQA S 2824 # JV-01 */ #endif /* (ADC_ENABLE_PARITY_ERR_INT == STD_ON) */ { /* Check for parity error that may occur when read by DMA */ LblErrorFlag = Adc_CheckParity(LddGroup); if (ADC_TRUE == LblErrorFlag) { /* Clear the read data available flag */ LblDataAvailable = ADC_FALSE; } /* else: No action required */ } /* else: No action required */ #endif /* (ADC_ENABLE_PARITY_ERR == STD_ON) */ #if (ADC_ENABLE_STREAMING == STD_ON) /* Increment the counter even if there is an error in case of streaming in DMA */ if (ADC_ACCESS_MODE_STREAMING == LpGroup->enGroupAccessMode) /* PRQA S 2814 # JV-01 */ { /* First half streaming sample */ LucFirstHalf = (uint8)(((uint32)LpGroup->ddNumberofSamples + 1UL) >> 1U); /* PRQA S 3383 # JV-04 */ /* Update the number of completed samples. (Possible values are 0, half, full) */ if (LpGroupData->ucSamplesCompleted != LucFirstHalf) /* PRQA S 2814 # JV-01 */ { LpGroupData->ucSamplesCompleted = LucFirstHalf; } else { LpGroupData->ucSamplesCompleted = LpGroup->ddNumberofSamples; } if (LpGroupData->ucSamplesCompleted == LpGroup->ddNumberofSamples) { /* All samples have completed the conversion */ Adc_SetStatus(LddGroup, ADC_STREAM_COMPLETED); if (ADC_STREAM_BUFFER_LINEAR == LpGroup->enStreamBufferMode) { LblConversionCompleted = ADC_TRUE; } /* else: No action required */ } else { /* Half of the samples have completed the conversion */ Adc_SetStatus(LddGroup, ADC_COMPLETED); } /* Set the flag indicating Adc_ReadGroup or Adc_GetStreamLastPointer should be called */ LpGroupData->blResultRead = ADC_FALSE; /* Set the read data enable flag for streaming even if any error occurs */ LblDataAvailable = ADC_TRUE; } /* end of if (ADC_ACCESS_MODE_STREAMING == LpGroup->enGroupAccessMode) */ else #endif /* (ADC_ENABLE_STREAMING == STD_ON) */ { /* Discard data if an error occurs in DMA single mode */ #if (((ADC_ENABLE_ERR == STD_ON) && (ADC_IP_ADCH == STD_OFF)) || (ADC_ENABLE_OVERWRITE_ERR == STD_ON) || \\ (ADC_ENABLE_LIMIT_CHECK == STD_ON) || (ADC_ENABLE_ERR_INT == STD_ON) || (ADC_ENABLE_PARITY_ERR == STD_ON)) #if (ADC_TRACK_AND_HOLD == STD_ON) /* If the requested group is for T&H, do not discard the result even when error is detected */ if (ADC_TH_DISABLED != LpGroup->ucTrackAndHoldGroup) /* PRQA S 2814 # JV-01 */ { /* Set the read data available flag even if the error occurs */ LblDataAvailable = ADC_TRUE; } /* else: No action required */ #endif /* (ADC_TRACK_AND_HOLD == STD_ON) */ if (ADC_TRUE == LblDataAvailable) #endif { /* Update the completed conversion samples */ LpGroupData->ucSamplesCompleted = ADC_COUNT_BYTE_ONE; /* PRQA S 2814 # JV-01 */ /* Stop scan group if requested group is implicitly stopped */ if (ADC_TRUE == LpGroup->blImplicitlyStopped) /* PRQA S 2814 # JV-01 */ { LblConversionCompleted = ADC_TRUE; } /* else: No action required */ Adc_SetStatus(LddGroup, ADC_STREAM_COMPLETED); /* Set the flag indicating Adc_ReadGroup or Adc_GetStreamLastPointer should be called */ LpGroupData->blResultRead = ADC_FALSE; } /* else: No action required */ } /* Check whether current group is implicitly stopped or not */ if (ADC_TRUE == LblConversionCompleted) { /* Stop the DMA and scan group */ LblDmaTimedOut = Adc_DmaDisable(LddGroup); LblHwTimedOut = Adc_HwStopScanGroup(LddGroup, ADC_FALSE); #if (ADC_ENABLE_PIC_TSEL == STD_ON) /* Check if the conversion is HW Triggered */ if (LddGroup >= Adc_GucMaxSwTriggGroups) { /* Clear to avoid conversion on next HW trigger */ Adc_PicClearHwTrigger(LddGroup); } /* else: No action required */ #endif /* (ADC_HW_TRIGGER_API == STD_ON) */ #if ((ADC_ENABLE_SELF_DIAG_PIN_LVL == STD_ON) || \\ (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) || (ADC_ENABLE_WIRE_BRK == STD_ON)) /* Disable self-diagnosis pin level and wiring break detection if they are configured */ Adc_DisableDetection(LddGroup); #endif /* Change SG unit status to inactive */ LpSgUnitData->blSgUnitStatus = ADC_FALSE; Adc_GaaHwUnitData[LucHwUnitIndex].ucSgUnitStatus &= ~(1U << LucSgUnitId); /* PRQA S 2844 # JV-01 */ #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && \\ ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) || (ADC_ENABLE_QUEUING == STD_ON))) /* Check if DMA and SG are stopped */ if ((ADC_FALSE == LblDmaTimedOut) && (ADC_FALSE == LblHwTimedOut)) { /* Fetch the next group for conversion if the queue is not empty */ LddNextGroup = Adc_PopFromQueue(LucSgUnitIndex); if (ADC_INVALID_GROUP != LddNextGroup) { Adc_ConfigureGroupForConversion(LddNextGroup); } /* else: No action required */ } /* else: No action required */ #endif } /* end of if (ADC_TRUE == LblConversionCompleted) */ else { #if (ADC_ENABLE_ADTIMER == STD_ON) /* If AD timer is enabled and group is one-shot, just stop AD timer */ if ((ADC_TRUE == LpGroup->blAdcEnableAdTimerTriggMode) && (ADC_CONV_MODE_ONESHOT == LpGroup->enGroupConvMode)) { LpAdcRegisters->aaADCXnSG[LucSgUnitId].ucADCXnADTENDCRx = ADC_ADCX_ADTENDCR_ADTEND; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } /* else: No action required */ #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ } } /* end of if (ADC_TRUE == LblDataAvailable) */ /* else: No action required */ /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); if (ADC_TRUE == LblDataAvailable) { #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON) /* Call to notification function */ Adc_CallGroupNotify(LddGroup); #endif /* Report an error to Dem if some timeouts occur */ if ((ADC_TRUE == LblDmaTimedOut) || (ADC_TRUE == LblHwTimedOut)) { ADC_DEM_REPORT_ERROR(ADC_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* else: No action required */ } /* else: No action required */ #if ((ADC_ENABLE_ERR == STD_ON) || (ADC_ENABLE_PARITY_ERR == STD_ON)) /* Report errors to Dem and invokes error notification callback functions, if any errors are detected */ Adc_ReportError(LddGroup); #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': 'E2x: 0..3\\nU2x: 0..2', 'Name': 'LucHwUnitIndex', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'x', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'y', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'z', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'a', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'enFunctionalityModeType', 'Value': 'ADC_POLLING_MODE'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'blInterruptErr', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ddNumberofSamples', 'Value': '0xFF'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucTrackAndHoldGroup', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'ADC_ACCESS_MODE_SINGLE\\nADC_ACCESS_MODE_STREAMING', 'Name': 'enGroupAccessMode', 'Value': 'ADC_ACCESS_MODE_STREAMING'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'ADC_STREAM_BUFFER_LINEAR\\nADC_STREAM_BUFFER_CIRCULAR', 'Name': 'enStreamBufferMode', 'Value': 'ADC_STREAM_BUFFER_LINEAR'], 'Input_Param_020': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_TRUE'], 'Input_Param_021': ['Type': 'Variable', 'Range': 'ADC_CONV_MODE_ONESHOT\\nADC_CONV_MODE_CONTINUOUS', 'Name': 'enGroupConvMode', 'Value': 'ADC_CONV_MODE_ONESHOT'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '0xFF'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': 'ADC_QUEUE_FILLED'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'blAdcEnableAdTimerTriggMode', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitStatus', 'Value': '0'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'ADC_TRUE'], 'Input_Param_027': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'ADC_TRUE'], 'Input_Param_028': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_029': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_030': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_031': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '0x80'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blResultRead', 'Value': 'ADC_FALSE'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucADCXnADTENDCRx', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenStatusType', 'Value': 'ADC_COMPLETED'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'ADC_FALSE', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddNextGroup', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ #if (ADC_DMA0_ISR_CH00_API == STD_ON) /* Defines the CAT2 interrupt mapping */ #if defined (Os_ADC_DMA0_CH00_CAT2_ISR) || (ADC_ISR_CATEGORY_2 == STD_ON) ISR(ADC_DMA0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ADC_CODE_FAST) ADC_DMA0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif /* defined (Os_ADC_DMA0_CH00_CAT2_ISR) || (ADC_ISR_CATEGORY_2 == STD_ON) */ { #if (ADC_INTERRUPT_CONSISTENCY_CHECK == STD_ON) /* Check whether the EIMK bit of EIC is set */ if (ADC_EIC_EIMK == (uint8)((ADC_EIC_DMA0_BASEADDR)[ADC_DMA_CHANNEL_0] & ADC_EIC_EIMK)) /* PRQA S 0303 # JV-01 */ { /* Reporting to DEM that interrupt from unknown source */ ADC_DEM_REPORT_ERROR(ADC_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } else #endif /* (ADC_INTERRUPT_CONSISTENCY_CHECK == STD_ON) */ { Adc_DmaIsr(Adc_GpDmaHWUnitMapping[ADC_DMA_CHANNEL_0], Adc_GpDmaSGUnitMapping[ADC_DMA_CHANNEL_0]); /* PRQA S 2824 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '2 = ADC_DMA1_CH02_ISR'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Offset', 'Value': '2'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Dma_Channel', 'Value': '18'], 'Input_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_DMA0_Test[CURRENT_TEST.Offset]', 'Value': '-'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_DMA1_Test[CURRENT_TEST.Offset]', 'Value': '0x0080'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpDmaHWUnitMapping', 'Value': '&map_Adc_GpDmaHWUnitMapping[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpDmaHWUnitMapping[CURRENT_TEST.Count_Dma_Channel]', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpDmaSGUnitMapping', 'Value': '&map_Adc_GpDmaSGUnitMapping[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpDmaSGUnitMapping[CURRENT_TEST.Count_Dma_Channel]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_INT_INCONSISTENT'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '-'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ #if (ADC_DMA0_ISR_CH00_API == STD_ON) /* Defines the CAT2 interrupt mapping */ #if defined (Os_ADC_DMA0_CH00_CAT2_ISR) || (ADC_ISR_CATEGORY_2 == STD_ON) ISR(ADC_DMA0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ADC_CODE_FAST) ADC_DMA0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif /* defined (Os_ADC_DMA0_CH00_CAT2_ISR) || (ADC_ISR_CATEGORY_2 == STD_ON) */ { #if (ADC_INTERRUPT_CONSISTENCY_CHECK == STD_ON) /* Check whether the EIMK bit of EIC is set */ if (ADC_EIC_EIMK == (uint8)((ADC_EIC_DMA0_BASEADDR)[ADC_DMA_CHANNEL_0] & ADC_EIC_EIMK)) /* PRQA S 0303 # JV-01 */ { /* Reporting to DEM that interrupt from unknown source */ ADC_DEM_REPORT_ERROR(ADC_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } else #endif /* (ADC_INTERRUPT_CONSISTENCY_CHECK == STD_ON) */ { Adc_DmaIsr(Adc_GpDmaHWUnitMapping[ADC_DMA_CHANNEL_0], Adc_GpDmaSGUnitMapping[ADC_DMA_CHANNEL_0]); /* PRQA S 2824 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '11 = ADC_DMA1_CH11_ISR'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Offset', 'Value': '11'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Dma_Channel', 'Value': '27'], 'Input_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_DMA0_Test[CURRENT_TEST.Offset]', 'Value': '-'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_DMA1_Test[CURRENT_TEST.Offset]', 'Value': '0x0000'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpDmaHWUnitMapping', 'Value': '&map_Adc_GpDmaHWUnitMapping[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpDmaHWUnitMapping[CURRENT_TEST.Count_Dma_Channel]', 'Value': '3'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpDmaSGUnitMapping', 'Value': '&map_Adc_GpDmaSGUnitMapping[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpDmaSGUnitMapping[CURRENT_TEST.Count_Dma_Channel]', 'Value': '19']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '3'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '19'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ #if (ADC_DMA0_ISR_CH00_API == STD_ON) /* Defines the CAT2 interrupt mapping */ #if defined (Os_ADC_DMA0_CH00_CAT2_ISR) || (ADC_ISR_CATEGORY_2 == STD_ON) ISR(ADC_DMA0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ADC_CODE_FAST) ADC_DMA0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif /* defined (Os_ADC_DMA0_CH00_CAT2_ISR) || (ADC_ISR_CATEGORY_2 == STD_ON) */ { #if (ADC_INTERRUPT_CONSISTENCY_CHECK == STD_ON) /* Check whether the EIMK bit of EIC is set */ if (ADC_EIC_EIMK == (uint8)((ADC_EIC_DMA0_BASEADDR)[ADC_DMA_CHANNEL_0] & ADC_EIC_EIMK)) /* PRQA S 0303 # JV-01 */ { /* Reporting to DEM that interrupt from unknown source */ ADC_DEM_REPORT_ERROR(ADC_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } else #endif /* (ADC_INTERRUPT_CONSISTENCY_CHECK == STD_ON) */ { Adc_DmaIsr(Adc_GpDmaHWUnitMapping[ADC_DMA_CHANNEL_0], Adc_GpDmaSGUnitMapping[ADC_DMA_CHANNEL_0]); /* PRQA S 2824 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '0 = ADC_DMA0_CH00_ISR'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Offset', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Dma_Channel', 'Value': '0'], 'Input_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_DMA0_Test[CURRENT_TEST.Offset]', 'Value': '0x0002'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ADC_EIC_DMA1_Test[CURRENT_TEST.Offset]', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpDmaHWUnitMapping', 'Value': '&map_Adc_GpDmaHWUnitMapping[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpDmaHWUnitMapping[CURRENT_TEST.Count_Dma_Channel]', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpDmaSGUnitMapping', 'Value': '&map_Adc_GpDmaSGUnitMapping[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpDmaSGUnitMapping[CURRENT_TEST.Count_Dma_Channel]', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '0'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '0'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_DISABLE_CHANNEL == STD_ON) #define ADC_START_SEC_PUBLIC_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PUBLIC_CODE) Adc_EnableChannel(Adc_GroupType Group, Adc_ChannelType ChannelId) /* PRQA S 1503 # JV-01 */ { #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) boolean LblDetErrFlag; /* Initialize the Det error flag to ADC_FALSE */ LblDetErrFlag = ADC_FALSE; #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Check if the ADC Module is not Initialized */ if (ADC_UNINITIALIZED == Adc_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_CHANNEL_SID, ADC_E_UNINIT); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* Check if the requested group is invalid group ID */ else if (Group >= Adc_GucNoOfGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_CHANNEL_SID, ADC_E_PARAM_GROUP); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } else #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Check if the group is already enabled */ if (ADC_IDLE != Adc_GpGroupRamData[Group].enGroupStatus) /* PRQA S 2824 # JV-01 */ { /* Report Error to DET */ ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_CHANNEL_SID, ADC_E_BUSY); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* else: No action required */ #if ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) || (ADC_ENABLE_QUEUING == STD_ON)) /* Check if the group is present in queue */ if (ADC_TRUE == Adc_GpGroupRamData[Group].blGrpPresent) /* PRQA S 2824 # JV-01 */ { /* Report Error to DET */ ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_CHANNEL_SID, ADC_E_BUSY); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* else: No action required */ #endif /* ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) || (ADC_ENABLE_QUEUING == STD_ON)) */ } /* Check if no errors were detected */ if (ADC_FALSE == LblDetErrFlag) #endif /* ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) */ { /* Set the channel to be enabled for conversion after start group conversion. */ Adc_IntDisableEnableChannel(Group, ChannelId, ADC_TRUE); } /* else: No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': '-', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'Group', 'Value': '254'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'ChannelId', 'Value': '27'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GblDriverStatus', 'Value': 'ADC_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucNoOfGroups', 'Value': '255'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,\\nADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': 'ADC_IDLE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blGrpPresent', 'Value': 'ADC_FALSE']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '254'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '27'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblApiType', 'Value': 'ADC_TRUE'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_HW_TRIGGER_API == STD_ON) #define ADC_START_SEC_PUBLIC_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PUBLIC_CODE) Adc_EnableHardwareTrigger(Adc_GroupType Group) /* PRQA S 1503 # JV-01 */ { #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) boolean LblDetErrFlag; /* Initialize the Det error flag to ADC_FALSE */ LblDetErrFlag = ADC_FALSE; #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Check if the ADC Module is not initialized */ if (ADC_UNINITIALIZED == Adc_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_HARDWARE_TRIGGER_SID, ADC_E_UNINIT); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* Check if the requested group is invalid group ID */ else if (Group >= Adc_GucNoOfGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_HARDWARE_TRIGGER_SID, ADC_E_PARAM_GROUP); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* valid group ID */ else #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ { #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Check if requested group is SW triggered group */ if (Group < Adc_GucMaxSwTriggGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_HARDWARE_TRIGGER_SID, ADC_E_WRONG_TRIGG_SRC); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* else: No action required */ #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ /* Check if the requested group is already enabled and not implicitly stopped */ if ((ADC_TRUE == Adc_GpGroupRamData[Group].blHwTriggStatus) && /* PRQA S 2824 # JV-01 */ ((ADC_FALSE == Adc_GpGroupConfig[Group].blImplicitlyStopped) || /* PRQA S 2824 # JV-01 */ (ADC_STREAM_COMPLETED != Adc_GpGroupRamData[Group].enGroupStatus))) { /* Report Error to DET */ ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_HARDWARE_TRIGGER_SID, ADC_E_BUSY); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* else: No action required */ #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Check if result buffer is initialized for requested group */ if (ADC_FALSE == Adc_GpGroupRamData[Group].blBufferStatus) /* PRQA S 2824 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_HARDWARE_TRIGGER_SID, ADC_E_BUFFER_UNINIT); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* else: No action required */ #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ } /* Check if no errors were detected */ if (ADC_FALSE == LblDetErrFlag) #endif /* ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) */ { /* Enable the hardware trigger */ (void)Adc_HwEnableHardwareTrigger(Group); } /* else: No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': '-', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..254', 'Name': 'Group', 'Value': '254'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ADC_UNINITIALIZED (0)\\nADC_INITIALIZED (1)', 'Name': 'Adc_GblDriverStatus', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '1..255', 'Name': 'Adc_GucNoOfGroups', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0..255', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blHwTriggStatus', 'Value': 'ADC_TRUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,\\nADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': 'ADC_IDLE'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blBufferStatus', 'Value': 'ADC_TRUE'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_TRUE'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '254'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_HW_TRIGGER_API == STD_ON) #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, ADC_PRIVATE_CODE) Adc_EnableHwGroup(const Adc_GroupType LddGroup) { #if (ADC_ENABLE_ADC_TSEL == STD_ON) P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; #endif /* (ADC_ENABLE_ADC_TSEL == STD_ON) */ P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2VAR(volatile Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; uint8 LucSgUnitIndex; /* Get the pointer to requested group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ LucSgUnitIndex = LpGroup->ucSgUnitIndex; /* PRQA S 2814 # JV-01 */ /* Initialize HW RAM data to a local pointer */ LpSgUnitData = &Adc_GpSgUnitRamData[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Read the group data pointer */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_PWM_DIAG == STD_ON) /* Check if trigger source of requested group is PWM-Diag */ if (ADC_TRUE == LpGroup->blPwmDiag) { /* No action required for HW triggers when enabling PWM-Diag */ } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { #if (ADC_ENABLE_ADC_TSEL == STD_ON) /* Get the HW unit configuration. */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LpGroup->ucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Check if requested group belongs to HW unit in AWO */ if (NULL_PTR != LpHwUnitConfig->pSgTriggReg) /* PRQA S 2814 # JV-01 */ { /* No action required for HW triggers as those for HW unit in AWO are statically configured at initialization */ } else #endif /* (ADC_ENABLE_ADC_TSEL == STD_ON) */ { #if (ADC_ENABLE_PIC_TSEL == STD_ON) /* Enable Hw trigger of PIC unit */ Adc_PicEnableHwTrigger(LddGroup); #endif /* (ADC_ENABLE_PIC_TSEL == STD_ON) */ } } /* Set the Trigger status for the group as true */ LpGroupData->blHwTriggStatus = ADC_TRUE; /* PRQA S 2814 # JV-01 */ /* Set the SG unit status to busy */ LpSgUnitData->blSgUnitStatus = ADC_TRUE; /* PRQA S 2814 # JV-01 */ /* Reset the number of completed sample to zero. */ LpGroupData->ucSamplesCompleted = ADC_COUNT_BYTE_INIT; /* Reset the number of completed channels to zero. */ LpGroupData->ucChannelsCompleted = ADC_COUNT_BYTE_INIT; /* Configure the group for conversion */ Adc_ConfigureGroupForConversion(LddGroup); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'x', 'Value': ''], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '14'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitIndex', 'Value': '&map_Adc_GpHwUnitIndex[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0x00..0x03, 0xFF', 'Name': 'map_Adc_GpHwUnitIndex[2]', 'Value': '0x00'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0..2', 'Name': 'ucHwUnitIndex', 'Value': 'ADC_HWUNIT_1'], 'Input_Param_018': ['Type': 'Variable', 'Range': '0..2', 'Name': 'ucHwUnitIndex', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '0..2', 'Name': 'ucHwUnitIndex', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHWGroupTrigg', 'Value': '&map_Adc_GpHWGroupTrigg[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '0x0000000..0x00008100', 'Name': 'map_Adc_GpHWGroupTrigg[0 to 1]', 'Value': '[0] = 0x00000001'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'pSgTriggReg', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'pSgTriggReg', 'Value': 'NULL_PTR'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'pSgTriggReg', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blHwTriggStatus', 'Value': 'ADC_TRUE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': 'ADC_COUNT_BYTE_INIT'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': 'ADC_COUNT_BYTE_INIT'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_TRUE'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_PUBLIC_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Adc_StatusType, ADC_PUBLIC_CODE) Adc_GetGroupStatus(Adc_GroupType Group) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Local variable to store the group status */ Adc_StatusType LenGroupStatus; #if (ADC_DEV_ERROR_DETECT == STD_ON) boolean LblDetErrFlag; /* Default value that to be returned in case of error */ LenGroupStatus = ADC_IDLE; /* Initialize the Det error flag to ADC_FALSE */ LblDetErrFlag = ADC_FALSE; /* Check if the ADC Module is not Initialized */ if (ADC_UNINITIALIZED == Adc_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_GET_GROUP_STATUS_SID, ADC_E_UNINIT); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } /* Check if the requested group is invalid group ID */ else if (Group >= Adc_GucNoOfGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_GET_GROUP_STATUS_SID, ADC_E_PARAM_GROUP); /* Set the error status flag to ADC_TRUE */ LblDetErrFlag = ADC_TRUE; } else { /* No action required as group Id is valid */ } /* Check if no errors were detected */ if (ADC_FALSE == LblDetErrFlag) #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Read the group status */ LenGroupStatus = Adc_GpGroupRamData[Group].enGroupStatus; /* PRQA S 2824 # JV-01 */ } /* else: No action required */ return LenGroupStatus; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': '-', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..254', 'Name': 'Group', 'Value': '254'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ADC_UNINITIALIZED\\nADC_INITIALIZED', 'Name': 'Adc_GblDriverStatus', 'Value': 'ADC_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '1..255', 'Name': 'Adc_GucNoOfGroups', 'Value': '255'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enGroupStatus', 'Value': 'ADC_COMPLETED']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenGroupStatus', 'Value': 'ADC_COMPLETED'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((ADC_FUNCTIONALITY_MODE != ADC_POLLING) || (ADC_READ_GROUP_API == STD_ON)) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(boolean, ADC_CODE_FAST) Adc_GroupCompleteMode(const Adc_GroupType LddGroup, const uint8 LucHwUnitIndex) { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; #if (ADC_ENABLE_ADTIMER == STD_ON) P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ P2VAR(volatile Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2CONST(Adc_HwSgUnitType, AUTOMATIC, ADC_CONFIG_DATA) LpSgUnitConfig; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; uint8 LucSgUnitId; uint8 LucSgUnitIndex; #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && \\ ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) || (ADC_ENABLE_QUEUING == STD_ON))) Adc_GroupType LddNextGroup; #endif boolean LblHwTimedOut; /* Initialize scan group stop timeout flag to ADC_FALSE */ LblHwTimedOut = ADC_FALSE; /* Read the hardware unit of the group */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Read the group data pointer */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit to which the channel group is mapped */ LucSgUnitIndex = LpGroup->ucSgUnitIndex; /* PRQA S 2814 # JV-01 */ /* Initialize HW RAM data to a local pointer */ LpSgUnitData = &Adc_GpSgUnitRamData[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit which is configured for this group */ LpSgUnitConfig = &Adc_GpSgUnitConfig[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit Id */ LucSgUnitId = LpSgUnitConfig->ucSgUnitId; /* PRQA S 2814 # JV-01 */ #if (ADC_ENABLE_ADTIMER == STD_ON) /* Read the base address of the hardware unit */ LpAdcRegisters = Adc_GpHwUnitConfig[LucHwUnitIndex].pHwUnitBaseAddress; /* PRQA S 2824 # JV-01 */ #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ /* Check if the conversion of all the samples are completed */ if (LpGroupData->ucSamplesCompleted == LpGroup->ddNumberofSamples) /* PRQA S 2814 # JV-01 */ { LpGroupData->ucSamplesCompleted = ADC_COUNT_BYTE_INIT; } /* else: No action required */ /* Update the completed conversion samples */ LpGroupData->ucSamplesCompleted++; /* PRQA S 3383, 3387 # JV-02, JV-01 */ #if (ADC_ENABLE_STREAMING == STD_ON) /* Check if the result access mode is Streaming */ if (ADC_ACCESS_MODE_STREAMING == LpGroup->enGroupAccessMode) { /* Update the buffer pointer to point to the next sample */ LpGroupData->pBuffer++; /* PRQA S 3387 # JV-01 */ /* Check if the conversion of all the samples are completed */ if (LpGroupData->ucSamplesCompleted == LpGroup->ddNumberofSamples) { /* If the conversion mode is circular buffer, reload the result buffer pointer */ if (ADC_STREAM_BUFFER_CIRCULAR == LpGroup->enStreamBufferMode) { LpGroupData->pBuffer = LpGroupData->pChannelBuffer; } /* else: No action required */ /* Set group status as conversion completed */ Adc_SetStatus(LddGroup, ADC_STREAM_COMPLETED); } else { /* Set group status as conversion completed */ Adc_SetStatus(LddGroup, ADC_COMPLETED); } /* Set the flag indicating Adc_ReadGroup or Adc_GetStreamLastPointer should be called */ LpGroupData->blResultRead = ADC_FALSE; } /* end of if (ADC_ACCESS_MODE_STREAMING == LpGroup->enGroupAccessMode) */ else #endif /* (ADC_ENABLE_STREAMING == STD_ON) */ { /* Set group status as conversion completed */ Adc_SetStatus(LddGroup, ADC_STREAM_COMPLETED); /* Set the flag indicating Adc_ReadGroup or Adc_GetStreamLastPointer should be called */ LpGroupData->blResultRead = ADC_FALSE; } /* Check if the conversion of all the samples are completed */ if (ADC_STREAM_COMPLETED == LpGroupData->enGroupStatus) { /* Check if the conversion is implicitly stopped */ if (ADC_TRUE == LpGroup->blImplicitlyStopped) { /* Stop the conversion of the SG unit */ LblHwTimedOut = Adc_HwStopScanGroup(LddGroup, ADC_FALSE); #if (ADC_FUNCTIONALITY_MODE != ADC_POLLING) /* Check if the Group is mapped for HW configured for interrupt mode */ if (ADC_INTERRUPT_MODE == LpSgUnitConfig->enFunctionalityModeType) { /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_INTERRUPT_CONTROL_PROTECTION); /* Disable interrupt for SG unit to which group is mapped */ Adc_DisableConvertInterrupt(LucHwUnitIndex, LucSgUnitIndex); /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_INTERRUPT_CONTROL_PROTECTION); } /* else: No action required */ #endif /* (ADC_FUNCTIONALITY_MODE != ADC_POLLING) */ #if (ADC_ENABLE_PIC_TSEL == STD_ON) /* Check if the conversion is HW Triggered */ if (LddGroup >= Adc_GucMaxSwTriggGroups) { /* Clear to avoid conversion on next HW trigger */ Adc_PicClearHwTrigger(LddGroup); } /* else: No action required */ #endif /* (ADC_HW_TRIGGER_API == STD_ON) */ #if ((ADC_ENABLE_SELF_DIAG_PIN_LVL == STD_ON) || \\ (ADC_ENABLE_SELF_DIAG_WIRE_BRK == STD_ON) || (ADC_ENABLE_WIRE_BRK == STD_ON)) /* Disable self-diagnosis pin level and wiring break detection if they are configured */ Adc_DisableDetection(LddGroup); #endif /* Change SG unit status to inactive */ LpSgUnitData->blSgUnitStatus = ADC_FALSE; /* PRQA S 2814 # JV-01 */ Adc_GaaHwUnitData[LucHwUnitIndex].ucSgUnitStatus &= ~(1U << LucSgUnitId); /* PRQA S 2844 # JV-01 */ #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && \\ ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) || (ADC_ENABLE_QUEUING == STD_ON))) /* Check if SG is stopped */ if (ADC_FALSE == LblHwTimedOut) { /* Fetch the next group for conversion if the queue is not empty */ LddNextGroup = Adc_PopFromQueue(LucSgUnitIndex); if (ADC_INVALID_GROUP != LddNextGroup) { Adc_ConfigureGroupForConversion(LddNextGroup); } /* else: No action required */ } /* else: No action required */ #endif } /* end of if (ADC_TRUE == LpGroup->blImplicitlyStopped) */ else { #if (ADC_ENABLE_ADTIMER == STD_ON) /* If AD timer is enabled and group is one-shot, just stop AD timer */ if ((ADC_TRUE == LpGroup->blAdcEnableAdTimerTriggMode) && (ADC_CONV_MODE_ONESHOT == LpGroup->enGroupConvMode)) { LpAdcRegisters->aaADCXnSG[LucSgUnitId].ucADCXnADTENDCRx = ADC_ADCX_ADTENDCR_ADTEND; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } /* else: No action required */ #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ } } /* end of if (ADC_STREAM_COMPLETED == LpGroupData->enGroupStatus) */ /* else: No action required */ return LblHwTimedOut; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'LucHwUnitIndex', 'Name': 'x', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': 'LddGroup', 'Name': 'z', 'Value': ''], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_ACCESS_MODE_SINGLE\\nADC_ACCESS_MODE_STREAMING', 'Name': 'enGroupAccessMode', 'Value': 'ADC_ACCESS_MODE_SINGLE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddNumberofSamples', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_STREAM_BUFFER_LINEAR\\nADC_STREAM_BUFFER_CIRCULAR', 'Name': 'enStreamBufferMode', 'Value': 'ADC_STREAM_BUFFER_CIRCULAR'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blAdcEnableAdTimerTriggMode', 'Value': 'ADC_TRUE'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_TRUE'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'ADC_CONV_MODE_ONESHOT\\nADC_CONV_MODE_CONTINUOUS', 'Name': 'enGroupConvMode', 'Value': 'ADC_CONV_MODE_ONESHOT'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '3'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'ADC_POLLING_MODE\\nADC_POLLING_INTERRUPT_MODE\\nADC_INTERRUPT_MODE', 'Name': 'enFunctionalityModeType', 'Value': 'ADC_POLLING_MODE'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'y', 'Value': ''], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': 'ADC_POLLING_MODE\\nADC_POLLING_INTERRUPT_MODE\\nADC_INTERRUPT_MODE', 'Name': 'enFunctionalityModeType', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': 'ADC_POLLING_MODE\\nADC_POLLING_INTERRUPT_MODE\\nADC_INTERRUPT_MODE', 'Name': 'enFunctionalityModeType', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': 'ADC_QUEUE_EMPTY \\nADC_QUEUE_FILLED \\nADC_QUEUE_FULL', 'Name': 'ucQueueStatus', 'Value': 'ADC_QUEUE_FILLED'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '1'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pBuffer', 'Value': '&map_pBuffer[0]'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '3'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '0'], 'Input_Param_031': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blResultRead', 'Value': 'ADC_FALSE'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelBuffer', 'Value': '&map_pChannelBuffer[0]'], 'Input_Param_033': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,\\nADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': 'ADC_STREAM_COMPLETED'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelBuffer[0]', 'Value': '-'], 'Input_Param_035': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '~ADC_INVALID_GROUP'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'ADC_FALSE']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_FALSE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'blResultRead', 'Value': 'ADC_FALSE'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pBuffer', 'Value': '&map_pBuffer[0]'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '1'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnSG[y].ucADCXnADTENDCRx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenStatusType', 'Value': 'ADC_STREAM_COMPLETED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'ADC_FALSE', 'Value': '0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSgUnitIndex', 'Value': '0'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddNextGroup', 'Value': '0'], 'Output_Param_020': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblHwTimedOut', 'Value': 'ADC_FALSE'], 'Output_Param_021': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_HW_TRIGGER_API == STD_ON) #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_HwEnableHardwareTrigger(const Adc_GroupType LddGroup) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; /* Pointer to the hardware unit user base configuration address */ volatile P2CONST(Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; volatile P2CONST(Adc_SGRegType, AUTOMATIC, REGSPACE) LpSGRegisters; volatile P2CONST(Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; /* Local variable to store the hardware unit number */ uint8 LucHwUnitIndex; uint8 LucSgUnitId; uint8 LucSgUnitIndex; #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) boolean LblDetErrFlag; #endif #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Local variable to store the current conversion group ID */ Adc_GroupType LddCurrentGroup; boolean LblHwTimedOut; #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_DMA_MODE == STD_ON)) boolean LblDmaTimedOut; #endif /* ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_DMA_MODE == STD_ON)) */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) LblDetErrFlag = ADC_FALSE; #endif #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Initialize the error flag */ LblHwTimedOut = ADC_FALSE; #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit to which the channel group is mapped */ LucSgUnitIndex = LpGroup->ucSgUnitIndex; /* PRQA S 2814 # JV-01 */ /* Read the Hardware Unit to which the group belongs */ LucHwUnitIndex = LpGroup->ucHwUnitIndex; /* Get the SG unit Id */ LucSgUnitId = Adc_GpSgUnitConfig[LucSgUnitIndex].ucSgUnitId; /* PRQA S 2824 # JV-01 */ /* Get the pointer to SG runtime data */ LpSgUnitData = &Adc_GpSgUnitRamData[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the base register address of the hardware unit */ LpAdcRegisters = Adc_GpHwUnitConfig[LucHwUnitIndex].pHwUnitBaseAddress; /* PRQA S 2824 # JV-01 */ /* Get the SG register address */ LpSGRegisters = &LpAdcRegisters->aaADCXnSG[LucSgUnitId]; /* PRQA S 2814, 2934 # JV-01, JV-01 */ /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); if ((ADC_BYTE_ZERO == LpSGRegisters->ucADCXnSGSRx) && (ADC_FALSE == LpSgUnitData->blSgUnitStatus)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { Adc_EnableHwGroup(LddGroup); } #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) else if (LpSgUnitData->ddCurrentPriority < LpGroup->ddGroupPriority) { /* Fetch the group id of the current conversion group */ LddCurrentGroup = LpSgUnitData->ddCurrentConvGroup; #if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON) /* Check if the current ongoing conversion is of SW triggered group */ if (LddCurrentGroup < Adc_GucMaxSwTriggGroups) { /* Check if the queue is full */ if (ADC_QUEUE_FULL != LpSgUnitData->ucQueueStatus) { #if (ADC_ENABLE_DMA_MODE == STD_ON) if (ADC_TRUE == Adc_GpGroupConfig[LddCurrentGroup].blEnableDmaTransfer) /* PRQA S 2824 # JV-01 */ { LblDmaTimedOut = Adc_DmaDisable(LddCurrentGroup); } else { LblDmaTimedOut = ADC_FALSE; } #endif /* (ADC_ENABLE_DMA_MODE == STD_ON) */ /* * Stop conversion of SG unit in which requested group is mapped * by changing mode to Multicycle scan mode and no of scan as one */ LblHwTimedOut = Adc_HwStopScanGroup(LddCurrentGroup, ADC_TRUE); if (ADC_FALSE == LblHwTimedOut) { #if (ADC_ENABLE_DMA_MODE == STD_ON) if (ADC_TRUE == LblDmaTimedOut) { /* Merge the timed out flags */ LblHwTimedOut = ADC_TRUE; } else #endif /* (ADC_ENABLE_DMA_MODE == STD_ON) */ { /* Push the current conversion group into queue */ Adc_PushToQueue(LddCurrentGroup); /* Configure the requested group for conversion */ Adc_EnableHwGroup(LddGroup); } } /* end of if (ADC_FALSE == LblHwTimedOut) */ /* else: No action required */ } /* end of if (ADC_QUEUE_FULL != LpSgUnitData->ucQueueStatus) */ else { #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) LblDetErrFlag = ADC_TRUE; #endif } } /* end of if (LddCurrentGroup < Adc_GucMaxSwTriggGroups) */ else #endif /* (ADC_ENABLE_START_STOP_GROUP_API == STD_ON) */ { LblHwTimedOut = Adc_DisableHwGroup(LddCurrentGroup); if (ADC_FALSE == LblHwTimedOut) { Adc_EnableHwGroup(LddGroup); } /* else: No action required */ } } /* end of else if (LpSgUnitData->ddCurrentPriority < LpGroup->ddGroupPriority) */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ else { #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) LblDetErrFlag = ADC_TRUE; #endif } /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) /* Report Error to DET if error occurs */ if (ADC_TRUE == LblDetErrFlag) { ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_HARDWARE_TRIGGER_SID, ADC_E_BUSY); } else #endif { #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Report an error to Dem if some timeouts occur */ if (ADC_TRUE == LblHwTimedOut) { /* Reporting to DEM when timeout cause by hardware error */ ADC_DEM_REPORT_ERROR(ADC_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* else: No action required */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucHwUnitIndex', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '1'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blEnableDmaTransfer', 'Value': 'ADC_FALSE'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '3'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '1'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blSgUnitStatus', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentPriority', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'ADC_QUEUE_FILLED\\nADC_QUEUE_EMPTY\\nADC_QUEUE_FULL', 'Name': 'ucQueueStatus', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_TRUE'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_pHwUnitBaseAddress[0].aaADCXnSG[3].ucADCXnSGSRx', 'Value': '-'], 'Input_Param_023': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_024': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'ADC_TRUE', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_007': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ADC_MODULE_ID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ADC_INSTANCE_ID'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ADC_ENABLE_HARDWARE_TRIGGER_SID'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ADC_E_BUSY'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_HW_TRIGGER_API == STD_ON) #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_HwEnableHardwareTrigger(const Adc_GroupType LddGroup) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; /* Pointer to the hardware unit user base configuration address */ volatile P2CONST(Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; volatile P2CONST(Adc_SGRegType, AUTOMATIC, REGSPACE) LpSGRegisters; volatile P2CONST(Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; /* Local variable to store the hardware unit number */ uint8 LucHwUnitIndex; uint8 LucSgUnitId; uint8 LucSgUnitIndex; #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) boolean LblDetErrFlag; #endif #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Local variable to store the current conversion group ID */ Adc_GroupType LddCurrentGroup; boolean LblHwTimedOut; #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_DMA_MODE == STD_ON)) boolean LblDmaTimedOut; #endif /* ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_DMA_MODE == STD_ON)) */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) LblDetErrFlag = ADC_FALSE; #endif #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Initialize the error flag */ LblHwTimedOut = ADC_FALSE; #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit to which the channel group is mapped */ LucSgUnitIndex = LpGroup->ucSgUnitIndex; /* PRQA S 2814 # JV-01 */ /* Read the Hardware Unit to which the group belongs */ LucHwUnitIndex = LpGroup->ucHwUnitIndex; /* Get the SG unit Id */ LucSgUnitId = Adc_GpSgUnitConfig[LucSgUnitIndex].ucSgUnitId; /* PRQA S 2824 # JV-01 */ /* Get the pointer to SG runtime data */ LpSgUnitData = &Adc_GpSgUnitRamData[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the base register address of the hardware unit */ LpAdcRegisters = Adc_GpHwUnitConfig[LucHwUnitIndex].pHwUnitBaseAddress; /* PRQA S 2824 # JV-01 */ /* Get the SG register address */ LpSGRegisters = &LpAdcRegisters->aaADCXnSG[LucSgUnitId]; /* PRQA S 2814, 2934 # JV-01, JV-01 */ /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); if ((ADC_BYTE_ZERO == LpSGRegisters->ucADCXnSGSRx) && (ADC_FALSE == LpSgUnitData->blSgUnitStatus)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { Adc_EnableHwGroup(LddGroup); } #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) else if (LpSgUnitData->ddCurrentPriority < LpGroup->ddGroupPriority) { /* Fetch the group id of the current conversion group */ LddCurrentGroup = LpSgUnitData->ddCurrentConvGroup; #if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON) /* Check if the current ongoing conversion is of SW triggered group */ if (LddCurrentGroup < Adc_GucMaxSwTriggGroups) { /* Check if the queue is full */ if (ADC_QUEUE_FULL != LpSgUnitData->ucQueueStatus) { #if (ADC_ENABLE_DMA_MODE == STD_ON) if (ADC_TRUE == Adc_GpGroupConfig[LddCurrentGroup].blEnableDmaTransfer) /* PRQA S 2824 # JV-01 */ { LblDmaTimedOut = Adc_DmaDisable(LddCurrentGroup); } else { LblDmaTimedOut = ADC_FALSE; } #endif /* (ADC_ENABLE_DMA_MODE == STD_ON) */ /* * Stop conversion of SG unit in which requested group is mapped * by changing mode to Multicycle scan mode and no of scan as one */ LblHwTimedOut = Adc_HwStopScanGroup(LddCurrentGroup, ADC_TRUE); if (ADC_FALSE == LblHwTimedOut) { #if (ADC_ENABLE_DMA_MODE == STD_ON) if (ADC_TRUE == LblDmaTimedOut) { /* Merge the timed out flags */ LblHwTimedOut = ADC_TRUE; } else #endif /* (ADC_ENABLE_DMA_MODE == STD_ON) */ { /* Push the current conversion group into queue */ Adc_PushToQueue(LddCurrentGroup); /* Configure the requested group for conversion */ Adc_EnableHwGroup(LddGroup); } } /* end of if (ADC_FALSE == LblHwTimedOut) */ /* else: No action required */ } /* end of if (ADC_QUEUE_FULL != LpSgUnitData->ucQueueStatus) */ else { #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) LblDetErrFlag = ADC_TRUE; #endif } } /* end of if (LddCurrentGroup < Adc_GucMaxSwTriggGroups) */ else #endif /* (ADC_ENABLE_START_STOP_GROUP_API == STD_ON) */ { LblHwTimedOut = Adc_DisableHwGroup(LddCurrentGroup); if (ADC_FALSE == LblHwTimedOut) { Adc_EnableHwGroup(LddGroup); } /* else: No action required */ } } /* end of else if (LpSgUnitData->ddCurrentPriority < LpGroup->ddGroupPriority) */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ else { #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) LblDetErrFlag = ADC_TRUE; #endif } /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #if ((ADC_DEV_ERROR_DETECT == STD_ON) || (ADC_AR_VERSION == ADC_AR_431_VERSION)) /* Report Error to DET if error occurs */ if (ADC_TRUE == LblDetErrFlag) { ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_ENABLE_HARDWARE_TRIGGER_SID, ADC_E_BUSY); } else #endif { #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Report an error to Dem if some timeouts occur */ if (ADC_TRUE == LblHwTimedOut) { /* Reporting to DEM when timeout cause by hardware error */ ADC_DEM_REPORT_ERROR(ADC_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* else: No action required */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucHwUnitIndex', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '1'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blEnableDmaTransfer', 'Value': 'ADC_FALSE'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '3'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '1'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'ADC_FALSE\\nADC_TRUE', 'Name': 'blSgUnitStatus', 'Value': 'ADC_TRUE'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentPriority', 'Value': '0'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'ADC_QUEUE_FILLED\\nADC_QUEUE_EMPTY\\nADC_QUEUE_FULL', 'Name': 'ucQueueStatus', 'Value': 'ADC_QUEUE_FULL'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_FALSE'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '255'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_pHwUnitBaseAddress[0].aaADCXnSG[3].ucADCXnSGSRx', 'Value': 'ADC_BYTE_ZERO'], 'Input_Param_023': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_024': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'ADC_TRUE', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_007': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ADC_MODULE_ID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ADC_INSTANCE_ID'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ADC_ENABLE_HARDWARE_TRIGGER_SID'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ADC_E_BUSY'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_HwInit(void) /* PRQA S 1532 # JV-01 */ { /* Pointer to the group data ram base array */ P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_APPL_DATA) LpGroupData; /* PRQA S 3432 # JV-01 */ /* Pointer to the hardware uint ram data */ P2VAR(volatile Adc_HwUnitDataType, AUTOMATIC, ADC_APPL_DATA) LpHwUnitData; /* PRQA S 3432 # JV-01 */ /* Initialize the count variable */ VAR(uint8, AUTOMATIC) LucLoopCount; LpHwUnitData = &Adc_GaaHwUnitData[ADC_HWUNIT_0]; #if (ADC_ENABLE_QUEUING == STD_ON) /* Set the queue status as empty */ LpHwUnitData->ucQueueStatus = ADC_QUEUE_EMPTY; /* Set the queue counter as ADC_ZERO */ LpHwUnitData->ucQueueCounter = ADC_COUNT_BYTE_INIT; #endif /* end if (ADC_ENABLE_QUEUING == STD_ON) */ /* Set flag initial for group conversion flag */ LpHwUnitData->blGroupConverionFlag = ADC_FALSE; /* Set default init group conversion with group ADC_GROUP_INVALID */ LpHwUnitData->ddCurrentConvGroup = ADC_INVALID_GROUP; /* Initialize all the groups as idle */ for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < Adc_GucNoOfGroups;LucLoopCount++) { /* Initialize the local pointer to group RAM data */ LpGroupData = &Adc_GpGroupRamData[LucLoopCount]; /* PRQA S 2824 # JV-01 */ /* Initialize all the groups as idle */ Adc_SetStatus(LucLoopCount, ADC_IDLE); #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Initialize all the buffer pointer initialization status as false */ LpGroupData->blBufferStatus = ADC_FALSE; /* PRQA S 2814 # JV-01 */ #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ #if (ADC_ENABLE_QUEUING == STD_ON) /* Initialize all the status if the group is present in queue as false */ LpGroupData->blGrpPresent = ADC_FALSE; #endif /* end if (ADC_ENABLE_QUEUING == STD_ON) */ #if (ADC_GRP_NOTIF_CAPABILITY == STD_ON) /* Disable notifications */ LpGroupData->blNotifyStatus = ADC_FALSE; #endif /* (ADC_GRP_NOTIF_CAPABILITY == STD_ON) */ /* Initialize all the number of samples completed as ADC_ZERO */ LpGroupData->ucSamplesCompleted = ADC_COUNT_BYTE_INIT; /* Initialize RAM pointer */ Adc_GaaRamPtr[LucLoopCount] = ADC_COUNT_BYTE_INIT; /* PRQA S 2844 # JV-01 */ } #if (ADC_ENABLE_QUEUING == STD_ON) for (LucLoopCount = ADC_COUNT_BYTE_INIT; LucLoopCount < Adc_GucQueueSize; LucLoopCount++) { /* Initialize all the group into queue as ADC_ZERO */ Adc_GpHWUnitQueueBuffer[LucLoopCount] = ADC_COUNT_BYTE_INIT; /* PRQA S 2824 # JV-01 */ } /* Initialize MMIC specific feature */ Adc_APB2SPI_Init(); /* Write - read back for Filter DC subtraction value */ (void)Adc_APB2SPI_Write(ADC_SPI_VMON_REG5, 0); /* Write - read back for Filter TestMode 1 */ (void)Adc_APB2SPI_Write(ADC_SPI_VMON_REG7,0x3000); /* Write - read back for Filter enable */ (void)Adc_APB2SPI_Write(ADC_SPI_VMON_REG8,0x01); #endif /* End if (ADC_ENABLE_QUEUING == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'ADC_MAX_HW_UNITS', 'Value': '3U'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxDmaChannels', 'Value': 'ADC_NUM_CHANNEL_ZERO'], 'Input_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ADC_AIR_ISELR0_Test[0]', 'Value': '0x0000001'], 'Input_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ADC_AIR_DSELR0_Test[0]', 'Value': '0x0000001'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0] = &map_pHwUnitBaseAddress[0]\\n[1] = &map_pHwUnitBaseAddress[1]\\n[2] = &map_pHwUnitBaseAddress[2]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pErrEicRegAddress', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'blInterruptErr', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitCount', 'Value': '[0 to 2] = 4'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ulLimitCheckInterruptMask1', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ulLimitCheckInterruptMask2', 'Value': '-'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'ucWaitTimeIndex', 'Value': '[0 to 2] = ADC_WAITTIME_DISABLED'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pErrEicRegAddress[0]', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucNoOfGroups', 'Value': '1'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpLimitCheckRange', 'Value': '-'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ulVCULLMTBR[0 to 7]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_pErrEicRegAddress[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ADC_AIR_ISELR0_Test[0]', 'Value': '0x0000001 & ADC_INTERRUPT_REQUEST'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ADC_AIR_DSELR0_Test[0]', 'Value': '0x0000001 & ADC_DMATRANSFER_REQUEST'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ucADCXnSFTCR', 'Value': '[0 to 2] = ADC_READ_AND_CLEAR_ENABLE'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucADCXnTOCCR', 'Value': '[0 to 2] = ADC_BYTE_ONE'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucADCXnADHALTR', 'Value': '[0 to 2] = ADC_ADCX_ADHALTR_HALT'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ucADCXnADCR1', 'Value': '[0 to 2] = ADC_ASYNCHRONOUS_SUSPEND'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucADCXnADCR2', 'Value': '[0 to 2] = ADC_ALIGN_RIGHT_MASK'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'aaADCXnVCULLMTBRy[0 to 7]', 'Value': '-'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'aaADCXnVCLMINTER[ADC_VCLM_1]', 'Value': '-'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'aaADCXnVCLMINTER[ADC_VCLM_2]', 'Value': '-'], 'Output_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '[0 to 11] = ADC_FALSE'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '[0 to 11] = ADC_INVALID_GROUP'], 'Output_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ddCurrentPriority', 'Value': '[0 to 11] = 0U'], 'Output_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ucQueueStatus', 'Value': '[0 to 11] = ADC_QUEUE_EMPTY'], 'Output_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucQueueCounter', 'Value': '[0 to 11] = ADC_COUNT_BYTE_INIT'], 'Output_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '[0] = ADC_FALSE'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'blBufferStatus', 'Value': '[0] = ADC_FALSE'], 'Output_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'blHwTriggStatus', 'Value': '[0] = ADC_FALSE'], 'Output_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'blGrpPresent', 'Value': '[0] = ADC_FALSE'], 'Output_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'blResultRead', 'Value': '[0] = ADC_TRUE'], 'Output_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'ucNoOfDisabledChannels', 'Value': '[0] = 0U'], 'Output_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'blConvError', 'Value': '[0] = ADC_FALSE'], 'Output_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelIdError', 'Value': '-'], 'Output_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelOverwritten', 'Value': '-'], 'Output_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelLimitError', 'Value': '-'], 'Output_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'blTriggerOverlapped', 'Value': '[0] = ADC_FALSE'], 'Output_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelParityError', 'Value': '-'], 'Output_Param_028': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '-'], 'Output_Param_029': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitStatus', 'Value': '[0 to 2] = ADC_BYTE_ZERO'], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'ucTrackHoldStatus', 'Value': '[0 to 2] = ADC_BYTE_ZERO'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '0'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '1'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '2'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucHwUnitIndex', 'Value': '-'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': 'ADC_TRUE'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '[1] = 0'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenStatusType', 'Value': '[1] = ADC_IDLE'], 'Output_Param_046': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON) #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_HwStartGroupConversion(const Adc_GroupType LddGroup) /* PRQA S 1532 # JV-01 */ { /* Pointer to the hardware uint ram data */ P2VAR(volatile Adc_HwUnitDataType, AUTOMATIC, ADC_APPL_DATA) LpHwUnitData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer to the group config */ P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_DATA) LpGroupConfig; /* PRQA S 3432 # JV-01 */ /* Pointer to the group ram data */ P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_APPL_DATA) LpGroupRamData; /* PRQA S 3432 # JV-01 */ #if (ADC_ENABLE_QUEUING == STD_ON) #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Declare local variable to store Group status */ VAR(Adc_StatusType, AUTOMATIC) LddGroupStatusTemp; #endif /* Local variable to store the current conversion group ID */ VAR(Adc_GroupType, AUTOMATIC) LddCurrentGroup; #endif #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(uint8, AUTOMATIC) LucErrorValue; #endif /* End of ((ADC_DEV_ERROR_DETECT == STD_ON) */ LpHwUnitData = &Adc_GaaHwUnitData[Adc_GpGroupConfig[LddGroup].ucHwUnitIndex]; /* PRQA S 2824, 2934 # JV-01, JV-01 */ /* Pointer the local Group config to global Group config */ LpGroupConfig = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2983 # JV-01 */ /* Pointer the local Group Ram Data to global Group Ram Data */ LpGroupRamData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_QUEUING == STD_ON) /* Get the current group under conversion */ LddCurrentGroup = LpHwUnitData->ddCurrentConvGroup; /* PRQA S 2844 # JV-01 */ #endif #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Initialize the variable with No Errors */ LucErrorValue = E_OK; /* Check if Group Priority and queue are disabled */ #if (ADC_ENABLE_QUEUING == STD_OFF) if (ADC_TRUE == LpHwUnitData->blGroupConverionFlag) /* PRQA S 2844 # JV-01 */ { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } #endif /* end of (ADC_ENABLE_QUEUING == STD_OFF)*/ #if(ADC_ENABLE_QUEUING == STD_ON) /* Check if Group Priority or Queue are enabled */ if (((LddGroup == LddCurrentGroup) && (LpGroupRamData->enGroupStatus != ADC_IDLE)) && /* PRQA S 2814 # JV-01 */ (LpGroupConfig->enGroupConvMode == ADC_CONV_MODE_CONTINUOUS)) /* PRQA S 2814 # JV-01 */ { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } LddGroupStatusTemp = LpGroupRamData->enGroupStatus; if (((LddGroup == LddCurrentGroup) && (LddGroupStatusTemp != ADC_IDLE)) && ((LddGroupStatusTemp != ADC_STREAM_COMPLETED) && (LpGroupConfig->enGroupConvMode == ADC_CONV_MODE_ONESHOT))) { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } if ((LddGroup == LddCurrentGroup) && (ADC_QUEUE_FULL == LpHwUnitData->ucQueueStatus)) { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } #endif /* ADC_USE_QUEUE */ /* Check if any DET was reported */ if (LucErrorValue == E_OK) #endif /* #if (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Check if critical section protection is required */ #if (ADC_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #endif /* Clear the number of samples completed */ LpGroupRamData->ucSamplesCompleted = ADC_COUNT_BYTE_INIT; /* PRQA S 2814 # JV-01 */ /* Reset the number of completed channels to zero. */ LpGroupRamData->ucChannelsCompleted = ADC_COUNT_BYTE_INIT; /* Init RAM ppointer */ Adc_GaaRamPtr[LddGroup] = ADC_COUNT_BYTE_INIT; /* PRQA S 2844 # JV-01 */ /* Reset the buffer pointer to base address */ LpGroupRamData->pBuffer = LpGroupRamData->pChannelBuffer; /* If priority implementation is priority HW_SW */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) if (ADC_FALSE == LpGroupRamData->blGrpPresent) { /* Push group request to queue */ Adc_PushToQueue(LddGroup); } else { /* No action required */ } /* Check if HW already had conversion */ if (ADC_TRUE == LpHwUnitData->blGroupConverionFlag) { /* Check priority of current group with input group */ if (LpGroupConfig->ddGroupPriority > Adc_GpGroupConfig[LddCurrentGroup].ddGroupPriority) /* PRQA S 2824 # JV-01 */ { /* Invoke API to stop current group */ Adc_HwInitStopGroup(); /* Reset RAM ptr in case of switching groups */ Adc_GaaRamPtr[LddCurrentGroup] = ADC_COUNT_BYTE_INIT; /* PRQA S 2844 # JV-01 */ if (ADC_FALSE == LpGroupRamData->blGrpPresent) { /* Push group request to queue */ Adc_PushToQueue(LddCurrentGroup); } else { /* No action required */ } /* Start queue */ Adc_HwInitStartGroup(LddGroup); } /* Otherwise, push input group to queue */ else { /* No action required */ } } /* If HW is free */ else { /* Invoke Initial Start Group for requested group */ Adc_HwInitStartGroup(LddGroup); } #elif ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_NONE) && \\ (ADC_ENABLE_QUEUING == STD_ON)) { /* Push group request to queue */ Adc_PushToQueue(LddGroup); /* Check if HW had not conversion */ if (ADC_FALSE == LpHwUnitData->blGroupConverionFlag) { Adc_HwInitStartGroup(LddGroup); } /* If HW is free */ else { /* No action required */ } } #else { /* Invoke Init Start Group */ Adc_HwInitStartGroup(LddGroup); } #endif /* Check if critical section protection is required */ #if (ADC_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #endif } #if (ADC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* #if (ADC_DEV_ERROR_DETECT == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': 'LddGroup', 'Name': 'x', 'Value': ''], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ucSgUnitIndex', 'Name': 'y', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'E2x: 0..19\\nU2x: 0..14', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'E2x: 0..3\\nU2x: 0..2', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blEnableDmaTransfer', 'Value': 'ADC_TRUE'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '3'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '1'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_TRUE'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': 'ADC_QUEUE_FILLED'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentPriority', 'Value': '0'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'enGroupStatus', 'Value': 'ADC_BUSY'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0] = &map_pHwUnitBaseAddress[0]'], 'Input_Param_021': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_022': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_023': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_024': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnSG[3].ucADCXnSGSRx', 'Value': '~ADC_BYTE_ZERO']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_TRUE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': '-'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ADC_TRUE', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ADC_MODULE_ID'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ADC_INSTANCE_ID'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ADC_START_GROUP_CONVERSION_SID'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ADC_E_BUSY'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_022': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_023': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON) #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_HwStartGroupConversion(const Adc_GroupType LddGroup) /* PRQA S 1532 # JV-01 */ { /* Pointer to the hardware uint ram data */ P2VAR(volatile Adc_HwUnitDataType, AUTOMATIC, ADC_APPL_DATA) LpHwUnitData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer to the group config */ P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_DATA) LpGroupConfig; /* PRQA S 3432 # JV-01 */ /* Pointer to the group ram data */ P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_APPL_DATA) LpGroupRamData; /* PRQA S 3432 # JV-01 */ #if (ADC_ENABLE_QUEUING == STD_ON) #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Declare local variable to store Group status */ VAR(Adc_StatusType, AUTOMATIC) LddGroupStatusTemp; #endif /* Local variable to store the current conversion group ID */ VAR(Adc_GroupType, AUTOMATIC) LddCurrentGroup; #endif #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(uint8, AUTOMATIC) LucErrorValue; #endif /* End of ((ADC_DEV_ERROR_DETECT == STD_ON) */ LpHwUnitData = &Adc_GaaHwUnitData[Adc_GpGroupConfig[LddGroup].ucHwUnitIndex]; /* PRQA S 2824, 2934 # JV-01, JV-01 */ /* Pointer the local Group config to global Group config */ LpGroupConfig = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2983 # JV-01 */ /* Pointer the local Group Ram Data to global Group Ram Data */ LpGroupRamData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_QUEUING == STD_ON) /* Get the current group under conversion */ LddCurrentGroup = LpHwUnitData->ddCurrentConvGroup; /* PRQA S 2844 # JV-01 */ #endif #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Initialize the variable with No Errors */ LucErrorValue = E_OK; /* Check if Group Priority and queue are disabled */ #if (ADC_ENABLE_QUEUING == STD_OFF) if (ADC_TRUE == LpHwUnitData->blGroupConverionFlag) /* PRQA S 2844 # JV-01 */ { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } #endif /* end of (ADC_ENABLE_QUEUING == STD_OFF)*/ #if(ADC_ENABLE_QUEUING == STD_ON) /* Check if Group Priority or Queue are enabled */ if (((LddGroup == LddCurrentGroup) && (LpGroupRamData->enGroupStatus != ADC_IDLE)) && /* PRQA S 2814 # JV-01 */ (LpGroupConfig->enGroupConvMode == ADC_CONV_MODE_CONTINUOUS)) /* PRQA S 2814 # JV-01 */ { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } LddGroupStatusTemp = LpGroupRamData->enGroupStatus; if (((LddGroup == LddCurrentGroup) && (LddGroupStatusTemp != ADC_IDLE)) && ((LddGroupStatusTemp != ADC_STREAM_COMPLETED) && (LpGroupConfig->enGroupConvMode == ADC_CONV_MODE_ONESHOT))) { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } if ((LddGroup == LddCurrentGroup) && (ADC_QUEUE_FULL == LpHwUnitData->ucQueueStatus)) { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } #endif /* ADC_USE_QUEUE */ /* Check if any DET was reported */ if (LucErrorValue == E_OK) #endif /* #if (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Check if critical section protection is required */ #if (ADC_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #endif /* Clear the number of samples completed */ LpGroupRamData->ucSamplesCompleted = ADC_COUNT_BYTE_INIT; /* PRQA S 2814 # JV-01 */ /* Reset the number of completed channels to zero. */ LpGroupRamData->ucChannelsCompleted = ADC_COUNT_BYTE_INIT; /* Init RAM ppointer */ Adc_GaaRamPtr[LddGroup] = ADC_COUNT_BYTE_INIT; /* PRQA S 2844 # JV-01 */ /* Reset the buffer pointer to base address */ LpGroupRamData->pBuffer = LpGroupRamData->pChannelBuffer; /* If priority implementation is priority HW_SW */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) if (ADC_FALSE == LpGroupRamData->blGrpPresent) { /* Push group request to queue */ Adc_PushToQueue(LddGroup); } else { /* No action required */ } /* Check if HW already had conversion */ if (ADC_TRUE == LpHwUnitData->blGroupConverionFlag) { /* Check priority of current group with input group */ if (LpGroupConfig->ddGroupPriority > Adc_GpGroupConfig[LddCurrentGroup].ddGroupPriority) /* PRQA S 2824 # JV-01 */ { /* Invoke API to stop current group */ Adc_HwInitStopGroup(); /* Reset RAM ptr in case of switching groups */ Adc_GaaRamPtr[LddCurrentGroup] = ADC_COUNT_BYTE_INIT; /* PRQA S 2844 # JV-01 */ if (ADC_FALSE == LpGroupRamData->blGrpPresent) { /* Push group request to queue */ Adc_PushToQueue(LddCurrentGroup); } else { /* No action required */ } /* Start queue */ Adc_HwInitStartGroup(LddGroup); } /* Otherwise, push input group to queue */ else { /* No action required */ } } /* If HW is free */ else { /* Invoke Initial Start Group for requested group */ Adc_HwInitStartGroup(LddGroup); } #elif ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_NONE) && \\ (ADC_ENABLE_QUEUING == STD_ON)) { /* Push group request to queue */ Adc_PushToQueue(LddGroup); /* Check if HW had not conversion */ if (ADC_FALSE == LpHwUnitData->blGroupConverionFlag) { Adc_HwInitStartGroup(LddGroup); } /* If HW is free */ else { /* No action required */ } } #else { /* Invoke Init Start Group */ Adc_HwInitStartGroup(LddGroup); } #endif /* Check if critical section protection is required */ #if (ADC_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #endif } #if (ADC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* #if (ADC_DEV_ERROR_DETECT == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': 'LddGroup', 'Name': 'x', 'Value': ''], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ucSgUnitIndex', 'Name': 'y', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'E2x: 0..19\\nU2x: 0..14', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'E2x: 0..3\\nU2x: 0..2', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blEnableDmaTransfer', 'Value': 'ADC_FALSE'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '3'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '1'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '1'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_TRUE'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': 'ADC_QUEUE_EMPTY '], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentPriority', 'Value': '0'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'enGroupStatus', 'Value': 'ADC_BUSY'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0] = &map_pHwUnitBaseAddress[0]'], 'Input_Param_021': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_022': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_023': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_024': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnSG[3].ucADCXnSGSRx', 'Value': '~ADC_BYTE_ZERO']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_TRUE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': 'ADC_COUNT_BYTE_INIT'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': 'ADC_COUNT_BYTE_INIT'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ADC_TRUE', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '0'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_022': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_023': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON) #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_HwStartGroupConversion(const Adc_GroupType LddGroup) /* PRQA S 1532 # JV-01 */ { /* Pointer to the hardware uint ram data */ P2VAR(volatile Adc_HwUnitDataType, AUTOMATIC, ADC_APPL_DATA) LpHwUnitData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer to the group config */ P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_APPL_DATA) LpGroupConfig; /* PRQA S 3432 # JV-01 */ /* Pointer to the group ram data */ P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_APPL_DATA) LpGroupRamData; /* PRQA S 3432 # JV-01 */ #if (ADC_ENABLE_QUEUING == STD_ON) #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Declare local variable to store Group status */ VAR(Adc_StatusType, AUTOMATIC) LddGroupStatusTemp; #endif /* Local variable to store the current conversion group ID */ VAR(Adc_GroupType, AUTOMATIC) LddCurrentGroup; #endif #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(uint8, AUTOMATIC) LucErrorValue; #endif /* End of ((ADC_DEV_ERROR_DETECT == STD_ON) */ LpHwUnitData = &Adc_GaaHwUnitData[Adc_GpGroupConfig[LddGroup].ucHwUnitIndex]; /* PRQA S 2824, 2934 # JV-01, JV-01 */ /* Pointer the local Group config to global Group config */ LpGroupConfig = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2983 # JV-01 */ /* Pointer the local Group Ram Data to global Group Ram Data */ LpGroupRamData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_QUEUING == STD_ON) /* Get the current group under conversion */ LddCurrentGroup = LpHwUnitData->ddCurrentConvGroup; /* PRQA S 2844 # JV-01 */ #endif #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Initialize the variable with No Errors */ LucErrorValue = E_OK; /* Check if Group Priority and queue are disabled */ #if (ADC_ENABLE_QUEUING == STD_OFF) if (ADC_TRUE == LpHwUnitData->blGroupConverionFlag) /* PRQA S 2844 # JV-01 */ { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } #endif /* end of (ADC_ENABLE_QUEUING == STD_OFF)*/ #if(ADC_ENABLE_QUEUING == STD_ON) /* Check if Group Priority or Queue are enabled */ if (((LddGroup == LddCurrentGroup) && (LpGroupRamData->enGroupStatus != ADC_IDLE)) && /* PRQA S 2814 # JV-01 */ (LpGroupConfig->enGroupConvMode == ADC_CONV_MODE_CONTINUOUS)) /* PRQA S 2814 # JV-01 */ { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } LddGroupStatusTemp = LpGroupRamData->enGroupStatus; if (((LddGroup == LddCurrentGroup) && (LddGroupStatusTemp != ADC_IDLE)) && ((LddGroupStatusTemp != ADC_STREAM_COMPLETED) && (LpGroupConfig->enGroupConvMode == ADC_CONV_MODE_ONESHOT))) { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } if ((LddGroup == LddCurrentGroup) && (ADC_QUEUE_FULL == LpHwUnitData->ucQueueStatus)) { /* Report Error to DET */ (void)ADC_DET_RUNTIME_ERROR(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_START_GROUP_CONVERSION_SID, ADC_E_BUSY); /* Set the error status flag to E_NOT_OK */ LucErrorValue = E_NOT_OK; } else { /* No action required */ } #endif /* ADC_USE_QUEUE */ /* Check if any DET was reported */ if (LucErrorValue == E_OK) #endif /* #if (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Check if critical section protection is required */ #if (ADC_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter the critical section protection */ ADC_ENTER_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #endif /* Clear the number of samples completed */ LpGroupRamData->ucSamplesCompleted = ADC_COUNT_BYTE_INIT; /* PRQA S 2814 # JV-01 */ /* Reset the number of completed channels to zero. */ LpGroupRamData->ucChannelsCompleted = ADC_COUNT_BYTE_INIT; /* Init RAM ppointer */ Adc_GaaRamPtr[LddGroup] = ADC_COUNT_BYTE_INIT; /* PRQA S 2844 # JV-01 */ /* Reset the buffer pointer to base address */ LpGroupRamData->pBuffer = LpGroupRamData->pChannelBuffer; /* If priority implementation is priority HW_SW */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) if (ADC_FALSE == LpGroupRamData->blGrpPresent) { /* Push group request to queue */ Adc_PushToQueue(LddGroup); } else { /* No action required */ } /* Check if HW already had conversion */ if (ADC_TRUE == LpHwUnitData->blGroupConverionFlag) { /* Check priority of current group with input group */ if (LpGroupConfig->ddGroupPriority > Adc_GpGroupConfig[LddCurrentGroup].ddGroupPriority) /* PRQA S 2824 # JV-01 */ { /* Invoke API to stop current group */ Adc_HwInitStopGroup(); /* Reset RAM ptr in case of switching groups */ Adc_GaaRamPtr[LddCurrentGroup] = ADC_COUNT_BYTE_INIT; /* PRQA S 2844 # JV-01 */ if (ADC_FALSE == LpGroupRamData->blGrpPresent) { /* Push group request to queue */ Adc_PushToQueue(LddCurrentGroup); } else { /* No action required */ } /* Start queue */ Adc_HwInitStartGroup(LddGroup); } /* Otherwise, push input group to queue */ else { /* No action required */ } } /* If HW is free */ else { /* Invoke Initial Start Group for requested group */ Adc_HwInitStartGroup(LddGroup); } #elif ((ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_NONE) && \\ (ADC_ENABLE_QUEUING == STD_ON)) { /* Push group request to queue */ Adc_PushToQueue(LddGroup); /* Check if HW had not conversion */ if (ADC_FALSE == LpHwUnitData->blGroupConverionFlag) { Adc_HwInitStartGroup(LddGroup); } /* If HW is free */ else { /* No action required */ } } #else { /* Invoke Init Start Group */ Adc_HwInitStartGroup(LddGroup); } #endif /* Check if critical section protection is required */ #if (ADC_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit the critical section protection */ ADC_EXIT_CRITICAL_SECTION(ADC_RAM_DATA_PROTECTION); #endif } #if (ADC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* #if (ADC_DEV_ERROR_DETECT == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': 'LddGroup', 'Name': 'x', 'Value': ''], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ucSgUnitIndex', 'Name': 'y', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'E2x: 0..19\\nU2x: 0..14', 'Name': 'ucSgUnitIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'E2x: 0..3\\nU2x: 0..2', 'Name': 'ucHwUnitIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blEnableDmaTransfer', 'Value': 'ADC_TRUE'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '3'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '1'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': 'ADC_TRUE'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': 'ADC_QUEUE_FULL'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentPriority', 'Value': '1'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'enGroupStatus', 'Value': 'ADC_IDLE'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0] = &map_pHwUnitBaseAddress[0]'], 'Input_Param_021': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_022': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_023': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_024': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnSG[3].ucADCXnSGSRx', 'Value': 'ADC_BYTE_ZERO']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucSamplesCompleted', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': '-'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ADC_TRUE', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddCurrentGroup', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'called'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ADC_MODULE_ID'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ADC_INSTANCE_ID'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ADC_START_GROUP_CONVERSION_SID'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ADC_E_BUSY'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_022': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_023': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(boolean, ADC_PRIVATE_CODE) Adc_HwStopScanGroup(const Adc_GroupType LddGroup, const boolean LblForced) { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; P2CONST(Adc_HwSgUnitType, AUTOMATIC, ADC_CONFIG_DATA) LpSgUnitConfig; P2VAR(volatile Adc_SGRegType, AUTOMATIC, REGSPACE) LpSGRegisters; P2CONST(volatile Adc_HwUnitDataType, AUTOMATIC, ADC_VAR_NO_INIT) LpHwUnitData; uint32 LulDelayCount; uint8 LucHwUnitIndex; uint8 LucSgUnitIndex; uint8 LucSgUnitId; uint8 LucSgUnitStatus; boolean LblHwTimedOut; /* Get the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the hardware unit index to which the group belongs */ LucHwUnitIndex = LpGroup->ucHwUnitIndex; /* PRQA S 2814 # JV-01 */ /* Read the base configuration address of the hardware unit */ LpAdcRegisters = Adc_GpHwUnitConfig[LucHwUnitIndex].pHwUnitBaseAddress; /* PRQA S 2824 # JV-01 */ /* Get the SG unit to which the channel group is mapped */ LucSgUnitIndex = LpGroup->ucSgUnitIndex; /* Get the SG unit which is configured for this group */ LpSgUnitConfig = &Adc_GpSgUnitConfig[LucSgUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the SG unit Id */ LucSgUnitId = LpSgUnitConfig->ucSgUnitId; /* PRQA S 2814 # JV-01 */ /* Get the pointer to SG register */ LpSGRegisters = &LpAdcRegisters->aaADCXnSG[LucSgUnitId]; /* PRQA S 2814, 2934 # JV-01, JV-01 */ /* Get the pointer to the HW unit data */ LpHwUnitData = &Adc_GaaHwUnitData[LucHwUnitIndex]; /* PRQA S 2934 # JV-01 */ /* Get the status of all other SG units in the HW unit */ LucSgUnitStatus = LpHwUnitData->ucSgUnitStatus; /* PRQA S 2844 # JV-01 */ /* Initialize scan group stop timeout flag to ADC_FALSE */ LblHwTimedOut = ADC_FALSE; #if (ADC_TRACK_AND_HOLD == STD_ON) /* Check if all other SGs are inactive when the T&H groups are explicitly stopped */ if (((ADC_TRUE == LblForced) || (ADC_TH_DISABLED == LpGroup->ucTrackAndHoldGroup)) && ((uint8)0U == (uint8)(LucSgUnitStatus & (uint8)~(1U << LucSgUnitId))) && (ADC_TH_SAMPLING == LpHwUnitData->ucTrackHoldStatus)) { /* Stop T&H sampling */ Adc_TrackHoldDisable(LddGroup); } else #endif /* (ADC_TRACK_AND_HOLD == STD_ON) */ { /* Check if the requested group is not stopped */ if ((uint8)0UL != (uint8)(LucSgUnitStatus & (uint8)(1U << LucSgUnitId))) { #if (ADC_TRACK_AND_HOLD == STD_ON) /* Check if the requested group is configured as T&H and it stops explicitly */ if ((ADC_TRUE == LblForced) && (ADC_TH_DISABLED == LpGroup->ucTrackAndHoldGroup)) { /* Disable T&H hold trigger */ Adc_TrackHoldDisable(LddGroup); } /* else: No action required */ #endif /* (ADC_TRACK_AND_HOLD == STD_ON) */ /* Disable trigger mode and conversion end interrupt */ LpSGRegisters->ucADCXnSGCRx &= (uint8)~(ADC_ADCX_SGCR_TRGMD | ADC_ADCX_SGCR_ADIE); /* PRQA S 2844 # JV-01 */ #if (ADC_ENABLE_ADTIMER == STD_ON) /* Stop the AD Timer if the requested group has AD Timer Trigger */ if (ADC_TRUE == LpGroup->blAdcEnableAdTimerTriggMode) { LpSGRegisters->ucADCXnADTENDCRx = ADC_ADCX_ADTENDCR_ADTEND; } /* else: No action required */ #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ /* Check If the request is an explicit stop or the requested group uses continuous scan mode */ if ((ADC_TRUE == LblForced) || ((uint8)0U != LpGroup->ucScanMode)) { /* Check if any other SG is active */ if ((uint8)0U != (uint8)(LucSgUnitStatus & (uint8)~(1U << LucSgUnitId))) { /* Set A/D conversion stop for Scan Group x Stop Control Register */ LpSGRegisters->ucADCXnSGSTPCRx = ADC_ADCX_SGSTPCR_SGSTP; #if (ADC_ENABLE_ADTIMER == STD_ON) /* Wait for the AD Timer to stop if the requested group uses AD Timer Trigger */ if (ADC_TRUE == LpGroup->blAdcEnableAdTimerTriggMode) { /* Initialize the delay loop count to zero */ LulDelayCount = ADC_AD_TIMER_TIMEOUT_COUNT; while (((uint8)0U != (uint8)(LpSGRegisters->ucADCXnSGSRx & ADC_ADTACT_STATUS)) && (LulDelayCount > 0UL)) { LulDelayCount--; } if (0UL == LulDelayCount) { LblHwTimedOut = ADC_TRUE; } /* else: No action required */ } /* else: No action required */ /* Check if the AD Timer is stopped */ if (ADC_FALSE == LblHwTimedOut) #endif /* (ADC_ENABLE_ADTIMER == STD_ON) */ { /* Initialize the delay loop count to zero */ LulDelayCount = LpSgUnitConfig->ulVcrProcessWait; /* Wait for the termination of the Scan Group x */ while (((uint8)0U != (uint8)(LpSGRegisters->ucADCXnSGSRx & ADC_SGACT_STATUS)) && (LulDelayCount > 0UL)) { LulDelayCount--; } /* Check if it has timed out */ if (0UL == LulDelayCount) { /* Timed out, Can not stop scan group */ LblHwTimedOut = ADC_TRUE; } /* else: No action required */ } /* end of if (ADC_FALSE == LblHwTimedOut) */ /* else: No action required */ } /* end of if ((uint8)0U != (uint8)(LucSgUnitStatus & (uint8)~(1U << LucSgUnitId))) */ else { /* Use HALT to stop the SG if only one SG is used */ LpAdcRegisters->ucADCXnADHALTR = ADC_ADCX_ADHALTR_HALT; } } /* end of if ((ADC_TRUE == LblForced) || (ADC_CONV_MODE_CONTINUOUS == LpGroup->enGroupConvMode)) */ /* else: No action required */ } /* end of if ((uint8)0UL != (uint8)(LucSgUnitStatus & (uint8)(1U << LucSgUnitId))) */ /* else: No action required */ } return LblHwTimedOut; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '254'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LblForced', 'Value': 'ADC_TRUE'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'LddGroup', 'Name': 'a', 'Value': '254'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucHwUnitIndex', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucTrackAndHoldGroup', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blAdcEnableAdTimerTriggMode', 'Value': 'ADC_TRUE'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0x00, 0x20', 'Name': 'ucScanMode', 'Value': '0x00'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ucHwUnitIndex', 'Name': 'z', 'Value': '1'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitStatus', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucTrackHoldStatus', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '&map_pHwUnitBaseAddress[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'ucSgUnitId', 'Name': 'x', 'Value': '0'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulVcrProcessWait', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '0'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulVcrProcessWait', 'Value': '0x00013FEC'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulVcrProcessWait', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ucSgUnitId', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulVcrProcessWait', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ucADCXnSGCRx', 'Value': '0x04'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'usADCXnSGVCPRx', 'Value': '0x00'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ucADCXnSGSRx', 'Value': '0x05'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'aaADCXnVCR[0]', 'Value': '-'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'aaADCXnVCR[2]', 'Value': '0x01'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'aaADCXnVCR[3]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucADCXnSGCRx', 'Value': '0x04'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucADCXnSGSTPCRx', 'Value': 'ADC_ADCX_SGSTPCR_SGSTP'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnADTENDCRx', 'Value': 'ADC_ADCX_ADTENDCR_ADTEND'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[0]', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[2]', 'Value': '0x01&~ADC_ADCX_VCR_ADIE'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[3]', 'Value': '-'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnADHALTR', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_008': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblSgTimedOut', 'Value': 'ADC_TRUE'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_PARITY_ERR_INT == STD_ON) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_CODE_FAST) Adc_ParityErrIsr(void) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; volatile P2CONST(Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; uint8 LucHwUnitIndex; uint32 LulSgUnitIndex; uint32 LulSgUnitCount; uint8 LucPerValue; uint8 LucErrorVirCh; Adc_GroupType LddGroup; uint8 LucStartVirCh; uint8 LucEndVirCh; uint8 LucPhysCh; #if (ADC_ENABLE_PWM_DIAG == STD_ON) uint8 LucChannelToGroupIndex; #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ /* Check all HW units as parity errors are handled by a common interrupt */ for (LucHwUnitIndex = ADC_COUNT_BYTE_INIT; LucHwUnitIndex < (uint8)ADC_MAX_HW_UNITS; LucHwUnitIndex++) /* PRQA S 2877 # JV-01 */ { /* Get the pointer to the hardware unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the base register address of the hardware unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; /* PRQA S 2814 # JV-01 */ /* Check the parity error status */ LucPerValue = LpAdcRegisters->ucADCXnPER; /* PRQA S 2814 # JV-01 */ if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) { /* Get the virtual channel captured due to parity error */ LucErrorVirCh = (uint8)(LucPerValue & ADC_ADCX_PER_PECAP); /* Initialize the physical channel to ADC_INVALID_CHANNELID */ LucPhysCh = ADC_INVALID_CHANNELID; /* Get the index of the first SG unit configuration in the hardware unit */ #if ((ADC_IP_ADCJ == STD_ON) || (ADC_IP_ADCK == STD_ON)) LulSgUnitIndex = LpHwUnitConfig->ucSgUnitOffset; #endif /* ((ADC_IP_ADCJ == STD_ON) || (ADC_IP_ADCK == STD_ON)) */ #if (ADC_IP_ADCH == STD_ON) LulSgUnitIndex = Adc_GaaHwUnitData[LucHwUnitIndex].ucSgUnitIndex; #endif /* (ADC_IP_ADCH == STD_ON) */ /* Get the number of SG unit configurations in the hardware unit */ LulSgUnitCount = (uint32)LpHwUnitConfig->ucSgUnitCount; /* Check for errors in order from the highest priority SG unit */ while (LulSgUnitCount != 0UL) { LulSgUnitCount--; /* Get the pointer to the runtime data of the SG unit */ LpSgUnitData = &Adc_GpSgUnitRamData[LulSgUnitIndex + LulSgUnitCount]; /* PRQA S 2824, 3383 # JV-01, JV-04 */ /* Check if the SG unit is active */ if (ADC_TRUE == LpSgUnitData->blSgUnitStatus) /* PRQA S 2814 # JV-01 */ { /* Get the current group of the SG unit */ LddGroup = LpSgUnitData->ddCurrentConvGroup; /* Get the pointer to the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the pointer to the runtime data of the group */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) /* PRQA S 2814 # JV-01 */ { /* Set the group channel range to PWM-Diag channel */ LucStartVirCh = ADC_ADCX_PER_PECAP_PWD; LucEndVirCh = ADC_ADCX_PER_PECAP_PWD; } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) /* PRQA S 2814 # JV-01 */ { /* Set the group channel range to the current virtual channel of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr + LpGroupData->ucChannelsCompleted; /* PRQA S 2814 # JV-01 */ LucEndVirCh = LucStartVirCh; } else #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ { /* Set the group channel range to the virtual channel range of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr; /* PRQA S 2814 # JV-01 */ LucEndVirCh = (uint8)(LucStartVirCh + LpGroupData->ucChannelCount - ADC_BYTE_ONE); /* PRQA S 2814 # JV-01 */ } /* Check if it is within the range of channels in the group */ if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Set the conversion error status */ LpGroupData->blConvError = ADC_TRUE; #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_ADCX_PER_PECAP_PWD == LucErrorVirCh) { /* Get the channel from the group channel configuration as PWM-Diag has no virtual channel */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; LucPhysCh = (uint8)(Adc_GpChannelToGroup[LucChannelToGroupIndex] & ADC_CHANNEL_ID_MASK); /* PRQA S 2824 # JV-01 */ } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Get the physical channel where parity error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ } /* Set the loop count to 0 to end the loop */ LulSgUnitCount = 0UL; } /* end of if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) */ /* else: No action required */ } /* end of if (ADC_TRUE == LpSgUnitData->blSgUnitStatus) */ /* else: No action required */ } /* end of while (LulSgUnitCount != 0UL) */ if (NULL_PTR != LpHwUnitConfig->pErrorNotificationPointer) { if (ADC_INVALID_CHANNELID != LucPhysCh) { /* Invoke a callback function for error notification */ LpHwUnitConfig->pErrorNotificationPointer(LucPhysCh); } /* else: No action required */ } /* else: No action required */ /* Report parity check error to Dem */ ADC_DEM_REPORT_ERROR(ADC_E_PARITY_FAILURE, DEM_EVENT_STATUS_FAILED); /* Clear parity error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_PEC; } /* end of if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) */ /* else: No action required */ } /* end of for (LucHwUnitIndex = ADC_COUNT_BYTE_INIT; LucHwUnitIndex < (uint8)ADC_MAX_HW_UNITS; LucHwUnitIndex++) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'ADC_MAX_HW_UNITS', 'Value': '2U'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0 to 1] = &map_pHwUnitBaseAddress[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'pErrorNotificationPointer', 'Value': '[0 to 1] = &dummy_IoHwAb_Adc_ErrNotification_001'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitCount', 'Value': '[0 to 1] = 0'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitOffset', 'Value': '[0 to 1] = 0'], 'Input_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnPER', 'Value': '0x00'], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[0]', 'Value': 'ADC_ADCX_VCR_GCTRL'], 'Input_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[1]', 'Value': '-'], 'Input_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[2]', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucStartVirChPtr', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_023': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_024': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_PARITY_ERR_INT == STD_ON) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_CODE_FAST) Adc_ParityErrIsr(void) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; volatile P2CONST(Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; uint8 LucHwUnitIndex; uint32 LulSgUnitIndex; uint32 LulSgUnitCount; uint8 LucPerValue; uint8 LucErrorVirCh; Adc_GroupType LddGroup; uint8 LucStartVirCh; uint8 LucEndVirCh; uint8 LucPhysCh; #if (ADC_ENABLE_PWM_DIAG == STD_ON) uint8 LucChannelToGroupIndex; #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ /* Check all HW units as parity errors are handled by a common interrupt */ for (LucHwUnitIndex = ADC_COUNT_BYTE_INIT; LucHwUnitIndex < (uint8)ADC_MAX_HW_UNITS; LucHwUnitIndex++) /* PRQA S 2877 # JV-01 */ { /* Get the pointer to the hardware unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the base register address of the hardware unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; /* PRQA S 2814 # JV-01 */ /* Check the parity error status */ LucPerValue = LpAdcRegisters->ucADCXnPER; /* PRQA S 2814 # JV-01 */ if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) { /* Get the virtual channel captured due to parity error */ LucErrorVirCh = (uint8)(LucPerValue & ADC_ADCX_PER_PECAP); /* Initialize the physical channel to ADC_INVALID_CHANNELID */ LucPhysCh = ADC_INVALID_CHANNELID; /* Get the index of the first SG unit configuration in the hardware unit */ #if ((ADC_IP_ADCJ == STD_ON) || (ADC_IP_ADCK == STD_ON)) LulSgUnitIndex = LpHwUnitConfig->ucSgUnitOffset; #endif /* ((ADC_IP_ADCJ == STD_ON) || (ADC_IP_ADCK == STD_ON)) */ #if (ADC_IP_ADCH == STD_ON) LulSgUnitIndex = Adc_GaaHwUnitData[LucHwUnitIndex].ucSgUnitIndex; #endif /* (ADC_IP_ADCH == STD_ON) */ /* Get the number of SG unit configurations in the hardware unit */ LulSgUnitCount = (uint32)LpHwUnitConfig->ucSgUnitCount; /* Check for errors in order from the highest priority SG unit */ while (LulSgUnitCount != 0UL) { LulSgUnitCount--; /* Get the pointer to the runtime data of the SG unit */ LpSgUnitData = &Adc_GpSgUnitRamData[LulSgUnitIndex + LulSgUnitCount]; /* PRQA S 2824, 3383 # JV-01, JV-04 */ /* Check if the SG unit is active */ if (ADC_TRUE == LpSgUnitData->blSgUnitStatus) /* PRQA S 2814 # JV-01 */ { /* Get the current group of the SG unit */ LddGroup = LpSgUnitData->ddCurrentConvGroup; /* Get the pointer to the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the pointer to the runtime data of the group */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) /* PRQA S 2814 # JV-01 */ { /* Set the group channel range to PWM-Diag channel */ LucStartVirCh = ADC_ADCX_PER_PECAP_PWD; LucEndVirCh = ADC_ADCX_PER_PECAP_PWD; } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) /* PRQA S 2814 # JV-01 */ { /* Set the group channel range to the current virtual channel of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr + LpGroupData->ucChannelsCompleted; /* PRQA S 2814 # JV-01 */ LucEndVirCh = LucStartVirCh; } else #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ { /* Set the group channel range to the virtual channel range of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr; /* PRQA S 2814 # JV-01 */ LucEndVirCh = (uint8)(LucStartVirCh + LpGroupData->ucChannelCount - ADC_BYTE_ONE); /* PRQA S 2814 # JV-01 */ } /* Check if it is within the range of channels in the group */ if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Set the conversion error status */ LpGroupData->blConvError = ADC_TRUE; #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_ADCX_PER_PECAP_PWD == LucErrorVirCh) { /* Get the channel from the group channel configuration as PWM-Diag has no virtual channel */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; LucPhysCh = (uint8)(Adc_GpChannelToGroup[LucChannelToGroupIndex] & ADC_CHANNEL_ID_MASK); /* PRQA S 2824 # JV-01 */ } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Get the physical channel where parity error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ } /* Set the loop count to 0 to end the loop */ LulSgUnitCount = 0UL; } /* end of if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) */ /* else: No action required */ } /* end of if (ADC_TRUE == LpSgUnitData->blSgUnitStatus) */ /* else: No action required */ } /* end of while (LulSgUnitCount != 0UL) */ if (NULL_PTR != LpHwUnitConfig->pErrorNotificationPointer) { if (ADC_INVALID_CHANNELID != LucPhysCh) { /* Invoke a callback function for error notification */ LpHwUnitConfig->pErrorNotificationPointer(LucPhysCh); } /* else: No action required */ } /* else: No action required */ /* Report parity check error to Dem */ ADC_DEM_REPORT_ERROR(ADC_E_PARITY_FAILURE, DEM_EVENT_STATUS_FAILED); /* Clear parity error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_PEC; } /* end of if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) */ /* else: No action required */ } /* end of for (LucHwUnitIndex = ADC_COUNT_BYTE_INIT; LucHwUnitIndex < (uint8)ADC_MAX_HW_UNITS; LucHwUnitIndex++) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'ADC_MAX_HW_UNITS', 'Value': '3U'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0 to 2] = &map_pHwUnitBaseAddress[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'pErrorNotificationPointer', 'Value': '[0 to 2] = &dummy_IoHwAb_Adc_ErrNotification_001'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitCount', 'Value': '[0 to 2] = 4'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitOffset', 'Value': '[0 to 2] = 2'], 'Input_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnPER', 'Value': 'ADC_ADCX_PER_PE'], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[0]', 'Value': 'ADC_REG_DWORD_INIT'], 'Input_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[1]', 'Value': '-'], 'Input_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[2]', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '[2 to 5] = ADC_TRUE'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '[2 to 5] = 0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': 'ADC_GROUP_REPL_SUSPEND_RESUME'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucStartVirChPtr', 'Value': '0'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': '0'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': 'ADC_ADCX_ECR_PEC'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': 'ADC_TRUE'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': 'ADC_REG_DWORD_INIT'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_PARITY_FAILURE'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': 'ADC_REG_DWORD_INIT'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_PARITY_FAILURE'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': 'ADC_REG_DWORD_INIT'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_PARITY_FAILURE'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_023': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_024': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_PARITY_ERR_INT == STD_ON) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_CODE_FAST) Adc_ParityErrIsr(void) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; volatile P2CONST(Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; uint8 LucHwUnitIndex; uint32 LulSgUnitIndex; uint32 LulSgUnitCount; uint8 LucPerValue; uint8 LucErrorVirCh; Adc_GroupType LddGroup; uint8 LucStartVirCh; uint8 LucEndVirCh; uint8 LucPhysCh; #if (ADC_ENABLE_PWM_DIAG == STD_ON) uint8 LucChannelToGroupIndex; #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ /* Check all HW units as parity errors are handled by a common interrupt */ for (LucHwUnitIndex = ADC_COUNT_BYTE_INIT; LucHwUnitIndex < (uint8)ADC_MAX_HW_UNITS; LucHwUnitIndex++) /* PRQA S 2877 # JV-01 */ { /* Get the pointer to the hardware unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the base register address of the hardware unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; /* PRQA S 2814 # JV-01 */ /* Check the parity error status */ LucPerValue = LpAdcRegisters->ucADCXnPER; /* PRQA S 2814 # JV-01 */ if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) { /* Get the virtual channel captured due to parity error */ LucErrorVirCh = (uint8)(LucPerValue & ADC_ADCX_PER_PECAP); /* Initialize the physical channel to ADC_INVALID_CHANNELID */ LucPhysCh = ADC_INVALID_CHANNELID; /* Get the index of the first SG unit configuration in the hardware unit */ #if ((ADC_IP_ADCJ == STD_ON) || (ADC_IP_ADCK == STD_ON)) LulSgUnitIndex = LpHwUnitConfig->ucSgUnitOffset; #endif /* ((ADC_IP_ADCJ == STD_ON) || (ADC_IP_ADCK == STD_ON)) */ #if (ADC_IP_ADCH == STD_ON) LulSgUnitIndex = Adc_GaaHwUnitData[LucHwUnitIndex].ucSgUnitIndex; #endif /* (ADC_IP_ADCH == STD_ON) */ /* Get the number of SG unit configurations in the hardware unit */ LulSgUnitCount = (uint32)LpHwUnitConfig->ucSgUnitCount; /* Check for errors in order from the highest priority SG unit */ while (LulSgUnitCount != 0UL) { LulSgUnitCount--; /* Get the pointer to the runtime data of the SG unit */ LpSgUnitData = &Adc_GpSgUnitRamData[LulSgUnitIndex + LulSgUnitCount]; /* PRQA S 2824, 3383 # JV-01, JV-04 */ /* Check if the SG unit is active */ if (ADC_TRUE == LpSgUnitData->blSgUnitStatus) /* PRQA S 2814 # JV-01 */ { /* Get the current group of the SG unit */ LddGroup = LpSgUnitData->ddCurrentConvGroup; /* Get the pointer to the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the pointer to the runtime data of the group */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) /* PRQA S 2814 # JV-01 */ { /* Set the group channel range to PWM-Diag channel */ LucStartVirCh = ADC_ADCX_PER_PECAP_PWD; LucEndVirCh = ADC_ADCX_PER_PECAP_PWD; } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) /* PRQA S 2814 # JV-01 */ { /* Set the group channel range to the current virtual channel of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr + LpGroupData->ucChannelsCompleted; /* PRQA S 2814 # JV-01 */ LucEndVirCh = LucStartVirCh; } else #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ { /* Set the group channel range to the virtual channel range of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr; /* PRQA S 2814 # JV-01 */ LucEndVirCh = (uint8)(LucStartVirCh + LpGroupData->ucChannelCount - ADC_BYTE_ONE); /* PRQA S 2814 # JV-01 */ } /* Check if it is within the range of channels in the group */ if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Set the conversion error status */ LpGroupData->blConvError = ADC_TRUE; #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_ADCX_PER_PECAP_PWD == LucErrorVirCh) { /* Get the channel from the group channel configuration as PWM-Diag has no virtual channel */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; LucPhysCh = (uint8)(Adc_GpChannelToGroup[LucChannelToGroupIndex] & ADC_CHANNEL_ID_MASK); /* PRQA S 2824 # JV-01 */ } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Get the physical channel where parity error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ } /* Set the loop count to 0 to end the loop */ LulSgUnitCount = 0UL; } /* end of if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) */ /* else: No action required */ } /* end of if (ADC_TRUE == LpSgUnitData->blSgUnitStatus) */ /* else: No action required */ } /* end of while (LulSgUnitCount != 0UL) */ if (NULL_PTR != LpHwUnitConfig->pErrorNotificationPointer) { if (ADC_INVALID_CHANNELID != LucPhysCh) { /* Invoke a callback function for error notification */ LpHwUnitConfig->pErrorNotificationPointer(LucPhysCh); } /* else: No action required */ } /* else: No action required */ /* Report parity check error to Dem */ ADC_DEM_REPORT_ERROR(ADC_E_PARITY_FAILURE, DEM_EVENT_STATUS_FAILED); /* Clear parity error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_PEC; } /* end of if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) */ /* else: No action required */ } /* end of for (LucHwUnitIndex = ADC_COUNT_BYTE_INIT; LucHwUnitIndex < (uint8)ADC_MAX_HW_UNITS; LucHwUnitIndex++) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'ADC_MAX_HW_UNITS', 'Value': '4U'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0 to 3] = &map_pHwUnitBaseAddress[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'pErrorNotificationPointer', 'Value': '[0 to 3] = &dummy_IoHwAb_Adc_ErrNotification_001'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitCount', 'Value': '[0 to 3] = 1'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitOffset', 'Value': '[0 to 3] = 0'], 'Input_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnPER', 'Value': 'ADC_ADCX_PER_PE | 0x01'], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[0]', 'Value': '-'], 'Input_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[1]', 'Value': 'ADC_REG_DWORD_INIT'], 'Input_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[2]', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '[0 to 3] = 0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '[0] = ADC_TRUE'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '[0] = 0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': 'ADC_GROUP_REPL_ABORT_RESTART'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucStartVirChPtr', 'Value': '0'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '3']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': 'ADC_ADCX_ECR_PEC'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': 'ADC_TRUE'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': 'ADC_REG_DWORD_INIT'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_PARITY_FAILURE'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': 'ADC_REG_DWORD_INIT'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_PARITY_FAILURE'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': 'ADC_REG_DWORD_INIT'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_PARITY_FAILURE'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': 'ADC_REG_DWORD_INIT'], 'Output_Param_023': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_PARITY_FAILURE'], 'Output_Param_024': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_PARITY_ERR_INT == STD_ON) #define ADC_START_SEC_CODE_FAST #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_CODE_FAST) Adc_ParityErrIsr(void) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; P2CONST(Adc_HwUnitConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpHwUnitConfig; P2VAR(volatile Adc_ConfigRegisters, AUTOMATIC, REGSPACE) LpAdcRegisters; volatile P2CONST(Adc_SgUnitRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpSgUnitData; P2VAR(volatile Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; uint8 LucHwUnitIndex; uint32 LulSgUnitIndex; uint32 LulSgUnitCount; uint8 LucPerValue; uint8 LucErrorVirCh; Adc_GroupType LddGroup; uint8 LucStartVirCh; uint8 LucEndVirCh; uint8 LucPhysCh; #if (ADC_ENABLE_PWM_DIAG == STD_ON) uint8 LucChannelToGroupIndex; #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ /* Check all HW units as parity errors are handled by a common interrupt */ for (LucHwUnitIndex = ADC_COUNT_BYTE_INIT; LucHwUnitIndex < (uint8)ADC_MAX_HW_UNITS; LucHwUnitIndex++) /* PRQA S 2877 # JV-01 */ { /* Get the pointer to the hardware unit configuration */ LpHwUnitConfig = &Adc_GpHwUnitConfig[LucHwUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Get the base register address of the hardware unit */ LpAdcRegisters = LpHwUnitConfig->pHwUnitBaseAddress; /* PRQA S 2814 # JV-01 */ /* Check the parity error status */ LucPerValue = LpAdcRegisters->ucADCXnPER; /* PRQA S 2814 # JV-01 */ if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) { /* Get the virtual channel captured due to parity error */ LucErrorVirCh = (uint8)(LucPerValue & ADC_ADCX_PER_PECAP); /* Initialize the physical channel to ADC_INVALID_CHANNELID */ LucPhysCh = ADC_INVALID_CHANNELID; /* Get the index of the first SG unit configuration in the hardware unit */ #if ((ADC_IP_ADCJ == STD_ON) || (ADC_IP_ADCK == STD_ON)) LulSgUnitIndex = LpHwUnitConfig->ucSgUnitOffset; #endif /* ((ADC_IP_ADCJ == STD_ON) || (ADC_IP_ADCK == STD_ON)) */ #if (ADC_IP_ADCH == STD_ON) LulSgUnitIndex = Adc_GaaHwUnitData[LucHwUnitIndex].ucSgUnitIndex; #endif /* (ADC_IP_ADCH == STD_ON) */ /* Get the number of SG unit configurations in the hardware unit */ LulSgUnitCount = (uint32)LpHwUnitConfig->ucSgUnitCount; /* Check for errors in order from the highest priority SG unit */ while (LulSgUnitCount != 0UL) { LulSgUnitCount--; /* Get the pointer to the runtime data of the SG unit */ LpSgUnitData = &Adc_GpSgUnitRamData[LulSgUnitIndex + LulSgUnitCount]; /* PRQA S 2824, 3383 # JV-01, JV-04 */ /* Check if the SG unit is active */ if (ADC_TRUE == LpSgUnitData->blSgUnitStatus) /* PRQA S 2814 # JV-01 */ { /* Get the current group of the SG unit */ LddGroup = LpSgUnitData->ddCurrentConvGroup; /* Get the pointer to the group configuration */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Get the pointer to the runtime data of the group */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_TRUE == LpGroup->blPwmDiag) /* PRQA S 2814 # JV-01 */ { /* Set the group channel range to PWM-Diag channel */ LucStartVirCh = ADC_ADCX_PER_PECAP_PWD; LucEndVirCh = ADC_ADCX_PER_PECAP_PWD; } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) if (ADC_GROUP_REPL_SUSPEND_RESUME == LpGroup->enGroupReplacement) /* PRQA S 2814 # JV-01 */ { /* Set the group channel range to the current virtual channel of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr + LpGroupData->ucChannelsCompleted; /* PRQA S 2814 # JV-01 */ LucEndVirCh = LucStartVirCh; } else #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ { /* Set the group channel range to the virtual channel range of the group */ LucStartVirCh = LpGroup->ucStartVirChPtr; /* PRQA S 2814 # JV-01 */ LucEndVirCh = (uint8)(LucStartVirCh + LpGroupData->ucChannelCount - ADC_BYTE_ONE); /* PRQA S 2814 # JV-01 */ } /* Check if it is within the range of channels in the group */ if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) { /* Set the conversion error status */ LpGroupData->blConvError = ADC_TRUE; #if (ADC_ENABLE_PWM_DIAG == STD_ON) if (ADC_ADCX_PER_PECAP_PWD == LucErrorVirCh) { /* Get the channel from the group channel configuration as PWM-Diag has no virtual channel */ LucChannelToGroupIndex = LpGroup->ucChannelToGroupIndex; LucPhysCh = (uint8)(Adc_GpChannelToGroup[LucChannelToGroupIndex] & ADC_CHANNEL_ID_MASK); /* PRQA S 2824 # JV-01 */ } else #endif /* (ADC_ENABLE_PWM_DIAG == STD_ON) */ { /* Get the physical channel where parity error occurred */ LucPhysCh = (uint8)(LpAdcRegisters->aaADCXnVCR[LucErrorVirCh] & ADC_ADCX_VCR_GCTRL); /* PRQA S 2844 # JV-01 */ } /* Set the loop count to 0 to end the loop */ LulSgUnitCount = 0UL; } /* end of if ((LucStartVirCh <= LucErrorVirCh) && (LucErrorVirCh <= LucEndVirCh)) */ /* else: No action required */ } /* end of if (ADC_TRUE == LpSgUnitData->blSgUnitStatus) */ /* else: No action required */ } /* end of while (LulSgUnitCount != 0UL) */ if (NULL_PTR != LpHwUnitConfig->pErrorNotificationPointer) { if (ADC_INVALID_CHANNELID != LucPhysCh) { /* Invoke a callback function for error notification */ LpHwUnitConfig->pErrorNotificationPointer(LucPhysCh); } /* else: No action required */ } /* else: No action required */ /* Report parity check error to Dem */ ADC_DEM_REPORT_ERROR(ADC_E_PARITY_FAILURE, DEM_EVENT_STATUS_FAILED); /* Clear parity error status */ LpAdcRegisters->ddADCXnECR = ADC_ADCX_ECR_PEC; } /* end of if (ADC_BYTE_ZERO != (uint8)(LucPerValue & ADC_ADCX_PER_PE)) */ /* else: No action required */ } /* end of for (LucHwUnitIndex = ADC_COUNT_BYTE_INIT; LucHwUnitIndex < (uint8)ADC_MAX_HW_UNITS; LucHwUnitIndex++) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'ADC_MAX_HW_UNITS', 'Value': '1U'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpHwUnitConfig', 'Value': '&map_Adc_GpHwUnitConfig[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'pHwUnitBaseAddress', 'Value': '[0] = &map_pHwUnitBaseAddress[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'pErrorNotificationPointer', 'Value': '[0] = NULL_PTR'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitCount', 'Value': '[0] = 1'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitOffset', 'Value': '[0] = 0'], 'Input_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ucADCXnPER', 'Value': 'ADC_ADCX_PER_PE | 0x3F'], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[0]', 'Value': '-'], 'Input_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[1]', 'Value': '-'], 'Input_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'aaADCXnVCR[2]', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '[0] = 0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'blSgUnitStatus', 'Value': '[0] = ADC_TRUE'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '[0] = 0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'ADC_GROUP_REPL_ABORT_RESTART\\nADC_GROUP_REPL_SUSPEND_RESUME', 'Name': 'enGroupReplacement', 'Value': 'ADC_GROUP_REPL_ABORT_RESTART'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucStartVirChPtr', 'Value': '0x00'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'blPwmDiag', 'Value': 'ADC_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelToGroupIndex', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpChannelToGroup', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_Adc_GpChannelToGroup[0]', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelsCompleted', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelCount', 'Value': '0x80']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ddADCXnECR', 'Value': 'ADC_ADCX_ECR_PEC'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blConvError', 'Value': 'ADC_TRUE'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'ADC_E_PARITY_FAILURE'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_023': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_024': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((ADC_ENABLE_START_STOP_GROUP_API == STD_ON) && (ADC_ENABLE_QUEUING == STD_ON)) #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, ADC_PRIVATE_CODE) Adc_PushToQueue(const Adc_GroupType LddGroup) { #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Pointer to the group configuration base array */ P2VAR(volatile Adc_GroupType, AUTOMATIC, ADC_APPL_DATA) LpHWUnitQueueBuffer; /* PRQA S 3432 # JV-01 */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ P2VAR(volatile Adc_HwUnitDataType, AUTOMATIC, ADC_APPL_DATA) LpHwUnitData; /* PRQA S 3432 # JV-01 */ /* Declare variable to store count loop */ VAR(uint8, AUTOMATIC) LucLoopCount; #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Declare variable to store current group priority */ VAR(uint8, AUTOMATIC) LucPriority; /* Pointer the local base queue buffer to global queue buffer */ LpHWUnitQueueBuffer = Adc_GpHWUnitQueueBuffer; #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ LpHwUnitData = &Adc_GaaHwUnitData[Adc_GpGroupConfig[LddGroup].ucHwUnitIndex]; /* PRQA S 2824, 2934 # JV-01, JV-01 */ /* Set the flag indicating that group is present in the queue */ Adc_GpGroupRamData[LddGroup].blGrpPresent = ADC_TRUE; /* PRQA S 2824 # JV-01 */ /* Read the queue counter */ LucLoopCount = LpHwUnitData->ucQueueCounter; /* PRQA S 2844 # JV-01 */ #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Store the group into queue if queue is empty */ if (ADC_QUEUE_EMPTY == LpHwUnitData->ucQueueStatus) #else /* Store the group into queue if queue is empty or not full */ if ((ADC_QUEUE_EMPTY == LpHwUnitData->ucQueueStatus) || (ADC_QUEUE_FILLED == LpHwUnitData->ucQueueStatus)) #endif { /* Store the group into queue */ Adc_GpHWUnitQueueBuffer[LucLoopCount] = LddGroup; /* PRQA S 2824 # JV-01 */ /* Increment the queue counter */ LpHwUnitData->ucQueueCounter++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } else /* Queue not empty */ { #if (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) /* Read the priority of the requested group */ LucPriority = Adc_GpGroupConfig[LddGroup].ddGroupPriority; /* Place the requested group in the queue based on this priority */ do { if ((ADC_VAL_BYTE_INIT != LucLoopCount) && (Adc_GpGroupConfig[LpHWUnitQueueBuffer[LucLoopCount - 1U]].ddGroupPriority >= LucPriority)) /* PRQA S 2824 # JV-01 */ { /* Swap ID */ LpHWUnitQueueBuffer[LucLoopCount] = LpHWUnitQueueBuffer[LucLoopCount - 1U]; LpHWUnitQueueBuffer[LucLoopCount - 1U] = LddGroup; LucLoopCount--; } else { LpHWUnitQueueBuffer[LucLoopCount] = LddGroup; LucLoopCount = ADC_COUNT_BYTE_INIT; } } while (ADC_COUNT_BYTE_INIT < LucLoopCount); /* Increment the queue counter */ LpHwUnitData->ucQueueCounter++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ #endif /* (ADC_PRIORITY_IMPLEMENTATION == ADC_PRIORITY_HW_SW) */ } /* Update status for Queue Manage */ /* Check whether the Queue is Full */ if (Adc_GucQueueSize <= LpHwUnitData->ucQueueCounter) { /* Set queue status as full */ LpHwUnitData->ucQueueStatus = ADC_QUEUE_FULL; } else { /* Set queue status as filled */ LpHwUnitData->ucQueueStatus = ADC_QUEUE_FILLED; } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'ucSgUnitIndex', 'Value': '[0] = 0'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ddGroupPriority', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitConfig', 'Value': '&map_Adc_GpSgUnitConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!NULL_PTR', 'Name': 'pQueue', 'Value': '&map_pQueue[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucAdcSgQueueSize', 'Value': '255'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'map_pQueue[0 to 2]', 'Value': '[0] = 1\\n[1] = 2'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!NULL_PTR', 'Name': 'pQueue', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucAdcSgQueueSize', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!NULL_PTR', 'Name': 'pQueue', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucAdcSgQueueSize', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpSgUnitRamData', 'Value': '&map_Adc_GpSgUnitRamData[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueCounter', 'Value': '127'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': 'ADC_QUEUE_FULL'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueCounter', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueCounter', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ddCurrentConvGroup', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blGrpPresent', 'Value': 'ADC_TRUE'], 'Input_Param_024': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blGrpPresent', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blGrpPresent', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blGrpPresent', 'Value': ''], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blGrpPresent', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'blGrpPresent', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueCounter', 'Value': ''], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': 'ADC_QUEUE_FILLED'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueCounter', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueCounter', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucQueueStatus', 'Value': '-'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_pQueue[0 to 3]', 'Value': '-'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ADC_START_SEC_PRIVATE_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PRIVATE_CODE) Adc_StateTransition(const Adc_GroupType LddGroup) /* PRQA S 1532 # JV-01 */ { P2CONST(Adc_GroupConfigType, AUTOMATIC, ADC_CONFIG_DATA) LpGroup; /* PRQA S 3432 # JV-01 */ volatile P2CONST(Adc_ChannelGroupRamData, AUTOMATIC, ADC_VAR_NO_INIT) LpGroupData; /* PRQA S 3432 # JV-01 */ LpGroupData = &Adc_GpGroupRamData[LddGroup]; /* PRQA S 2824 # JV-01 */ LpGroup = &Adc_GpGroupConfig[LddGroup]; /* PRQA S 2824 # JV-01 */ /* Check if the group status is stream completed */ if (ADC_STREAM_COMPLETED == LpGroupData->enGroupStatus) /* PRQA S 2814 # JV-01 */ { if (ADC_TRUE == LpGroup->blImplicitlyStopped) /* PRQA S 2814 # JV-01 */ { /* Set the group status to idle */ Adc_SetStatus(LddGroup, ADC_IDLE); } else { /* Set the Group status to busy */ Adc_SetStatus(LddGroup, ADC_BUSY); } } else if (ADC_COMPLETED == LpGroupData->enGroupStatus) { /* Set the Group status to busy */ Adc_SetStatus(LddGroup, ADC_BUSY); } else { /* No action required */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..255', 'Name': 'LddGroup', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupConfig', 'Value': '&map_Adc_GpGroupConfig[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blImplicitlyStopped', 'Value': 'ADC_TRUE'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'ADC_TRUE\\nADC_FALSE', 'Name': 'blImplicitlyStopped', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Adc_GpGroupRamData', 'Value': '&map_Adc_GpGroupRamData[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,  ADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': 'ADC_COMPLETED'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,  ADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,  ADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ADC_IDLE,\\nADC_BUSY,\\nADC_COMPLETED,  ADC_STREAM_COMPLETED', 'Name': 'enGroupStatus', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'enGroupStatus', 'Value': 'ADC_COMPLETED'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'enGroupStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Adc_StatusType', 'Value': 'ADC_BUSY'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ADC_ENABLE_START_STOP_GROUP_API == STD_ON) #define ADC_START_SEC_PUBLIC_CODE #include \"Adc_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ADC_PUBLIC_CODE) Adc_StopGroupConversion(Adc_GroupType Group) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if (ADC_DEV_ERROR_DETECT == STD_ON) /* Check if the ADC Module is not initialized */ if (ADC_UNINITIALIZED == Adc_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_STOP_GROUP_CONVERSION_SID, ADC_E_UNINIT); } /* Check if the requested group is invalid group ID */ else if (Group >= Adc_GucNoOfGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_STOP_GROUP_CONVERSION_SID, ADC_E_PARAM_GROUP); } /* Check if the requested group is HW triggered */ else if (Group >= Adc_GucMaxSwTriggGroups) { /* Report Error to DET */ (void)Det_ReportError(ADC_MODULE_ID, ADC_INSTANCE_ID, ADC_STOP_GROUP_CONVERSION_SID, ADC_E_WRONG_TRIGG_SRC); } else #endif /* (ADC_DEV_ERROR_DETECT == STD_ON) */ { /* Stop the conversion */ Adc_HwStopGroupConversion(Group); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': '-', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..254', 'Name': 'Group', 'Value': '255'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'ADC_UNINITIALIZED (0)\\nADC_INITIALIZED (1)', 'Name': 'Adc_GblDriverStatus', 'Value': 'ADC_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '1..255', 'Name': 'Adc_GucNoOfGroups', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0..255', 'Name': 'Adc_GucMaxSwTriggGroups', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ADC_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ADC_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ADC_STOP_GROUP_CONVERSION_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ADC_E_PARAM_GROUP'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddGroup', 'Value': '-'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) FUNC(void, CAN_PUBLIC_CODE) Can_DeInit(void) /* PRQA S 1503 # JV-01 */ { VAR(uint8, AUTOMATIC) LucIndex; VAR(boolean, AUTOMATIC) LblErrFlag; VAR(uint32, AUTOMATIC) LulTimeoutDuration; VAR(Std_ReturnType, AUTOMATIC) LucTimeoutResult; #if (CAN_WAKEUP_SUPPORT == STD_ON) P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpPCController; #endif LblErrFlag = CAN_FALSE; LucTimeoutResult = E_OK; /* PRQA S 2982 # JV-01 */ #if (CAN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not initialized */ if (CAN_FALSE == Can_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_DEINIT_SID, CAN_E_TRANSITION); /* Set the error status flag to true */ LblErrFlag = CAN_TRUE; } else { for (LucIndex = 0U; (LucIndex < Can_GpConfig->ucNoOfControllers) && (CAN_FALSE == LblErrFlag); LucIndex++) { /* Report Det if any channel is in STARTED state */ if ((CAN_CS_STARTED == Can_GaaCtrlState[LucIndex].enMode) || /* PRQA S 2844 # JV-01 */ (CAN_PENDING_START_WAIT_COM == Can_GaaCtrlState[LucIndex].enSubState)) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_DEINIT_SID, CAN_E_TRANSITION); /* Set the error status flag to true */ LblErrFlag = CAN_TRUE; } /* else No action required */ } } /* Check whether any development error occurred */ if (CAN_FALSE == LblErrFlag) #endif /*#if (CAN_DEV_ERROR_DETECT == STD_ON) */ { /* Change the module state to CAN_UNINIT before de-initializing all */ /* controllers inside the HW unit. */ Can_SetStatus(CAN_FALSE); // /** DISABLE CONTROLLER WAKEUP INTERRUPTS **/ // #if (CAN_WAKEUP_SUPPORT == STD_ON) for (LucIndex = 0U; (LucIndex < Can_GpConfig->ucNoOfControllers); LucIndex++) { LpPCController = &Can_GpPCController[LucIndex]; if (NULL_PTR != LpPCController->pICWakeup) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Disable interrupt for wakeup hardware event. */ #if (CAN_CR52_PROC == STD_ON) #ifndef CAN_V4H_PROC /* Clear INTPnMSK bit for APPPINTMSKrn */ RH850_SV_MODE_ICR_AND(32, LpPCController->pICWakeup, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_W << (LpPCController->ucCh + (LpPCController->ucUnit * ((uint8)8)))))); #endif /* #ifndef CAN_V4H_PROC */ #else /* set EIMK bit in EIC */ RH850_SV_MODE_ICR_OR(8, LpPCController->pICWakeup, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, LpPCController->pICWakeup); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif /* #if (CAN_CR52_PROC == STD_ON) */ } /* else No action required */ } #endif // /** ENTER GLOBAL_RESET MODE **/ // for (LucIndex = 0U; (LucIndex < Can_GpConfig->ucNoOfUnits) && (CAN_FALSE == LblErrFlag); LucIndex++) { #if (CAN_WAKEUP_SUPPORT == STD_ON) /* Check whether the global mode is in transition duration from */ /* GLOBAL_RESET to GLOBAL_STOP. */ LulTimeoutDuration = CAN_TIMEOUT_COUNT; if ((CAN_RSCAN_GRSTSTS == (Can_GaaRegs[LucIndex].pCmn->ulGSTS & CAN_RSCAN_GSTSMASK)) && /* PRQA S 2814, 2844 # JV-01, JV-01 */ (CAN_RSCAN_GSLPR == (Can_GaaRegs[LucIndex].pCmn->ulGCTR & CAN_RSCAN_GSLPR))) { /* Wait for the transition to GLOBAL_STOP completed. */ LucTimeoutResult = Can_WaitRegisterChange(&Can_GaaRegs[LucIndex].pCmn->ulGSTS, CAN_RSCAN_GSLPSTS, CAN_RSCAN_GSLPSTS, &LulTimeoutDuration); } /* Check whether the global mode is in transition duration from */ /* GLOBAL_RESET to GLOBAL_OPERATING. */ else if ((CAN_RSCAN_GRSTSTS == (Can_GaaRegs[LucIndex].pCmn->ulGSTS & CAN_RSCAN_GSTSMASK)) && /* PRQA S 2004 # JV-01 */ (CAN_RSCAN_GMDC_OP == (Can_GaaRegs[LucIndex].pCmn->ulGCTR & CAN_RSCAN_GMDC_MASK))) { /* Wait for the transition to GLOBAL_OPERATING completed. */ LucTimeoutResult = Can_WaitRegisterChange(&Can_GaaRegs[LucIndex].pCmn->ulGSTS, CAN_RSCAN_GSTSMASK, CAN_RSCAN_GMDC_OP, &LulTimeoutDuration); } /* else No action required */ /* Change to GLOBAL_RESET mode if no timeout occurs. */ if (E_OK != LucTimeoutResult) { /* Do nothing. */ } else #endif { LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucTimeoutResult = Can_GlobalModeChange(LucIndex, CAN_RSCAN_GMDC_RESET, &LulTimeoutDuration); } /* Report to Dem and set error flag if timeout occurs. */ if (E_OK != LucTimeoutResult) { #if defined(CAN_E_TIMEOUT_FAILURE) CAN_DEM_REPORT_ERROR(CAN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif LblErrFlag = CAN_TRUE; } /* else No action required */ } // /** DE-INITIALIZATION OF CONTROLLERS **/ // for (LucIndex = 0U; (LucIndex < Can_GpConfig->ucNoOfControllers) && (CAN_FALSE == LblErrFlag); LucIndex++) { if (CAN_TRUE == Can_GpPCController[LucIndex].blActivation) { /* De-initialize Controller */ LblErrFlag = Can_DeInitController(LucIndex); } /* else No action required */ /* Reset status variables */ Can_GaaCtrlState[LucIndex].enMode = CAN_COMMON_STATE_UNINIT; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucIndex].enSubState = CAN_NO_PENDING_TRANSITION; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucIndex].blBusOff = CAN_FALSE; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucIndex].ulBaudrateIndex = 0U; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucIndex].ulIntCount = 0U; /* PRQA S 2844 # JV-01 */ #if (CAN_WAKEUP_SUPPORT == STD_ON) Can_GaaCtrlState[LucIndex].blWakeupEventOccurred = CAN_FALSE; /* PRQA S 2844 # JV-01 */ #endif } // /** DE-INITIALIZATION OF RSCANn MODULES **/ // for (LucIndex = 0U; (LucIndex < Can_GpConfig->ucNoOfUnits) && (CAN_FALSE == LblErrFlag); LucIndex++) { #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) /* Reset disabled interrupt global counter */ Can_GaaGlobalIntCount[LucIndex] = 0UL; /* PRQA S 2844 # JV-01 */ #endif #if (CAN_WAKEUP_SUPPORT == STD_ON) /* Reset variables to handle the global stop */ Can_GaaActiveControllers[LucIndex] = 0UL; /* PRQA S 2844 # JV-01 */ Can_GaaGlobalStateTransition[LucIndex] = CAN_FALSE; /* PRQA S 2844 # JV-01 */ #endif #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) /* De-initialize Can Time Sync Capture Unit. */ Can_TSCapUnitDeInit(LucIndex); #endif /* De-initialize module and enter GLOBAL_RESET mode. */ LblErrFlag = Can_DeInitModule(LucIndex); } } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblInitialized', 'Value': 'CAN_TRUE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_DEV_ERROR_DETECT\\nCAN_E_TIMEOUT_FAILURE\\nCAN_WAKEUP_SUPPORT\\nCAN_RSCANn_RXFIFO_INTERRUPT', 'Value': 'STD_ON\\nSTD_ON\\nSTD_ON\\nSTD_ON'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfControllers', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfUnits', 'Value': '2'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enMode', 'Value': '~CAN_CS_STARTED'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enSubState', 'Value': 'CAN_PENDING_WAKEUP_WAIT_RESET'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'pICWakeup', 'Value': '[0] = &map_pICWakeup[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'blActivation', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'ucUnit', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '-', 'Name': 'ucCh', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICWakeup[0]', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pCmn', 'Value': '[0]=&map_pCmn[0]\\n[1] = &map_pCmn[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': 'CAN_RSCAN_GRSTSTS'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulGCTR', 'Value': 'CAN_RSCAN_GMDC_MASK'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '<Not Called>'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_NOT_OK'], 'Input_Param_019': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '<Not Called>'], 'Input_Param_020': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '<Not Called>']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatus', 'Value': 'CAN_FALSE'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICWakeup[0]', 'Value': 'CAN_EIC_EIMK_MASK'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpReg', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBits', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_GMDC_RESET'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '<Not Called>'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': '<Not Called>'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CAN_E_TIMEOUT_FAILURE'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucIndex', 'Value': '<Not Called>'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'enMode', 'Value': '-'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'enSubState', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'blBusOff', 'Value': '-'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulBaudrateIndex', 'Value': '-'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulIntCount', 'Value': '-'], 'Output_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupEventOccurred', 'Value': '-'], 'Output_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GaaGlobalIntCount[0]', 'Value': '-'], 'Output_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'Can_GaaActiveControllers[0 to 1]', 'Value': '-'], 'Output_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'Can_GaaGlobalStateTransition[0 to 1]', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucUnit', 'Value': '<Not Called>'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucIndex', 'Value': '<Not Called>'], 'Output_Param_030': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) STATIC FUNC(boolean, CAN_PRIVATE_CODE) Can_DeInitController(CONST(uint8, AUTOMATIC) LucCtrlIndex) { VAR(boolean, AUTOMATIC) LblErrFlag; VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; VAR(uint16, AUTOMATIC) LusHohIndex; P2CONST(Can_HohConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpHoh; /* PRQA S 3432 # JV-01 */ P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ uint32 LulTimeoutDuration; Std_ReturnType LucTimeoutResult; #if ((CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) uint32 LulTxQCh; uint32 LulTxQIdx; #endif LblErrFlag = CAN_FALSE; /* Get pointer to configuration table */ LpPCController = &Can_GpPCController[LucCtrlIndex]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LucCh = LpPCController->ucCh; // /** ENTER CHANNEL_RESET MODE **/ // LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucTimeoutResult = Can_ChannelModeChange(LucUnit, LucCh, CAN_RSCAN_CHMDC_RESET, &LulTimeoutDuration); if (E_OK != LucTimeoutResult) { #if defined(CAN_E_TIMEOUT_FAILURE) CAN_DEM_REPORT_ERROR(CAN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif LblErrFlag = CAN_TRUE; } else { // /** DISABLING OF INTERRUPTS **/ // #ifndef CAN_V4H_PROC #if (CAN_CR52_PROC == STD_ON) /* Disable interrupts */ RH850_SV_MODE_ICR_AND(32, LpPCController->pICErr, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_E << (LpPCController->ucCh * ((uint8)3))))); RH850_SV_MODE_ICR_AND(32, LpPCController->pICRec, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3))))); RH850_SV_MODE_ICR_AND(32, LpPCController->pICTx, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_T << (LpPCController->ucCh * ((uint8)3))))); #else /* Disable interrupts */ RH850_SV_MODE_ICR_OR(8, LpPCController->pICErr, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_OR(8, LpPCController->pICRec, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_OR(8, LpPCController->pICTx, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, LpPCController->pICTx); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif /* #ifdef CAN_CR52_PROC */ #endif /* #ifndef CAN_V4H_PROC */ // /** RESET ERROR INTERRUPTS **/ // /* Reset Interrupts in can controller control register */ Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulCTR = CAN_RSCAN_CTR_DEFAULT; /* PRQA S 2814, 2844 # JV-01, JV-01 */ // /** RESET TRANSMIT HISTORY BUFFER **/ // Can_GaaRegs[LucUnit].pCmn->aaTHLCC[LucCh] = CAN_RSCAN_THLCC_DEFAULT; // /** DE-INITIALIZATION OF HTHHRH BUFFERS **/ // for (LusHohIndex = 0U; LusHohIndex < Can_GpConfig->usNoOfHohs; LusHohIndex++) { LpHoh = &Can_GpHohConfig[LusHohIndex]; if (LpHoh->ucController == LucCtrlIndex) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { switch (LpHoh->enBufferType) { #if ((CAN_TX_BUFFER == STD_ON) || (CAN_RX_BUFFER == STD_ON)) case CAN_BUFFERTYPE_BUFFER: /* Nothing is required */ break; #endif #if (CAN_RX_FIFO == STD_ON) case CAN_BUFFERTYPE_RXFIFO: Can_GaaRegs[LucUnit].pCmn->aaRFCC[LpHoh->usBufferIndex] = CAN_RSCAN_RFCC_DEFAULT; break; #endif #if ((CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) case CAN_BUFFERTYPE_TXQUEUE: LulTxQCh = (uint32)LpHoh->usBufferIndex / CAN_RSCAN_TXQUEUE_PER_CH; LulTxQIdx = (uint32)LpHoh->usBufferIndex % CAN_RSCAN_TXQUEUE_PER_CH; Can_GaaRegs[LucUnit].pCmn->aaTQueueReg[LulTxQIdx].aaTXQCC[LulTxQCh] = CAN_RSCAN_TXQCC_DEFAULT; break; #endif default: /* PRQA S 2016 # JV-01 */ #if ((CAN_RX_COMFIFO == STD_ON) || (CAN_TX_COMFIFO == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON)) Can_GaaRegs[LucUnit].pCmn->aaCFCC[LpHoh->usBufferIndex] = CAN_RSCAN_CFCC_DEFAULT; #ifdef CAN_COMFIFO_ENHANCEMENT_SUPPORT Can_GaaRegs[LucUnit].pCmn->aaCFCCE[LpHoh->usBufferIndex] = CAN_RSCAN_CFCCE_DEFAULT; #endif #endif break; } } /* else No action required */ } // /** DE-INITIALIZATION OF BAUDRATE **/ // /* Reset the value for nBTP into the nominal channel register */ Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulCFG = CAN_RSCAN_CFG_DEFAULT; #if ((CAN_RSCAN_CONFIGURED == STD_ON) && (CAN_RSCANFD_CONFIGURED == STD_ON)) if (CAN_MACRO_RSCANFD == Can_GaaRegs[LucUnit].enMacroType) #endif { #if (CAN_RSCANFD_CONFIGURED == STD_ON) /* Reset FDCFG register */ Can_GaaRegs[LucUnit].pFD->aaFDChReg[LucCh].ulFDCFG = CAN_RSCAN_FDCFG_DEFAULT; /* Reset DCFG register */ Can_GaaRegs[LucUnit].pFD->aaFDChReg[LucCh].ulDCFG = CAN_RSCAN_DCFG_DEFAULT; #endif } /* else No action required */ } // /** ENTER CHANNEL_STOP MODE **/ // if (CAN_FALSE == LblErrFlag) { LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucTimeoutResult = Can_ChannelModeChange(LucUnit, LucCh, CAN_RSCAN_CSLPR | CAN_RSCAN_CHMDC_RESET, &LulTimeoutDuration); if (E_OK != LucTimeoutResult) { #if defined(CAN_E_TIMEOUT_FAILURE) CAN_DEM_REPORT_ERROR(CAN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif LblErrFlag = CAN_TRUE; } /* else No action required */ } /* else No action required */ return LblErrFlag; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_RSCAN_CONFIGURED\\nCAN_RSCANFD_CONFIGURED', 'Value': 'STD_OFF\\nSTD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucCtrlIndex', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pICErr', 'Value': '&map_pICErr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pICRec', 'Value': '&map_pICRec[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pICTx', 'Value': '&map_pICTx[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'enMacroType', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pFD', 'Value': '&map_pFD[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICErr[0]', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRec[0]', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICTx[0]', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfHohs', 'Value': '1'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpHohConfig', 'Value': '&map_Can_GpHohConfig[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucController', 'Value': '0'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'enBufferType', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'usBufferIndex', 'Value': '0'], 'Input_Param_021': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucUnit', 'Value': '[1] = 0\\n'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCh', 'Value': '[1] = 0\\n'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': '[1] = CAN_RSCAN_CHMDC_RESET'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': '[1] = CAN_TIMEOUT_COUNT'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CAN_E_TIMEOUT_FAILURE'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_pICErr[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_pICRec[0]', 'Value': '-'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'map_pICTx[0]', 'Value': '-'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'aaChReg[0].ulCTR', 'Value': '-'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'aaTHLCC[0]', 'Value': '-'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'aaRFCC[0]', 'Value': '-'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'aaTQueueReg[0].aaTXQCC[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'aaCFCC[0]', 'Value': '-'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'aaCFCCE[0]', 'Value': '-'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'aaChReg[0].ulCFG', 'Value': '-'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'aaFDChReg[0].ulFDCFG ', 'Value': '-'], 'Output_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'aaFDChReg[0].ulDCFG', 'Value': '-'], 'Output_Param_018': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblErrFlag', 'Value': 'CAN_TRUE'], 'Output_Param_019': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((CAN_AR_VERSION == CAN_AR_431_VERSION) ||(CAN_AR_VERSION == CAN_AR_1911_VERSION)) STATIC FUNC(boolean, CAN_PRIVATE_CODE) Can_DeInitModule(CONST(uint8, AUTOMATIC) LucUnit) { P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulCount; VAR(boolean, AUTOMATIC) LblErrFlag; VAR(uint32, AUTOMATIC) LulTimeoutDuration; VAR(Std_ReturnType, AUTOMATIC) LucTimeoutResult; #if ((CAN_RX_OBJECT == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) VAR(uint32, AUTOMATIC) LulRulePage; VAR(uint32, AUTOMATIC) LulRuleIndex; #endif LblErrFlag = CAN_FALSE; /* Get PBConfig data for this RSCAN(FD) unit */ LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA))Can_GpConfig->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpHWInfo = &LpHWInfo[LucUnit]; /* PRQA S 2824 # JV-01 */ #if ((CAN_RX_OBJECT == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) // /** DE-INITIALIZATION OF GLOBAL INTERRUPTION **/ // #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) /* Disable RxFIFO interrupt */ #ifndef CAN_V4H_PROC #if (CAN_CR52_PROC == STD_ON) RH850_SV_MODE_ICR_AND(32, Can_GaaRegs[LucUnit].pICRxFIFO, (uint32)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0310, 2814, 2844, 3305 # JV-01, JV-01, JV-01, JV-01 */ #else RH850_SV_MODE_ICR_OR(8, Can_GaaRegs[LucUnit].pICRxFIFO, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814, 2844 # JV-01, JV-01, JV-01 */ #endif /* CAN_CR52_PROC */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Can_GaaRegs[LucUnit].pICRxFIFO); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif /* #ifndef CAN_V4H_PROC */ #endif /* #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) */ // /** DE-INITIALIZATION OF ACCEPTANCE FILTER LIST **/ // LulCount = 0U; LulRulePage = 0U; /* Reset all receive rules to the receive filter registers */ while (LulCount < (uint32)LpHWInfo->usNoOfFilters) /* PRQA S 2814 # JV-01 */ { /* Set page index for each 16 rules */ Can_GaaRegs[LucUnit].pCmn->ulGAFLECTR = CAN_RSCAN_AFLDAE | CAN_RSCAN_AFLPN(LulRulePage); /* PRQA S 2814, 2844, 3469 # JV-01, JV-01, JV-01 */ LulRuleIndex = 0U; /* Reset 16 rules of the receive filter registers in this page */ while (((uint32)CAN_RSCAN_RULES_PER_PAGE > LulRuleIndex) && (LulCount < (uint32)LpHWInfo->usNoOfFilters)) { Can_GaaRegs[LucUnit].pRR[LulRuleIndex].ulGAFLID = CAN_RSCAN_GAFLID_DEFAULT; /* PRQA S 2824 # JV-01 */ Can_GaaRegs[LucUnit].pRR[LulRuleIndex].ulGAFLM = CAN_RSCAN_GAFLM_DEFAULT; Can_GaaRegs[LucUnit].pRR[LulRuleIndex].aaGAFLP[CAN_RSCAN_GAFLP_PAGE0] = CAN_RSCAN_GAFLP0_DEFAULT; Can_GaaRegs[LucUnit].pRR[LulRuleIndex].aaGAFLP[CAN_RSCAN_GAFLP_PAGE1] = CAN_RSCAN_GAFLP1_DEFAULT; LulRuleIndex++; LulCount++; } /* Increment page */ LulRulePage++; /* PRQA S 3383 # JV-01 */ } /* Write disabling the Acceptance Filter List*/ Can_GaaRegs[LucUnit].pCmn->ulGAFLECTR = CAN_RSCAN_AFLDAE_OFF; #endif /* #if ((CAN_RX_OBJECT == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON)) */ /* Reset number of receive rules */ for (LulCount = 0U; LulCount < (uint32)LpHWInfo->ucNoOfGAFLCFG; LulCount++) /* PRQA S 2814 # JV-01 */ { Can_GaaRegs[LucUnit].pCmn->aaGAFLCFG[LulCount] = CAN_RSCAN_GAFLCFG_DEFAULT; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } // /** DE-INITIALIZATION OF BUFFER REGISTERS **/ // /* Reset payload size and buffer number of RxBuffer */ Can_GaaRegs[LucUnit].pCmn->ulRMNB = CAN_RSCAN_RMNB_DEFAULT; /* Reset the value of global configuration register */ Can_GaaRegs[LucUnit].pCmn->ulGCFG = CAN_RSCAN_GCFG_DEFAULT; /* Reset transmission buffer interruption enable/disable */ for (LulCount = 0UL; LulCount < (uint32)LpHWInfo->ucNoOfTMIEC; LulCount++) { Can_GaaRegs[LucUnit].pCmn->aaTMIEC[LulCount] = CAN_RSCAN_TMIEC_DEFAULT; } #if ((CAN_RSCAN_CONFIGURED == STD_ON) && (CAN_RSCANFD_CONFIGURED == STD_ON)) if (CAN_MACRO_RSCANFD == Can_GaaRegs[LucUnit].enMacroType) #endif { #if (CAN_RSCANFD_CONFIGURED == STD_ON) #if (CAN_INTERFACE_MODE_SELECTION_LOCATION == CAN_GRMCFG_REG) /* Reset RCMC bit for Global Interface Mode Select Register. */ Can_GaaRegs[LucUnit].pCmn->ulGRMCFG = CAN_RSCAN_GRMCFG_DEFAULT; #endif /* Reset Global FD Configuration Register. */ Can_GaaRegs[LucUnit].pCmn->ulGFDCFG = CAN_RSCAN_GFDCFG_DEFAULT; #endif } /* else No action required */ // /** ENTER GLOBAL_STOP MODE **/ // /* Change to GLOBAL_STOP mode */ LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucTimeoutResult = Can_GlobalModeChange(LucUnit, CAN_RSCAN_GSLPR | CAN_RSCAN_GMDC_RESET, &LulTimeoutDuration); /* If mode changed was not finished, report error */ if (E_OK != LucTimeoutResult) { #if defined(CAN_E_TIMEOUT_FAILURE) CAN_DEM_REPORT_ERROR(CAN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif LblErrFlag = CAN_TRUE; } /* else No action required */ return LblErrFlag; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_RSCAN_CONFIGURED\\nCAN_RSCANFD_CONFIGURED', 'Value': 'STD_ON\\nSTD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucUnit', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '&map_LpHWInfo[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfFilters', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfGAFLCFG', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfTMIEC', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pICRxFIFO', 'Value': '&map_pICRxFIFO[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pRR', 'Value': '&map_pRR[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'enMacroType', 'Value': 'CAN_MACRO_RSCANFD'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRxFIFO[0]', 'Value': '0'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_GSLPR | CAN_RSCAN_GMDC_RESET'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRxFIFO[0]', 'Value': 'CAN_EIC_EIMK_MASK'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulGAFLECTR', 'Value': 'CAN_RSCAN_AFLDAE_OFF'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'aaGAFLCFG[0]', 'Value': 'CAN_RSCAN_GAFLCFG_DEFAULT'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulRMNB', 'Value': 'CAN_RSCAN_RMNB_DEFAULT'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulGCFG', 'Value': 'CAN_RSCAN_GCFG_DEFAULT'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'aaTMIEC[0]', 'Value': 'CAN_RSCAN_TMIEC_DEFAULT'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulGRMCFG', 'Value': 'CAN_RSCAN_GFDCFG_DEFAULT'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulGFDCFG', 'Value': 'CAN_RSCAN_GFDCFG_DEFAULT'], 'Output_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ulGAFLID', 'Value': '[0] = CAN_RSCAN_GAFLID_DEFAULT'], 'Output_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ulGAFLM', 'Value': '[0] = CAN_RSCAN_GAFLM_DEFAULT'], 'Output_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'aaGAFLP[0 to 1]', 'Value': '[0][0] = CAN_RSCAN_GAFLP0_DEFAULT\\n[0][1] = CAN_RSCAN_GAFLP1_DEFAULT'], 'Output_Param_016': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblErrFlag', 'Value': 'CAN_FALSE'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PUBLIC_CODE) Can_DisableControllerInterrupts(VAR(uint8, AUTOMATIC) Controller) /* PRQA S 1503 # JV-01 */ { P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ #ifdef CAN_V4H_PROC VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; #if (CAN_TX_BUFFER == STD_ON) VAR(uint8, AUTOMATIC) LucTMIECIndex; VAR(uint8, AUTOMATIC) LucCount; P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ #endif VAR(uint16, AUTOMATIC) LusHohIndex; P2CONST(Can_HohConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpHoh; /* PRQA S 3432 # JV-01 */ #if (CAN_TX_QUEUE == STD_ON) VAR(uint32, AUTOMATIC) LulTxQCh; VAR(uint32, AUTOMATIC) LulTxQIdx; #endif #endif #if (CAN_DEV_ERROR_DETECT == STD_ON) VAR(Can_CommonReturnType, AUTOMATIC) LenCommonResult; LenCommonResult = Can_CommonDetCheck(CAN_DISABLE_CNTRL_INT_SID, Controller); if (CAN_COMMON_OK != LenCommonResult) { /* Nothing to do */ } else #endif { LpPCController = &Can_GpPCController[Controller]; /* If this Controller is configuread as polling mode for all events, do nothing */ if (CAN_INT_DISABLED != LpPCController->ucIntEnable) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Critical section is required to protect updating of ulIntCount and to prevent the interruption during manipulating EIMK flag */ CAN_ENTER_CRITICAL_SECTION(CAN_INTERRUPT_CONTROL_PROTECTION); if (0UL != Can_GaaCtrlState[Controller].ulIntCount) /* PRQA S 2844 # JV-01 */ { /* When this function is called recursively, do nothing */ } else { #ifndef CAN_V4H_PROC #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) /* Disable Global interruption */ #if (CAN_CR52_PROC == STD_ON) RH850_SV_MODE_ICR_AND(32, /* PRQA S 0310, 2814, 2844, 3305 # JV-01, JV-01, JV-01, JV-01 */ Can_GaaRegs[LpPCController->ucUnit].pICRxFIFO, (uint32)(~CAN_EIC_EIMK_MASK)); #else RH850_SV_MODE_ICR_OR(8, Can_GaaRegs[LpPCController->ucUnit].pICRxFIFO, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814, 2844 # JV-01, JV-01, JV-01 */ #endif /* #ifdef CAN_CR52_PROC */ /* Increment Global interruption disable count */ Can_GaaGlobalIntCount[LpPCController->ucUnit]++; /* PRQA S 2844, 3383, 3387 # JV-01, JV-01, JV-01 */ #endif /* #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) */ #if (CAN_CR52_PROC == STD_ON) /* Disable Channel interruption */ RH850_SV_MODE_ICR_AND(32, LpPCController->pICErr, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_E << (LpPCController->ucCh * ((uint8)3))))); RH850_SV_MODE_ICR_AND(32, LpPCController->pICRec, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3))))); RH850_SV_MODE_ICR_AND(32, LpPCController->pICTx, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_T << (LpPCController->ucCh * ((uint8)3))))); #else RH850_SV_MODE_ICR_OR(8, LpPCController->pICErr, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_OR(8, LpPCController->pICRec, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_OR(8, LpPCController->pICTx, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ #endif /* #ifdef CAN_CR52_PROC */ #if (CAN_WAKEUP_SUPPORT == STD_ON) if (NULL_PTR != LpPCController->pICWakeup) { #if (CAN_CR52_PROC == STD_ON) RH850_SV_MODE_ICR_AND(32, LpPCController->pICWakeup, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_W << (LpPCController->ucCh + (LpPCController->ucUnit * ((uint8)8)))))); #else /* To modify EIMK flag without affecting EIRF flag, access the lower 8 bit only */ RH850_SV_MODE_ICR_OR(8, LpPCController->pICWakeup, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ #endif /* CAN_CR52_PROC */ } /* else No action required */ #endif /* DummyRead & SYNCP are required to guarantee that any interruption never occurs after this function returns. */ RH850_SV_MODE_REG_READ_ONLY(16, LpPCController->pICTx); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #else /* For V4H only */ LucUnit = LpPCController->ucUnit; LucCh = LpPCController->ucCh; / * Disable Controller Error Interrupt * / Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulCTR &= (~CAN_RSCAN_BOEIE); /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if (CAN_TX_BUFFER == STD_ON) / * Disable transmit message buffer Interrupt * / if (CAN_CHECK_INT_TX == (LpPCController->ucIntEnable & CAN_CHECK_INT_TX)) { /* Get PBConfig data for this RSCAN(FD) unit */ LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA)) Can_GpConfig->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Loop for number of (CFD)TMIECf registers assigned to Controller */ LpHWInfo = &LpHWInfo[LucUnit]; /* PRQA S 2824 # JV-01 */ /* Maximum 2 (CFD)TMIECf registers will be assigned to each CAN channel. */ LucTMIECIndex = LucCh*2U; /* PRQA S 3383 # JV-01 */ for (LucCount = LucTMIECIndex; LucCount < (LucTMIECIndex + 2U); LucCount++) /* PRQA S 3383 # JV-01 */ { Can_GaaRegs[LucUnit].pCmn->aaTMIEC[LucCount] &= (~LpHWInfo->pTMIEC[LucCount]); /* PRQA S 2814, 2824 # JV-01, JV-01 */ } } /* else No action required */ #endif /* #if (CAN_TX_BUFFER == STD_ON) */ / * Disable transmit history list interrupt * / Can_GaaRegs[LucUnit].pCmn->aaTHLCC[LucCh] &= (~CAN_RSCAN_THLIE); / * Disable Receive FIFO/COM FIFO RX Interrupt * / /* Scan all HOH objects */ for (LusHohIndex = 0U; LusHohIndex < Can_GpConfig->usNoOfHohs; LusHohIndex++) { LpHoh = &Can_GpHohConfig[LusHohIndex]; if (LpHoh->ucController == Controller) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Check each HRH object */ if (CAN_HOH_HRH == LpHoh->enHoh) { #if ((CAN_RX_FIFO == STD_ON) || (CAN_RX_COMFIFO == STD_ON)) switch (LpHoh->enBufferType) { #if (CAN_RX_FIFO == STD_ON) case CAN_BUFFERTYPE_RXFIFO: /* Disable Receive FIFO interrupt */ Can_GaaRegs[LucUnit].pCmn->aaRFCC[LpHoh->usBufferIndex] &= (~CAN_RSCAN_RFIE); break; #endif /* #if (CAN_RX_FIFO == STD_ON) */ #if (CAN_RX_COMFIFO == STD_ON) case CAN_BUFFERTYPE_TXRXFIFO: /* Disable RX COM FIFO interrupt */ Can_GaaRegs[LucUnit].pCmn->aaCFCC[LpHoh->usBufferIndex] &= (~CAN_RSCAN_CFRXIE); break; #endif /* #if (CAN_RX_COMFIFO == STD_ON) */ /* Receive buffer and (COM FIFO or TXQ in Gateway mode) don't enable interrupt, so no action required. */ default: /* PRQA S 2016 # JV-01 */ break; } /* switch (LpHoh->enBufferType) */ #endif /* if ((CAN_RX_FIFO == STD_ON) || (CAN_RX_COMFIFO == STD_ON)) */ } else { / * Disable Transmit Queue/COM FIFO TX Interrupt * / /* Check each HTH object */ #if ((CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) switch (LpHoh->enBufferType) { #if (CAN_TX_COMFIFO == STD_ON) case CAN_BUFFERTYPE_TXRXFIFO: /* Disable TX COM FIFO interrupt */ Can_GaaRegs[LucUnit].pCmn->aaCFCC[LpHoh->usBufferIndex] &= (~CAN_RSCAN_CFTXIE); break; #endif /* #if (CAN_TX_COMFIFO == STD_ON) */ #if (CAN_TX_QUEUE == STD_ON) case CAN_BUFFERTYPE_TXQUEUE: LulTxQCh = (uint32)LpHoh->usBufferIndex / CAN_RSCAN_TXQUEUE_PER_CH; LulTxQIdx = (uint32)LpHoh->usBufferIndex % CAN_RSCAN_TXQUEUE_PER_CH; /* Disable TX Queue interrupt */ Can_GaaRegs[LucUnit].pCmn->aaTQueueReg[LulTxQIdx].aaTXQCC[LulTxQCh] &= (~CAN_RSCAN_TXQTXIE); break; #endif /* #if (CAN_TX_QUEUE == STD_ON) */ default: /* PRQA S 2016 # JV-01 */ break; } #endif /* #if ((CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) */ } } /* else No action required */ } #endif /* #ifndef CAN_V4H_PROC */ } /* Increment recursive count */ Can_GaaCtrlState[Controller].ulIntCount++; /* PRQA S 2844, 3383, 3387 # JV-01, JV-01, JV-01 */ CAN_EXIT_CRITICAL_SECTION(CAN_INTERRUPT_CONTROL_PROTECTION); } /* else No action required */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_RSCANn_RXFIFO_INTERRUPT\\n(n = 0 to 1)', 'Value': 'STD_ON\\nSTD_OFF(E2M and E2H)\\nSTD_ON (E2UH and U2Ax)\\nSTD_ON (S4_G4MH, S4_CR52)'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_TX_BUFFER', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_RX_FIFO', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_RX_COMFIFO', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_TX_COMFIFO', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_TX_QUEUE', 'Value': 'STD_ON'], 'Input_Param_008': ['Type': 'Argument', 'Range': '0..CAN_MAX_NUMBER_OF_CONTROLLER -1', 'Name': 'Controller', 'Value': 'CAN_MAX_NUMBER_OF_CONTROLLER'], 'Input_Param_009': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'CAN_CHECK_INT_TX / \\nCAN_INT_DISABLED', 'Name': 'ucIntEnable', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '1', 'Name': 'ucUnit', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '1', 'Name': 'ucCh', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '!NULL_PTR / NULL_PTR', 'Name': 'pICWakeup', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pICErr', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pICRec', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pICTx', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'ulIntCount', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '-', 'Name': 'Can_GaaGlobalIntCount[0 to 1]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICWakeup[0]', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICErr[0]', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICRec[0]', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICTx[0]', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_024': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pICRxFIFO', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCmn', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '-', 'Name': 'aaChReg[0].ulCTR', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GpConfig', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '-'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'pTMIEC', 'Value': '-'], 'Input_Param_031': ['Type': 'Array', 'Range': '-', 'Name': 'aaTMIEC[0 to 15]', 'Value': '-'], 'Input_Param_032': ['Type': 'Variable', 'Range': '-', 'Name': 'aaTHLCC[0]', 'Value': '-'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfHohs', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpHohConfig', 'Value': '-'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'ucController', 'Value': '-'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'enHoh', 'Value': '-'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'enBufferType', 'Value': '-'], 'Input_Param_038': ['Type': 'Variable', 'Range': '-', 'Name': 'aaRFCC[0]', 'Value': '-'], 'Input_Param_039': ['Type': 'Variable', 'Range': '-', 'Name': 'aaCFCC[0]', 'Value': '-'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'usBufferIndex', 'Value': '-'], 'Input_Param_041': ['Type': 'Variable', 'Range': '-', 'Name': 'aaTQueueReg[0].aaTXQCC[0]', 'Value': '-'], 'Input_Param_042': ['Type': 'Return_Value_of', 'Range': 'CAN_COMMON_NOT_OK / CAN_COMMON_OK', 'Name': 'return', 'Value': 'CAN_COMMON_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LucSID', 'Value': 'CAN_DISABLE_CNTRL_INT_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LucController', 'Value': 'CAN_MAX_NUMBER_OF_CONTROLLER'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GaaGlobalIntCount[0]', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICErr[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICRec[0]', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICTx[0]', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICWakeup[0]', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'aaChReg[0].ulCTR', 'Value': '-'], 'Output_Param_011': ['Type': 'Array', 'Range': '-', 'Name': 'aaTMIEC[0 to 15]', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'aaTHLCC[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'aaRFCC[0]', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'aaCFCC[0]', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'aaTQueueReg[0].aaTXQCC[0]', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulIntCount', 'Value': '-'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PUBLIC_CODE) Can_EnableControllerInterrupts(VAR(uint8, AUTOMATIC) Controller) /* PRQA S 1503 # JV-01 */ { P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ #ifdef CAN_V4H_PROC VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; #if (CAN_TX_BUFFER == STD_ON) VAR(uint8, AUTOMATIC) LucTMIECIndex; VAR(uint8, AUTOMATIC) LucCount; P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ #endif VAR(uint16, AUTOMATIC) LusHohIndex; P2CONST(Can_HohConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpHoh; /* PRQA S 3432 # JV-01 */ #if (CAN_TX_QUEUE == STD_ON) VAR(uint32, AUTOMATIC) LulTxQCh; VAR(uint32, AUTOMATIC) LulTxQIdx; #endif #endif #if (CAN_DEV_ERROR_DETECT == STD_ON) VAR(Can_CommonReturnType, AUTOMATIC) LenCommonResult; LenCommonResult = Can_CommonDetCheck(CAN_ENABLE_CNTRL_INT_SID, Controller); if (CAN_COMMON_OK != LenCommonResult) { /* Do nothing */ } else #endif { LpPCController = &Can_GpPCController[Controller]; /* If this Controller is configuread as polling mode for all events, do nothing */ if (CAN_INT_DISABLED != LpPCController->ucIntEnable) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Critical section is required to protect updating of ulIntCount */ CAN_ENTER_CRITICAL_SECTION(CAN_INTERRUPT_CONTROL_PROTECTION); if (0UL == Can_GaaCtrlState[Controller].ulIntCount) /* PRQA S 2844 # JV-01 */ { /* If interruption is already enabled, do nothing */ } else { /* Decrement recursive count */ Can_GaaCtrlState[Controller].ulIntCount--; /* PRQA S 3384, 3387 # JV-01, JV-01 */ if (0UL != Can_GaaCtrlState[Controller].ulIntCount) /* PRQA S 2844 # JV-01 */ { /* Recursive count is still remained, do nothing */ } else { #ifndef CAN_V4H_PROC #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) /* Decrement Global interruption disable count */ Can_GaaGlobalIntCount[LpPCController->ucUnit]--; /* PRQA S 2844, 3384, 3387 # JV-01, JV-01, JV-01 */ /* Enable Global interruption */ if (0UL == Can_GaaGlobalIntCount[LpPCController->ucUnit]) /* PRQA S 2844 # JV-01 */ { #if (CAN_CR52_PROC == STD_ON) RH850_SV_MODE_ICR_OR(32, Can_GaaRegs[LpPCController->ucUnit].pICRxFIFO, CAN_EIC_EIMK_MASK); /* PRQA S 0310, 2814, 2844, 3305 # JV-01, JV-01, JV-01, JV-01 */ #else RH850_SV_MODE_ICR_AND(8, Can_GaaRegs[LpPCController->ucUnit].pICRxFIFO, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751, 2814, 2844 # JV-01, JV-01, JV-01 */ #endif /* CAN_CR52_PROC */ } /* else No action required */ #endif /* #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) */ #if (CAN_CR52_PROC == STD_ON) /* Enable Channel interrupts */ RH850_SV_MODE_ICR_OR(32, LpPCController->pICErr, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_E << (LpPCController->ucCh * ((uint8)3))))); RH850_SV_MODE_ICR_OR(32, LpPCController->pICRec, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3))))); RH850_SV_MODE_ICR_OR(32, LpPCController->pICTx, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_T << (LpPCController->ucCh * ((uint8)3))))); #else /* Enable Channel interrupts */ RH850_SV_MODE_ICR_AND(8, LpPCController->pICErr, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_AND(8, LpPCController->pICRec, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_AND(8, LpPCController->pICTx, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751, 2814 # JV-01, JV-01 */ #endif /* CAN_CR52_PROC */ #if (CAN_WAKEUP_SUPPORT == STD_ON) /* If waiting wake-up interrupt now, enable it */ if ((CAN_COMMON_STATE_SLEEP == Can_GaaCtrlState[Controller].enMode) && (CAN_NO_PENDING_TRANSITION == Can_GaaCtrlState[Controller].enSubState) && (0U != (LpPCController->ucIntEnable & CAN_CHECK_INT_WAKEUP)) && (NULL_PTR != LpPCController->pICWakeup)) { #if (CAN_CR52_PROC == STD_ON) /* Set INTPnMSK bit for APPPINTMSKrn */ RH850_SV_MODE_ICR_OR(32, LpPCController->pICWakeup, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_W << (LpPCController->ucCh + (LpPCController->ucUnit * ((uint8)8)))))); #else /* To modify EIMK flag without affecting EIRF flag, access the lower 8 bit only */ RH850_SV_MODE_ICR_AND(8, LpPCController->pICWakeup, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751, 2814 # JV-01, JV-01 */ #endif /* #if (CAN_CR52_PROC == STD_ON) */ } /* else No action required */ #endif /* DummyRead & SYNCP are not required when opening Interrupt Mask. Because even though there is a pending interrupt, it should not necessarily be accepted on the next instruction. */ #else /* For V4H only */ LucUnit = LpPCController->ucUnit; LucCh = LpPCController->ucCh; / * Enable Controller Error Interrupt * / if (CAN_CHECK_INT_BUSOFF == (LpPCController->ucIntEnable & CAN_CHECK_INT_BUSOFF)) { Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulCTR |= CAN_RSCAN_BOEIE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } /* else No action required */ #if (CAN_TX_BUFFER == STD_ON) / * Enable transmit message buffer Interrupt * / if (CAN_CHECK_INT_TX == (LpPCController->ucIntEnable & CAN_CHECK_INT_TX)) { /* Get PBConfig data for this RSCAN(FD) unit */ LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_RSCAN_CONFIG_DATA)) /* PRQA S 0316, 3432 # JV-01, JV-01 */ Can_GpConfig->pHWUnitInfo; /* Loop for number of (CFD)TMIECf registers assigned to Controller */ LpHWInfo = &LpHWInfo[LucUnit]; /* PRQA S 2824 # JV-01 */ /* Maximum 2 (CFD)TMIECf registers will be assigned to each CAN channel. */ LucTMIECIndex = LucCh*2U; /* PRQA S 3383 # JV-01 */ for (LucCount = LucTMIECIndex; LucCount < (LucTMIECIndex + 2U); LucCount++) /* PRQA S 3383 # JV-01 */ { Can_GaaRegs[LucUnit].pCmn->aaTMIEC[LucCount] |= LpHWInfo->pTMIEC[LucCount]; /* PRQA S 2814, 2824 # JV-01, JV-01 */ } } /* else No action required */ #endif /* #if (CAN_TX_BUFFER == STD_ON) */ / * Enable transmit history list interrupt * / if (CAN_RSCAN_THLIE == (CAN_RSCAN_THLIE & LpPCController->ulTHLCC)) { Can_GaaRegs[LucUnit].pCmn->aaTHLCC[LucCh] |= CAN_RSCAN_THLIE; } /* else No action required */ / * Enable Receive FIFO/COM FIFO Interrupt * / /* Scan all HOH objects */ for (LusHohIndex = 0U; LusHohIndex < Can_GpConfig->usNoOfHohs; LusHohIndex++) { LpHoh = &Can_GpHohConfig[LusHohIndex]; if (LpHoh->ucController == Controller) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Check each HRH object */ if (CAN_HOH_HRH == LpHoh->enHoh) { #if ((CAN_RX_FIFO == STD_ON) || (CAN_RX_COMFIFO == STD_ON)) switch (LpHoh->enBufferType) { /* PRQA S 0715 # JV-01 */ #if (CAN_RX_FIFO == STD_ON) case CAN_BUFFERTYPE_RXFIFO: if (CAN_RSCAN_RFIE == (LpHoh->ulXXCCRegValue & CAN_RSCAN_RFIE)) /* PRQA S 0715 # JV-01 */ { /* Enable Receive FIFO interrupt */ Can_GaaRegs[LucUnit].pCmn->aaRFCC[LpHoh->usBufferIndex] |= CAN_RSCAN_RFIE; } /* else No action required */ break; #endif /* #if (CAN_RX_FIFO == STD_ON) */ #if (CAN_RX_COMFIFO == STD_ON) case CAN_BUFFERTYPE_TXRXFIFO: if (CAN_RSCAN_CFRXIE == (LpHoh->ulXXCCRegValue & CAN_RSCAN_CFRXIE)) /* PRQA S 0715 # JV-01 */ { /* Enable RX COM FIFO interrupt */ Can_GaaRegs[LucUnit].pCmn->aaCFCC[LpHoh->usBufferIndex] |= CAN_RSCAN_CFRXIE; } /* else No action required */ break; #endif /* #if (CAN_RX_COMFIFO == STD_ON) */ /* Receive buffer and (COM FIFO or TXQ in Gateway mode) don't enable interrupt, so no action required. */ default: /* PRQA S 2016 # JV-01 */ break; } /* switch (LpHoh->enBufferType) */ #endif /* if ((CAN_RX_FIFO == STD_ON) || (CAN_RX_COMFIFO == STD_ON)) */ } else { / * Enable Transmit Queue/COM FIFO Interrupt * / /* Check each HTH object */ #if ((CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) switch (LpHoh->enBufferType) { /* PRQA S 0715 # JV-01 */ #if (CAN_TX_COMFIFO == STD_ON) case CAN_BUFFERTYPE_TXRXFIFO: if (CAN_RSCAN_CFTXIE == (LpHoh->ulXXCCRegValue & CAN_RSCAN_CFTXIE)) { /* Enable TX COM FIFO interrupt */ Can_GaaRegs[LucUnit].pCmn->aaCFCC[LpHoh->usBufferIndex] |= CAN_RSCAN_CFTXIE; } /* else No action required */ break; #endif /* #if (CAN_TX_COMFIFO == STD_ON) */ #if (CAN_TX_QUEUE == STD_ON) case CAN_BUFFERTYPE_TXQUEUE: if (CAN_RSCAN_TXQTXIE == (LpHoh->ulXXCCRegValue & CAN_RSCAN_TXQTXIE)) { LulTxQCh = (uint32)LpHoh->usBufferIndex / CAN_RSCAN_TXQUEUE_PER_CH; LulTxQIdx = (uint32)LpHoh->usBufferIndex % CAN_RSCAN_TXQUEUE_PER_CH; /* Enable TX Queue interrupt */ Can_GaaRegs[LucUnit].pCmn->aaTQueueReg[LulTxQIdx].aaTXQCC[LulTxQCh] |= CAN_RSCAN_TXQTXIE; } /* else No action required */ break; #endif /* #if (CAN_TX_QUEUE == STD_ON) */ default: /* PRQA S 2016 # JV-01 */ break; } #endif /* #if ((CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) */ } } /* else No action required */ } #endif /* #ifndef CAN_V4H_PROC */ } } /* Enable Interruption */ CAN_EXIT_CRITICAL_SECTION(CAN_INTERRUPT_CONTROL_PROTECTION); } /* else No action required */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_TX_BUFFER', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_RX_FIFO', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_RX_COMFIFO', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_TX_COMFIFO', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_TX_QUEUE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..CAN_MAX_NUMBER_OF_CONTROLLER -1', 'Name': 'Controller', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GaaGlobalIntCount[0]', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'enMode', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'enSubState', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '-', 'Name': 'ucIntEnable', 'Value': 'CAN_CHECK_INT_TX'], 'Input_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'pICWakeup', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'pICErr', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'pICRec', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'pICTx', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_017': ['Type': 'Variable', 'Range': '1', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_018': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICWakeup[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICErr[0]', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICRec[0]', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICTx[0]', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '-', 'Name': 'ulIntCount', 'Value': '1'], 'Input_Param_023': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '-', 'Name': 'pICRxFIFO', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'aaChReg[0].ulCTR', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '&map_LpHWInfo[0]'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'pTMIEC', 'Value': '&map_pTMIEC[0]'], 'Input_Param_031': ['Type': 'Array', 'Range': '', 'Name': 'map_pTMIEC[0 to 15]', 'Value': '[0 to 15] = 1'], 'Input_Param_032': ['Type': 'Array', 'Range': '', 'Name': 'aaTMIEC[0 to 15]', 'Value': '[0 to 15] = 0'], 'Input_Param_033': ['Type': 'Variable', 'Range': '-', 'Name': 'ulTHLCC', 'Value': 'CAN_RSCAN_THLE'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'aaTHLCC[0]', 'Value': '-'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfHohs', 'Value': '1'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpHohConfig', 'Value': '&map_Can_GpHohConfig[0]'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'ucController', 'Value': '0'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'enHoh', 'Value': 'CAN_HOH_HRH'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'enBufferType', 'Value': 'CAN_BUFFERTYPE_TXRXFIFO'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'ulXXCCRegValue', 'Value': 'CAN_RSCAN_CFRXIE'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'aaRFCC[0]', 'Value': '-'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFCC[0]', 'Value': 'CAN_RSCAN_CFRXIE'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'usBufferIndex', 'Value': '0'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'aaTQueueReg[0].aaTXQCC[0]', 'Value': '-'], 'Input_Param_045': ['Type': 'Return_Value_of', 'Range': '-', 'Name': 'return', 'Value': 'CAN_COMMON_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LucSID', 'Value': 'CAN_ENABLE_CNTRL_INT_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LucController', 'Value': '0'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': 'Called'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Register', 'Range': '-', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GaaGlobalIntCount[0]', 'Value': '-'], 'Output_Param_006': ['Type': 'Register', 'Range': '-', 'Name': 'map_pICErr[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Register', 'Range': '-', 'Name': 'map_pICRec[0]', 'Value': '-'], 'Output_Param_008': ['Type': 'Register', 'Range': '-', 'Name': 'map_pICTx[0]', 'Value': '-'], 'Output_Param_009': ['Type': 'Register', 'Range': '-', 'Name': 'map_pICWakeup[0]', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'aaChReg[0].ulCTR', 'Value': '-'], 'Output_Param_011': ['Type': 'Array', 'Range': '-', 'Name': 'aaTMIEC[0 to 15]', 'Value': '[0 to 1] = 1\\n[2 to 15] = 0'], 'Output_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'aaTHLCC[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'aaRFCC[0]', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'aaCFCC[0]', 'Value': 'CAN_RSCAN_CFRXIE'], 'Output_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'aaTQueueReg[0].aaTXQCC[0]', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulIntCount', 'Value': '0'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (CAN_ACCESS_HW_ENABLE == STD_ON) #if ((CAN_TX_COMFIFO == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON) || \\ (CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) STATIC FUNC(void, CAN_PRIVATE_CODE) Can_EnableTxBuffers( CONST(uint8, AUTOMATIC) LucUnit, CONST(uint8, AUTOMATIC) LucCtrlIndex) { P2CONST(Can_HohConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpHoh; /* PRQA S 3432 # JV-01 */ VAR(uint16, AUTOMATIC) LusHohIndex; #if ((CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) VAR(uint32, AUTOMATIC) LulTxQCh; VAR(uint32, AUTOMATIC) LulTxQIdx; #endif /* Scan all HOH objects */ for (LusHohIndex = 0U; LusHohIndex < Can_GpConfig->usNoOfHohs; LusHohIndex++) { LpHoh = &Can_GpHohConfig[LusHohIndex]; /* If this HOH belongs to this Controller, process it according to a type */ if (LpHoh->ucController == LucCtrlIndex) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if ((CAN_TX_COMFIFO == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON)) if (((CAN_BUFFERTYPE_TXRXFIFO == LpHoh->enBufferType) && (CAN_HOH_HTH == LpHoh->enHoh)) || (CAN_BUFFERTYPE_GATEWAY == LpHoh->enBufferType)) { #ifdef CAN_V4H_PROC /* Checking whether CAN controller interrupts have been disabled by Can_DisableControllerInterrupts API. */ if (0UL != Can_GaaCtrlState[LucCtrlIndex].ulIntCount) /* PRQA S 2844 # JV-01 */ { Can_GaaRegs[LucUnit].pCmn->aaCFCC[LpHoh->usBufferIndex] = /* PRQA S 2814, 2844 # JV-01, JV-01 */ ((LpHoh->ulXXCCRegValue | CAN_RSCAN_CFE) & (~CAN_RSCAN_CFTXIE)); } else #endif { Can_GaaRegs[LucUnit].pCmn->aaCFCC[LpHoh->usBufferIndex] = LpHoh->ulXXCCRegValue | CAN_RSCAN_CFE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } } /* else No action required if (CAN_TX_QUEUE == STD_OFF) && (CAN_GATEWAY_QUEUE == STD_OFF*/ #endif /* #if ((CAN_TX_COMFIFO == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON)) */ #if ((CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) if (CAN_BUFFERTYPE_TXQUEUE == LpHoh->enBufferType) { LulTxQCh = (uint32)LpHoh->usBufferIndex / CAN_RSCAN_TXQUEUE_PER_CH; LulTxQIdx = (uint32)LpHoh->usBufferIndex % CAN_RSCAN_TXQUEUE_PER_CH; #ifdef CAN_V4H_PROC /* Checking whether CAN controller interrupts have been disabled by Can_DisableControllerInterrupts API. */ if (0UL != Can_GaaCtrlState[LucCtrlIndex].ulIntCount) { Can_GaaRegs[LucUnit].pCmn->aaTQueueReg[LulTxQIdx].aaTXQCC[LulTxQCh] = ((LpHoh->ulXXCCRegValue | CAN_RSCAN_TXQE) & (~CAN_RSCAN_TXQTXIE)); } else #endif { Can_GaaRegs[LucUnit].pCmn->aaTQueueReg[LulTxQIdx].aaTXQCC[LulTxQCh] = LpHoh->ulXXCCRegValue | CAN_RSCAN_TXQE; } } /* else No action required */ #endif /* #if ((CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) */ } /* else No action required */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_TX_COMFIFO\\nCAN_GATEWAY_COMFIFO\\nCAN_TX_QUEUE', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucUnit', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucCtrlIndex', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfHohs', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpHohConfig', 'Value': '&map_Can_GpHohConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucController', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'enBufferType', 'Value': 'CAN_BUFFERTYPE_TXRXFIFO\\n'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulIntCount', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enHoh', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulXXCCRegValue', 'Value': '0x2'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'usBufferIndex', 'Value': '23'], 'Input_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pCmn', 'Value': '[0] = &map_pCmn[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'aaCFCC[0 to 23]', 'Value': '[0 to 23] = 0'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'aaTXQCC[0 to 7]', 'Value': '[0 to 7] = 0']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'aaCFCC[0 to 23]', 'Value': '-'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'aaTXQCC[0 to 7]', 'Value': '-'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) #define CAN_START_SEC_PUBLIC_CODE #include \"Can_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CAN_PUBLIC_CODE) Can_GetControllerErrorState( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) ControllerId, P2VAR(Can_ErrorStateType, AUTOMATIC, CAN_APPL_DATA) ErrorStatePtr) /* PRQA S 3432 # JV-01 */ { VAR(Std_ReturnType, AUTOMATIC) LenReturnValue; P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; #if (CAN_DEV_ERROR_DETECT == STD_ON) LenReturnValue = Can_CommonDetCheck(CAN_GET_ERRSTATECNTRL_SID, ControllerId); if (E_OK != LenReturnValue) { /* Return LenReturnValue as it is */ } /* Check if parameter passed is equal to Null pointer */ else if (NULL_PTR == ErrorStatePtr) { /* Report to DET */ (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_GET_ERRSTATECNTRL_SID, CAN_E_PARAM_POINTER); LenReturnValue = E_NOT_OK; } else #endif /* #if (CAN_DEV_ERROR_DETECT == STD_ON) */ { LenReturnValue = E_OK; LpPCController = &Can_GpPCController[ControllerId]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LucCh = LpPCController->ucCh; /* Get the current error state of the Controller */ if (0UL != (Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulSTS & CAN_RSCAN_BOSTS)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF; /* PRQA S 2814 # JV-01 */ } else if (0UL != (Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulSTS & CAN_RSCAN_EPSTS)) { *ErrorStatePtr = CAN_ERRORSTATE_PASSIVE; } else { *ErrorStatePtr = CAN_ERRORSTATE_ACTIVE; } } /* Return LenReturnValue */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..CAN_MAX_NUMBER_OF_CONTROLLER -1', 'Name': 'ControllerId', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'ErrorStatePtr', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_ErrorStatePtr[0]', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'aaChReg[0].ulSTS', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'CAN_GET_ERRSTATECNTRL_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucController', 'Value': '0'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CAN_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CAN_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CAN_GET_ERRSTATECNTRL_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CAN_E_PARAM_POINTER'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_ErrorStatePtr[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'returnvalue', 'Value': 'E_NOT_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (CAN_AR_VERSION == CAN_AR_1911_VERSION) FUNC(Std_ReturnType, CAN_PUBLIC_CODE) Can_GetControllerTxErrorCounter( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) ControllerId, P2VAR(uint8, AUTOMATIC, CAN_APPL_DATA) TxErrorCounterPtr) /* PRQA S 3432 # JV-01 */ { VAR(Std_ReturnType, AUTOMATIC) LenReturnValue; VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; #if (CAN_DEV_ERROR_DETECT == STD_ON) LenReturnValue = Can_CommonDetCheck(CAN_GET_CONTROLLER_TXERROR_COUNTER_SID, ControllerId); if (E_OK!= LenReturnValue) { /* Nothing to do */ } else if(NULL_PTR == TxErrorCounterPtr) { /* SWS_Can_00514 */ (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_GET_CONTROLLER_TXERROR_COUNTER_SID, CAN_E_PARAM_POINTER); LenReturnValue = E_NOT_OK; } else #endif /* (CAN_DEV_ERROR_DETECT == STD_ON) */ { LucUnit = Can_GpPCController[ControllerId].ucUnit; LucCh = Can_GpPCController[ControllerId].ucCh; /* SWS_Can_00515 */ /* Read Tx Error counter from CFDCnSTS register */ *TxErrorCounterPtr = ((Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulSTS /* PRQA S 2814, 2844, 4461 # JV-01, JV-01, JV-01 */ & CAN_RSCAN_TEC_MASK) >> CAN_RSCAN_TEC_OFFSET); /* Init return value */ LenReturnValue = E_OK; } /* return final value */ return(LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..CAN_MAX_NUMBER_OF_CONTROLLER -1', 'Name': 'ControllerId', 'Value': 'CAN_MAX_NUMBER_OF_CONTROLLER'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'TxErrorCounterPtr', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_TxErrorCounterPtr[0]', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'aaChReg[0].ulSTS', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'CAN_GET_CONTROLLER_TXERROR_COUNTER_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucController', 'Value': 'CAN_MAX_NUMBER_OF_CONTROLLER'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_TxErrorCounterPtr[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'returnvalue', 'Value': 'E_NOT_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #ifdef CAN_V4H_PROC #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_PUBLIC_ICOM_SUPPORT == STD_ON)) /* Defines the CAT2 interrupt mapping */ #if defined (Os_CAN_GLOBAL_CAT2_ISR) || (CAN_ISR_CATEGORY_2 == STD_ON) ISR(CAN_GLOBAL_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, CAN_CODE_FAST) CAN_GLOBAL_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) VAR(boolean, AUTOMATIC) LblIrqSrcFlag; VAR(uint32, AUTOMATIC) LulRxFIFOIndex; VAR(uint32, AUTOMATIC) LulIrqExist; #endif #if ((CAN_PUBLIC_ICOM_SUPPORT == STD_ON) && (CAN_ICOM_PAYLOAD_LENGTH_ERROR_SUPPORT == STD_ON)) VAR(uint8, AUTOMATIC) LucController; VAR(IcomConfigIdType, AUTOMATIC) LddIcomConfigurationId; #endif /* Initialize Interrupt Source Flag check */ #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) LblIrqSrcFlag = CAN_FALSE; #endif / * Check whether the Interrupt is Receive FIFO * / #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) LulIrqExist = 0U; /* Accumurate all interrupt request flags of all RxFIFO */ for (LulRxFIFOIndex = 0UL; LulRxFIFOIndex < CAN_RSCAN_RXFIFO_PER_UNIT; LulRxFIFOIndex++) { /* if (RFCCa.RFIE && RFSTSa.RFIF), it means that irq exists */ LulIrqExist = LulIrqExist | ( CAN_RSCAN_RFIE_GET( /* PRQA S 2814, 3469 # JV-01, JV-01 */ Can_GaaRegs[CAN_PHYIDX_UNIT0].pCmn->aaRFCC[LulRxFIFOIndex]) & CAN_RSCAN_RFIF_GET( /* PRQA S 3469 # JV-01 */ Can_GaaRegs[CAN_PHYIDX_UNIT0].pCmn->aaRFSTS[LulRxFIFOIndex]) ); } /* If no irq exists from RS-CAN, this interrupt is wrong */ if (0UL == LulIrqExist) { /* No Action required*/ } else #endif /* #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) */ #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) /* If PN is supported and deactivated */ if (CAN_ICOM_DEACTIVATION == Can_GblIcomStatus) /* PRQA S 3416 # JV-01 */ #endif /* #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) */ { #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) LblIrqSrcFlag = CAN_TRUE; #endif /* Invoke Can_RxProcessing internal function for receive processing */ Can_RxProcessing(CAN_RXPROC_RXFIFO(CAN_PHYIDX_UNIT0), CAN_CHECK_INT_RX, CAN_MAINFUNCTION_INSTANCE_0); /* PRQA S 3469 # JV-01 */ } #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) else /* PN is activated */ { #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) LblIrqSrcFlag = CAN_TRUE; #endif /* Invoke Can_IcomRxProcessing internal function for receive processing */ Can_IcomRxProcessing(CAN_PHYIDX_UNIT0); } #endif /* #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) */ / * Check whether the Interrupt is global error * / #if ((CAN_PUBLIC_ICOM_SUPPORT == STD_ON) && (CAN_ICOM_PAYLOAD_LENGTH_ERROR_SUPPORT == STD_ON)) if ((CAN_ICOM_ACTIVATION == Can_GblIcomStatus) && /* PRQA S 3416 # JV-01 */ ( CAN_RSCAN_GERFL_DEF == (Can_GaaRegs[CAN_PHYIDX_UNIT0].pCmn->ulGERFL & CAN_RSCAN_GERFL_DEF))) /* PRQA S 2814 # JV-01 */ { /* Check Error Interrupt enable Flag */ #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) if (CAN_RSCAN_GCTR_DEIE_EN != (Can_GaaRegs[CAN_PHYIDX_UNIT0].pCmn->ulGCTR & CAN_RSCAN_GCTR_DEIE_EN)) { /* No action required */ } else #endif /* #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) */ { #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) LblIrqSrcFlag = CAN_TRUE; #endif /* #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) */ /* Clear the global Interrupt Request Flag */ Can_GaaRegs[CAN_PHYIDX_UNIT0].pCmn->ulGERFL = CAN_RSCAN_GERFL_CLEAR; /* Getting ICOM controller Id */ LucController = Can_GucIcomActivatedCtrId; /* Getting ICOM configuration Id */ LddIcomConfigurationId = Can_GucIcomActivatedConfigId; /* Invoke call-out function for Payload length error handling */ CAN_ICOM_CALLOUT_FUNCTION(LucController, LddIcomConfigurationId); } } /* else No action required */ #endif /* #if ((CAN_PUBLIC_ICOM_SUPPORT == STD_ON) && (CAN_ICOM_PAYLOAD_LENGTH_ERROR_SUPPORT == STD_ON)) */ / * Safety requirement for Unintended interrupt check * / #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) if (CAN_FALSE == LblIrqSrcFlag) { /* Report to DEM */ CAN_DEM_REPORT_ERROR(CAN_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } /* else No action required */ #endif /* #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '-', 'Name': 'CAN_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': '-', 'Name': 'CAN_RSCAN0_RXFIFO_INTERRUPT', 'Value': 'defined'], 'Input_Param_002': ['Type': 'Macro', 'Range': '-', 'Name': 'Os_CAN_GLOBAL_CAT2_ISR', 'Value': 'Not define'], 'Input_Param_003': ['Type': 'Macro', 'Range': '-', 'Name': 'CAN_UNINTENDED_INTERRUPT_CHECK', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_ICOM_CALLOUT_FUNCTION', 'Value': 'defined'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblIcomStatus', 'Value': 'CAN_ICOM_DEACTIVATION'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GucIcomActivatedCtrId', 'Value': '0x00'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GucIcomActivatedConfigId', 'Value': '0x01'], 'Input_Param_010': ['Type': 'Array', 'Range': '-', 'Name': 'aaRFCC[0 to 7]', 'Value': '[0 to 7] = 2'], 'Input_Param_011': ['Type': 'Array', 'Range': '-', 'Name': 'aaRFSTS[0 to 7]', 'Value': '[0 to 7] = 8'], 'Input_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'ulGERFL', 'Value': 'CAN_RSCAN_GERFL_DEF'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'ulGCTR', 'Value': '~CAN_RSCAN_GCTR_DEIE_EN']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '0x00100000'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': 'CAN_CHECK_INT_RX'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': 'CAN_MAINFUNCTION_INSTANCE_0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucUnit', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'IcomConfigurationId', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulGERFL', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PUBLIC_CODE) Can_Init(P2CONST(Can_ConfigType, AUTOMATIC, CAN_APPL_DATA) Config) /* PRQA S 1503, 3432 # JV-01, JV-01 */ { VAR(uint8, AUTOMATIC) LucIndex; VAR(boolean, AUTOMATIC) LblErrFlag; #if (CAN_ACCESS_HW_ENABLE == STD_ON) VAR(uint32, AUTOMATIC) LulCount; VAR(uint32, AUTOMATIC) LulTimeoutDuration; VAR(Std_ReturnType, AUTOMATIC) LucTimeoutResult; P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ #endif #if ((CAN_TX_BUFFER == STD_ON) || (CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) VAR(uint16, AUTOMATIC) LusHohIndex; #endif #if ((CAN_DEV_ERROR_DETECT == STD_ON) && (CAN_ACCESS_HW_ENABLE == STD_ON)) P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ #endif LblErrFlag = CAN_FALSE; #if (CAN_DEV_ERROR_DETECT == STD_ON) #if (CAN_ALREADY_INIT_DET_CHECK == STD_ON) /* Report to DET, if module is initialized */ if (CAN_TRUE == Can_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_INIT_SID, CAN_E_TRANSITION); /* Set the error status flag to true */ LblErrFlag = CAN_TRUE; } else #endif /* Report to DET, if Configure pointer is equal to Null */ if (NULL_PTR == Config) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_INIT_SID, CAN_E_PARAM_POINTER); /* Set the error status flag to true */ LblErrFlag = CAN_TRUE; } /* Report to DET, if database is not valid */ else if ((uint32)CAN_DBTOC_VALUE != Config->ulStartOfDbToc) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_INIT_SID, CAN_E_INVALID_DATABASE); /* Set the error status flag to true */ LblErrFlag = CAN_TRUE; } else { /* If hw access permission is enable */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) LpPCController = (P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA))Config->pControllerPCConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ for (LucIndex = 0U; (LucIndex < Config->ucNoOfControllers) && (CAN_FALSE == LblErrFlag); LucIndex++) { /* report Det if channels are not in uninitialized state */ if (CAN_T_UNINIT != (Can_GaaRegs[LpPCController[LucIndex].ucUnit].pCmn->aaChReg[LpPCController[LucIndex].ucCh] /* PRQA S 2814, 2824, 2844 # JV-01, JV-01, JV-01 */ .ulSTS)) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_INIT_SID, CAN_E_TRANSITION); /* Set the error status flag to true */ LblErrFlag = CAN_TRUE; } /* else No action required */ } #endif /* #if (CAN_ACCESS_HW_ENABLE == STD_ON) */ } /* Check whether any development error occurred */ if (CAN_FALSE == LblErrFlag) #endif /*#if (CAN_DEV_ERROR_DETECT == STD_ON) */ { // /** INITIALIZE GLOBAL VARIABLES **/ // /* Get pointers to configuration tables */ Can_GpConfig = Config; Can_GpPCController = (P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA))Config->pControllerPCConfig; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ Can_GpPBController = (P2CONST(Can_ControllerPBConfigType, AUTOMATIC, CAN_CONFIG_DATA))Config->pControllerPBConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ Can_GpHohConfig = (P2CONST(Can_HohConfigType, AUTOMATIC, CAN_CONFIG_DATA))Config->pHohConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ // /** INITIALIZATION OF RSCANn MODULES **/ // for (LucIndex = 0U; (LucIndex < Config->ucNoOfUnits) && (CAN_FALSE == LblErrFlag); LucIndex++) { #if (CAN_WAKEUP_SUPPORT == STD_ON) /* Initialize variables to handle the global stop */ Can_GaaActiveControllers[LucIndex] = 0UL; /* PRQA S 2844 # JV-01 */ Can_GaaGlobalStateTransition[LucIndex] = CAN_FALSE; /* PRQA S 2844 # JV-01 */ #endif #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) /* Initialize Global interruption disable count */ Can_GaaGlobalIntCount[LucIndex] = 0UL; /* PRQA S 2844 # JV-01 */ #endif /* If hw access permission is enable */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) /* Initialize module and enter GLOBAL_RESET mode */ LblErrFlag = Can_InitModule(LucIndex); #endif } // /** INITIALIZATION OF GLOBAL CAN TIME SYNC CAPTURE **/ // #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) if (CAN_FALSE == LblErrFlag) { /* If hw access permission is enable */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) LblErrFlag = Can_TSCapUnitInit(Config->ucNoOfUnits); #endif } else { /* Do nothing */ } #endif // /** INITIALIZATION OF CONTROLLERS **/ // for (LucIndex = 0U; (LucIndex < Config->ucNoOfControllers) && (CAN_FALSE == LblErrFlag); LucIndex++) { /* Initialize status variables */ Can_GaaCtrlState[LucIndex].enMode = CAN_COMMON_STATE_STOPPED; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucIndex].enSubState = CAN_NO_PENDING_TRANSITION; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucIndex].blBusOff = CAN_FALSE; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucIndex].ulBaudrateIndex = 0U; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucIndex].ulIntCount = 0U; /* PRQA S 2844 # JV-01 */ #if (CAN_WAKEUP_SUPPORT == STD_ON) Can_GaaCtrlState[LucIndex].blWakeupEventOccurred = CAN_FALSE; /* PRQA S 2844 # JV-01 */ #endif if (CAN_TRUE == Can_GpPCController[LucIndex].blActivation) { #if (CAN_ACCESS_HW_ENABLE == STD_ON) /* Initialize Controller and enter CHANNEL_RESET mode */ LblErrFlag = Can_InitController(LucIndex); #endif } /* else No action required */ } // /** INITIALIZATION OF Can_GaaHwAccessFlag **/ // #if ((CAN_TX_BUFFER == STD_ON) || (CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) for (LusHohIndex = 0U; (LusHohIndex < CAN_NO_OF_HOHS); LusHohIndex++) { /* Clear flags which indicates HOH is being accessed by a Can_Write */ Can_GaaHwAccessFlag[LusHohIndex] = CAN_FALSE; } #endif // /** INITIALIZATION TRANSMISSION BUFFER INTERRUPTION ENABLE/DISABLE **/ /** AND ENTER GLOBAL_OPERATING MODE **/ // #if (CAN_ACCESS_HW_ENABLE == STD_ON) for (LucIndex = 0U; (LucIndex < Config->ucNoOfUnits) && (CAN_FALSE == LblErrFlag); LucIndex++) { /* Get PBConfig data for this RSCAN(FD) unit */ LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA))Config->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpHWInfo = &LpHWInfo[LucIndex]; /* PRQA S 2824 # JV-01 */ /* Initialize transmission buffer interruption enable/disable */ for (LulCount = 0UL; LulCount < (uint32)LpHWInfo->ucNoOfTMIEC; LulCount++) /* PRQA S 2814 # JV-01 */ { Can_GaaRegs[LucIndex].pCmn->aaTMIEC[LulCount] = LpHWInfo->pTMIEC[LulCount]; /* PRQA S 2814, 2824, 2844 # JV-01, JV-01, JV-01 */ } /* Change to GLOBAL_OPERATING mode */ LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucTimeoutResult = Can_GlobalModeChange(LucIndex, CAN_RSCAN_GMDC_OP, &LulTimeoutDuration); /* If mode changed was not finished, report error */ if (E_OK != LucTimeoutResult) { #if defined(CAN_E_TIMEOUT_FAILURE) CAN_DEM_REPORT_ERROR(CAN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif LblErrFlag = CAN_TRUE; } /* else No action required */ } #endif /* If no error occurred, set the CAN status as initialized */ if (CAN_FALSE == LblErrFlag) { Can_SetStatus(CAN_TRUE); /* SWS_Can_00497: Setting ICOM status as deactivation */ #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) Can_GblIcomStatus = CAN_ICOM_DEACTIVATION; #endif } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_DEV_ERROR_DETECT\\nCAN_ALREADY_INIT_DET_CHECK\\nCAN_E_TIMEOUT_FAILURE', 'Value': 'STD_ON\\nSTD_ON\\nDefined'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_WAKEUP_SUPPORT\\nCAN_RSCAN0_RXFIFO_INTERRUPT\\nCAN_RSCAN1_RXFIFO_INTERRUPT', 'Value': 'STD_ON (U2Ax)\\nSTD_ON / STD_ON\\nSTD_OFF /STD_ON\\n'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'CAN_TRUE/CAN_FALSE', 'Name': 'Can_GblInitialized', 'Value': 'CAN_FALSE'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'Config', 'Value': '&map_Config[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'CAN_DBTOC_VALUE/!CAN_DBTOC_VALUE', 'Name': 'ulStartOfDbToc', 'Value': 'CAN_DBTOC_VALUE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '1..2', 'Name': 'ucNoOfUnits', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '1..CAN_MAX_NUMBER_OF_CONTROLLER', 'Name': 'ucNoOfControllers', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'pControllerPCConfig', 'Value': '&map_pControllerPCConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'pControllerPBConfig', 'Value': '&map_pControllerPBConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'pHohConfig', 'Value': '&map_pHohConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfTMIEC', 'Value': '1'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pTMIEC', 'Value': '&map_pTMIEC[0]'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_pTMIEC[0 to 15]', 'Value': '[0] = 0xFFFFF0FF'], 'Input_Param_014': ['Type': 'Array', 'Range': 'CAN_TRUE/CAN_FALSE', 'Name': 'blActivation', 'Value': '[0] = CAN_TRUE'], 'Input_Param_015': ['Type': 'Array', 'Range': '0', 'Name': 'ucUnit', 'Value': '[0] = 0'], 'Input_Param_016': ['Type': 'Array', 'Range': '0', 'Name': 'ucCh', 'Value': '[0] = 0'], 'Input_Param_017': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'CAN_T_UNINIT/!CAN_T_UNINIT', 'Name': 'aaChReg[0].ulSTS', 'Value': 'CAN_T_UNINIT'], 'Input_Param_020': ['Type': 'Return_Value_of', 'Range': 'CAN_TRUE/CAN_FALSE', 'Name': 'return', 'Value': 'CAN_FALSE'], 'Input_Param_021': ['Type': 'Return_Value_of', 'Range': 'CAN_TRUE/CAN_FALSE', 'Name': 'return', 'Value': 'CAN_FALSE'], 'Input_Param_022': ['Type': 'Return_Value_of', 'Range': 'CAN_TRUE/CAN_FALSE', 'Name': 'return', 'Value': 'CAN_FALSE'], 'Input_Param_023': ['Type': 'Return_Value_of', 'Range': 'E_OK / E_NOT_OK', 'Name': 'return', 'Value': 'E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LucNoOfUnits', 'Value': '1'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_GMDC_OP'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '-', 'Name': '*LpTimeoutDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_010': ['Type': 'Error', 'Range': '-', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Error', 'Range': '-', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Error', 'Range': '-', 'Name': 'EventId', 'Value': 'CAN_E_TIMEOUT_FAILURE'], 'Output_Param_013': ['Type': 'Error', 'Range': '-', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LblStatus', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GpConfig', 'Value': '&map_Config[0]'], 'Output_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GpPCController', 'Value': '&map_pControllerPCConfig[0]'], 'Output_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GpPBController', 'Value': '&map_pControllerPBConfig[0]'], 'Output_Param_018': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GpHohConfig', 'Value': '&map_pHohConfig[0]'], 'Output_Param_019': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GblIcomStatus', 'Value': '-'], 'Output_Param_020': ['Type': 'Array', 'Range': '-', 'Name': 'Can_GaaActiveControllers[0 to 1]', 'Value': '[0] = 0'], 'Output_Param_021': ['Type': 'Array', 'Range': '-', 'Name': 'Can_GaaGlobalStateTransition[0 to 1]', 'Value': '[0] = CAN_FALSE'], 'Output_Param_022': ['Type': 'Variable', 'Range': '-', 'Name': 'Can_GaaGlobalIntCount[0]', 'Value': '0'], 'Output_Param_023': ['Type': 'Array', 'Range': '-', 'Name': 'enMode', 'Value': '[0] = CAN_COMMON_STATE_STOPPED'], 'Output_Param_024': ['Type': 'Array', 'Range': '-', 'Name': 'enSubState', 'Value': '[0] = CAN_NO_PENDING_TRANSITION'], 'Output_Param_025': ['Type': 'Array', 'Range': '-', 'Name': 'blBusOff', 'Value': '[0] = CAN_FALSE'], 'Output_Param_026': ['Type': 'Array', 'Range': '-', 'Name': 'ulBaudrateIndex', 'Value': '[0] = 0'], 'Output_Param_027': ['Type': 'Array', 'Range': '-', 'Name': 'ulIntCount', 'Value': '[0] = 0'], 'Output_Param_028': ['Type': 'Array', 'Range': '-', 'Name': 'blWakeupEventOccurred', 'Value': '[0] = CAN_FALSE'], 'Output_Param_029': ['Type': 'Array', 'Range': '', 'Name': 'Can_GaaHwAccessFlag[0 to CAN_NO_OF_HOHS]', 'Value': '[0 to 39] = CAN_FALSE'], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'aaTMIEC[0 to 15]', 'Value': '[0] = 0xFFFFF0FF'], 'Output_Param_031': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (CAN_ACCESS_HW_ENABLE == STD_ON) STATIC FUNC(boolean, CAN_PRIVATE_CODE) Can_InitController(CONST(uint8, AUTOMATIC) LucCtrlIndex) { VAR(boolean, AUTOMATIC) LblErrFlag; VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; VAR(uint16, AUTOMATIC) LusHohIndex; P2CONST(Can_HohConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpHoh; /* PRQA S 3432 # JV-01 */ P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ P2CONST(Can_ControllerPBConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPBController; /* PRQA S 3432 # JV-01 */ P2CONST(Can_BaudrateConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpBaudrateConfig; /* PRQA S 3432 # JV-01 */ uint32 LulTimeoutDuration; Std_ReturnType LucTimeoutResult; #if ((CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) uint32 LulTxQCh; uint32 LulTxQIdx; #endif /* Get pointer to configuration table */ LpPCController = &Can_GpPCController[LucCtrlIndex]; LpPBController = &Can_GpPBController[LucCtrlIndex]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LucCh = LpPCController->ucCh; #if (CAN_WAKEUP_SUPPORT == STD_ON) /* Since initial state is not SLEEP, set active flag */ Can_GaaActiveControllers[LucUnit] |= (1UL << LucCtrlIndex); /* PRQA S 2844 # JV-01 */ #endif // /** ENTER CHANNEL_RESET MODE **/ // LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucTimeoutResult = Can_ChannelModeChange(LucUnit, LucCh, CAN_RSCAN_CHMDC_RESET, &LulTimeoutDuration); if (E_OK != LucTimeoutResult) { #if defined(CAN_E_TIMEOUT_FAILURE) CAN_DEM_REPORT_ERROR(CAN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif LblErrFlag = CAN_TRUE; } else { // /** INITIALIZATION OF BAUDRATE **/ // LpBaudrateConfig = &LpPBController->pBaudrateConfig[CAN_DEFAULT_BAUDRATE_INDEX]; /* PRQA S 2814, 2824, 2844 # JV-01, JV-01, JV-01 */ /* Setting the value for nBTP into the nominal channel register */ Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulCFG = LpBaudrateConfig->ulCFG; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if ((CAN_RSCAN_CONFIGURED == STD_ON) && (CAN_RSCANFD_CONFIGURED == STD_ON)) if (CAN_MACRO_RSCANFD == Can_GaaRegs[LucUnit].enMacroType) #endif { #if (CAN_RSCANFD_CONFIGURED == STD_ON) /* Configuring FDCFG register*/ Can_GaaRegs[LucUnit].pFD->aaFDChReg[LucCh].ulFDCFG = LpBaudrateConfig->ulFDCFG; /* Setting the value for dBTP into the register */ Can_GaaRegs[LucUnit].pFD->aaFDChReg[LucCh].ulDCFG = LpBaudrateConfig->ulDCFG; #endif } /* else No action required */ // /** INITIALIZATION OF HTHHRH BUFFERS **/ // for (LusHohIndex = 0U; LusHohIndex < Can_GpConfig->usNoOfHohs; LusHohIndex++) { LpHoh = &Can_GpHohConfig[LusHohIndex]; if (LpHoh->ucController == LucCtrlIndex) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { switch (LpHoh->enBufferType) { #if ((CAN_TX_BUFFER == STD_ON) || (CAN_RX_BUFFER == STD_ON)) case CAN_BUFFERTYPE_BUFFER: /* Nothing is required */ break; #endif #if (CAN_RX_FIFO == STD_ON) case CAN_BUFFERTYPE_RXFIFO: Can_GaaRegs[LucUnit].pCmn->aaRFCC[LpHoh->usBufferIndex] = LpHoh->ulXXCCRegValue; break; #endif #if ((CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) case CAN_BUFFERTYPE_TXQUEUE: LulTxQCh = (uint32)LpHoh->usBufferIndex / CAN_RSCAN_TXQUEUE_PER_CH; LulTxQIdx = (uint32)LpHoh->usBufferIndex % CAN_RSCAN_TXQUEUE_PER_CH; Can_GaaRegs[LucUnit].pCmn->aaTQueueReg[LulTxQIdx].aaTXQCC[LulTxQCh] = LpHoh->ulXXCCRegValue; break; #endif default: /* PRQA S 2016 # JV-01 */ #if ((CAN_RX_COMFIFO == STD_ON) || (CAN_TX_COMFIFO == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON)) Can_GaaRegs[LucUnit].pCmn->aaCFCC[LpHoh->usBufferIndex] = LpHoh->ulXXCCRegValue; #ifdef CAN_COMFIFO_ENHANCEMENT_SUPPORT Can_GaaRegs[LucUnit].pCmn->aaCFCCE[LpHoh->usBufferIndex] = LpHoh->ulXXCCERegValue; #endif #endif break; } } /* else No action required */ } // /** SETTING OF TRANSMIT HISTORY BUFFER **/ // Can_GaaRegs[LucUnit].pCmn->aaTHLCC[LucCh] = LpPCController->ulTHLCC; // /** SETTING OF ERROR INTERRUPTS **/ // /* Disabling Interrupts in can controller control register*/ Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulCTR = LpPCController->ulCTR; // /** ENABLING OF INTERRUPTS **/ // #ifndef CAN_V4H_PROC #if (CAN_CR52_PROC == STD_ON) /* Enable interrupts */ RH850_SV_MODE_ICR_OR(32, LpPCController->pICErr, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_E << (LpPCController->ucCh * ((uint8)3))))); RH850_SV_MODE_ICR_OR(32, LpPCController->pICRec, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3))))); RH850_SV_MODE_ICR_OR(32, LpPCController->pICTx, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_T << (LpPCController->ucCh * ((uint8)3))))); #else /* Enable interrupts */ RH850_SV_MODE_ICR_AND(8, LpPCController->pICErr, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_AND(8, LpPCController->pICRec, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_AND(8, LpPCController->pICTx, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751, 2814 # JV-01, JV-01 */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, LpPCController->pICTx); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif #endif /* #ifndef CAN_V4H_PROC */ LblErrFlag = CAN_FALSE; } return LblErrFlag; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_WAKEUP_SUPPORT\\nCAN_E_TIMEOUT_FAILURE\\nCAN_RSCAN_CONFIGURED\\nCAN_RSCANFD_CONFIGURED', 'Value': 'STD_ON(U2x)\\ndefined\\nSTD_OFF\\nSTD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucCtrlIndex', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfHohs', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulTHLCC', 'Value': '0x0FFFFFFF'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulCTR', 'Value': '0xF0FFFFF9'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pICErr', 'Value': '&map_pICErr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pICRec', 'Value': '&map_pICRec[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pICTx', 'Value': '&map_pICTx[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICErr[0]', 'Value': 'CAN_EIC_EIMK_MASK'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRec[0]', 'Value': 'CAN_EIC_EIMK_MASK'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICTx[0]', 'Value': 'CAN_EIC_EIMK_MASK'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPBController', 'Value': '&map_Can_GpPBController[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pBaudrateConfig', 'Value': '&map_pBaudrateConfig[0]'], 'Input_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'ulCFG', 'Value': '0xFF0FFFFF'], 'Input_Param_018': ['Type': 'Register', 'Range': '', 'Name': 'ulFDCFG', 'Value': '0xFFF0FFFF'], 'Input_Param_019': ['Type': 'Register', 'Range': '', 'Name': 'ulDCFG', 'Value': '0xFFFF0FFF'], 'Input_Param_020': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'enMacroType', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'pFD', 'Value': '&map_pFD[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpHohConfig', 'Value': '&map_Can_GpHohConfig[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'enBufferType', 'Value': 'CAN_BUFFERTYPE_BUFFER'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ucController', 'Value': '1'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'usBufferIndex', 'Value': '0'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulXXCCRegValue', 'Value': '0xFFFFF0FF'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulXXCCERegValue', 'Value': '-'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GaaActiveControllers[0]', 'Value': '0'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GaaActiveControllers[1]', 'Value': '0'], 'Input_Param_032': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCh', 'Value': '0'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_CHMDC_RESET'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Can_GaaActiveControllers[0 to 1]', 'Value': '[0] = 1UL'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'aaChReg[0].ulCFG', 'Value': '0xFF0FFFFF'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'aaFDChReg[0].ulFDCFG', 'Value': '0xFFF0FFFF'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'aaFDChReg[0].ulDCFG', 'Value': '0xFFFF0FFF'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'aaRFCC[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'aaTQueueReg[0].aaTXQCC[0]', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFCC[0]', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'aaTHLCC[0]', 'Value': '0x0FFFFFFF'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFCCE[0]', 'Value': '-'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'aaTMIEC[0 to 1]', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'aaChReg[0].ulCTR', 'Value': '0xF0FFFFF9'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICErr[0]', 'Value': '0'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRec[0]', 'Value': '0'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICTx[0]', 'Value': '0'], 'Output_Param_022': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblErrFlag', 'Value': 'CAN_FALSE'], 'Output_Param_023': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (CAN_ACCESS_HW_ENABLE == STD_ON) STATIC FUNC(boolean, CAN_PRIVATE_CODE) Can_InitModule(CONST(uint8, AUTOMATIC) LucUnit) { VAR(boolean, AUTOMATIC) LblErrFlag; VAR(uint32, AUTOMATIC) LulTimeoutDuration; VAR(Std_ReturnType, AUTOMATIC) LucTimeoutResult; P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulCount; #if ((CAN_RX_OBJECT == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) P2CONST(Can_FilterType, AUTOMATIC, CAN_CONFIG_DATA) LpFilter; /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulRulePage; VAR(uint32, AUTOMATIC) LulRuleIndex; #endif /* Get PBConfig data for this RSCAN(FD) unit */ LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA))Can_GpConfig->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpHWInfo = &LpHWInfo[LucUnit]; /* PRQA S 2824 # JV-01 */ /* Wait until GRAMINIT flag is set */ LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucTimeoutResult = Can_WaitRegisterChange(&Can_GaaRegs[LucUnit].pCmn->ulGSTS, /* PRQA S 2814, 2844 # JV-01, JV-01 */ CAN_RSCAN_GRAMINIT, 0UL, &LulTimeoutDuration); /* If GRAMINIT flag was not set, report error */ if (E_OK != LucTimeoutResult) { #if defined(CAN_E_TIMEOUT_FAILURE) CAN_DEM_REPORT_ERROR(CAN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif LblErrFlag = CAN_TRUE; } else { // /** ENTER GLOBAL_RESET MODE **/ // /* Change to GLOBAL_RESET mode */ LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucTimeoutResult = Can_GlobalModeChange(LucUnit, CAN_RSCAN_GMDC_RESET, &LulTimeoutDuration); /* If mode changed was not finished, report error */ if (E_OK != LucTimeoutResult) { #if defined(CAN_E_TIMEOUT_FAILURE) CAN_DEM_REPORT_ERROR(CAN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif LblErrFlag = CAN_TRUE; } else { #if ((CAN_RSCAN_CONFIGURED == STD_ON) && (CAN_RSCANFD_CONFIGURED == STD_ON)) if (CAN_MACRO_RSCANFD == Can_GaaRegs[LucUnit].enMacroType) #endif { #if (CAN_RSCANFD_CONFIGURED == STD_ON) #if (CAN_INTERFACE_MODE_SELECTION_LOCATION == CAN_GRMCFG_REG) /* Set RCMC bit to activate RSCANFD with CANFD mode */ Can_GaaRegs[LucUnit].pCmn->ulGRMCFG = CAN_RSCAN_RCMC; #endif /* Fix TSCCFG=0 and RPED=0, these functions are not used in MCAL */ Can_GaaRegs[LucUnit].pCmn->ulGFDCFG = CAN_RSCAN_GFDCFG_DEFAULT; #endif } /* else No action required */ // /** INITIALIZATION OF BUFFER SETTINGS **/ // /* Set payload size and buffer number of RxBuffer */ Can_GaaRegs[LucUnit].pCmn->ulRMNB = LpHWInfo->ulRMNB; /* PRQA S 2814 # JV-01 */ /* Set the value of global configuration register */ Can_GaaRegs[LucUnit].pCmn->ulGCFG = LpHWInfo->ulGCFG; // /** INITIALIZATION OF ACCEPTANCE FILTER LIST **/ // /* Set number of receive rules */ for (LulCount = 0U; LulCount < (uint32)LpHWInfo->ucNoOfGAFLCFG; LulCount++) { Can_GaaRegs[LucUnit].pCmn->aaGAFLCFG[LulCount] = LpHWInfo->pGAFLCFG[LulCount]; /* PRQA S 2824 # JV-01 */ } #if ((CAN_RX_OBJECT == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) LulCount = 0U; LulRulePage = 0U; /* Set all receive rules to the receive filter registers */ while (LulCount < (uint32)LpHWInfo->usNoOfFilters) { /* Set page index for each 16 rules */ Can_GaaRegs[LucUnit].pCmn->ulGAFLECTR = CAN_RSCAN_AFLDAE | CAN_RSCAN_AFLPN(LulRulePage); /* PRQA S 3469 # JV-01 */ LulRuleIndex = 0U; /* Set up to 16 rules to the receive filter registers in this page */ while (((uint32)CAN_RSCAN_RULES_PER_PAGE > LulRuleIndex) && (LulCount < (uint32)LpHWInfo->usNoOfFilters)) { LpFilter = &LpHWInfo->pFilterConfig[LulCount]; /* PRQA S 2824 # JV-01 */ Can_GaaRegs[LucUnit].pRR[LulRuleIndex].ulGAFLID = LpFilter->ulGAFLID; /* PRQA S 2814, 2824 # JV-01, JV-01 */ Can_GaaRegs[LucUnit].pRR[LulRuleIndex].ulGAFLM = LpFilter->ulGAFLM; Can_GaaRegs[LucUnit].pRR[LulRuleIndex].aaGAFLP[CAN_RSCAN_GAFLP_PAGE0] = LpFilter->aaGAFLP[CAN_RSCAN_GAFLP_PAGE0]; Can_GaaRegs[LucUnit].pRR[LulRuleIndex].aaGAFLP[CAN_RSCAN_GAFLP_PAGE1] = LpFilter->aaGAFLP[CAN_RSCAN_GAFLP_PAGE1]; LulRuleIndex++; LulCount++; } /* Increment page */ LulRulePage++; /* PRQA S 3383 # JV-01 */ } /* Write disabling the Acceptance Filter List*/ Can_GaaRegs[LucUnit].pCmn->ulGAFLECTR = CAN_RSCAN_AFLDAE_OFF; // /** INITIALIZATION OF GLOBAL INTERRUPTION **/ // #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) /* Enable RxFIFO interrupt */ #ifndef CAN_V4H_PROC #if (CAN_CR52_PROC == STD_ON) RH850_SV_MODE_ICR_OR(32, Can_GaaRegs[LucUnit].pICRxFIFO, CAN_EIC_EIMK_MASK); /* PRQA S 0310, 3305 # JV-01, JV-01 */ #else RH850_SV_MODE_ICR_AND(8, Can_GaaRegs[LucUnit].pICRxFIFO, (uint8)(~CAN_EIC_EIMK_MASK)); /* PRQA S 0751 # JV-01 */ #endif /* CAN_CR52_PROC */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Can_GaaRegs[LucUnit].pICRxFIFO); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif /* #ifndef CAN_V4H_PROC */ #endif /* #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) */ #endif /* #if ((CAN_RX_OBJECT == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON)) */ / * INITIALIZATION OF GLOBAL VIRTUAL MACHINE * / #if (CAN_VIRTUAL_MACHINE_ENABLE == STD_ON) if(CAN_TRUE == LpHWInfo->blFFIModeEnable) { /* Enable FFI mode for VM ISR */ Can_GaaRegs[LucUnit].pCmn->ulGFFIMC = (uint32)(CAN_CFDGFFIMC_FFIEN | CAN_CFDGFFIMC_KEY); /* Setting target Virtual Manchien channel for Rx FIFO */ Can_GaaRegs[LucUnit].pCmn->ulVMRFCFG = LpHWInfo->ulVMRFCFG; /* Setting target Virtual Manchine channel for TxFX FIFO and Tx Queue */ for (LulCount = 0UL; LulCount < CAN_MAX_NO_VM_CH; LulCount++) { Can_GaaRegs[LucUnit].pCmn->aaVMCFGn[LulCount] = LpHWInfo->pVMCFGn[LulCount]; /* PRQA S 2824 # JV-01 */ } } else { /* Disable FFI mode */ Can_GaaRegs[LucUnit].pCmn->ulGFFIMC = (uint32)CAN_CFDGFFIMC_KEY; /* Reset target Virtual Manchien channel for Rx FIFO */ Can_GaaRegs[LucUnit].pCmn->ulVMRFCFG = CAN_VMN_INVALID; /* Reset target Virtual Manchien channel for TxFX FIFO and Tx Queue */ for (LulCount = 0UL; LulCount < CAN_MAX_NO_VM_CH; LulCount++) { Can_GaaRegs[LucUnit].pCmn->aaVMCFGn[LulCount] = CAN_VMN_INVALID; } } / * INITIALIZATION OF GLOBAL VIRTUAL MACHINE INTERRUPTION * / if(CAN_TRUE == LpHWInfo->blFFIModeEnable) { / Enable Virtual Machine APPLINTMSKR11-RSCAN00/APPLINTMSKR12-RSCAN01 interrupt */ /* Tx and Rx interrupt */ RH850_SV_MODE_ICR_OR(32, Can_GaaRegs[LucUnit].pIn2AppTxRxVMInt, LpHWInfo->ulInt2AppVMIntMaskValue); / Setting interrupt register EIC / for (LulCount = 0UL; LulCount < CAN_MAX_NO_VM_CH; LulCount++) { /* Enable Virtual Machine EIC TX interrupt (EIC720-RSCAN00/EIC744-RSCAN01)*/ RH850_SV_MODE_ICR_AND(8, &Can_GaaRegs[LucUnit].pICTxVMInt[LulCount], /* PRQA S 0751, 3464 # JV-01, JV-01 */ /* shift to LulCount get channel mask respectively shift to 7 to get the interrup mask EIMKn */ (uint8)(~((((uint32)LpHWInfo->ucEicVMTxIntMaskValue >> LulCount) << 7UL) & CAN_EIC_EIMK_MASK))); /* Enable Virtual Machine EIC RX interrupt */ RH850_SV_MODE_ICR_AND(8, &Can_GaaRegs[LucUnit].pICRxVMInt[LulCount], /* PRQA S 0751, 3464 # JV-01, JV-01 */ /* shift to LulCount get channel mask respectively shift to 7 to get the interrup mask EIMKn */ (uint8)(~((((uint32)LpHWInfo->ucEicVMRxIntMaskValue >> LulCount) << 7UL) & CAN_EIC_EIMK_MASK))); } /* DummyRead & SYNCP for G4MH core only */ #if (CAN_CR52_PROC == STD_OFF) RH850_SV_MODE_REG_READ_ONLY(16, Can_GaaRegs[LucUnit].pICRxVMInt); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif /* #if (CAN_CR52_PROC == STD_ON) */ } /* else No action required */ #endif /* #if (CAN_VIRTUAL_MACHINE_ENABLE == STD_ON) */ / * INITIALIZATION OF ECC safety mechanism * / #ifdef CAN_V4H_PROC #if (CAN_ECC_ERROR_CORRECT == STD_ON) /* Set ECC control register */ /* + Set bit 15, 14 to 2B'01 (ECERVF write enable). + Set bit 6 to 1 (error judgement enabled). + Set bit 4 to 1 (2 bit error detection enabled). + Set bit 3 to 1 (1 bit error detection enabled). + Keep the initial value of bit 5 of EC710CTL to enable ECC. */ *Can_GaaRegs[LucUnit].pEC710CTLReg = CAN_RSCAN_EC710CTL_EN; #endif #endif LblErrFlag = CAN_FALSE; } } return LblErrFlag; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CAN_RX_OBJECT\\nCAN_GATEWAY_COMFIFO\\nCAN_GATEWAY_QUEUE\\nCAN_E_TIMEOUT_FAILURE', 'Value': 'STD_ON\\nSTD_ON\\nSTD_OFF(E2x)/ STD_ON(U2x)\\nDefined'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RSCAN_CONFIGURED\\nCAN_RSCANFD_CONFIGURED', 'Value': 'STD_OFF\\nSTD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RSCAN0_RXFIFO_INTERRUPT\\nCAN_RSCAN1_RXFIFO_INTERRUPT', 'Value': 'STD_ON\\nSTD_OFF(E2x)/STD_ON(U2x)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_VIRTUAL_MACHINE_ENABLE', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LucUnit', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulRMNB', 'Value': '0xFFFFFFF0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulGCFG', 'Value': '0xFFFFFF0F'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfGAFLCFG', 'Value': '1'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pGAFLCFG', 'Value': '&map_pGAFLCFG[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfFilters', 'Value': '1'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pFilterConfig', 'Value': '&map_pFilterConfig[0]'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_pGAFLCFG[0 to 3]', 'Value': '[0] = 0xFFFF0FFF'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ulGAFLID', 'Value': '[0 to 15] = 0x0FFFFFFF'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ulGAFLM', 'Value': '[0 to 15] = 0xF0FFFFFF'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'aaGAFLP[0 to 1]', 'Value': '[0 to 15][0] = 0xFF0FFFFF\\n[0 to 15][1] = 0xFFF0FFFF'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'pRR', 'Value': '&map_pRR[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'pICRxFIFO', 'Value': '&map_pICRxFIFO[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'enMacroType', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '0'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'blFFIModeEnable', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulVMRFCFG', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pVMCFGn', 'Value': '-'], 'Input_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'map_pVMCFGn[0 to 7]', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pICTxVMInt', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pICRxVMInt', 'Value': '-'], 'Input_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'map_pICTxVMInt[0 to 7]', 'Value': '-'], 'Input_Param_031': ['Type': 'Array', 'Range': '', 'Name': 'map_pICRxVMInt[0 to 7]', 'Value': '-'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ulInt2AppVMIntMaskValue', 'Value': '-'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'pIn2AppTxRxVMInt', 'Value': '-'], 'Input_Param_034': ['Type': 'Register', 'Range': '', 'Name': 'map_pIn2AppTxRxVMInt[0]', 'Value': '-'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'ucEicVMTxIntMaskValue', 'Value': '-'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'ucEicVMRxIntMaskValue', 'Value': '-'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'pEC710CTLReg', 'Value': '-'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEC710CTLReg[0]', 'Value': '-'], 'Input_Param_039': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_040': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpReg', 'Value': '&map_pCmn[0].ulGSTS'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CAN_RSCAN_GRAMINIT'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBits', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_GMDC_RESET'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CAN_E_TIMEOUT_FAILURE'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulGRMCFG', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulGFDCFG', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulRMNB', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulGCFG', 'Value': '-'], 'Output_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'aaGAFLCFG[0 to 3]', 'Value': '-'], 'Output_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'ulGAFLID', 'Value': '-'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ulGAFLM', 'Value': '-'], 'Output_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'aaGAFLP[0 to 1]', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulGAFLECTR', 'Value': '-'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulGFFIMC', 'Value': '-'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulVMRFCFG', 'Value': '-'], 'Output_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'aaVMCFGn[0 to 7]', 'Value': '-'], 'Output_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'map_pICTxVMInt[0 to 7]', 'Value': '-'], 'Output_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'map_pICRxVMInt[0 to 7]', 'Value': '-'], 'Output_Param_026': ['Type': 'Register', 'Range': '', 'Name': 'map_pIn2AppTxRxVMInt[0]', 'Value': '-'], 'Output_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEC710CTLReg[0]', 'Value': '-'], 'Output_Param_028': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblErrFlag', 'Value': 'CAN_TRUE'], 'Output_Param_029': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON) || \\ (CAN_PUBLIC_ICOM_SUPPORT == STD_ON)) STATIC FUNC(void, CAN_CODE_FAST) Can_RxGlobalIsr(CONST(uint8, AUTOMATIC) LucUnit) { #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) VAR(uint32, AUTOMATIC) LulRxFIFOIndex; VAR(uint32, AUTOMATIC) LulIrqExist; #endif #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) VAR(uint32, AUTOMATIC) LulWUFMask; P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ #endif #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) LulIrqExist = 0U; /* Accumurate all interrupt request flags of all RxFIFO */ for (LulRxFIFOIndex = 0UL; LulRxFIFOIndex < CAN_RSCAN_RXFIFO_PER_UNIT; LulRxFIFOIndex++) { /* if (RFCCk.RFIE && RFSTSk.RFIF), it means that irq exists */ LulIrqExist = LulIrqExist | (CAN_RSCAN_RFIE_GET(Can_GaaRegs[LucUnit].pCmn->aaRFCC[LulRxFIFOIndex]) & /* PRQA S 2814, 2844, 3469 # JV-01, JV-01, JV-01 */ CAN_RSCAN_RFIF_GET(Can_GaaRegs[LucUnit].pCmn->aaRFSTS[LulRxFIFOIndex])); /* PRQA S 3469 # JV-01 */ } /* If no irq from RS-CAN or EIC is masked, this interrupt is wrong */ #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) if((0UL == LulIrqExist) || \\ ((RH850_SV_MODE_REG_READ_ONLY(32, Can_GaaRegs[LucUnit].pICRxFIFO) & CAN_EIC_EIRF_MASK) != CAN_EIC_EIRF_MASK)) /* PRQA S 0310, 3305 # JV-01, JV-01 */ { CAN_DEM_REPORT_ERROR(CAN_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } #endif #if (CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((uint16)(*Can_GaaRegs[LucUnit].pICRxFIFO & (CAN_EIC_EIMK_MASK | CAN_EIC_EIRF_MASK)) != CAN_EIC_EIRF_MASK)) { CAN_DEM_REPORT_ERROR(CAN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } #endif else #endif /* End of #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) */ { #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA))Can_GpConfig->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpHWInfo = &LpHWInfo[LucUnit]; /* PRQA S 2824 # JV-01 */ LulWUFMask = LpHWInfo->ulRxFIFOWUFMask; /* PRQA S 2814 # JV-01 */ if (LulWUFMask == (uint32)(*Can_GaaRegs[LucUnit].pWUF0Reg & LulWUFMask)) { *Can_GaaRegs[LucUnit].pWUFC0Reg = LulWUFMask; } /* else No action required */ #endif #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) /* If PN is supported and deactivated */ if (CAN_ICOM_DEACTIVATION == Can_GblIcomStatus) /* PRQA S 3416 # JV-01 */ #endif { #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || \\ (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) /* Invoke Can_RxProcessing internal function for receive processing */ Can_RxProcessing(CAN_RXPROC_RXFIFO(LucUnit), CAN_CHECK_INT_RX, CAN_MAINFUNCTION_INSTANCE_0 /* PRQA S 3469 # JV-01 */ #if(CAN_VIRTUAL_MACHINE_ENABLE == STD_ON) , CAN_VM_INVALID #endif ); #endif /* #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || \\ (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) */ } #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) else /* PN is activated */ { Can_IcomRxProcessing(LucUnit); } #endif /* #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) */ /* DummyRead & SYNCP */ RH850_SET_IOREG_SYNCP(32, &Can_GaaRegs[LucUnit].pCmn->ulGSTS, 0UL); /* PRQA S 1006, 2814, 2844, 3464 # JV-01, JV-01, JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RSCANn_RXFIFO_INTERRUPT\\n(n = 0 to 1) ', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_WAKE_UP_FACTOR_CLEAR_ISR', 'Value': 'STD_ON(U2x)\\nSTD_OFF(E2x)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_VIRTUAL_MACHINE_ENABLE', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LucUnit', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblIcomStatus', 'Value': '(boolean)0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxFIFOWUFMask', 'Value': '0x00000008'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..1', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0..1', 'Name': 'pICRxFIFO', 'Value': '&map_pICRxFIFO[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0..1', 'Name': 'pWUF0Reg', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0..1', 'Name': 'pWUFC0Reg', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'aaRFCC[0 to 7]', 'Value': '[0 to 7]=0x00000002'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'aaRFSTS[0 to 7]', 'Value': '[0 to 7]=0x00000008'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '0'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRxFIFO[0]', 'Value': 'CAN_EIC_EIRF_MASK'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUF0Reg[0]', 'Value': '0x00000007'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUFC0Reg[0]', 'Value': '0x00000008']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucVMChannel', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '0x00100000UL << 0'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': 'CAN_CHECK_INT_RX'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': 'CAN_MAINFUNCTION_INSTANCE_0'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucUnit', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUFC0Reg[0]', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '0'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON) || \\ (CAN_PUBLIC_ICOM_SUPPORT == STD_ON)) STATIC FUNC(void, CAN_CODE_FAST) Can_RxGlobalIsr(CONST(uint8, AUTOMATIC) LucUnit) { #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) VAR(uint32, AUTOMATIC) LulRxFIFOIndex; VAR(uint32, AUTOMATIC) LulIrqExist; #endif #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) VAR(uint32, AUTOMATIC) LulWUFMask; P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ #endif #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) LulIrqExist = 0U; /* Accumurate all interrupt request flags of all RxFIFO */ for (LulRxFIFOIndex = 0UL; LulRxFIFOIndex < CAN_RSCAN_RXFIFO_PER_UNIT; LulRxFIFOIndex++) { /* if (RFCCk.RFIE && RFSTSk.RFIF), it means that irq exists */ LulIrqExist = LulIrqExist | (CAN_RSCAN_RFIE_GET(Can_GaaRegs[LucUnit].pCmn->aaRFCC[LulRxFIFOIndex]) & /* PRQA S 2814, 2844, 3469 # JV-01, JV-01, JV-01 */ CAN_RSCAN_RFIF_GET(Can_GaaRegs[LucUnit].pCmn->aaRFSTS[LulRxFIFOIndex])); /* PRQA S 3469 # JV-01 */ } /* If no irq from RS-CAN or EIC is masked, this interrupt is wrong */ #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) if((0UL == LulIrqExist) || \\ ((RH850_SV_MODE_REG_READ_ONLY(32, Can_GaaRegs[LucUnit].pICRxFIFO) & CAN_EIC_EIRF_MASK) != CAN_EIC_EIRF_MASK)) /* PRQA S 0310, 3305 # JV-01, JV-01 */ { CAN_DEM_REPORT_ERROR(CAN_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } #endif #if (CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((uint16)(*Can_GaaRegs[LucUnit].pICRxFIFO & (CAN_EIC_EIMK_MASK | CAN_EIC_EIRF_MASK)) != CAN_EIC_EIRF_MASK)) { CAN_DEM_REPORT_ERROR(CAN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } #endif else #endif /* End of #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) */ { #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA))Can_GpConfig->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpHWInfo = &LpHWInfo[LucUnit]; /* PRQA S 2824 # JV-01 */ LulWUFMask = LpHWInfo->ulRxFIFOWUFMask; /* PRQA S 2814 # JV-01 */ if (LulWUFMask == (uint32)(*Can_GaaRegs[LucUnit].pWUF0Reg & LulWUFMask)) { *Can_GaaRegs[LucUnit].pWUFC0Reg = LulWUFMask; } /* else No action required */ #endif #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) /* If PN is supported and deactivated */ if (CAN_ICOM_DEACTIVATION == Can_GblIcomStatus) /* PRQA S 3416 # JV-01 */ #endif { #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || \\ (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) /* Invoke Can_RxProcessing internal function for receive processing */ Can_RxProcessing(CAN_RXPROC_RXFIFO(LucUnit), CAN_CHECK_INT_RX, CAN_MAINFUNCTION_INSTANCE_0 /* PRQA S 3469 # JV-01 */ #if(CAN_VIRTUAL_MACHINE_ENABLE == STD_ON) , CAN_VM_INVALID #endif ); #endif /* #if ((CAN_RSCAN0_RXFIFO_INTERRUPT == STD_ON) || \\ (CAN_RSCAN1_RXFIFO_INTERRUPT == STD_ON)) */ } #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) else /* PN is activated */ { Can_IcomRxProcessing(LucUnit); } #endif /* #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) */ /* DummyRead & SYNCP */ RH850_SET_IOREG_SYNCP(32, &Can_GaaRegs[LucUnit].pCmn->ulGSTS, 0UL); /* PRQA S 1006, 2814, 2844, 3464 # JV-01, JV-01, JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RSCANn_RXFIFO_INTERRUPT\\n(n = 0 to 1) ', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_INTERRUPT_CONSISTENCY_CHECK', 'Value': '-'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_WAKE_UP_FACTOR_CLEAR_ISR', 'Value': '-'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_VIRTUAL_MACHINE_ENABLE', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LucUnit', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblIcomStatus', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxFIFOWUFMask', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..1', 'Name': 'pCmn', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0..1', 'Name': 'pICRxFIFO', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0..1', 'Name': 'pWUF0Reg', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0..1', 'Name': 'pWUFC0Reg', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'aaRFCC[0 to 7]', 'Value': '-'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'aaRFSTS[0 to 7]', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUF0Reg[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUFC0Reg[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucVMChannel', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucUnit', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUFC0Reg[0]', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRxFIFO[0]', 'Value': '-'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '-']]]"}
{"Input": "/ #if (CAN_RX_COMFIFO == STD_ON) STATIC FUNC(void, CAN_PRIVATE_CODE) Can_RxIndicationTxRxFIFO( CONSTP2CONST(Can_HohConfigType, AUTOMATIC, CAN_PRIVATE_CONST) LpHoh, CONST(uint8, AUTOMATIC) LucUnit) { P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpDataReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(uint32, AUTOMATIC) LulMessageDlc; VAR(uint32, AUTOMATIC) LulAvailableDlc; /* To optimize data copy operation, declare data array with uint32 */ VAR(uint32, AUTOMATIC) LaaCanSdu[CAN_LOCALBUFFER_SIZE_32]; VAR(uint32, AUTOMATIC) LulFDSts; VAR(uint32, AUTOMATIC) LulIDRegValue; VAR(uint32, AUTOMATIC) LulWordIndex; VAR(uint32, AUTOMATIC) LulDlcWords; VAR(uint8, AUTOMATIC) LucCFDCValue; VAR(uint8, AUTOMATIC) LucFifoBufferDepth; VAR(uint8, AUTOMATIC) LucCount; #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) VAR(uint32, AUTOMATIC) LulTSRAMOffset; #endif /* Clear interrupt request flag */ Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LpHoh->usBufferIndex] = (CAN_RSCAN_CLEAR_CFRXIF); /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Get Receive FIFO Buffer Depth Configuration value */ LucCFDCValue = (uint8)CAN_RSCAN_CFDC_GET(LpHoh->ulXXCCRegValue); /* PRQA S 3469 # JV-01 */ /* Get FIFO Buffer Depth value */ LucFifoBufferDepth = (uint8)CAN_RSCAN_FIFO_BUFFER_DEPTH_GET(LucCFDCValue); LucCount = 0U; /* Read TxRxFIFO until the FIFO becomes empty */ while ((0UL == (Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LpHoh->usBufferIndex] & CAN_RSCAN_CFEMP)) && (LucCount < LucFifoBufferDepth)) { #if ((CAN_DEV_ERROR_DETECT == STD_ON) || \\ (CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) /* Check lost message */ if (CAN_FIFO_MSG_LOST_MASK == ((Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LpHoh->usBufferIndex]) /* PRQA S 2814, 2844 # JV-01, JV-01 */ & CAN_FIFO_MSG_LOST_MASK)) { /* Clear transmit/receive FIFO message lost flag */ Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LpHoh->usBufferIndex] = (CAN_RSCAN_CLEAR_CFMLT); #if (CAN_AR_VERSION == CAN_AR_422_VERSION) /* Report to DET default error*/ (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_RXPROCESSING_SID, CAN_E_DATALOST); #elif ((CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) /* Report to DET runtime error*/ (void)Det_ReportRuntimeError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_RXPROCESSING_SID, CAN_E_DATALOST); #endif } /* else No action required */ #endif /* ((CAN_DEV_ERROR_DETECT == STD_ON) || */ /* (CAN_AR_VERSION == CAN_AR_431_VERSION) */ /* (CAN_AR_VERSION == CAN_AR_1911_VERSION)) */ #if ((CAN_RSCAN_CONFIGURED == STD_ON) && (CAN_RSCANFD_CONFIGURED == STD_ON)) if (CAN_MACRO_RSCANFD == Can_GaaRegs[LucUnit].enMacroType) #endif { #if (CAN_RSCANFD_CONFIGURED == STD_ON) /* Get status and data register address accroding to each buffer mode */ LulFDSts = Can_GaaRegs[LucUnit].pFD->aaCFReg[LpHoh->usBufferIndex].ulFDCSTS; LulIDRegValue = Can_GaaRegs[LucUnit].pFD->aaCFReg[LpHoh->usBufferIndex].ulFDCFID; LulMessageDlc = Can_GaaRegs[LucUnit].pFD->aaCFReg[LpHoh->usBufferIndex].ulFDCFPTR; #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) /* Get the offset address for TimeStampe ID register */ /* Reading CFDCFPTR.CFTS bits */ LulTSRAMOffset = (0x0000FFFFUL & LulMessageDlc); #endif LpDataReg = &Can_GaaRegs[LucUnit].pFD->aaCFReg[LpHoh->usBufferIndex].aaFDCFDF[0]; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Convert DLC value to actual byte length */ LulMessageDlc = (uint32)Can_GaaPayloadFromDLCTable[CAN_RSCAN_XXDLC_GET(LulMessageDlc)]; /* Read registers as the smaller one of message DLC or buffer DLC */ LulAvailableDlc = Can_GaaPayloadFromPLSTable[CAN_RSCAN_CFPLS_GET(LpHoh->ulXXCCRegValue)]; /* PRQA S 3469 # JV-01 */ if (LulAvailableDlc > LulMessageDlc) { LulAvailableDlc = LulMessageDlc; } /* else No action required */ #endif /* (CAN_RSCANFD_CONFIGURED == STD_ON) */ } #if ((CAN_RSCAN_CONFIGURED == STD_ON) && (CAN_RSCANFD_CONFIGURED == STD_ON)) else #endif { #if (CAN_RSCAN_CONFIGURED == STD_ON) LulFDSts = 0UL; LulIDRegValue = Can_GaaRegs[LucUnit].pCmn->aaCFReg[LpHoh->usBufferIndex].ulCFID; LulMessageDlc = Can_GaaRegs[LucUnit].pCmn->aaCFReg[LpHoh->usBufferIndex].ulCFPTR; LpDataReg = &Can_GaaRegs[LucUnit].pCmn->aaCFReg[LpHoh->usBufferIndex].aaCFDF[0]; LulMessageDlc = CAN_RSCAN_XXDLC_GET(LulMessageDlc); /* Truncate 1xxxb to 1000b */ if ((uint32)CAN_STD_MAX_PAYLOAD < LulMessageDlc) { LulMessageDlc = CAN_STD_MAX_PAYLOAD; } /* else No action required */ LulAvailableDlc = LulMessageDlc; #endif /* (CAN_RSCAN_CONFIGURED == STD_ON) */ } /* Copy Data to memory from registers by 4 bytes */ LulDlcWords = CAN_ALIGN_4(LulAvailableDlc) / (uint32)sizeof(uint32); /* PRQA S 3383, 3469 # JV-01, JV-01 */ for (LulWordIndex = 0U; LulWordIndex < LulDlcWords; LulWordIndex++) { LaaCanSdu[LulWordIndex] = LpDataReg[LulWordIndex]; /* PRQA S 2824, 2844 # JV-01, JV-01 */ } /* Increment FIFO pointer */ Can_GaaRegs[LucUnit].pCmn->aaCFPCTR[LpHoh->usBufferIndex] = CAN_RSCAN_CFPC_NEXT; /* Inform TimeStamp value first */ #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) /* Process the Tx Time Stamp Value */ Can_TSCapGetRxTimeStamp(LpHoh->ucController, LucUnit, LulTSRAMOffset, LulFDSts, LulIDRegValue); #endif /* Indicate to the uppder layer */ Can_RxIndicationCommonPart(LpHoh, LaaCanSdu, LulMessageDlc, LulIDRegValue, LulFDSts); LucCount++; } /* while (FIFO is not empty) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RX_COMFIFO', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RSCAN_CONFIGURED\\nCAN_RSCANFD_CONFIGURED', 'Value': 'STD_ON\\nSTD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpHoh', 'Value': '&map_LpHoh[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulUnit', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usBufferIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulXXCCRegValue', 'Value': '0x00000018'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucController', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pFD', 'Value': '&map_pFD[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'enMacroType', 'Value': 'CAN_MACRO_RSCANFD'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFSTS[0]', 'Value': '0x0000000E'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulCFID', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulCFPTR', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFDF[0]', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFDCSTS', 'Value': '1'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFDCFID', 'Value': '2'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFDCFPTR', 'Value': '0x0000000F << 28'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'aaFDCFDF[0]', 'Value': '4']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CAN_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CAN_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CAN_RXPROCESSING_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CAN_E_DATALOST'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFSTS[0]', 'Value': 'CAN_RSCAN_CLEAR_CFMLT'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFPCTR[0]', 'Value': 'CAN_RSCAN_CFPC_NEXT'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucController', 'Value': '0'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucUnit', 'Value': '1'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTSRAMOffset', 'Value': '0x0000FFFFUL&(0x0000000F << 28)'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFDSts', 'Value': '1'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIDRegValue', 'Value': '2'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpHoh', 'Value': '&map_LpHoh[0]'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LaaCanSdu', 'Value': '&map_pFD[0].aaCFReg[0].aaFDCFDF'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDlc', 'Value': '64'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIDRegValue', 'Value': '2'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFDSts', 'Value': '1'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (CAN_RX_COMFIFO == STD_ON) STATIC FUNC(void, CAN_PRIVATE_CODE) Can_RxIndicationTxRxFIFO( CONSTP2CONST(Can_HohConfigType, AUTOMATIC, CAN_PRIVATE_CONST) LpHoh, CONST(uint8, AUTOMATIC) LucUnit) { P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpDataReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(uint32, AUTOMATIC) LulMessageDlc; VAR(uint32, AUTOMATIC) LulAvailableDlc; /* To optimize data copy operation, declare data array with uint32 */ VAR(uint32, AUTOMATIC) LaaCanSdu[CAN_LOCALBUFFER_SIZE_32]; VAR(uint32, AUTOMATIC) LulFDSts; VAR(uint32, AUTOMATIC) LulIDRegValue; VAR(uint32, AUTOMATIC) LulWordIndex; VAR(uint32, AUTOMATIC) LulDlcWords; VAR(uint8, AUTOMATIC) LucCFDCValue; VAR(uint8, AUTOMATIC) LucFifoBufferDepth; VAR(uint8, AUTOMATIC) LucCount; #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) VAR(uint32, AUTOMATIC) LulTSRAMOffset; #endif /* Clear interrupt request flag */ Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LpHoh->usBufferIndex] = (CAN_RSCAN_CLEAR_CFRXIF); /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Get Receive FIFO Buffer Depth Configuration value */ LucCFDCValue = (uint8)CAN_RSCAN_CFDC_GET(LpHoh->ulXXCCRegValue); /* PRQA S 3469 # JV-01 */ /* Get FIFO Buffer Depth value */ LucFifoBufferDepth = (uint8)CAN_RSCAN_FIFO_BUFFER_DEPTH_GET(LucCFDCValue); LucCount = 0U; /* Read TxRxFIFO until the FIFO becomes empty */ while ((0UL == (Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LpHoh->usBufferIndex] & CAN_RSCAN_CFEMP)) && (LucCount < LucFifoBufferDepth)) { #if ((CAN_DEV_ERROR_DETECT == STD_ON) || \\ (CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) /* Check lost message */ if (CAN_FIFO_MSG_LOST_MASK == ((Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LpHoh->usBufferIndex]) /* PRQA S 2814, 2844 # JV-01, JV-01 */ & CAN_FIFO_MSG_LOST_MASK)) { /* Clear transmit/receive FIFO message lost flag */ Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LpHoh->usBufferIndex] = (CAN_RSCAN_CLEAR_CFMLT); #if (CAN_AR_VERSION == CAN_AR_422_VERSION) /* Report to DET default error*/ (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_RXPROCESSING_SID, CAN_E_DATALOST); #elif ((CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) /* Report to DET runtime error*/ (void)Det_ReportRuntimeError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_RXPROCESSING_SID, CAN_E_DATALOST); #endif } /* else No action required */ #endif /* ((CAN_DEV_ERROR_DETECT == STD_ON) || */ /* (CAN_AR_VERSION == CAN_AR_431_VERSION) */ /* (CAN_AR_VERSION == CAN_AR_1911_VERSION)) */ #if ((CAN_RSCAN_CONFIGURED == STD_ON) && (CAN_RSCANFD_CONFIGURED == STD_ON)) if (CAN_MACRO_RSCANFD == Can_GaaRegs[LucUnit].enMacroType) #endif { #if (CAN_RSCANFD_CONFIGURED == STD_ON) /* Get status and data register address accroding to each buffer mode */ LulFDSts = Can_GaaRegs[LucUnit].pFD->aaCFReg[LpHoh->usBufferIndex].ulFDCSTS; LulIDRegValue = Can_GaaRegs[LucUnit].pFD->aaCFReg[LpHoh->usBufferIndex].ulFDCFID; LulMessageDlc = Can_GaaRegs[LucUnit].pFD->aaCFReg[LpHoh->usBufferIndex].ulFDCFPTR; #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) /* Get the offset address for TimeStampe ID register */ /* Reading CFDCFPTR.CFTS bits */ LulTSRAMOffset = (0x0000FFFFUL & LulMessageDlc); #endif LpDataReg = &Can_GaaRegs[LucUnit].pFD->aaCFReg[LpHoh->usBufferIndex].aaFDCFDF[0]; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Convert DLC value to actual byte length */ LulMessageDlc = (uint32)Can_GaaPayloadFromDLCTable[CAN_RSCAN_XXDLC_GET(LulMessageDlc)]; /* Read registers as the smaller one of message DLC or buffer DLC */ LulAvailableDlc = Can_GaaPayloadFromPLSTable[CAN_RSCAN_CFPLS_GET(LpHoh->ulXXCCRegValue)]; /* PRQA S 3469 # JV-01 */ if (LulAvailableDlc > LulMessageDlc) { LulAvailableDlc = LulMessageDlc; } /* else No action required */ #endif /* (CAN_RSCANFD_CONFIGURED == STD_ON) */ } #if ((CAN_RSCAN_CONFIGURED == STD_ON) && (CAN_RSCANFD_CONFIGURED == STD_ON)) else #endif { #if (CAN_RSCAN_CONFIGURED == STD_ON) LulFDSts = 0UL; LulIDRegValue = Can_GaaRegs[LucUnit].pCmn->aaCFReg[LpHoh->usBufferIndex].ulCFID; LulMessageDlc = Can_GaaRegs[LucUnit].pCmn->aaCFReg[LpHoh->usBufferIndex].ulCFPTR; LpDataReg = &Can_GaaRegs[LucUnit].pCmn->aaCFReg[LpHoh->usBufferIndex].aaCFDF[0]; LulMessageDlc = CAN_RSCAN_XXDLC_GET(LulMessageDlc); /* Truncate 1xxxb to 1000b */ if ((uint32)CAN_STD_MAX_PAYLOAD < LulMessageDlc) { LulMessageDlc = CAN_STD_MAX_PAYLOAD; } /* else No action required */ LulAvailableDlc = LulMessageDlc; #endif /* (CAN_RSCAN_CONFIGURED == STD_ON) */ } /* Copy Data to memory from registers by 4 bytes */ LulDlcWords = CAN_ALIGN_4(LulAvailableDlc) / (uint32)sizeof(uint32); /* PRQA S 3383, 3469 # JV-01, JV-01 */ for (LulWordIndex = 0U; LulWordIndex < LulDlcWords; LulWordIndex++) { LaaCanSdu[LulWordIndex] = LpDataReg[LulWordIndex]; /* PRQA S 2824, 2844 # JV-01, JV-01 */ } /* Increment FIFO pointer */ Can_GaaRegs[LucUnit].pCmn->aaCFPCTR[LpHoh->usBufferIndex] = CAN_RSCAN_CFPC_NEXT; /* Inform TimeStamp value first */ #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) /* Process the Tx Time Stamp Value */ Can_TSCapGetRxTimeStamp(LpHoh->ucController, LucUnit, LulTSRAMOffset, LulFDSts, LulIDRegValue); #endif /* Indicate to the uppder layer */ Can_RxIndicationCommonPart(LpHoh, LaaCanSdu, LulMessageDlc, LulIDRegValue, LulFDSts); LucCount++; } /* while (FIFO is not empty) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RX_COMFIFO', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RSCAN_CONFIGURED\\nCAN_RSCANFD_CONFIGURED', 'Value': 'STD_ON\\nSTD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpHoh', 'Value': '&map_LpHoh[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulUnit', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usBufferIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulXXCCRegValue', 'Value': '0xFFFFFFFF'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucController', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pFD', 'Value': '&map_pFD[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'enMacroType', 'Value': 'CAN_MACRO_RSCANFD'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFSTS[0]', 'Value': '0x0000000A'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulCFID', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulCFPTR', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFDF[0]', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFDCSTS', 'Value': '1'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFDCFID', 'Value': '2'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFDCFPTR', 'Value': '0x00000008 << 28'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'aaFDCFDF[0]', 'Value': '4']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFSTS[0]', 'Value': 'CAN_RSCAN_CLEAR_CFRXIF'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'aaCFPCTR[0]', 'Value': 'CAN_RSCAN_CFPC_NEXT'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucController', 'Value': '1'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucUnit', 'Value': '1'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTSRAMOffset', 'Value': '0x0000FFFFUL&(0x00000008 << 28)'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFDSts', 'Value': '1'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIDRegValue', 'Value': '2'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpHoh', 'Value': '&map_LpHoh[0]'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LaaCanSdu', 'Value': '&map_pFD[0].aaCFReg[0].aaFDCFDF'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDlc', 'Value': '8'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIDRegValue', 'Value': '2'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFDSts', 'Value': '1'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #ifdef CAN_CONTROLLER_RX_INTERRUPT_ON STATIC FUNC(void, CAN_CODE_FAST) Can_RxIsr(CONST(uint8, AUTOMATIC) LucController) { VAR(uint8, AUTOMATIC) LucCtrlIndex; VAR(uint8, AUTOMATIC) LucUnit; P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) VAR(uint32, AUTOMATIC) LulTxRxFIFOIndex; VAR(uint32, AUTOMATIC) LulLoop; VAR(uint32, AUTOMATIC) LulIrqExist; #endif #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) VAR(uint32, AUTOMATIC) LulWUFMask; #endif /* Convert the physical Controller index to the config index */ LucCtrlIndex = Can_GpConfig->pPhysicalControllerToIndex[LucController]; /* PRQA S 2824 # JV-01 */ LpPCController = &Can_GpPCController[LucCtrlIndex]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) LulIrqExist = 0U; /* Accumurate all interrupt request flags of all TxRxFIFO */ LulTxRxFIFOIndex = (uint32)LpPCController->ucCh * CAN_RSCAN_TXRXFIFO_PER_CH; /* PRQA S 3383 # JV-01 */ for (LulLoop = 0U; LulLoop < CAN_RSCAN_TXRXFIFO_PER_CH; LulLoop++) { /* if (CFCCk.CFRXIE && CFSTSk.CFRXIF), it means that irq exists */ LulIrqExist = LulIrqExist | (CAN_RSCAN_CFRXIE_GET(Can_GaaRegs[LucUnit].pCmn->aaCFCC[LulTxRxFIFOIndex]) & /* PRQA S 2814, 2844, 3469 # JV-01, JV-01, JV-01 */ CAN_RSCAN_CFRXIF_GET(Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LulTxRxFIFOIndex])); /* PRQA S 3469 # JV-01 */ LulTxRxFIFOIndex++; /* PRQA S 3383 # JV-01 */ } /* If no irq exists from RS-CAN or EIC is masked, this interrupt is wrong */ #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((RH850_SV_MODE_REG_READ_ONLY(32, LpPCController->pICRec) & /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3)))) != (CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3))))) { CAN_DEM_REPORT_ERROR(CAN_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } #endif #if (CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((uint16)(*LpPCController->pICRec & (CAN_EIC_EIMK_MASK | CAN_EIC_EIRF_MASK)) != CAN_EIC_EIRF_MASK)) /* PRQA S 2814 # JV-01 */ { CAN_DEM_REPORT_ERROR(CAN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } #endif else #endif /* End of #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) */ { #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) LulWUFMask = LpPCController->ulWUFMask; if (LulWUFMask == (uint32)(*Can_GaaRegs[LucUnit].pWUF0Reg & LulWUFMask)) { *Can_GaaRegs[LucUnit].pWUFC0Reg = LulWUFMask; } /* else No action required */ #endif /* Invoke Can_RxProcessing internal function for receive processing */ Can_RxProcessing(CAN_RXPROC_TXRXFIFO(LucCtrlIndex), CAN_CHECK_INT_RX, CAN_MAINFUNCTION_INSTANCE_0 /* PRQA S 3469 # JV-01 */ #if(CAN_VIRTUAL_MACHINE_ENABLE == STD_ON) , CAN_VM_INVALID #endif ); /* DummyRead & SYNCP */ RH850_SET_IOREG_SYNCP(32, &Can_GaaRegs[LucUnit].pCmn->ulGSTS, 0UL); /* PRQA S 1006, 2814, 2844, 3464 # JV-01, JV-01, JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_CONTROLLERn_RX_INTERRUPT\\n(n=0 to 9)', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_WAKE_UP_FACTOR_CLEAR_ISR', 'Value': 'STD_ON(U2x/Gen4)\\nSTD_OFF(E2x)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_VIRTUAL_MACHINE_ENABLE', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LucController', 'Value': '3'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Can_GpConfig[0].pPhysicalControllerToIndex', 'Value': '&map_pPhysicalControllerToIndex[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPhysicalControllerToIndex[CURRENT_TEST.LucController]', 'Value': '2'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulWUFMask', 'Value': '0x00000002'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pICRec', 'Value': '&map_pICRec[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRec[0]', 'Value': 'CAN_EIC_EIRF_MASK'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pWUF0Reg', 'Value': '&map_pWUF0Reg[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pWUFC0Reg', 'Value': '&map_pWUFC0Reg[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUF0Reg[0]', 'Value': '0x00000001'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'aaCFCC[0 to 2]', 'Value': '[0] = 0x02\\n[1] = 0x02\\n[2] = 0x02'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'aaCFSTS[0 to 2]', 'Value': '[0] = 0x00000000\\n[1] = 0x00000000\\n[2] = 0x00000008'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '0x000000FE']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucVMChannel', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '0x10 << 2'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': 'CAN_CHECK_INT_RX'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': 'CAN_MAINFUNCTION_INSTANCE_0'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '0x000000FE'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUFC0Reg[0]', 'Value': '-'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #ifdef CAN_CONTROLLER_RX_INTERRUPT_ON STATIC FUNC(void, CAN_CODE_FAST) Can_RxIsr(CONST(uint8, AUTOMATIC) LucController) { VAR(uint8, AUTOMATIC) LucCtrlIndex; VAR(uint8, AUTOMATIC) LucUnit; P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) VAR(uint32, AUTOMATIC) LulTxRxFIFOIndex; VAR(uint32, AUTOMATIC) LulLoop; VAR(uint32, AUTOMATIC) LulIrqExist; #endif #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) VAR(uint32, AUTOMATIC) LulWUFMask; #endif /* Convert the physical Controller index to the config index */ LucCtrlIndex = Can_GpConfig->pPhysicalControllerToIndex[LucController]; /* PRQA S 2824 # JV-01 */ LpPCController = &Can_GpPCController[LucCtrlIndex]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) LulIrqExist = 0U; /* Accumurate all interrupt request flags of all TxRxFIFO */ LulTxRxFIFOIndex = (uint32)LpPCController->ucCh * CAN_RSCAN_TXRXFIFO_PER_CH; /* PRQA S 3383 # JV-01 */ for (LulLoop = 0U; LulLoop < CAN_RSCAN_TXRXFIFO_PER_CH; LulLoop++) { /* if (CFCCk.CFRXIE && CFSTSk.CFRXIF), it means that irq exists */ LulIrqExist = LulIrqExist | (CAN_RSCAN_CFRXIE_GET(Can_GaaRegs[LucUnit].pCmn->aaCFCC[LulTxRxFIFOIndex]) & /* PRQA S 2814, 2844, 3469 # JV-01, JV-01, JV-01 */ CAN_RSCAN_CFRXIF_GET(Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LulTxRxFIFOIndex])); /* PRQA S 3469 # JV-01 */ LulTxRxFIFOIndex++; /* PRQA S 3383 # JV-01 */ } /* If no irq exists from RS-CAN or EIC is masked, this interrupt is wrong */ #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((RH850_SV_MODE_REG_READ_ONLY(32, LpPCController->pICRec) & /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3)))) != (CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3))))) { CAN_DEM_REPORT_ERROR(CAN_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } #endif #if (CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((uint16)(*LpPCController->pICRec & (CAN_EIC_EIMK_MASK | CAN_EIC_EIRF_MASK)) != CAN_EIC_EIRF_MASK)) /* PRQA S 2814 # JV-01 */ { CAN_DEM_REPORT_ERROR(CAN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } #endif else #endif /* End of #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) */ { #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) LulWUFMask = LpPCController->ulWUFMask; if (LulWUFMask == (uint32)(*Can_GaaRegs[LucUnit].pWUF0Reg & LulWUFMask)) { *Can_GaaRegs[LucUnit].pWUFC0Reg = LulWUFMask; } /* else No action required */ #endif /* Invoke Can_RxProcessing internal function for receive processing */ Can_RxProcessing(CAN_RXPROC_TXRXFIFO(LucCtrlIndex), CAN_CHECK_INT_RX, CAN_MAINFUNCTION_INSTANCE_0 /* PRQA S 3469 # JV-01 */ #if(CAN_VIRTUAL_MACHINE_ENABLE == STD_ON) , CAN_VM_INVALID #endif ); /* DummyRead & SYNCP */ RH850_SET_IOREG_SYNCP(32, &Can_GaaRegs[LucUnit].pCmn->ulGSTS, 0UL); /* PRQA S 1006, 2814, 2844, 3464 # JV-01, JV-01, JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_CONTROLLERn_RX_INTERRUPT\\n(n=0 to 9)', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_WAKE_UP_FACTOR_CLEAR_ISR', 'Value': 'STD_ON(U2x/Gen4)\\nSTD_OFF(E2x)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_VIRTUAL_MACHINE_ENABLE', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LucController', 'Value': '3'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Can_GpConfig[0].pPhysicalControllerToIndex', 'Value': '&map_pPhysicalControllerToIndex[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPhysicalControllerToIndex[CURRENT_TEST.LucController]', 'Value': '2'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulWUFMask', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pICRec', 'Value': '&map_pICRec[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRec[0]', 'Value': 'CAN_EIC_EIRF_MASK'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pWUF0Reg', 'Value': '&map_pWUF0Reg[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pWUFC0Reg', 'Value': '&map_pWUFC0Reg[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUF0Reg[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'aaCFCC[0 to 2]', 'Value': '[0] = 0x00000002\\n[1] = 0x00000002\\n[2] = 0x00000002'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'aaCFSTS[0 to 2]', 'Value': '[0] = 0x00000000\\n[1] = 0x00000000\\n[2] = 0x00000000'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CAN_E_INT_INCONSISTENT'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucVMChannel', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUFC0Reg[0]', 'Value': '-'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #ifdef CAN_CONTROLLER_RX_INTERRUPT_ON STATIC FUNC(void, CAN_CODE_FAST) Can_RxIsr(CONST(uint8, AUTOMATIC) LucController) { VAR(uint8, AUTOMATIC) LucCtrlIndex; VAR(uint8, AUTOMATIC) LucUnit; P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) VAR(uint32, AUTOMATIC) LulTxRxFIFOIndex; VAR(uint32, AUTOMATIC) LulLoop; VAR(uint32, AUTOMATIC) LulIrqExist; #endif #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) VAR(uint32, AUTOMATIC) LulWUFMask; #endif /* Convert the physical Controller index to the config index */ LucCtrlIndex = Can_GpConfig->pPhysicalControllerToIndex[LucController]; /* PRQA S 2824 # JV-01 */ LpPCController = &Can_GpPCController[LucCtrlIndex]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) LulIrqExist = 0U; /* Accumurate all interrupt request flags of all TxRxFIFO */ LulTxRxFIFOIndex = (uint32)LpPCController->ucCh * CAN_RSCAN_TXRXFIFO_PER_CH; /* PRQA S 3383 # JV-01 */ for (LulLoop = 0U; LulLoop < CAN_RSCAN_TXRXFIFO_PER_CH; LulLoop++) { /* if (CFCCk.CFRXIE && CFSTSk.CFRXIF), it means that irq exists */ LulIrqExist = LulIrqExist | (CAN_RSCAN_CFRXIE_GET(Can_GaaRegs[LucUnit].pCmn->aaCFCC[LulTxRxFIFOIndex]) & /* PRQA S 2814, 2844, 3469 # JV-01, JV-01, JV-01 */ CAN_RSCAN_CFRXIF_GET(Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LulTxRxFIFOIndex])); /* PRQA S 3469 # JV-01 */ LulTxRxFIFOIndex++; /* PRQA S 3383 # JV-01 */ } /* If no irq exists from RS-CAN or EIC is masked, this interrupt is wrong */ #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((RH850_SV_MODE_REG_READ_ONLY(32, LpPCController->pICRec) & /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3)))) != (CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3))))) { CAN_DEM_REPORT_ERROR(CAN_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } #endif #if (CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((uint16)(*LpPCController->pICRec & (CAN_EIC_EIMK_MASK | CAN_EIC_EIRF_MASK)) != CAN_EIC_EIRF_MASK)) /* PRQA S 2814 # JV-01 */ { CAN_DEM_REPORT_ERROR(CAN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } #endif else #endif /* End of #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) */ { #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) LulWUFMask = LpPCController->ulWUFMask; if (LulWUFMask == (uint32)(*Can_GaaRegs[LucUnit].pWUF0Reg & LulWUFMask)) { *Can_GaaRegs[LucUnit].pWUFC0Reg = LulWUFMask; } /* else No action required */ #endif /* Invoke Can_RxProcessing internal function for receive processing */ Can_RxProcessing(CAN_RXPROC_TXRXFIFO(LucCtrlIndex), CAN_CHECK_INT_RX, CAN_MAINFUNCTION_INSTANCE_0 /* PRQA S 3469 # JV-01 */ #if(CAN_VIRTUAL_MACHINE_ENABLE == STD_ON) , CAN_VM_INVALID #endif ); /* DummyRead & SYNCP */ RH850_SET_IOREG_SYNCP(32, &Can_GaaRegs[LucUnit].pCmn->ulGSTS, 0UL); /* PRQA S 1006, 2814, 2844, 3464 # JV-01, JV-01, JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_CONTROLLERn_RX_INTERRUPT\\n(n=0 to 9)', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_WAKE_UP_FACTOR_CLEAR_ISR', 'Value': 'STD_ON(U2x/Gen4)\\nSTD_OFF(E2x)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_VIRTUAL_MACHINE_ENABLE', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LucController', 'Value': '3'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Can_GpConfig[0].pPhysicalControllerToIndex', 'Value': '&map_pPhysicalControllerToIndex[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPhysicalControllerToIndex[CURRENT_TEST.LucController]', 'Value': '2'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulWUFMask', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pICRec', 'Value': '&map_pICRec[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRec[0]', 'Value': 'CAN_EIC_EIMK_MASK | CAN_EIC_EIRF_MASK'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pWUF0Reg', 'Value': '&map_pWUF0Reg[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pWUFC0Reg', 'Value': '&map_pWUFC0Reg[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUF0Reg[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'aaCFCC[0 to 2]', 'Value': '[0] = 0x00000002\\n[1] = 0x00000002\\n[2] = 0x00000002'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'aaCFSTS[0 to 2]', 'Value': '[0] = 0x00000000\\n[1] = 0x00000000\\n[2] = 0x00000000'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CAN_E_INT_INCONSISTENT'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucVMChannel', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUFC0Reg[0]', 'Value': '-'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #ifdef CAN_CONTROLLER_RX_INTERRUPT_ON STATIC FUNC(void, CAN_CODE_FAST) Can_RxIsr(CONST(uint8, AUTOMATIC) LucController) { VAR(uint8, AUTOMATIC) LucCtrlIndex; VAR(uint8, AUTOMATIC) LucUnit; P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) VAR(uint32, AUTOMATIC) LulTxRxFIFOIndex; VAR(uint32, AUTOMATIC) LulLoop; VAR(uint32, AUTOMATIC) LulIrqExist; #endif #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) VAR(uint32, AUTOMATIC) LulWUFMask; #endif /* Convert the physical Controller index to the config index */ LucCtrlIndex = Can_GpConfig->pPhysicalControllerToIndex[LucController]; /* PRQA S 2824 # JV-01 */ LpPCController = &Can_GpPCController[LucCtrlIndex]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) LulIrqExist = 0U; /* Accumurate all interrupt request flags of all TxRxFIFO */ LulTxRxFIFOIndex = (uint32)LpPCController->ucCh * CAN_RSCAN_TXRXFIFO_PER_CH; /* PRQA S 3383 # JV-01 */ for (LulLoop = 0U; LulLoop < CAN_RSCAN_TXRXFIFO_PER_CH; LulLoop++) { /* if (CFCCk.CFRXIE && CFSTSk.CFRXIF), it means that irq exists */ LulIrqExist = LulIrqExist | (CAN_RSCAN_CFRXIE_GET(Can_GaaRegs[LucUnit].pCmn->aaCFCC[LulTxRxFIFOIndex]) & /* PRQA S 2814, 2844, 3469 # JV-01, JV-01, JV-01 */ CAN_RSCAN_CFRXIF_GET(Can_GaaRegs[LucUnit].pCmn->aaCFSTS[LulTxRxFIFOIndex])); /* PRQA S 3469 # JV-01 */ LulTxRxFIFOIndex++; /* PRQA S 3383 # JV-01 */ } /* If no irq exists from RS-CAN or EIC is masked, this interrupt is wrong */ #if (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((RH850_SV_MODE_REG_READ_ONLY(32, LpPCController->pICRec) & /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3)))) != (CAN_EIC_EIMK_MASK_R << (LpPCController->ucCh * ((uint8)3))))) { CAN_DEM_REPORT_ERROR(CAN_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } #endif #if (CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((0UL == LulIrqExist) || ((uint16)(*LpPCController->pICRec & (CAN_EIC_EIMK_MASK | CAN_EIC_EIRF_MASK)) != CAN_EIC_EIRF_MASK)) /* PRQA S 2814 # JV-01 */ { CAN_DEM_REPORT_ERROR(CAN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); } #endif else #endif /* End of #if ((CAN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) || (CAN_UNINTENDED_INTERRUPT_CHECK == STD_ON)) */ { #if (CAN_WAKE_UP_FACTOR_CLEAR_ISR == STD_ON) LulWUFMask = LpPCController->ulWUFMask; if (LulWUFMask == (uint32)(*Can_GaaRegs[LucUnit].pWUF0Reg & LulWUFMask)) { *Can_GaaRegs[LucUnit].pWUFC0Reg = LulWUFMask; } /* else No action required */ #endif /* Invoke Can_RxProcessing internal function for receive processing */ Can_RxProcessing(CAN_RXPROC_TXRXFIFO(LucCtrlIndex), CAN_CHECK_INT_RX, CAN_MAINFUNCTION_INSTANCE_0 /* PRQA S 3469 # JV-01 */ #if(CAN_VIRTUAL_MACHINE_ENABLE == STD_ON) , CAN_VM_INVALID #endif ); /* DummyRead & SYNCP */ RH850_SET_IOREG_SYNCP(32, &Can_GaaRegs[LucUnit].pCmn->ulGSTS, 0UL); /* PRQA S 1006, 2814, 2844, 3464 # JV-01, JV-01, JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_CONTROLLERn_RX_INTERRUPT\\n(n=0 to 9)', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_WAKE_UP_FACTOR_CLEAR_ISR', 'Value': 'STD_ON(U2x/Gen4)\\nSTD_OFF(E2x)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_VIRTUAL_MACHINE_ENABLE', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LucController', 'Value': '3'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Can_GpConfig[0].pPhysicalControllerToIndex', 'Value': '&map_pPhysicalControllerToIndex[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPhysicalControllerToIndex[CURRENT_TEST.LucController]', 'Value': '2'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulWUFMask', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pICRec', 'Value': '&map_pICRec[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICRec[0]', 'Value': 'CAN_EIC_EIMK_MASK | CAN_EIC_EIRF_MASK'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pWUF0Reg', 'Value': '&map_pWUF0Reg[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pWUFC0Reg', 'Value': '&map_pWUFC0Reg[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUF0Reg[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'aaCFCC[0 to 2]', 'Value': '[0] = 0x00000000\\n[1] = 0x00000000\\n[2] = 0x00000000'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'aaCFSTS[0 to 2]', 'Value': '[0] = 0x0000FF1F\\n[0] = 0x0000FF1F\\n[0] = 0x0000FF1F'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CAN_E_INT_INCONSISTENT'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucVMChannel', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufferBits', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMode', 'Value': '<Not Called>'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIndex', 'Value': '<Not Called>'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWUFC0Reg[0]', 'Value': '-'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CAN_START_SEC_PUBLIC_CODE #include \"Can_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Can_CommonReturnType, CAN_PUBLIC_CODE) Can_SetControllerMode( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Controller, VAR(Can_CommonControllerStateType, AUTOMATIC) Transition) { VAR(Can_CommonControllerStateType, AUTOMATIC) LenCurrentMode; VAR(Can_CommonReturnType, AUTOMATIC) LenReturnValue; #if (CAN_WAKEUP_SUPPORT == STD_ON) P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ #endif /* Get the current mode of the Controller */ LenCurrentMode = Can_GaaCtrlState[Controller].enMode; /* PRQA S 2844 # JV-01 */ #if (CAN_DEV_ERROR_DETECT == STD_ON) LenReturnValue = Can_CommonDetCheck(CAN_SET_MODECNTRL_SID, Controller); if (CAN_COMMON_OK != LenReturnValue) { /* Return LenReturnValue as is */ } /* Report to DET, if the transition is out of range */ else if ((uint32)CAN_MAX_VALID_STATE_TRANSITION < (uint32)Transition) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_SET_MODECNTRL_SID, CAN_E_TRANSITION); LenReturnValue = CAN_COMMON_NOT_OK; } /* Report to DET, if the transition is not valid */ else if ( #if (CAN_AR_VERSION == CAN_AR_422_VERSION) ((CAN_COMMON_STATE_STARTED == LenCurrentMode) && (CAN_COMMON_STATE_WAKEUP == Transition)) || ((CAN_COMMON_STATE_SLEEP == LenCurrentMode) && (CAN_COMMON_STATE_STOPPED == Transition)) || #endif ((CAN_COMMON_STATE_SLEEP == LenCurrentMode) && (CAN_COMMON_STATE_STARTED == Transition)) || ((CAN_COMMON_STATE_STARTED == LenCurrentMode) && (CAN_COMMON_STATE_SLEEP == Transition))) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_SET_MODECNTRL_SID, CAN_E_TRANSITION); LenReturnValue = CAN_COMMON_NOT_OK; } else #endif /* #if (CAN_DEV_ERROR_DETECT == STD_ON) */ { #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) /* If PN is active, State Transition can not be performed * User have to deactivate it first by calling Can_SetIcomConfiguration * SWS_Can_00498/SWS_Can_00499 */ if (CAN_ICOM_ACTIVATION == Can_GblIcomStatus) /* PRQA S 3416 # JV-01 */ { #if (CAN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_SET_MODECNTRL_SID, CAN_E_TRANSITION); #endif /* Set CanReturnType to CAN_NOT_OK */ LenReturnValue = CAN_COMMON_NOT_OK; } else #endif /* End of #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) */ { LenReturnValue = CAN_COMMON_OK; /* If Transition is to the Same State */ if (LenCurrentMode == Transition) { /* Indicate mode change to CanIf, if Transition is to the Same State */ if (CAN_COMMON_STATE_STARTED == Transition) { /* Indicate mode change to CanIf */ CanIf_ControllerModeIndication((uint8)(Controller + CAN_CONTROLLER_OFFSET), CAN_COMMON_IF_STATE_STARTED); /* PRQA S 2985, 3383 # JV-01, JV-01 */ } else if (CAN_COMMON_STATE_STOPPED == Transition) { /* Indicate mode change to CanIf */ CanIf_ControllerModeIndication((uint8)(Controller + CAN_CONTROLLER_OFFSET), CAN_COMMON_IF_STATE_STOPPED); /* PRQA S 2985, 3383 # JV-01, JV-01 */ } else if (CAN_COMMON_STATE_SLEEP == Transition) /* PRQA S 2004 # JV-01 */ { /* Indicate mode change to CanIf */ CanIf_ControllerModeIndication((uint8)(Controller + CAN_CONTROLLER_OFFSET), CAN_COMMON_IF_STATE_SLEEP); /* PRQA S 2985, 3383 # JV-01, JV-01 */ } /* else No action required */ } else { /* Invoke corresponding function based on the transition */ switch (Transition) { case CAN_COMMON_STATE_STARTED: Can_StartMode(Controller); break; case CAN_COMMON_STATE_STOPPED: #if ((CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) if (CAN_COMMON_STATE_STARTED == LenCurrentMode) #endif { /* * The transition START to STOP is done by the following triggers: * - Can_SetControllerMode(CAN_COMMON_STATE_STOPPED) * - Busoff * - Can_IcomStopControllers() * Can_SetControllerMode() and Can_IcomStopControllers() can't perform * changing controler mode simultaneously. * To avoid the state transition is done twice by both of triggers, * the exclusive control is required. */ CAN_ENTER_CRITICAL_SECTION(CAN_RAM_DATA_PROTECTION); if ((CAN_COMMON_STATE_STARTED == Can_GaaCtrlState[Controller].enMode) && /* PRQA S 2844 # JV-01 */ (CAN_NO_PENDING_TRANSITION == Can_GaaCtrlState[Controller].enSubState)) { /* Mark subState as \"TENTATIVE\" to block the transition by ISR */ Can_GaaCtrlState[Controller].enSubState = CAN_TENTATIVE_TRANSITION; /* PRQA S 2844 # JV-01 */ } /* else No action required */ CAN_EXIT_CRITICAL_SECTION(CAN_RAM_DATA_PROTECTION); if (CAN_FALSE == Can_GaaCtrlState[Controller].blBusOff) /* PRQA S 2844 # JV-01 */ { /* Start the transition to STOP state */ Can_StopMode(Controller); } /* else No action required */ } #if (CAN_AR_VERSION == CAN_AR_422_VERSION) break; case CAN_COMMON_STATE_WAKEUP: #elif ((CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION)) else #endif { #if (CAN_WAKEUP_SUPPORT == STD_ON) LpPCController = &Can_GpPCController[Controller]; /* * The transition SLEEP to STOP is done by the following triggers: * - Can_SetControllerMode(CAN_COMMON_STATE_WAKEUP) (AR422) * - Can_SetControllerMode(CAN_COMMON_STATE_STOPPED) (AR431) * - Wake-up trigger by the HW * To avoid the state transition is done twice by both of triggers, * the exclusive control is required. * This critical section must be INTERRUPT_CONTROL_PROTECTION, * because EIC register is manipulated and the exclusive control is * also required against Can_EnableControllerInterrupts. */ CAN_ENTER_CRITICAL_SECTION(CAN_INTERRUPT_CONTROL_PROTECTION); if ((CAN_COMMON_STATE_SLEEP == Can_GaaCtrlState[Controller].enMode) && /* PRQA S 2844 # JV-01 */ (CAN_NO_PENDING_TRANSITION == Can_GaaCtrlState[Controller].enSubState)) { /* Mark subState as \"TENTATIVE\" to block the transition by ISR */ Can_GaaCtrlState[Controller].enSubState = CAN_TENTATIVE_TRANSITION; /* PRQA S 2844 # JV-01 */ /* Wakeup is triggered by SW */ Can_GaaCtrlState[Controller].blWakeupByHW = CAN_FALSE; /* PRQA S 2844 # JV-01 */ /* Disable Wake-up ISR */ if (NULL_PTR != LpPCController->pICWakeup) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* PRQA S 0715 # JV-01 */ #if (CAN_CR52_PROC == STD_ON) /* Clear INTPnMSK bit for APPPINTMSKrn */ RH850_SV_MODE_ICR_AND(32, LpPCController->pICWakeup, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)(~(CAN_EIC_EIMK_MASK_W << (LpPCController->ucCh + (LpPCController->ucUnit * ((uint8)8)))))); #else RH850_SV_MODE_ICR_OR(8, LpPCController->pICWakeup, CAN_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ #endif /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, LpPCController->pICWakeup); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ } /* else No action required */ } /* else No action required. The transition to CAN_COMMON_STATE_STOPPED by ISR has been started */ CAN_EXIT_CRITICAL_SECTION(CAN_INTERRUPT_CONTROL_PROTECTION); if (CAN_TENTATIVE_TRANSITION != Can_GaaCtrlState[Controller].enSubState) /* PRQA S 2844 # JV-01 */ { /* The state transition has been started by the ISR. Return CAN_COMMON_NOT_OK according to SWS_Can_00048. */ LenReturnValue = CAN_COMMON_NOT_OK; } else #endif /* (CAN_WAKEUP_SUPPORT == STD_ON) */ { /* Start the transition to STOP sate */ Can_WakeupMode(Controller); } } break; default: /* CAN_COMMON_STATE_SLEEP */ Can_SleepMode(Controller); break; } /* end of switch(Transition) */ } /* end of if (LenCurrentMode == Transition) */ } /* end of if (CAN_ICOM_ACTIVATION == Can_GblIcomStatus) */ } /* Return LenCanReturnType */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Controller', 'Value': 'CAN_MAX_NUMBER_OF_CONTROLLER-1'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Transition', 'Value': 'CAN_COMMON_STATE_STOPPED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblIcomStatus', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pICWakeup', 'Value': '&map_pICWakeup[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'enMode', 'Value': 'CAN_COMMON_STATE_SLEEP'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'enSubState', 'Value': 'CAN_PENDING_WAKEUP_WAIT_GLOBALRESET'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'blBusOff', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICWakeup[0]', 'Value': '0'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CAN_COMMON_OK']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'Can_ReturnType', 'Value': 'CAN_COMMON_NOT_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'CAN_SET_MODECNTRL_SID'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucController', 'Value': 'CAN_MAX_NUMBER_OF_CONTROLLER-1'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'ControllerMode', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIndex', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIndex', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIndex', 'Value': '<Not Called>'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIndex', 'Value': '-'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'enSubState', 'Value': '-'], 'Output_Param_018': ['Type': 'Register', 'Range': '', 'Name': 'map_pICWakeup[0]', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupByHW', 'Value': '-'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CAN_START_SEC_PUBLIC_CODE #include \"Can_Mapping.h\" /* SWS_CAN_91001 & SWS_Can_00480 */ FUNC(Std_ReturnType, CAN_PUBLIC_CODE) Can_SetIcomConfiguration (uint8 Controller, IcomConfigIdType ConfigurationId) /* PRQA S 1503 # JV-01 */ { VAR(Can_CommonControllerStateType, AUTOMATIC) LenCurrentMode; VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; #if (CAN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not initialized */ LddStdReturnType = Can_CommonDetCheck(CAN_SET_ICOM_CONFIGURATION_SID, Controller); /* If DET is reported */ if (CAN_COMMON_OK!= LddStdReturnType) { /* Do nothing */ } else { /* SWS_Can_00475 */ if (((IcomConfigIdType)CAN_ICOM_NOCONFIG) < ConfigurationId) { /* Report to DET */ (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_SET_ICOM_CONFIGURATION_SID, CAN_E_ICOM_CONFIG_INVALID); /* Set return value */ LddStdReturnType = CAN_COMMON_NOT_OK; } else { /* No Action Required */ } } /* If no more error */ if (CAN_COMMON_OK == LddStdReturnType) #endif /* End of #if (CAN_DEV_ERROR_DETECT == STD_ON) */ { /* Get the current mode of the Controller */ LenCurrentMode = Can_GaaCtrlState[Controller].enMode; /* PRQA S 2844 # JV-01 */ /* SWS_Can_00471: if request is de-activate PN */ if (CAN_ICOM_DEACTIVATION_ID == ConfigurationId) { if ((CAN_ICOM_ACTIVATION == Can_GblIcomStatus) && (Controller == Can_GucIcomActivatedCtrId)) /* PRQA S 3416 # JV-01 */ { /* Setting ICOM deactivation */ LddStdReturnType = Can_IcomDeactivation(Controller, ConfigurationId); /* if failed to deactivate PN */ if (E_OK != LddStdReturnType) { /* SWS_Can_00474 Indicate to CanIf activation is failed */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED); } else { /* Do nothing */ } } /* if controller COM is already in Deactived mode, just inform to CanIf only */ else if ((CAN_ICOM_DEACTIVATION == Can_GblIcomStatus) && (Controller == Can_GucIcomActivatedCtrId)) /* PRQA S 3416 # JV-01 */ { /* SWS_Can_00474: Indicate to CanIf deactivation is OK */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_OK); /* return value */ LddStdReturnType = E_OK; } else { /* SWS_Can_00474: Indicate to CanIf deactivation is failed */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED); /* return value */ LddStdReturnType = E_NOT_OK; } } else /* SWS_Can_00481 & SWS_Can_00462 */ { /* if controller COM is already in actived mode, just inform to CanIf only */ if ((CAN_ICOM_ACTIVATION == Can_GblIcomStatus) && /* PRQA S 3416 # JV-01 */ (Controller == Can_GucIcomActivatedCtrId) && (ConfigurationId == Can_GucIcomActivatedConfigId)) { /* SWS_Can_00467 Indicate to CanIf activation is successful */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_OK); /* Return E_OK */ LddStdReturnType = E_OK; } else { /* Just active if Channel is on STARTED state */ if (CAN_COMMON_STATE_STARTED == LenCurrentMode) { /* SWS_Can_00464 */ /* Setting ICOM configuration for the appropriate CAN controller */ LddStdReturnType = Can_IcomActivation(Controller, ConfigurationId); /* if failed to activate PN */ if (E_OK != LddStdReturnType) { /* SWS_Can_00467: Indicate to CanIf activation is failed */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED); } else { /* Do nothing */ } } else { /*SWS_Can_00467: Indicate to CanIf activation is failed */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED); /* return value */ LddStdReturnType = E_NOT_OK; } } }/* End of if (0x00 == ConfigurationId) */ } #if (CAN_DEV_ERROR_DETECT == STD_ON) else { /* No Action Required */ }/* End of if (CAN_TRUE != LblErrFlag) */ #endif /* Return LddStdReturnType */ return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'Controller', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'ConfigurationId', 'Value': '0x01'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'enMode', 'Value': 'CAN_COMMON_STATE_STARTED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblIcomStatus', 'Value': 'CAN_ICOM_DEACTIVATION'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GucIcomActivatedCtrId', 'Value': '0x00'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GucIcomActivatedConfigId', 'Value': '0x03'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CAN_COMMON_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CAN_COMMON_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'CAN_SET_ICOM_CONFIGURATION_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucController', 'Value': '0x00'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigurationId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '0x00'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigurationId', 'Value': '0x01'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigurationId', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Error', 'Value': '-'], 'Output_Param_013': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'CAN_COMMON_OK'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CAN_START_SEC_PUBLIC_CODE #include \"Can_Mapping.h\" /* SWS_CAN_91001 & SWS_Can_00480 */ FUNC(Std_ReturnType, CAN_PUBLIC_CODE) Can_SetIcomConfiguration (uint8 Controller, IcomConfigIdType ConfigurationId) /* PRQA S 1503 # JV-01 */ { VAR(Can_CommonControllerStateType, AUTOMATIC) LenCurrentMode; VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; #if (CAN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not initialized */ LddStdReturnType = Can_CommonDetCheck(CAN_SET_ICOM_CONFIGURATION_SID, Controller); /* If DET is reported */ if (CAN_COMMON_OK!= LddStdReturnType) { /* Do nothing */ } else { /* SWS_Can_00475 */ if (((IcomConfigIdType)CAN_ICOM_NOCONFIG) < ConfigurationId) { /* Report to DET */ (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_SET_ICOM_CONFIGURATION_SID, CAN_E_ICOM_CONFIG_INVALID); /* Set return value */ LddStdReturnType = CAN_COMMON_NOT_OK; } else { /* No Action Required */ } } /* If no more error */ if (CAN_COMMON_OK == LddStdReturnType) #endif /* End of #if (CAN_DEV_ERROR_DETECT == STD_ON) */ { /* Get the current mode of the Controller */ LenCurrentMode = Can_GaaCtrlState[Controller].enMode; /* PRQA S 2844 # JV-01 */ /* SWS_Can_00471: if request is de-activate PN */ if (CAN_ICOM_DEACTIVATION_ID == ConfigurationId) { if ((CAN_ICOM_ACTIVATION == Can_GblIcomStatus) && (Controller == Can_GucIcomActivatedCtrId)) /* PRQA S 3416 # JV-01 */ { /* Setting ICOM deactivation */ LddStdReturnType = Can_IcomDeactivation(Controller, ConfigurationId); /* if failed to deactivate PN */ if (E_OK != LddStdReturnType) { /* SWS_Can_00474 Indicate to CanIf activation is failed */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED); } else { /* Do nothing */ } } /* if controller COM is already in Deactived mode, just inform to CanIf only */ else if ((CAN_ICOM_DEACTIVATION == Can_GblIcomStatus) && (Controller == Can_GucIcomActivatedCtrId)) /* PRQA S 3416 # JV-01 */ { /* SWS_Can_00474: Indicate to CanIf deactivation is OK */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_OK); /* return value */ LddStdReturnType = E_OK; } else { /* SWS_Can_00474: Indicate to CanIf deactivation is failed */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED); /* return value */ LddStdReturnType = E_NOT_OK; } } else /* SWS_Can_00481 & SWS_Can_00462 */ { /* if controller COM is already in actived mode, just inform to CanIf only */ if ((CAN_ICOM_ACTIVATION == Can_GblIcomStatus) && /* PRQA S 3416 # JV-01 */ (Controller == Can_GucIcomActivatedCtrId) && (ConfigurationId == Can_GucIcomActivatedConfigId)) { /* SWS_Can_00467 Indicate to CanIf activation is successful */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_OK); /* Return E_OK */ LddStdReturnType = E_OK; } else { /* Just active if Channel is on STARTED state */ if (CAN_COMMON_STATE_STARTED == LenCurrentMode) { /* SWS_Can_00464 */ /* Setting ICOM configuration for the appropriate CAN controller */ LddStdReturnType = Can_IcomActivation(Controller, ConfigurationId); /* if failed to activate PN */ if (E_OK != LddStdReturnType) { /* SWS_Can_00467: Indicate to CanIf activation is failed */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED); } else { /* Do nothing */ } } else { /*SWS_Can_00467: Indicate to CanIf activation is failed */ CanIf_CurrentIcomConfiguration(Controller, ConfigurationId, ICOM_SWITCH_E_FAILED); /* return value */ LddStdReturnType = E_NOT_OK; } } }/* End of if (0x00 == ConfigurationId) */ } #if (CAN_DEV_ERROR_DETECT == STD_ON) else { /* No Action Required */ }/* End of if (CAN_TRUE != LblErrFlag) */ #endif /* Return LddStdReturnType */ return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'Controller', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'ConfigurationId', 'Value': 'CAN_ICOM_DEACTIVATION_ID'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'enMode', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblIcomStatus', 'Value': 'CAN_ICOM_DEACTIVATION'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GucIcomActivatedCtrId', 'Value': '0x02'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GucIcomActivatedConfigId', 'Value': '-'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CAN_COMMON_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'CAN_SET_ICOM_CONFIGURATION_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucController', 'Value': '0x00'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigurationId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigurationId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '0x00'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigurationId', 'Value': 'CAN_ICOM_DEACTIVATION_ID'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Error', 'Value': 'ICOM_SWITCH_E_FAILED'], 'Output_Param_013': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'CAN_COMMON_NOT_OK'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PRIVATE_CODE) Can_SleepMode(CONST(uint8, AUTOMATIC) LucCtrlIndex) /* PRQA S 1505 # JV-01 */ { #if (CAN_WAKEUP_SUPPORT == STD_ON) P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulTimeoutDuration; VAR(Std_ReturnType, AUTOMATIC) LucResult; VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; VAR(Can_SubStatusType, AUTOMATIC) LenSubState; VAR(boolean, AUTOMATIC) LblGlobalTransitionRequired; LulTimeoutDuration = CAN_TIMEOUT_COUNT; LpPCController = &Can_GpPCController[LucCtrlIndex]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LucCh = LpPCController->ucCh; LenSubState = Can_GaaCtrlState[LucCtrlIndex].enSubState; /* PRQA S 2844 # JV-01 */ LucResult = E_OK; /* * STEP 1: * Start to change to CHANNEL_STOP. * At this time, global state transition is never on-going. * Because: * - While GLOBAL_STOP -> GLOBAL_OPERATION is on-going, it means that all * Controllers are CAN_COMMON_STATE_SLEEP or during transition to * CAN_COMMON_STATE_STOPPED. * - While GLOBAL_OPERATION -> GLOBAL_STOP is on-going, it means that one * Controller is during transition to CAN_COMMON_STATE_SLEEP and other * Controllers are CAN_COMMON_STATE_SLEEP. * - When Can_SetControllerMode(CAN_COMMON_STATE_SLEEP) is invoked for a * Controller which is CAN_COMMON_STATE_SLEEP already, Can_SetControllerMode * returns immediately. * - When Can_SetControllerMode(CAN_COMMON_STATE_SLEEP) is invoked for a * Controller which is during state transition, it causes the DET error. */ if (CAN_NO_PENDING_TRANSITION == LenSubState) { LenSubState = CAN_PENDING_SLEEP_WAIT_STOP; LucResult = Can_ChannelModeChange(LucUnit, LucCh, CAN_RSCAN_CSLPR | CAN_RSCAN_CHMDC_RESET, &LulTimeoutDuration); /* Continue to STEP 3 */ } /* * STEP 2: * If necessary, wait for CHANNEL_STOP. */ else if ((CAN_PENDING_SLEEP_WAIT_STOP == LenSubState) && /* PRQA S 2004 # JV-01 */ (0UL == (Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulSTS & CAN_RSCAN_CSLPSTS))) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Continue to pending */ LucResult = E_NOT_OK; } /* else No action required */ /* * STEP 3: * If all Controllers slept, change global state to GLOBAL_RESET. */ if ((E_OK == LucResult) && (CAN_PENDING_SLEEP_WAIT_STOP == LenSubState)) { /* Critical section is required in case entering to sleep and waking up occur on different channels at same time */ CAN_ENTER_CRITICAL_SECTION(CAN_RAM_DATA_PROTECTION); /* Clear active bit of this Controller */ Can_GaaActiveControllers[LucUnit] &= ~(1UL << LucCtrlIndex); /* PRQA S 2844 # JV-01 */ if (0UL == Can_GaaActiveControllers[LucUnit]) /* PRQA S 2844 # JV-01 */ { /* If all Controllers have been entered to CANNEL_STOP, start the global state change: GLOBAL_OPERATION -> GLOBAL_STOP */ Can_GaaGlobalStateTransition[LucUnit] = CAN_TRUE; /* PRQA S 2844 # JV-01 */ LblGlobalTransitionRequired = CAN_TRUE; } else { LblGlobalTransitionRequired = CAN_FALSE; } CAN_EXIT_CRITICAL_SECTION(CAN_RAM_DATA_PROTECTION); /* If all controllers stopped, enter GLOBAL_STOP mode */ if (CAN_TRUE == LblGlobalTransitionRequired) { /* At first, change to GLOBAL_RESET mode. This takes 2 CAN bits. */ LenSubState = CAN_PENDING_SLEEP_WAIT_GLOBALRESET; LucResult = Can_GlobalModeChange(LucUnit, CAN_RSCAN_GMDC_RESET, &LulTimeoutDuration); /* Continue to STEP 5 */ } /* else No action required. Continue to STEP 7 */ } /* * STEP 4: * If necessary, wait for GLOBAL_RESET. */ else if ((E_OK == LucResult) && (CAN_PENDING_SLEEP_WAIT_GLOBALRESET == LenSubState) && /* PRQA S 2004 # JV-01 */ (CAN_RSCAN_GRSTSTS != (Can_GaaRegs[LucUnit].pCmn->ulGSTS & CAN_RSCAN_GSTSMASK))) { /* Continue to pending */ LucResult = E_NOT_OK; } /* else No action required */ /* * STEP 5: * If necessary, enter GLOBAL_STOP. */ if ((E_OK == LucResult) && (CAN_PENDING_SLEEP_WAIT_GLOBALRESET == LenSubState)) { LenSubState = CAN_PENDING_SLEEP_WAIT_GLOBALSTOP; LucResult = Can_GlobalModeChange(LucUnit, CAN_RSCAN_GSLPR | CAN_RSCAN_GMDC_RESET, &LulTimeoutDuration); /* Continue to STEP 7 */ } /* * STEP 6: * If necessary, wait for GLOBAL_STOP. */ else if ((E_OK == LucResult) && (CAN_PENDING_SLEEP_WAIT_GLOBALSTOP == LenSubState) && /* PRQA S 2004 # JV-01 */ (0UL != (Can_GaaRegs[LucUnit].pCmn->ulGSTS & CAN_RSCAN_GSLPSTS))) { /* Continue to pending */ LucResult = E_NOT_OK; } /* else No action required */ /* * STEP 7: * Finish transition. */ if (E_OK == LucResult) { /* Clear Global transition on-going flag */ if (CAN_PENDING_SLEEP_WAIT_GLOBALSTOP == LenSubState) { /* No critical section is required because this can be done atomically */ Can_GaaGlobalStateTransition[LucUnit] = CAN_FALSE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ /* Critical section is required to avoid confliction with Can_DisableControllerInterrupts */ CAN_ENTER_CRITICAL_SECTION(CAN_INTERRUPT_CONTROL_PROTECTION); Can_GaaCtrlState[LucCtrlIndex].enMode = CAN_COMMON_STATE_SLEEP; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucCtrlIndex].enSubState = CAN_NO_PENDING_TRANSITION; /* PRQA S 2844 # JV-01 */ if (NULL_PTR != LpPCController->pICWakeup) { /* Enable wakeup interrupt */ if ((0U != (LpPCController->ucIntEnable & CAN_CHECK_INT_WAKEUP)) && (0UL == Can_GaaCtrlState[LucCtrlIndex].ulIntCount)) { #if (CAN_CR52_PROC == STD_ON) /* Clear interrupt flag by set 1 to respective bit APPPINTCLRRn */ RH850_SV_MODE_ICR_OR(32, LpPCController->pICWakeup + CAN_EIC_EIMK_MASK_OFFSET, /* PRQA S 0310, 0488, 2824, 3305 # JV-01, JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_W << (LpPCController->ucCh + (LpPCController->ucUnit * ((uint8)8)))))); /* Set INTPnMSK bit for APPPINTMSKrn */ RH850_SV_MODE_ICR_OR(32, LpPCController->pICWakeup, /* PRQA S 0310, 2814, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_W << (LpPCController->ucCh + (LpPCController->ucUnit * ((uint8)8)))))); #else /* Clear EIMK and EIRF */ RH850_SV_MODE_ICR_AND(16, LpPCController->pICWakeup, /* PRQA S 2814 # JV-01 */ (uint16)(~(CAN_EIC_EIRF_MASK | (uint16)CAN_EIC_EIMK_MASK))); /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, LpPCController->pICWakeup); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif } else { #if (CAN_CR52_PROC == STD_ON) /* Clear interrupt flag by set 1 to respective bit APPPINTCLRRn */ RH850_SV_MODE_ICR_OR(32, LpPCController->pICWakeup + CAN_EIC_EIMK_MASK_OFFSET, /* PRQA S 0310, 0488, 3305 # JV-01, JV-01, JV-01 */ (uint32)((CAN_EIC_EIMK_MASK_W << (LpPCController->ucCh + (LpPCController->ucUnit * ((uint8)8)))))); #else /* If the interrupt is disabled, clear EIRF only */ RH850_SV_MODE_ICR_AND(16, LpPCController->pICWakeup, (uint16)(~CAN_EIC_EIRF_MASK)); /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, LpPCController->pICWakeup); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif /* #ifdef CAN_CR52_PROC */ } #ifdef CAN_FILTER_CONTROL_SUPPORT if (NULL_PTR != LpPCController->pFCLAReg) /* PRQA S 2814 # JV-01 */ { /* Setting the filter control register for falling edge detection */ *(LpPCController->pFCLAReg) = CAN_RSCAN_FCLA_FALLING_EDGE; /* PRQA S 2814 # JV-01 */ } /* else No action required */ #endif } /* else No action required. Wakeup is not available on this Controller, nothing to do */ CAN_EXIT_CRITICAL_SECTION(CAN_INTERRUPT_CONTROL_PROTECTION); /* Notify CanIf of completion of transition to SLEEP state */ CanIf_ControllerModeIndication((uint8)(LucCtrlIndex + CAN_CONTROLLER_OFFSET), CAN_COMMON_IF_STATE_SLEEP); /* PRQA S 2985, 3383 # JV-01, JV-01 */ } else { /* If timeout occurred, update the pending status. This should be done at the end of this function once to avoid reentrant call from Can_SetControllerMode and Can_MainFunction_Mode. */ Can_GaaCtrlState[LucCtrlIndex].enSubState = LenSubState; /* PRQA S 2844 # JV-01 */ } #else /* (CAN_WAKEUP_SUPPORT == STD_ON) */ /* Set the Controller to sleep mode */ Can_GaaCtrlState[LucCtrlIndex].enMode = CAN_COMMON_STATE_SLEEP; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucCtrlIndex].enSubState = CAN_NO_PENDING_TRANSITION; /* PRQA S 2844 # JV-01 */ /* Indicate mode change to CanIf */ CanIf_ControllerModeIndication((uint8)(LucCtrlIndex + CAN_CONTROLLER_OFFSET), CAN_COMMON_IF_STATE_SLEEP); /* PRQA S 2985, 3383 # JV-01, JV-01 */ #endif /* (CAN_WAKEUP_SUPPORT == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_WAKEUP_SUPPORT', 'Value': 'STD_ON (U2Ax, U2Bx)\\nSTD_OFF (E2x)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'defined CAN_FILTER_CONTROL_SUPPORT', 'Value': 'defined'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucCtrlIndex', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucUnit', 'Value': '[0] = 0'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucCh', 'Value': '[0] = 0'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pICWakeup', 'Value': '[0] = NULL_PTR'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pFCLAReg', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucIntEnable', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICWakeup[0]', 'Value': '0xFFFFFFFF'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'enSubState', 'Value': '[0] = CAN_NO_PENDING_TRANSITION'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'ulIntCount', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'aaChReg[0].ulSTS', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulGSTS', 'Value': '-'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'Can_GaaActiveControllers[0 to 1]', 'Value': '[0] = 1'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCh', 'Value': '0'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_CSLPR | CAN_RSCAN_CHMDC_RESET'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_004': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_GMDC_RESET'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': 'map_LpTimeoutDuration[0]'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_GSLPR | CAN_RSCAN_GMDC_RESET'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeoutDuration', 'Value': 'map_LpTimeoutDuration[0]'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '0'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'ControllerMode', 'Value': 'CAN_COMMON_IF_STATE_SLEEP'], 'Output_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'Can_GaaActiveControllers[0 to 1]', 'Value': '[0] = 1 &  ~1UL'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GaaGlobalStateTransition[0]', 'Value': 'CAN_FALSE'], 'Output_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'enMode', 'Value': '[0] = CAN_COMMON_STATE_SLEEP'], 'Output_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'enSubState', 'Value': '[0] = CAN_NO_PENDING_TRANSITION'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_pICWakeup[0]', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_pFCLAReg[0]', 'Value': '-'], 'Output_Param_022': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PRIVATE_CODE) Can_StartMode(CONST(uint8, AUTOMATIC) LucCtrlIndex) { #if (CAN_ACCESS_HW_ENABLE == STD_ON) #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ #endif P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) LpPCController; /* PRQA S 3432 # JV-01 */ VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; VAR(uint32, AUTOMATIC) LulTimeoutDuration; #endif VAR(Can_SubStatusType, AUTOMATIC) LenSubState; VAR(Std_ReturnType, AUTOMATIC) LucResult; LucResult = E_OK; LenSubState = Can_GaaCtrlState[LucCtrlIndex].enSubState; /* PRQA S 2844 # JV-01 */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) LpPCController = &Can_GpPCController[LucCtrlIndex]; LulTimeoutDuration = CAN_TIMEOUT_COUNT; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LucCh = LpPCController->ucCh; #endif /* * STEP 1: * If current state is BusOff, Controller should be CHANNEL_HALT. * Change to CHANNEL_RESET to clear tx buffers before start. */ if ((CAN_NO_PENDING_TRANSITION == LenSubState) && (CAN_TRUE == Can_GaaCtrlState[LucCtrlIndex].blBusOff)) { /* if HW access is enable */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) /* Clear error flags */ Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulERFL = CAN_RSCAN_ERFL_CLEAR; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #endif Can_GaaCtrlState[LucCtrlIndex].blBusOff = CAN_FALSE; /* PRQA S 2844 # JV-01 */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) /* Change to CHANNEL_RESET mode */ LenSubState = CAN_PENDING_START_WAIT_RESET; LucResult = Can_ChannelModeChange(LucUnit, LucCh, CAN_RSCAN_CHMDC_RESET, &LulTimeoutDuration); #endif } /* if HW access is enable */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) /* * STEP 2: * If necessary, wait for CHANNEL_RESET. */ else if ((CAN_PENDING_START_WAIT_RESET == LenSubState) && /* PRQA S 2004 # JV-01 */ (0UL == (Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulSTS & CAN_RSCAN_CRSTSTS))) { LucResult = E_NOT_OK; } /* else No action required. Continue to STEP 3 */ #endif /* #if (CAN_ACCESS_HW_ENABLE == STD_ON) */ /* * STEP 3: * Change to CHANNEL_COMMUNICATION mode. */ if ((E_OK == LucResult) && ((CAN_NO_PENDING_TRANSITION == LenSubState) || (CAN_PENDING_START_WAIT_RESET == LenSubState))) { /* if HW access is enable */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) #if (CAN_RX_OBJECT == STD_ON) /* * Clear all buffers * TX_BUFFER, TX_QUEUE and TXRX_FIFO(TxMode) are cleared automatically * in CHANNEL_RESET mode. * RX_BUFFER, RX_FIFO, TXRX_FIFO(RxMode) must be cleared by software. */ Can_ClearRxBuffers(LucUnit, LucCtrlIndex); #endif /* (CAN_RX_OBJECT == STD_ON) */ /* Change Channel Mode to Communication Mode */ LenSubState = CAN_PENDING_START_WAIT_COM; LucResult = Can_ChannelModeChange(LucUnit, LucCh, CAN_RSCAN_CHMDC_COM, &LulTimeoutDuration); #endif /* #if (CAN_ACCESS_HW_ENABLE == STD_ON) */ } /* * STEP 4: * Wait for CHANNEL_COMMUNICATION. */ /* if HW access is enable */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) else if ((E_OK == LucResult) && (CAN_PENDING_START_WAIT_COM == LenSubState) && /* PRQA S 2004 # JV-01 */ (CAN_RSCAN_COPSTS != (Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulSTS & CAN_RSCAN_CSTSMASK))) { /* Continue pending */ LucResult = E_NOT_OK; } /* else No action required */ #endif /* #if (CAN_ACCESS_HW_ENABLE == STD_ON) */ /* * STEP 5: * Finish transition. */ if (E_OK == LucResult) { /* if HW access is enable */ #if (CAN_ACCESS_HW_ENABLE == STD_ON) #if ((CAN_TX_COMFIFO == STD_ON) || (CAN_GATEWAY_COMFIFO == STD_ON) || \\ (CAN_TX_QUEUE == STD_ON) || (CAN_GATEWAY_QUEUE == STD_ON)) /* Re-enable CFCC.CFE and TXQCC.TXQE since these registers are cleared in CHANNEL_RESET */ Can_EnableTxBuffers(LucUnit, LucCtrlIndex); #endif #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA)) /* PRQA S 0316, 3432 # JV-01, JV-01 */ Can_GpConfig->pHWUnitInfo; /* If Can Time Sync is enable for this hw unit */ if (CAN_TRUE == LpHWInfo[LucUnit].blTsCapEnable) /* PRQA S 2824 # JV-01 */ { /* Setting Can Time Sync for Controller */ Can_TSCapChStart(LucCtrlIndex); } #endif /* endif if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) */ #ifdef CAN_V4H_PROC /* Checking whether CAN controller interrupts have been disabled by Can_DisableControllerInterrupts API. */ if (0UL != Can_GaaCtrlState[LucCtrlIndex].ulIntCount) /* PRQA S 2844 # JV-01 */ { /* Enable transmit history buffer without enabling THLIE bit. */ Can_GaaRegs[LucUnit].pCmn->aaTHLCC[LucCh] = ((LpPCController->ulTHLCC | CAN_RSCAN_THLE) & (~CAN_RSCAN_THLIE)); } else #endif /* end ifdef CAN_V4H_PROC */ { /* Enable transmit history buffer */ Can_GaaRegs[LucUnit].pCmn->aaTHLCC[LucCh] = LpPCController->ulTHLCC | CAN_RSCAN_THLE; } #endif /* #if (CAN_ACCESS_HW_ENABLE == STD_ON) */ /* Inform the upper layer */ Can_GaaCtrlState[LucCtrlIndex].enMode = CAN_COMMON_STATE_STARTED; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucCtrlIndex].enSubState = CAN_NO_PENDING_TRANSITION; /* PRQA S 2844 # JV-01 */ CanIf_ControllerModeIndication((uint8)(LucCtrlIndex + CAN_CONTROLLER_OFFSET), CAN_COMMON_IF_STATE_STARTED); /* PRQA S 2985, 3383 # JV-01, JV-01 */ } else { /* If timeout occurred, update the pending status. This should be done at the end of this function once to avoid reentrant call from Can_SetControllerMode and Can_MainFunction_Mode. */ Can_GaaCtrlState[LucCtrlIndex].enSubState = LenSubState; /* PRQA S 2844 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RX_OBJECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_TX_COMFIFO\\nCAN_GATEWAY_COMFIFO\\nCAN_TX_QUEUE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucCtrlIndex', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'enSubState', 'Value': 'CAN_NO_PENDING_TRANSITION'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blBusOff', 'Value': 'CAN_TRUE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulIntCount', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulTHLCC', 'Value': '0x2'], 'Input_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulSTS', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'blTsCapEnable', 'Value': 'CAN_TRUE'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1 to 2] = E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCh', 'Value': '0'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_CHMDC_RESET'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIndex', 'Value': '0'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCh', 'Value': '0'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': 'CAN_RSCAN_CHMDC_COM'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeDuration', 'Value': 'CAN_TIMEOUT_COUNT'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCh', 'Value': '0'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIndex', 'Value': '0'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '0'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'ControllerMode', 'Value': 'CAN_COMMON_IF_STATE_STARTED'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'aaChReg[0].ulERFL', 'Value': 'CAN_RSCAN_ERFL_CLEAR'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'aaTHLCC[0]', 'Value': '0x2 | CAN_RSCAN_THLE'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'enMode', 'Value': 'CAN_COMMON_STATE_STARTED'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'enSubState', 'Value': 'CAN_NO_PENDING_TRANSITION'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'blBusOff ', 'Value': 'CAN_FALSE'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PRIVATE_CODE) Can_StopMode(CONST(uint8, AUTOMATIC) LucCtrlIndex) { #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ #endif VAR(uint32, AUTOMATIC) LulTimeoutDuration; VAR(Can_SubStatusType, AUTOMATIC) LenSubState; VAR(Std_ReturnType, AUTOMATIC) LucResult; VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; LucResult = E_OK; LulTimeoutDuration = CAN_TIMEOUT_COUNT; LenSubState = Can_GaaCtrlState[LucCtrlIndex].enSubState; /* PRQA S 2844 # JV-01 */ LucUnit = Can_GpPCController[LucCtrlIndex].ucUnit; LucCh = Can_GpPCController[LucCtrlIndex].ucCh; /* * STEP 1: * If the current state is START, change to HALT mode before RESET mode * to wait the completion of on-going transmission or reception. * If the STOP transition is invoked from Can_SetControlerMode, * the first subState is CAN_TENTATIVE_TRANSITION. * If the STOP transition is invoked from BusOff, * the state transition is done immediately and this function is not invoked. */ if (CAN_TENTATIVE_TRANSITION == LenSubState) { LenSubState = CAN_PENDING_STOP_WAIT_HALT; LucResult = Can_ChannelModeChange(LucUnit, LucCh, CAN_RSCAN_CHMDC_HALT, &LulTimeoutDuration); } /* * STEP 2: * If necessary, wait for the completion to change to CHANNEL_HALT mode. */ else if ((CAN_PENDING_STOP_WAIT_HALT == LenSubState) && /* PRQA S 2004 # JV-01 */ (0UL == (Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulSTS & CAN_RSCAN_CHLTSTS))) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { LucResult = E_NOT_OK; } /* else No action required */ /* * STEP 3: * Change the controller to CHANNEL_RESET mode. */ if ((E_OK == LucResult) && (CAN_PENDING_STOP_WAIT_RESET != LenSubState)) { LenSubState = CAN_PENDING_STOP_WAIT_RESET; LucResult = Can_ChannelModeChange(LucUnit, LucCh, CAN_RSCAN_CHMDC_RESET, &LulTimeoutDuration); } /* * STEP 4: * Wait for the completion to change to CHANNEL_RESET mode. */ else if ((E_OK == LucResult) && (0UL == (Can_GaaRegs[LucUnit].pCmn->aaChReg[LucCh].ulSTS & CAN_RSCAN_CRSTSTS))) /* PRQA S 2004 # JV-01 */ { /* Continue to pending */ LucResult = E_NOT_OK; } /* else No action required */ /* * STEP 5: * Clear all received data and notify CanIf. */ if (E_OK == LucResult) { /* Set the Controller to stop mode */ Can_GaaCtrlState[LucCtrlIndex].enMode = CAN_COMMON_STATE_STOPPED; /* PRQA S 2844 # JV-01 */ Can_GaaCtrlState[LucCtrlIndex].enSubState = CAN_NO_PENDING_TRANSITION; /* PRQA S 2844 # JV-01 */ #if (CAN_TIME_SYNC_CAPTURE_EN == STD_ON) LpHWInfo = (P2CONST(Can_HWUnitInfoType, AUTOMATIC, CAN_CONFIG_DATA)) Can_GpConfig->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* If Can Time Sync is enable for this hw unit */ if (CAN_TRUE == LpHWInfo[LucUnit].blTsCapEnable) /* PRQA S 2824 # JV-01 */ { /* Setting Can Time Sync for Controller to stop operation */ Can_TSCapChStop(LucCtrlIndex); } /* else No action required */ #endif CanIf_ControllerModeIndication((uint8)(LucCtrlIndex + CAN_CONTROLLER_OFFSET), CAN_COMMON_IF_STATE_STOPPED); /* PRQA S 2985, 3383 # JV-01, JV-01 */ } else { /* If timeout occurred, update the pending status. This should be done at the end of this function once to avoid reentrant call from Can_SetControllerMode and Can_MainFunction_Mode. */ Can_GaaCtrlState[LucCtrlIndex].enSubState = LenSubState; /* PRQA S 2844 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LucCtrlIndex', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enSubState', 'Value': 'CAN_PENDING_STOP_WAIT_RESET'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pCmn', 'Value': '&map_pCmn[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'aaChReg[0].ulSTS', 'Value': '~CAN_RSCAN_CRSTSTS'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pHWUnitInfo', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'blTsCapEnable', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '<Not Called>']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCh', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeDuration', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUnit', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCh', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMdBits', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': '*LpTimeDuration', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIndex', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Controller', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'ControllerMode', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'enMode', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'enSubState', 'Value': 'CAN_PENDING_STOP_WAIT_RESET'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (CAN_ACCESS_HW_ENABLE == STD_ON) FUNC(void, CAN_PRIVATE_CODE) Can_TSCapChStart(CONST(uint8, AUTOMATIC) /* PRQA S 1532 # JV-01 */ LucChannel) { P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpPCController; VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; /* Get value of P Controller configuration value */ LpPCController = &Can_GpPCController[LucChannel]; /* Get physical Channel id and hw unit */ LucCh = LpPCController->ucCh; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LucUnit = LpPCController->ucUnit; /* Enable Chanel Time Stamp */ /* Enable Transmit and Receive Time Stamp capture: clear TXMASK-9, RXMASK - 8 and Set TSSEL bits */ Can_GaaRegs[LucUnit].pTsCm->aaChRegType[LucCh].ulTSSELCFG = /* PRQA S 2814, 2844 # JV-01, JV-01 */ LpPCController->ulTSSELCFG; /* Enable Can Time Sync Capture Channel */ /* Set the CFDCnEXTSCTR.EXTSEN Bit */ Can_GaaRegs[LucUnit].pTsCm->aaChRegType[LucCh].ulEXTSCTR = LpPCController->ulEXTSCTR; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..255', 'Name': 'LucChannel', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '0'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ulTSSELCFG', 'Value': '0x00000303UL'], 'Input_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ulEXTSCTR', 'Value': '0x00000001UL'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pTsCm', 'Value': '[0 to 1] = &map_pTsCm[0]']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[0].ulTSSELCFG', 'Value': '0x00000303UL'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[1].ulTSSELCFG', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[10].ulTSSELCFG', 'Value': '-'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[0].ulEXTSCTR', 'Value': '0x00000001UL'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[1].ulEXTSCTR', 'Value': '-'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[10].ulEXTSCTR', 'Value': '-'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PRIVATE_CODE) Can_TSCapChStop(CONST(uint8, AUTOMATIC) /* PRQA S 1532 # JV-01 */ LucChannel) { P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpPCController; VAR(uint8, AUTOMATIC) LucUnit; VAR(uint8, AUTOMATIC) LucCh; /* Get value of P Controller configuration value */ LpPCController = &Can_GpPCController[LucChannel]; LucUnit = LpPCController->ucUnit; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LucCh = LpPCController->ucCh; /* Disble Channel Time Stamp */ /* Clear the CFDCnEXTSCTR.EXTSEN Bit */ Can_GaaRegs[LucUnit].pTsCm->aaChRegType[LucCh].ulEXTSCTR &= /* PRQA S 2814, 2844 # JV-01, JV-01 */ ~(CAN_EXTSCTR_EXTSEN_SET); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..255', 'Name': 'LucChannel', 'Value': '10'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucCh', 'Value': '1'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '1'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[0].ulEXTSCTR', 'Value': '-'], 'Input_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[1].ulEXTSCTR', 'Value': '0x00000001UL'], 'Input_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[10].ulEXTSCTR', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'pTsCm', 'Value': '[0 to 1] = &map_pTsCm[0]']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[0].ulEXTSCTR', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[1].ulEXTSCTR', 'Value': '0x00000000UL'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'aaChRegType[10].ulEXTSCTR', 'Value': '-'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PRIVATE_CODE) Can_TSCapGetTxTimeStamp( /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) LucController, CONST(uint8, AUTOMATIC) LucUnit, CONST(uint32, AUTOMATIC) LulHistoryData0, CONST(uint32, AUTOMATIC) LulHistoryData1) { P2CONST(Can_ControllerPCConfigType, AUTOMATIC, CAN_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpPCController; VAR(Can_TimeStampProtolType, AUTOMATIC) LenProtolType; VAR(uint32, AUTOMATIC) LulTSRAMAddress; VAR(uint32, AUTOMATIC) LulCFDCnIDL; VAR(uint32, AUTOMATIC) LulCFDCnIDH; VAR(uint32, AUTOMATIC) LulTSRAMOffset; /* Get value of P Controller configuration value */ LpPCController = &Can_GpPCController[LucController]; /* If can hw unit enable can time sync capture */ /* By checking TXMASK-9 bit mask */ if(CAN_TSSELCFG_TXMASK_SET != ((LpPCController->ulTSSELCFG) & CAN_TSSELCFG_TXMASK_SET)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Get the store TSRAM address by reading CFDTHLACC0n.TMTS */ LulTSRAMOffset = ((LulHistoryData0 >> CAN_THLACC0_TMTS_OFFSET) & /* PRQA S 2985 # JV-01 */ CAN_THLACC0_TMTS_MASK); /* Get the base address of hw unit ts */ LulTSRAMAddress = (uint32)Can_GaaRegs[LucUnit].pTsCm; /* PRQA S 0303, 2844 # JV-01, JV-01 */ /* Get the stored TimeStamp address of Low rank */ LulTSRAMAddress = LulTSRAMAddress + LulTSRAMOffset; /* PRQA S 3383 # JV-01 */ /* Read the captured Time Stamp value */ LulCFDCnIDL = (*((uint32 *)LulTSRAMAddress)); /* PRQA S 0306, 2814 # JV-01, JV-01 */ /* Get the stored TimeStamp address of High rank */ LulTSRAMAddress = LulTSRAMAddress + CAN_TIME_STAMP_ID_OFFSET; /* PRQA S 3383 # JV-01 */ /* Read the captured Time Stamp value */ LulCFDCnIDH = (*((uint32 *)LulTSRAMAddress)); /* PRQA S 0306 # JV-01 */ /* Check if time stamp gPTP or AVTP protocol */ /* By checking configuration TSSEL[1] */ if(CAN_TSSELCFG_TSSEL_INDICATE_BIT == ((LpPCController->ulTSSELCFG) & CAN_TSSELCFG_TSSEL_INDICATE_BIT)) { LenProtolType = CAN_TIMESTAMP_GPTP; } else { LenProtolType = CAN_TIMESTAMP_AVTP; } /* Inform to upper layer via Callout function */ CAN_TSCAP_TRANSMIT_CALLOUT_FUNCTION( (PduIdType)CAN_RSCAN_TID_GET(LulHistoryData1), LulCFDCnIDL, LulCFDCnIDH, LenProtolType); } else { /* Do nothing */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..1', 'Name': 'LucController', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucUnit', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LulHistoryData0', 'Value': '0x0000FFFFUL'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulHistoryData1', 'Value': '0x00000000UL'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulTSSELCFG', 'Value': '0x00000103UL'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pTsCm', 'Value': '[0 to 1] = &map_pTsCm[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTsCm[0].aaTimeStampId[0][0].ulCFDCnIDL', 'Value': '0xFFFFFFFFUL'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTsCm[0].aaTimeStampId[0][0].ulCFDCnIDH', 'Value': '0x0000000FUL']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'CanTxPduId', 'Value': '(PduIdType)(0x000000000UL & 0x0000FFFFUL)'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTimeStampL', 'Value': '0xFFFFFFFFUL'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTimeStampH', 'Value': '0x0000000FUL'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LdProtolType', 'Value': 'CAN_TIMESTAMP_GPTP'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, CAN_PRIVATE_CODE) Can_TSCapUnitDeInit(CONST(uint8, AUTOMATIC) /* PRQA S 1532 # JV-01 */ LucUnit) { /* Change the CAN Global Time Stamp to Sleep Mode */ /* Set CFDGTSSLCTRL.SLEEP bit */ Can_GaaRegs[LucUnit].pTsCm->ulGTSSLCTR = CAN_GTSSLCTRL_SLEEP_SET; /* PRQA S 2814, 2844 # JV-01, JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..1', 'Name': 'LucUnit', 'Value': '1'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'pTsCm', 'Value': '[0 to 1] = &map_pTsCm[0]'], 'Input_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ulGTSSLCTR', 'Value': '0x00000001UL']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ulGTSSLCTR', 'Value': 'CAN_GTSSLCTRL_SLEEP_SET'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (CAN_VM0_RX_INTERRUPT == STD_ON) /* Defines the CAT2 interrupt mapping */ #if defined (Os_CAN_VM0_RX_CAT2_ISR) || (CAN_ISR_CATEGORY_2 == STD_ON) ISR(CAN_VM0_RX_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, CAN_CODE_FAST) CAN_VM0_RX_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Can_RxVMIsr(CAN_PHYIDX_UNIT0, CAN_VM_CH0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_VMm_RX_INTERRUPT\\n(m=0 to 15)', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'Os_CAN_VM0_RX_CAT2_ISR', 'Value': 'Not Defined'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Count1', 'Value': '6 = CAN_VM14_RX_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucUnit', 'Value': 'CAN_PHYIDX_UNIT1'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucVMChannel', 'Value': 'CAN_VM_CH14'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CAN_START_SEC_PUBLIC_CODE #include \"Can_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Can_CommonReturnType, CAN_PUBLIC_CODE) Can_Write( /* PRQA S 1503 # JV-01 */ VAR(Can_HwHandleType, AUTOMATIC) Hth, P2CONST(Can_PduType, AUTOMATIC, CAN_APPL_DATA) PduInfo) /* PRQA S 3432 # JV-01 */ { VAR(Can_CommonReturnType, AUTOMATIC) LenReturnValue; #if ((CAN_TX_BUFFER == STD_ON) || (CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) #if (CAN_TRIGGER_TRANSMIT_FUNCTION == STD_ON) VAR(PduInfoType, AUTOMATIC) LstTTPduInfo; VAR(uint32, AUTOMATIC) LaaTTSduData[CAN_LOCALBUFFER_SIZE_32]; /* PRQA S 3678 # JV-01 */ VAR(Std_ReturnType, AUTOMATIC) LenCanIfResult; #endif P2CONST(Can_HohConfigType, AUTOMATIC, CAN_APPL_DATA) LpHoh; /* PRQA S 3432 # JV-01 */ VAR(Can_TxRegSetType, AUTOMATIC) LstTxRegSet; VAR(uint8, AUTOMATIC) LucSduLength; P2VAR(uint8, AUTOMATIC, CAN_APPL_DATA) LpSduPtr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(uint32, AUTOMATIC) LulDLC; VAR(uint32, AUTOMATIC) LulActualLength; VAR(uint8, AUTOMATIC) LucController; VAR(boolean, AUTOMATIC) LblHohAccessFlag; #endif /* ((CAN_TX_BUFFER == STD_ON) || (CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) */ // /** DET Checking **/ // #if (CAN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not initialized */ if (CAN_FALSE == Can_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_WRITE_SID, CAN_E_UNINIT); LenReturnValue = CAN_COMMON_NOT_OK; } /* Report to DET, if HTH is out of range */ else if ((Can_GpConfig->usNoOfHohs <= Hth) || (CAN_HOH_HTH != Can_GpHohConfig[Hth].enHoh)) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_WRITE_SID, CAN_E_PARAM_HANDLE); LenReturnValue = CAN_COMMON_NOT_OK; } /* Report to DET, if PduInfo or SduPtr is NULL */ else if ((NULL_PTR == PduInfo) || ((NULL_PTR == PduInfo->sdu) #if (CAN_TRIGGER_TRANSMIT_FUNCTION == STD_ON) && (CAN_FALSE == Can_GpHohConfig[Hth].blTriggerTransmitEnable) #endif )) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_WRITE_SID, CAN_E_PARAM_POINTER); LenReturnValue = CAN_COMMON_NOT_OK; } /* Check payload length */ else if ((Can_GpHohConfig[Hth].ucTMDLC < PduInfo->length) #if (CAN_RSCANFD_CONFIGURED == STD_ON) || ((CAN_STD_MAX_PAYLOAD < PduInfo->length) && ((0UL == (uint32)(PduInfo->id & CAN_FD_FRAME_FORMAT)) || (CAN_FALSE == Can_GpPBController[Can_GpHohConfig[Hth].ucController] .pBaudrateConfig[Can_GaaCtrlState[Can_GpHohConfig[Hth].ucController].ulBaudrateIndex].blFdConfigured))) /* PRQA S 2844 # JV-01 */ #endif ) { (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_WRITE_SID, #if (CAN_AR_VERSION == CAN_AR_422_VERSION) CAN_E_PARAM_DLC); #elif (CAN_AR_VERSION == CAN_AR_431_VERSION) || (CAN_AR_VERSION == CAN_AR_1911_VERSION) CAN_E_PARAM_DATA_LENGTH); #endif LenReturnValue = CAN_COMMON_NOT_OK; } else #endif /* (CAN_DEV_ERROR_DETECT == STD_ON) */ { /* To check if PN is activated or not */ #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) if (CAN_ICOM_ACTIVATION != Can_GblIcomStatus) /* PRQA S 3416 # JV-01 */ #endif { #if ((CAN_TX_BUFFER == STD_ON) || (CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) // /** Prepare data **/ // LpHoh = &Can_GpHohConfig[Hth]; /* Getting the value of ucController Id*/ LucController = LpHoh->ucController; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Initial local Hoh access flag */ LblHohAccessFlag = CAN_FALSE; /* Critical section is required in case of the reentant call on same HTH */ CAN_ENTER_CRITICAL_SECTION(CAN_RAM_DATA_PROTECTION); /* Check whether global flag for other hardware is already set or not */ if (CAN_TRUE != Can_GaaHwAccessFlag[LpHoh->usHohId]) /* PRQA S 2844 # JV-01 */ { /* Set the global flag which indicates HOH is being accessed to true */ Can_GaaHwAccessFlag[LpHoh->usHohId] = CAN_TRUE; /* PRQA S 2844 # JV-01 */ LblHohAccessFlag = CAN_TRUE; } /* else No action required */ CAN_EXIT_CRITICAL_SECTION(CAN_RAM_DATA_PROTECTION); if (CAN_TRUE == LblHohAccessFlag) { // /** Check whether device is busy and get address of registers **/ // LenReturnValue = Can_GetTxRegPointers(&LstTxRegSet, LpHoh); // /** Trigger Transmission **/ // LucSduLength = PduInfo->length; LpSduPtr = PduInfo->sdu; #if (CAN_TRIGGER_TRANSMIT_FUNCTION == STD_ON) /* If SDU in the parameter is NULL, get SDU from CanIf */ if ((CAN_COMMON_OK == LenReturnValue) && (NULL_PTR == PduInfo->sdu) && (CAN_TRUE == LpHoh->blTriggerTransmitEnable)) { LstTTPduInfo.SduDataPtr = (P2VAR(uint8, AUTOMATIC, CAN_APPL_DATA))LaaTTSduData; /* PRQA S 0751, 3432 # JV-01, JV-01 */ LstTTPduInfo.SduLength = (PduLengthType)(CAN_LOCALBUFFER_SIZE_32 * sizeof(uint32)); LenCanIfResult = CanIf_TriggerTransmit(PduInfo->swPduHandle, &LstTTPduInfo); if (E_OK == LenCanIfResult) { /* Use LstTTPduInfo instead of the original parameter */ LucSduLength = (uint8)LstTTPduInfo.SduLength; LpSduPtr = LstTTPduInfo.SduDataPtr; } else { #if ((CAN_DEV_ERROR_DETECT == STD_ON) && (CAN_AR_VERSION == CAN_AR_422_VERSION)) (void)Det_ReportError(CAN_MODULE_ID, CAN_INSTANCE_ID, CAN_WRITE_SID, CAN_E_PARAM_POINTER); #endif LenReturnValue = CAN_COMMON_NOT_OK; } } /* else No action required */ #endif /* (CAN_TRIGGER_TRANSMIT_FUNCTION == STD_ON) */ // /** Send data **/ // if (CAN_COMMON_OK == LenReturnValue) { /* If EXTENDED ID format, set IDE bit */ if (0UL != (uint32)(PduInfo->id & CAN_EXTENDED_FORMAT)) { *LstTxRegSet.pID = (uint32)(PduInfo->id & CAN_ID_TYPE_IDMASK) | CAN_RSCAN_THLEN | CAN_RSCAN_IDE; /* PRQA S 2814 # JV-01 */ } else { *LstTxRegSet.pID = (uint32)(PduInfo->id & CAN_ID_TYPE_IDMASK) | CAN_RSCAN_THLEN; } /* When classical CAN, DLC is as is */ LulDLC = LucSduLength; LulActualLength = LulDLC; #if (CAN_RSCANFD_CONFIGURED == STD_ON) #if (CAN_RSCAN_CONFIGURED == STD_ON) if (CAN_MACRO_RSCAN == Can_GaaRegs[Can_GpPCController[LpHoh->ucController].ucUnit].enMacroType) { /* No pCTR for RSCAN */ } else #endif { if (0UL != (uint32)(PduInfo->id & CAN_FD_FRAME_FORMAT)) { if (CAN_TRUE == Can_GpPBController[LucController] .pBaudrateConfig[Can_GaaCtrlState[LucController].ulBaudrateIndex].blBRS) /* PRQA S 2844 # JV-01 */ { /* PRQA S 0715 # JV-01 */ *LstTxRegSet.pCTR = CAN_RSCAN_XXFDF | CAN_RSCAN_XXBRS; /* PRQA S 2814 # JV-01 */ } else { /* PRQA S 0715 # JV-01 */ *LstTxRegSet.pCTR = CAN_RSCAN_XXFDF; } /* Convert payload length (0-64byte) to DLC value (0x0-0xF) */ LulDLC = Can_GaaDLCFromPayloadTable[LucSduLength]; /* PRQA S 2844 # JV-01 */ LulActualLength = Can_GaaPayloadFromDLCTable[LulDLC]; /* PRQA S 2844 # JV-01 */ } else { *LstTxRegSet.pCTR = 0UL; } #if (CAN_LABEL_DATA_LOCATION == CAN_CTR_REG) /* Set CTR reg value with PduHandle as label data */ *LstTxRegSet.pCTR |= CAN_RSCAN_XXPTR(PduInfo->swPduHandle); #endif } #endif /* Set PTR reg value, including DLC */ *LstTxRegSet.pPTR = /* PRQA S 2814 # JV-01 */ #if (CAN_LABEL_DATA_LOCATION == CAN_PTR_REG) CAN_RSCAN_XXPTR(PduInfo->swPduHandle) | #endif CAN_RSCAN_XXDLC(LulDLC); /* Copy payload data to data register */ Can_WriteDataReg(LpSduPtr, LstTxRegSet.pDF, (uint32)LucSduLength, LulActualLength, #if (CAN_RSCANFD_CONFIGURED == STD_ON) LpHoh->ucPaddingValue #else 0x00U #endif ); /* Start transmission */ *LstTxRegSet.pTrig = LstTxRegSet.ucTrigValue; /* PRQA S 2814 # JV-01 */ } /* else No action required */ /* Release this HTH */ /* Clear the global flag which indicates HOH is being accessed to false */ Can_GaaHwAccessFlag[LpHoh->usHohId] = CAN_FALSE; /* PRQA S 2844 # JV-01 */ } else /* if (CAN_TRUE == LblHohAccessFlag) */ { LenReturnValue = (Can_CommonReturnType)CAN_BUSY; } #else /* Return CAN_BUSY when no TX hardware buffer available */ LenReturnValue = (Can_CommonReturnType)CAN_BUSY; #if(CAN_DEV_ERROR_DETECT == STD_OFF) /* Casting void to avoid compiler warning */ (void)Hth; (void)PduInfo; #endif /* #if(CAN_DEV_ERROR_DETECT == STD_OFF) */ #endif /* ((CAN_TX_BUFFER == STD_ON) || (CAN_TX_COMFIFO == STD_ON) || (CAN_TX_QUEUE == STD_ON)) */ } #if (CAN_PUBLIC_ICOM_SUPPORT == STD_ON) else { /* SWS_Can_00470: Return CAN_BUSY when PN is activated */ LenReturnValue = (Can_CommonReturnType) CAN_BUSY; } #endif } /* if (DET check) */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_TRIGGER_TRANSMIT_FUNCTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CAN_RSCANFD_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Hth', 'Value': '2'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR / !NULL_PTR', 'Name': 'PduInfo', 'Value': '&map_PduInfo[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'sdu', 'Value': '&map_sdu[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'length', 'Value': '7'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'id', 'Value': '~CAN_FD_FRAME_FORMAT'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'swPduHandle', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblInitialized', 'Value': 'CAN_TRUE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpConfig', 'Value': '&map_Can_GpConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '1..65535', 'Name': 'usNoOfHohs', 'Value': '3'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpHohConfig', 'Value': '&map_Can_GpHohConfig[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GblIcomStatus', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': 'CAN_HOH_HRH\\nCAN_HOH_HTH', 'Name': 'enHoh', 'Value': '[2] = CAN_HOH_HTH'], 'Input_Param_014': ['Type': 'Array', 'Range': 'CAN_TRUE/CAN_FALSE', 'Name': 'blTriggerTransmitEnable', 'Value': '[2] = CAN_TRUE'], 'Input_Param_015': ['Type': 'Array', 'Range': '0..64', 'Name': 'ucTMDLC', 'Value': '[2] = 6'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'ucController', 'Value': '[2] = 0'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ucPaddingValue', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'usHohId', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulBaudrateIndex', 'Value': '0'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPBController', 'Value': '&map_Can_GpPBController[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pBaudrateConfig', 'Value': '&map_pBaudrateConfig[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'blFdConfigured', 'Value': 'CAN_TRUE'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'blBRS', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GpPCController', 'Value': '&map_Can_GpPCController[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ucUnit', 'Value': '-'], 'Input_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'map_Can_GaaDLCFromPayloadTable[0 to 64]', 'Value': '-'], 'Input_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'map_Can_GaaPayloadFromDLCTable[0 to 15]', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '-', 'Name': 'P2CONST_Can_GaaRegs', 'Value': '&Can_GaaRegs[0]'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'enMacroType', 'Value': '-'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GaaHwAccessFlag[0]', 'Value': '-'], 'Input_Param_031': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '<Not Called>'], 'Input_Param_032': ['Type': 'Output_Argument', 'Range': '', 'Name': 'LpRegSet->pID', 'Value': '<Not Called>'], 'Input_Param_033': ['Type': 'Output_Argument', 'Range': '', 'Name': 'LpRegSet->pCTR', 'Value': '<Not Called>'], 'Input_Param_034': ['Type': 'Output_Argument', 'Range': '', 'Name': 'LpRegSet->pPTR', 'Value': '<Not Called>'], 'Input_Param_035': ['Type': 'Output_Argument', 'Range': '', 'Name': 'LpRegSet->pDF', 'Value': '<Not Called>'], 'Input_Param_036': ['Type': 'Output_Argument', 'Range': '', 'Name': 'LpRegSet->pTrig', 'Value': '<Not Called>'], 'Input_Param_037': ['Type': 'Output_Argument', 'Range': '', 'Name': 'LpRegSet->ucTrigValue', 'Value': '<Not Called>'], 'Input_Param_038': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '<Not Called>']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegSet', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpHoh', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'TxPduId', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'PduInfoPtr', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CAN_MODULE_ID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CAN_INSTANCE_ID'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CAN_WRITE_SID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CAN_E_PARAM_DLC'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSrc', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpDF', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSrcLength', 'Value': '<Not Called>'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDestLength', 'Value': '<Not Called>'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucPadding', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pID[0]', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCTR[0]', 'Value': '-'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPTR[0]', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTrig[0]', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Can_GaaHwAccessFlag[0]', 'Value': '-'], 'Output_Param_020': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'CAN_COMMON_NOT_OK'], 'Output_Param_021': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CDDCRC_START_SEC_PUBLIC_CODE #include \"CddCrc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDCRC_PUBLIC_CODE) CddCrc_Compare /* PRQA S 1503, 3432 # JV-01, JV-01 */ ( CddCrc_ChannelType LddChannelId, P2CONST(uint8, AUTOMATIC, CDDCRC_APPL_DATA) LpDataIn, /* PRQA S 3432 # JV-01 */ P2CONST(uint32, AUTOMATIC, CDDCRC_APPL_DATA) LpExpData, /* PRQA S 3432 # JV-01 */ CddCrc_CompareFreqType LenCompFreq, uint32 LulConvSize ) { /* Declare local variables */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; VAR(uint8, AUTOMATIC) LucHWIPType; P2CONST(CddCrc_ChannelConfigType, AUTOMATIC, CDDCRC_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulDataLength; /* Initialize local variable */ LddReturnValue = E_OK; /* Check driver initialization status */ if (CDDCRC_INITIALIZED != CddCrc_GblDriverStatus) { #if (CDDCRC_DEV_ERROR_DETECT == STD_ON) /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_COMPARE_SID, CDDCRC_E_UNINIT); #endif LddReturnValue = E_NOT_OK; } #if (CDDCRC_DEV_ERROR_DETECT == STD_ON) /* Check input and expected data pointer */ else if ((NULL_PTR == LpDataIn) || (NULL_PTR == LpExpData)) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_COMPARE_SID, CDDCRC_E_PARAM_POINTER); LddReturnValue = E_NOT_OK; } /* Validate of input data size */ else if ((FREQ_16_BYTE > LenCompFreq) || (FREQ_64_BYTE < LenCompFreq)) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_COMPARE_SID, CDDCRC_E_PARAM_COMPARE_FREQ); LddReturnValue = E_NOT_OK; } /* Check channel ID */ else if ((CddCrc_ChannelType)CDDCRC_TOTAL_CHANNELS_CONFIG <= LddChannelId) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_COMPARE_SID, CDDCRC_E_PARAM_CHANNEL); LddReturnValue = E_NOT_OK; } /* Check for Conversion size and 16 byte alignment for output data */ else if (((uint32)CDDCRC_MAX_CONVERSIONSIZE < LulConvSize) || (CDDCRC_ZERO_32 == LulConvSize)) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_COMPARE_SID, CDDCRC_E_PARAM_CONVERSION_SIZE); LddReturnValue = E_NOT_OK; } /* Check if the mode is invalid */ else if (CDDCRC_HWIP_AES_ACC == CddCrc_GpChannelConfig[LddChannelId].ucHWIPType) /* PRQA S 2824 # JV-01 */ { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_COMPARE_SID, CDDCRC_E_INCOMPATIBLE_HWIP); LddReturnValue = E_NOT_OK; } #endif /* CDDCRC_DEV_ERROR_DETECT == STD_ON */ else { /* No action is required */ } if (E_OK == LddReturnValue) { /* Enter critical section */ CDDCRC_ENTER_CRITICAL_SECTION(CDDCRC_RAM_DATA_PROTECTION); /* Check current status of selected channel */ if (CDDCRC_CH_BUSY == CddCrc_GaaChannelState[LddChannelId].enStatus) /* PRQA S 2844 # JV-01 */ { /* Set return value to E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { /* Set current status of selected channel to BUSY */ CddCrc_GaaChannelState[LddChannelId].enStatus = CDDCRC_CH_BUSY; /* PRQA S 2844 # JV-01 */ } /* Exit critical section */ CDDCRC_EXIT_CRITICAL_SECTION(CDDCRC_RAM_DATA_PROTECTION); if (E_OK == LddReturnValue) { LpChannel = &CddCrc_GpChannelConfig[LddChannelId]; /* PRQA S 2824 # JV-01 */ LucHWIPType = LpChannel->ucHWIPType; /* PRQA S 2814 # JV-01 */ if (NULL_PTR != CddCrc_GaaHWFunc[LucHWIPType]) { /* Set initial CRC code and conversion size */ CddCrc_GaaHWFunc[LucHWIPType]->pInitModule(LddChannelId, LulConvSize); /* PRQA S 2814 # JV-01 */ } else { /* No action is required */ } /* Set compare */ CddCrc_WCRC_SetCompare((uint8)LddChannelId, LenCompFreq); /* Calculate data length */ LulDataLength = (1UL << (uint32)LenCompFreq) * LulConvSize; /* PRQA S 3384 # JV-01 */ /* Set up descriptor for comparison */ CddCrc_WCRC_DescSetup((uint8)LddChannelId, (volatile P2CONST(void, AUTOMATIC, CDDCRC_APPL_DATA))LpDataIn, /* PRQA S 0314, 3432 # JV-01, JV-01 */ (volatile P2CONST(void, AUTOMATIC, CDDCRC_APPL_DATA))LpExpData, /* PRQA S 0314, 3432 # JV-01, JV-01 */ LenCompFreq, LulDataLength); /* Start descriptors */ CddCrc_WCRC_DescStart((uint8)LddChannelId, 2UL, 0U); } else { /* No action required */ } } else { /* No action required */ } return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': 'CDDCRC_INITIALIZED/CDDCRC_UNINITIALIZED', 'Name': 'CddCrc_GblDriverStatus', 'Value': 'CDDCRC_INITIALIZED'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CDDCRC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpDataIn', 'Value': '&map_LpDataIn[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LpExpData', 'Value': '&map_LpExpData[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '-', 'Name': 'LenCompFreq', 'Value': '2'], 'Input_Param_005': ['Type': 'Argument', 'Range': '-', 'Name': 'LddChannelId', 'Value': '0'], 'Input_Param_006': ['Type': 'Argument', 'Range': '-', 'Name': 'LulConvSize', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'CddCrc_GpChannelConfig', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWIPType', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enStatus', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpExpData[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': 'CDDCRC_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': 'CDDCRC_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': 'CDDCRC_COMPARE_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': 'CDDCRC_E_PARAM_CONVERSION_SIZE'], 'Output_Param_004': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'enStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LddChannelId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LulConvSize', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LddChannelId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCompFreq', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpDataIn', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpExpData', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCmpFreq', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDataLength', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDescCount', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucOffsetFromBase', 'Value': '-'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CDDCRC_START_SEC_CODE_FAST #include \"CddCrc_MemMap.h\" STATIC FUNC (void, CDDCRC_CODE_FAST) CddCrc_DmaISR(uint8 LucDmaChannel) { /* Declare local variable */ VAR(uint8, AUTOMATIC) LucChannelIdx; P2CONST(CddCrc_ChannelConfigType, AUTOMATIC, CDDCRC_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ P2CONST(CddCrc_DmaConfigType, AUTOMATIC, CDDCRC_CONFIG_DATA) LpDmaConfig; /* PRQA S 3432 # JV-01 */ VAR(CddCrc_CompareResultType, AUTOMATIC) LddCompareResult; /* Initialize local variable */ LpDmaConfig = &CddCrc_GpDmaChannelConfig[LucDmaChannel]; /* PRQA S 2824 # JV-01 */ LucChannelIdx = LpDmaConfig->ucChannelIdx; /* PRQA S 2814 # JV-01 */ LpChannel = &CddCrc_GpChannelConfig[LucChannelIdx]; /* PRQA S 2824 # JV-01 */ #if (CDDCRC_UNINTENDED_INTERRUPT_CHECK == STD_ON) if (((CDDCRC_DMA_TE | CDDCRC_DMA_INT) == (LpDmaConfig->pDmaRegs->ulCHCR & (CDDCRC_DMA_TE | CDDCRC_DMA_INT))) /* PRQA S 2814 # JV-01 */ || ((CDDCRC_DMA_DSE | CDDCRC_DMA_DSIE) == (LpDmaConfig->pDmaRegs->ulCHCR & (CDDCRC_DMA_DSE | CDDCRC_DMA_DSIE)))) #endif /* CDDCRC_UNINTENDED_INTERRUPT_CHECK == STD_ON */ { /* Disable interrupt, disable DMA transfer and clear bit TE */ LpDmaConfig->pDmaRegs->ulCHCR &= ~(CDDCRC_DMA_INT | CDDCRC_DMA_TE | CDDCRC_DMA_ENABLE); if (0UL != (LpChannel->pWcrcRegs->ulSTS & CDDCRC_STOP_DONE)) /* PRQA S 2814 # JV-01 */ { if (0UL != (LpChannel->pWcrcRegs->ulSTS & CDDCRC_COMP_DONE)) { /* Call notification */ if(NULL_PTR != LpChannel->pCompareEndNotification) { /* Get comparison result */ LddCompareResult = (uint16)(LpChannel->pWcrcRegs->ulCOMP_RES); /* Call notification */ LpChannel->pCompareEndNotification(LddCompareResult); /* PRQA S 2814 # JV-01 */ } else { /* No action required */ } } else { /* No action required */ } /* Clear bit stop-done by writing 1 to it */ LpChannel->pWcrcRegs->ulSTS &= CDDCRC_STOP_DONE; /* Update the channel status to stopped */ CddCrc_GaaChannelState[LucChannelIdx].enStatus = CDDCRC_CH_STOPPED; /* PRQA S 2844 # JV-01 */ #if (CDDCRC_UNINTENDED_MODULE_STOP_CHECK == STD_ON) /* Bit in_en of WCRCm_XXXX_EN is cleared by stop command */ CddCrc_GaaMirrorRegs[LucChannelIdx].ulEN &= ~1UL; /* PRQA S 2844 # JV-01 */ #endif } else if (0UL != (LpChannel->pWcrcRegs->ulSTS & CDDCRC_CMD_DONE)) { /* Check if current event is comparing end interrupt */ if ((CDDCRC_RES_CMP_ENDFLAG | CDDCRC_BUF_EMPTY) == (LpChannel->pWcrcRegs->ulBUF_STS & (CDDCRC_RES_CMP_ENDFLAG | CDDCRC_BUF_EMPTY))) { /* Stop channel by CPU */ LpChannel->pWcrcRegs->ulSTOP |= 1UL; /* Check if channel status is stop_done */ if (0UL != (LpChannel->pWcrcRegs->ulSTS & CDDCRC_STOP_DONE)) { /* Clear status bits */ LpChannel->pWcrcRegs->ulSTS &= CDDCRC_STOP_DONE; /* Update the channel status to stopped */ CddCrc_GaaChannelState[LucChannelIdx].enStatus = CDDCRC_CH_STOPPED; /* PRQA S 2844 # JV-01 */ /* Store value for unintended module stop check */ #if (CDDCRC_UNINTENDED_MODULE_STOP_CHECK == STD_ON) /* WCRCm_XXXX_EN is cleared when stop by CPU */ CddCrc_GaaMirrorRegs[LucChannelIdx].ulEN = 0UL; /* PRQA S 2844 # JV-01 */ #endif /* Call notification */ if(NULL_PTR != LpChannel->pCompareEndNotification) { /* Get comparison result */ LddCompareResult = (CddCrc_CompareResultType)(LpChannel->pWcrcRegs->ulCOMP_RES); /* Call notification */ LpChannel->pCompareEndNotification(LddCompareResult); } else { /* No action required */ } } else { /* No action required */ } } else { /* Update the channel status to OK */ CddCrc_GaaChannelState[LucChannelIdx].enStatus = CDDCRC_CH_OK; /* PRQA S 2844 # JV-01 */ } /* End of checking current event */ /* Clear bit res-done and cmd-done by writing 1 to them */ LpChannel->pWcrcRegs->ulSTS &= CDDCRC_CMD_DONE; } else if (0UL != (LpChannel->pWcrcRegs->ulSTS & CDDCRC_RES_DONE)) { /* Clear bit res-done and cmd-done by writing 1 to them */ LpChannel->pWcrcRegs->ulSTS &= CDDCRC_RES_DONE; /* Update the channel status to OK */ CddCrc_GaaChannelState[LucChannelIdx].enStatus = CDDCRC_CH_OK; /* PRQA S 2844 # JV-01 */ } else if ((DATA_THROUGH_MODE == CddCrc_GaaChannelState[LucChannelIdx].enMode) /* PRQA S 2844 # JV-01 */ || (E2E_PLUS_DATA_THROUGH_MODE == CddCrc_GaaChannelState[LucChannelIdx].enMode)) { /* Update the channel status to OK */ CddCrc_GaaChannelState[LucChannelIdx].enStatus = CDDCRC_CH_OK; /* PRQA S 2844 # JV-01 */ } else { #if defined(CDDCRC_E_HARDWARE_ERROR) (void)Dem_SetEventStatus(CDDCRC_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); #endif } } #if (CDDCRC_UNINTENDED_INTERRUPT_CHECK == STD_ON) else { (void)Dem_SetEventStatus(CDDCRC_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON / STD_OFF', 'Name': 'CDDCRC_UNINTENDED_INTERRUPT_CHECK', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucDmaChannel', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'CddCrc_GpDmaChannelConfig', 'Value': '&map_CddCrc_GpDmaChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelIdx', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pDmaRegs', 'Value': '&map_pDmaRegs[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulCHCR', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'CddCrc_GpChannelConfig', 'Value': '&map_CddCrc_GpChannelConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pWcrcRegs', 'Value': '&map_pWcrcRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulSTS', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulEN', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulCMDEN', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pCompareEndNotification', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulSTOP', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulCOMP_RES', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulBUF_STS', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'INDEPENDENT_MODE\\nE2E_MODE\\nAES_ACC_MODE\\nDATA_THROUGH_MODE\\nE2E_PLUS_DATA_THROUGH_MODE', 'Name': 'enMode', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulEN', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'ulCMDEN', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'EventId', 'Value': 'CDDCRC_E_INTERRUPT_CONTROLLER_FAILURE'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Variable', 'Range': '-', 'Name': 'ulCHCR', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '-', 'Name': 'ulSTS', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '-', 'Name': 'ulSTOP', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LddResult', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'enStatus', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'ulEN', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'ulCMDEN', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if (CDDCRC_VERSION_INFO_API == STD_ON) #define CDDCRC_START_SEC_PUBLIC_CODE #include \"CddCrc_MemMap.h\" FUNC(void, CDDCRC_PUBLIC_CODE) CddCrc_GetVersionInfo /* PRQA S 1503 # JV-01 */ ( P2VAR(Std_VersionInfoType, AUTOMATIC, CDDCRC_APPL_DATA) VersionInfoPtr /* PRQA S 3432 # JV-01 */ ) { /* Parameter check */ if (NULL_PTR == VersionInfoPtr) { #if (CDDCRC_DEV_ERROR_DETECT == STD_ON) /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_GET_VERSION_INFO_SID, CDDCRC_E_PARAM_POINTER); #endif /* CDDCRC_DEV_ERROR_DETECT == STD_ON */ } else { /* Write version information */ VersionInfoPtr->vendorID = CDDCRC_VENDOR_ID; VersionInfoPtr->moduleID = CDDCRC_MODULE_ID; VersionInfoPtr->sw_major_version = CDDCRC_SW_MAJOR_VERSION; VersionInfoPtr->sw_minor_version = CDDCRC_SW_MINOR_VERSION; VersionInfoPtr->sw_patch_version = CDDCRC_SW_PATCH_VERSION; } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CDDCRC_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'VersionInfoPtr', 'Value': 'NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '-', 'Name': 'map_versioninfo[0].vendorID', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'map_versioninfo[0].moduleID', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'map_versioninfo[0].sw_major_version', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'map_versioninfo[0].sw_minor_version', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'map_versioninfo[0].sw_patch_version ', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CDDCRC_START_SEC_PRIVATE_CODE #include \"CddCrc_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, CDDCRC_PRIVATE_CODE) CddCrc_KCRC_HWInit ( CddCrc_ChannelType LddChannelID ) { /* Local pointer to KCRC channel configuration */ P2CONST(CddCrc_KcrcModuleConfigType, AUTOMATIC, CDDCRC_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpKcrcChannelConfig; /* Place holder for value of KCRCmCTL Register */ VAR(uint32, AUTOMATIC) LulKCRCmCTLVal; /* Place holder for value of KCRCmPOLY Register */ VAR(uint32, AUTOMATIC) LulKCRCmPOLYVal; /* Initialize local variable */ LulKCRCmPOLYVal = CDDCRC_ZERO_32; /* Initialize local pointer */ LpKcrcChannelConfig = CddCrc_GpChannelConfig[LddChannelID].pChannelConfig; /* PRQA S 0317, 2824 # JV-01, JV-01 */ /* Set bit width input data */ LulKCRCmCTLVal = CDDCRC_KCRC_DW; /* Set modes */ LulKCRCmCTLVal |= LpKcrcChannelConfig->ulCMDValue; /* PRQA S 2814 # JV-01 */ /* * Set up KCRCmCTL value to select polynomial size * Set up poly value for KCRCmPOLY register * Set up XOR value */ switch (LpKcrcChannelConfig->enPoly) { case CDDCRC_POLY_32_ETH: /* Select poly size */ LulKCRCmCTLVal |= CDDCRC_KCRC_PSIZE_32; /* Set up poly value for KCRCmPOLY register */ LulKCRCmPOLYVal = CDDCRC_KCRC_32_ETH; break; case CDDCRC_POLY_32_1EDC6F41: /* Select poly size */ LulKCRCmCTLVal |= CDDCRC_KCRC_PSIZE_32; /* Set up poly value for KCRCmPOLY register */ LulKCRCmPOLYVal = CDDCRC_KCRC_32_1EDC6F41; break; case CDDCRC_POLY_16_CCITT: /* Select poly size */ LulKCRCmCTLVal |= CDDCRC_KCRC_PSIZE_16; /* Set up poly value for KCRCmPOLY register */ LulKCRCmPOLYVal = CDDCRC_KCRC_16_CCITT; break; case CDDCRC_POLY_8_SAE_J1850: /* Select poly size */ LulKCRCmCTLVal |= CDDCRC_KCRC_PSIZE_8; /* Set up poly value for KCRCmPOLY register */ LulKCRCmPOLYVal = CDDCRC_KCRC_8_SAE_J1850; break; case CDDCRC_POLY_8_0x2F: /* Select poly size */ LulKCRCmCTLVal |= CDDCRC_KCRC_PSIZE_8; /* Set up poly value for KCRCmPOLY register */ LulKCRCmPOLYVal = CDDCRC_KCRC_8_0x2F; break; default: /* Do nothing */ break; } /* end of switch (LddPoly) */ /* Write value to KCRCmCTL Register */ *(LpKcrcChannelConfig->pKCRCmCTLReg) = LulKCRCmCTLVal; /* PRQA S 2814 # JV-01 */ #if (CDDCRC_REGISTER_WRITE_VERIFY == STD_ON) (void)CddCrc_VerifyWriteRegister(LpKcrcChannelConfig->pKCRCmCTLReg, LulKCRCmCTLVal, CDDCRC_COMMON_MASK); #endif /* CDDCRC_REGISTER_WRITE_VERIFY == STD_ON */ /* Write value to KCRCmPOLY Register */ *(LpKcrcChannelConfig->pKCRCmPOLYReg) = LulKCRCmPOLYVal; /* PRQA S 2814 # JV-01 */ #if (CDDCRC_REGISTER_WRITE_VERIFY == STD_ON) (void)CddCrc_VerifyWriteRegister(LpKcrcChannelConfig->pKCRCmPOLYReg, LulKCRCmPOLYVal, CDDCRC_COMMON_MASK); #endif /* CDDCRC_REGISTER_WRITE_VERIFY == STD_ON */ /* Write XOR value to KCRCmXOR register */ *(LpKcrcChannelConfig->pKCRCmXORReg) = LpKcrcChannelConfig->ulKCRCmXOR; /* PRQA S 2814 # JV-01 */ #if (CDDCRC_REGISTER_WRITE_VERIFY == STD_ON) (void)CddCrc_VerifyWriteRegister(LpKcrcChannelConfig->pKCRCmXORReg, LpKcrcChannelConfig->ulKCRCmXOR, CDDCRC_COMMON_MASK); #endif /* CDDCRC_REGISTER_WRITE_VERIFY == STD_ON */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CDDCRC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0.. 2', 'Name': 'LddChannelID', 'Value': '2'], 'Input_Param_002': ['Type': 'Variable', 'Range': '-', 'Name': 'CddCrc_GpChannelConfig', 'Value': '&map_CddCrc_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '-', 'Name': 'pChannelConfig', 'Value': '&map_CddCrc_GpKcrcChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0.. 4294967295', 'Name': 'ulKCRCmXOR', 'Value': '0x0000FFFF'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0.. 4294967295', 'Name': 'ulCMDValue', 'Value': '0x00000130'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0.. 8', 'Name': 'enPoly', 'Value': '7'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0.. 4294967295', 'Name': 'pKCRCmCTLReg', 'Value': '&map_pKCRCmCTLReg[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0.. 4294967295', 'Name': 'pKCRCmPOLYReg', 'Value': '&map_pKCRCmPOLYReg[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0.. 4294967295', 'Name': 'pKCRCmXORReg', 'Value': '&map_pKCRCmXORReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pKCRCmCTLReg[0]', 'Value': '0x00000133'], 'Output_Param_001': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pKCRCmPOLYReg[0]', 'Value': '0'], 'Output_Param_002': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pKCRCmXORReg[0]', 'Value': '0x0000FFFF'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '[1] = Called\\n[2] = Called\\n[3] = Called'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CDDCRC_START_SEC_PUBLIC_CODE #include \"CddCrc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(CddCrc_ReturnType, CDDCRC_PUBLIC_CODE) CddCrc_Process /* PRQA S 1503 # JV-01 */ ( CddCrc_ChannelType LddChannelID, uint32 LulDataSize, CrcInDataPtr LpDataIn, CrcOutDataPtr LpDataOut ) { /* Place holder for return value */ VAR(CddCrc_ReturnType, AUTOMATIC) LddReturnValue; /* Place holder for HWIP type */ VAR(uint8, AUTOMATIC) LucHWIPType; /* Place holder for value of CRC code */ VAR(uint32, AUTOMATIC) LulCRCVal; /* Initialize local variables */ LddReturnValue = CDDCRC_OK; /* Check driver initialization status */ if (CDDCRC_INITIALIZED != CddCrc_GblDriverStatus) { #if (CDDCRC_DEV_ERROR_DETECT == STD_ON) /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_PROCESS_SID, CDDCRC_E_UNINIT); #endif LddReturnValue = CDDCRC_NOT_OK; } #if (CDDCRC_DEV_ERROR_DETECT == STD_ON) /* Check input and output data pointer */ else if ((NULL_PTR == LpDataIn) || (NULL_PTR == LpDataOut)) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_PROCESS_SID, CDDCRC_E_PARAM_POINTER); LddReturnValue = CDDCRC_NOT_OK; } /* Validate of input data size */ else if (CDDCRC_ZERO_32 == LulDataSize) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_PROCESS_SID, CDDCRC_E_PARAM_LENGTH); LddReturnValue = CDDCRC_NOT_OK; } /* Check channel ID */ else if ((CddCrc_ChannelType)CDDCRC_TOTAL_CHANNELS_CONFIG <= LddChannelID) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_PROCESS_SID, CDDCRC_E_PARAM_CHANNEL); LddReturnValue = CDDCRC_NOT_OK; } #endif /* CDDCRC_DEV_ERROR_DETECT == STD_ON */ else { /* No action is required since DET check */ } /* Cast E_OK to the same type with RHS for comparison */ if (CDDCRC_OK == LddReturnValue) { /* Enter critical section */ CDDCRC_ENTER_CRITICAL_SECTION(CDDCRC_RAM_DATA_PROTECTION); /* Check current status of selected channel */ if (CDDCRC_CH_BUSY == CddCrc_GaaChannelState[LddChannelID].enStatus) /* PRQA S 2844 # JV-01 */ { /* Return channel busy */ LddReturnValue = CDDCRC_BUSY; } else { /* Set current status of selected channel to BUSY */ CddCrc_GaaChannelState[LddChannelID].enStatus = CDDCRC_CH_BUSY; /* PRQA S 2844 # JV-01 */ } /* Exit critical section */ CDDCRC_EXIT_CRITICAL_SECTION(CDDCRC_RAM_DATA_PROTECTION); /* Channel status is OK */ if (CDDCRC_OK == LddReturnValue) { LucHWIPType = CddCrc_GpChannelConfig[LddChannelID].ucHWIPType; /* PRQA S 2824 # JV-01 */ /* Get output result */ if (NULL_PTR != CddCrc_GaaHWFunc[LucHWIPType]) { LulCRCVal = CddCrc_GaaHWFunc[LucHWIPType]->pGetOutputValue(LpDataIn, /* PRQA S 2814 # JV-01 */ LulDataSize, LddChannelID); /* Set CRC value to output pointer */ *LpDataOut = LulCRCVal; /* PRQA S 2814 # JV-01 */ } else { /* No action required */ } /* Set current status of selected channel to OK */ CddCrc_GaaChannelState[LddChannelID].enStatus = CDDCRC_CH_OK; /* PRQA S 2844 # JV-01 */ } else { /* Report application error */ } /* End of if ((uint8)CDDCRC_CH_OK == LddReturnValue) */ } else { /* No action required since DET checked */ } /* End of if (E_OK == LddReturnValue) */ /* Single exit point */ return LddReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CDDCRC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CDDCRC_KCRC', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..7', 'Name': 'LddChannelID', 'Value': '1'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulDataSize', 'Value': '1'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'LpDataIn', 'Value': '&map_LpDataIn[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'LpDataOut', 'Value': '&map_LpDataOut[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDCRC_INITIALIZED/ CDDCRC_UNINITIALIZED', 'Name': 'CddCrc_GblDriverStatus', 'Value': 'CDDCRC_INITIALIZED'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'enStatus', 'Value': 'CDDCRC_CH_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '0.. 4294967295', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'CddCrc_GpChannelConfig', 'Value': '&map_CddCrc_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'CDDCRC_HWIP_CRC (0x00)\\nCDDCRC_HWIP_KCRC (0x01)', 'Name': 'ucHWIPType', 'Value': 'CDDCRC_HWIP_AES_ACC'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpDataIn[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'enStatus', 'Value': 'CDDCRC_CH_OK'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LpDataIn', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LulDataSize', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LddChannelID', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'map_LpDataOut[0]', 'Value': '-'], 'Output_Param_011': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddReturnValue', 'Value': 'CDDCRC_OK'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CDDCRC_START_SEC_PUBLIC_CODE #include \"CddCrc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDCRC_PUBLIC_CODE) CddCrc_SetMode /* PRQA S 1503 # JV-01 */ ( CddCrc_ChannelType LddChannelId, CddCrc_ModeType LenMode ) { /* Place holder for error check */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize error check as no error occurred */ LddReturnValue = E_OK; /* Validate driver initialization status */ if (CDDCRC_INITIALIZED != CddCrc_GblDriverStatus) { #if (CDDCRC_DEV_ERROR_DETECT == STD_ON) /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_SETMODE_SID, CDDCRC_E_UNINIT); #endif LddReturnValue = E_NOT_OK; } else { #if (CDDCRC_DEV_ERROR_DETECT == STD_ON) /* Check if the mode is out of range */ if (E2E_PLUS_DATA_THROUGH_MODE < LenMode) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_SETMODE_SID, CDDCRC_E_PARAM_MODE); LddReturnValue = E_NOT_OK; } /* Check if channel id is out of range */ else if (CDDCRC_TOTAL_CHANNELS_CONFIG <= LddChannelId) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_SETMODE_SID, CDDCRC_E_PARAM_CHANNEL); LddReturnValue = E_NOT_OK; } /* Check if the mode is compatible with HWIP */ else if (((AES_ACC_MODE != LenMode) && (DATA_THROUGH_MODE != LenMode)) && (CDDCRC_HWIP_AES_ACC == CddCrc_GpChannelConfig[LddChannelId].ucHWIPType)) /* PRQA S 2824 # JV-01 */ { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_SETMODE_SID, CDDCRC_E_INCOMPATIBLE_HWIP); LddReturnValue = E_NOT_OK; } /* Check if the mode is compatible with HWIP */ else if ((AES_ACC_MODE == LenMode) && (CDDCRC_HWIP_AES_ACC != CddCrc_GpChannelConfig[LddChannelId].ucHWIPType)) { /* Report to Det */ (void)Det_ReportError(CDDCRC_MODULE_ID, CDDCRC_INSTANCE_ID, CDDCRC_SETMODE_SID, CDDCRC_E_INCOMPATIBLE_HWIP); LddReturnValue = E_NOT_OK; } else { /* No action required */ } #endif /* CDDCRC_DEV_ERROR_DETECT == STD_ON */ } if (E_OK == LddReturnValue) { /* Enter critical section */ CDDCRC_ENTER_CRITICAL_SECTION(CDDCRC_RAM_DATA_PROTECTION); /* Check current status of selected channel */ if (CDDCRC_CH_BUSY == CddCrc_GaaChannelState[LddChannelId].enStatus) /* PRQA S 2844 # JV-01 */ { LddReturnValue = E_NOT_OK; } else { /* Set mode for corresponding channel */ CddCrc_WCRC_SetMode((uint8)LddChannelId, LenMode); /* Set the channel status to OK */ CddCrc_GaaChannelState[LddChannelId].enStatus = CDDCRC_CH_OK; /* PRQA S 2844 # JV-01 */ /* Set the channel mode */ CddCrc_GaaChannelState[LddChannelId].enMode = LenMode; /* PRQA S 2844 # JV-01 */ } /* Exit critical section */ CDDCRC_EXIT_CRITICAL_SECTION(CDDCRC_RAM_DATA_PROTECTION); } else { /* No action required */ } return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CDDCRC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4', 'Name': 'LenMode', 'Value': 'E2E_MODE'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..15', 'Name': 'LddChannelId', 'Value': 'CDDCRC_TOTAL_CHANNELS_CONFIG'], 'Input_Param_003': ['Type': 'Variable', 'Range': '-', 'Name': 'CddCrc_GblDriverStatus', 'Value': 'CDDCRC_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'CddCrc_GpChannelConfig', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWIPType', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'enStatus', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': 'CDDCRC_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': 'CDDCRC_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': 'CDDCRC_SETMODE_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': 'CDDCRC_E_PARAM_CHANNEL'], 'Output_Param_004': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LucChannelIdx', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LenMode', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'enStatus', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'enMode', 'Value': '-'], 'Output_Param_009': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CDDCRC_START_SEC_PRIVATE_CODE #include \"CddCrc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDCRC_PRIVATE_CODE) CddCrc_WCRC_DescSetup /* PRQA S 1532 # JV-01 */ ( const uint8 LucChannelIdx, volatile CONSTP2CONST(void, AUTOMATIC, CDDCRC_APPL_DATA) LpDataIn, volatile CONSTP2CONST(void, AUTOMATIC, CDDCRC_APPL_DATA) LpExpData, const CddCrc_CompareFreqType LenCmpFreq, const uint32 LulDataLength ) { P2CONST(CddCrc_ChannelConfigType, AUTOMATIC, CDDCRC_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ P2VAR(CddCrc_DmaDescSetType, AUTOMATIC, CDDCRC_VAR_NO_INIT) LpDmaDescSet; /* PRQA S 3432 # JV-01 */ P2CONST(volatile CddCrc_FifoRegType, AUTOMATIC, REGSPACE) LpFifoRegs; /* PRQA S 3432 # JV-01 */ P2CONST(CddCrc_DmaConfigType, AUTOMATIC, CDDCRC_CONFIG_DATA) LpDmaConfig; /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulDPCR; VAR(uint32, AUTOMATIC) LulDMRS; VAR(uint32, AUTOMATIC) LulTS; /* Initialize local pointer to channel configuration */ LpChannel = &CddCrc_GpChannelConfig[LucChannelIdx]; /* PRQA S 2824 # JV-01 */ LpDmaDescSet = &CddCrc_GaaDmaDescSet[LucChannelIdx]; /* PRQA S 2934 # JV-01 */ LpFifoRegs = LpChannel->pFifoRegs; /* PRQA S 2814 # JV-01 */ LpDmaConfig = &CddCrc_GpDmaChannelConfig[LpChannel->ucResDmaIndex]; /* PRQA S 2824 # JV-01 */ /* First descriptor */ /* Setup for data transfer to data port */ LulDMRS = CDDCRC_RES2IN(LpDmaConfig->usDMRS); /* PRQA S 2814, 3469, 3383 # JV-01, JV-01, JV-01 */ LulDPCR = CDDCRC_DESC_4BYTE | CDDCRC_DESC_DMRS(LulDMRS) | CDDCRC_DESC_SM_INC | /* PRQA S 3469 # JV-01 */ CDDCRC_DESC_EXTENDED; /* SAR, DAR, TCR, DPCR */ LpDmaDescSet->aaDmaDesc[0].ulSAR = (uint32)LpDataIn; /* PRQA S 2844, 0326 # JV-01, JV-01 */ LpDmaDescSet->aaDmaDesc[0].ulDAR = (uint32)(&(LpFifoRegs->ulData)); /* PRQA S 0303, 2814 # JV-01, JV-01 */ LpDmaDescSet->aaDmaDesc[0].ulTCR = LulDataLength >> 2UL; LpDmaDescSet->aaDmaDesc[0].ulDPCR = LulDPCR; /* Second descriptor */ /* Setup for data transfer to expected data port */ /* Covert res to restx */ LulDMRS = CDDCRC_RES2EXP(LpDmaConfig->usDMRS); /* PRQA S 3383, 3469 # JV-01, JV-01 */ /* Get transfer size for corresponding comparison frequency */ switch (LenCmpFreq) { case FREQ_16_BYTE: LulTS = CDDCRC_DESC_16BYTE; break; case FREQ_32_BYTE: LulTS = CDDCRC_DESC_32BYTE; break; case FREQ_64_BYTE: LulTS = CDDCRC_DESC_64BYTE; break; default: LulTS = CDDCRC_DESC_16BYTE; break; } LulDPCR = LulTS | CDDCRC_DESC_DMRS(LulDMRS) | CDDCRC_DESC_SM_INC | /* PRQA S 3469 # JV-01 */ CDDCRC_DESC_EXTENDED; /* SAR, DAR, TCR, DPCR */ LpDmaDescSet->aaDmaDesc[1].ulSAR = (uint32)LpExpData; /* PRQA S 0326 # JV-01 */ LpDmaDescSet->aaDmaDesc[1].ulDAR = (uint32)(&(LpFifoRegs->ulExpData)); /* PRQA S 0303 # JV-01 */ LpDmaDescSet->aaDmaDesc[1].ulTCR = 1UL; LpDmaDescSet->aaDmaDesc[1].ulDPCR = LulDPCR; /* Third descriptor */ /* Covert in to in request */ LulDMRS = CDDCRC_RES2IN(LpDmaConfig->usDMRS); /* PRQA S 3383, 3469 # JV-01, JV-01 */ /* Setup for transferring \"stop\" command to command port */ LulDPCR = CDDCRC_DESC_DMRS(LulDMRS) | CDDCRC_DESC_SM_INC | /* PRQA S 3469 # JV-01 */ CDDCRC_DESC_8BYTE | CDDCRC_DESC_EXTENDED | CDDCRC_DESC_DSIE; CddCrc_GaaCommandBuffer[LucChannelIdx].aaEntry[0] = /* PRQA S 2844 # JV-01 */ (uint32)(&(LpChannel->pWcrcRegs->ulSTOP)); /* PRQA S 0303, 2814 # JV-01, JV-01 */ CddCrc_GaaCommandBuffer[LucChannelIdx].aaEntry[1] = 1UL; /* PRQA S 2844 # JV-01 */ /* SAR, DAR, TCR, DPCR */ LpDmaDescSet->aaDmaDesc[2].ulSAR = (uint32)(&CddCrc_GaaCommandBuffer[LucChannelIdx]); /* PRQA S 0306, 2934 # JV-01, JV-01 */ LpDmaDescSet->aaDmaDesc[2].ulDAR = (uint32)(&(LpFifoRegs->ulCommand)); /* PRQA S 0303 # JV-01 */ LpDmaDescSet->aaDmaDesc[2].ulTCR = 1UL; LpDmaDescSet->aaDmaDesc[2].ulDPCR = LulDPCR; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpDataIn', 'Value': '&map_LpDataIn[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpExpData', 'Value': '&map_LpExpData[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LenCmpFreq', 'Value': 'FREQ_32_BYTE'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LulDataLength', 'Value': '4'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'CddCrc_GpChannelConfig', 'Value': '&map_CddCrc_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'CddCrc_GpDmaChannelConfig', 'Value': '&map_CddCrc_GpDmaChannelConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pFifoRegs', 'Value': '&map_pFifoRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pWcrcRegs', 'Value': '&map_pWcrcRegs[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucResDmaIndex', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usDMRS', 'Value': '0x18U'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpDataIn[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpExpData[0]', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pFifoRegs[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'ulSAR', 'Value': '[0] = (uint32)(&map_LpDataIn[0])\\n[1] = (uint32)(&map_LpExpData[0])\\n[2] =(uint32)(&CddCrc_GaaCommandBuffer[0])  '], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'ulDAR', 'Value': '[0] =(uint32)(&(map_pFifoRegs[0].ulData))\\n[1] =(uint32)(&(map_pFifoRegs[0].ulExpData))\\n[2] =(uint32)(&(map_pFifoRegs[0].ulCommand))'], 'Output_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'ulTCR', 'Value': '[0] = 1\\n[1] = 1\\n[2] = 1'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulDPCR', 'Value': '[0] = CDDCRC_DESC_4BYTE | CDDCRC_DESC_DMRS(0x19U) | CDDCRC_DESC_SM_INC | CDDCRC_DESC_EXTENDED\\n[1] =CDDCRC_DESC_32BYTE | CDDCRC_DESC_DMRS(0x1BU) | CDDCRC_DESC_SM_INC | CDDCRC_DESC_EXTENDED\\n[2] = CDDCRC_DESC_8BYTE | CDDCRC_DESC_DMRS(0x19U) | CDDCRC_DESC_SM_INC | CDDCRC_DESC_EXTENDED | CDDCRC_DESC_DSIE'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'aaEntry[0]', 'Value': '(uint32)(&map_pWcrcRegs[0].ulSTOP)'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'aaEntry[1]', 'Value': '1UL'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define CDDCRC_START_SEC_PRIVATE_CODE #include \"CddCrc_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDCRC_PRIVATE_CODE) CddCrc_WCRC_ReadCompareResult /* PRQA S 1532 # JV-01 */ ( const uint8 LucChannelIdx, P2VAR(uint16, AUTOMATIC, CDDCRC_APPL_DATA) LpCompareResult /* PRQA S 3432 # JV-01 */ ) { /* Declare local variables */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; P2CONST(CddCrc_ChannelConfigType, AUTOMATIC, CDDCRC_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Initialize local variable */ LddReturnValue = E_OK; LpChannel = &CddCrc_GpChannelConfig[LucChannelIdx]; /* PRQA S 2824 # JV-01 */ if (0UL != (LpChannel->pWcrcRegs->ulSTS & CDDCRC_COMP_DONE)) /* PRQA S 2814 # JV-01 */ { /* Get comparison result */ *LpCompareResult = (uint16)(LpChannel->pWcrcRegs->ulCOMP_RES); /* PRQA S 2814 # JV-01 */ /* Clear status bits */ LpChannel->pWcrcRegs->ulSTS &= CDDCRC_COMP_DONE | CDDCRC_COMP_ERR; } else { /* Set return value to E_NOT_OK */ LddReturnValue = E_NOT_OK; } return LddReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpCompareResult', 'Value': '&map_LpCompareResult[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL_PTR / NOT NULL_PTR', 'Name': 'CddCrc_GpChannelConfig', 'Value': '&map_CddCrc_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pWcrcRegs', 'Value': '&map_pWcrcRegs[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulSTS', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulCOMP_RES', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulSTS', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpCompareResult[0]', 'Value': '-'], 'Output_Param_002': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if defined(CDDEMM_DOMAIN33_USE) && (CDDEMM_DOMAIN33_USE == STD_ON) /* Define the ISR for EMM Domain 33 */ #define CDDEMM_START_SEC_CODE_FAST #include \"CddEmm_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* Define the CAT2 interrupt mapping */ #if defined(Os_CDDEMM_DOMAIN33_CAT2_ISR) || defined(CDDEMM_DOMAIN33_CAT2_ISR) ISR(CDDEMM_DOMAIN33_CAT2_ISR) /* Define the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, CDDEMM_CODE_FAST) CDDEMM_DOMAIN33_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { /* Invoke common interrupt handler for processing */ CddEmm_CommonIsr(CDDEMM_ECMERRSTSR33_ADDR, CDDEMM_ECMERRTGTR33_ADDR, CDDEMM_ECMERRCTLR33_ADDR, CDDEMM_DOMAIN33_USER_ADDR); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CDDEMM_DOMAIN33_USE', 'Value': 'STD_ON']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulStatusRegAddr', 'Value': '&map_CDDEMM_ECMERRSTSR33_ADDR'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTargetRegAddr', 'Value': '&map_CDDEMM_ECMERRTGTR33_ADDR'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulControlRegAddr', 'Value': '&map_CDDEMM_ECMERRCTLR33_ADDR'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUsrAddr', 'Value': '&map_CDDEMM_DOMAIN33_USER_ADDR'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if defined(CDDEMM_DOMAIN39_USE) && (CDDEMM_DOMAIN39_USE == STD_ON) /* Define the ISR for EMM Domain 39 */ #define CDDEMM_START_SEC_CODE_FAST #include \"CddEmm_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* Define the CAT2 interrupt mapping */ #if defined(Os_CDDEMM_DOMAIN39_CAT2_ISR) || defined(CDDEMM_DOMAIN39_CAT2_ISR) ISR(CDDEMM_DOMAIN39_CAT2_ISR) /* Define the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, CDDEMM_CODE_FAST) CDDEMM_DOMAIN39_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { /* Invoke common interrupt handler for processing */ CddEmm_CommonIsr(CDDEMM_ECMERRSTSR39_ADDR, CDDEMM_ECMERRTGTR39_ADDR, CDDEMM_ECMERRCTLR39_ADDR, CDDEMM_DOMAIN39_USER_ADDR); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'CDDEMM_DOMAIN39_USE', 'Value': 'STD_ON']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulStatusRegAddr', 'Value': '&map_CDDEMM_ECMERRSTSR39_ADDR'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTargetRegAddr', 'Value': '&map_CDDEMM_ECMERRTGTR39_ADDR'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulControlRegAddr', 'Value': '&map_CDDEMM_ECMERRCTLR39_ADDR'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulUsrAddr', 'Value': '&map_CDDEMM_DOMAIN39_USER_ADDR'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_FAST #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_FAST) CddIccom_AckHandle ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, VAR(uint32, AUTOMATIC) LulCtrlVal, VAR(uint32, AUTOMATIC) LulMsgVal ) { VAR(CddIccom_CtaPartType, AUTOMATIC) LenCtaPart; if (CDDICCOM_ACK_BUFF_UPPER == (LulCtrlVal & CDDICCOM_CTRL_ACK_BUFF)) { LenCtaPart = CDDICCOM_CTA_UPPER; } else { LenCtaPart = CDDICCOM_CTA_BOTTOM; } /* Check if status of CTA partition is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart]) /* PRQA S 2824 # JV-01 */ { /* Validate ACK */ if (LulMsgVal == CddIccom_GpChannelStatus[LddChannel].ulSndSize[LenCtaPart]) { /* Ack receive, the status can be free now */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart] = CDDICCOM_SND_IDLE; } else { /* Report error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_INVALID_ACK, DEM_EVENT_STATUS_FAILED); } } /* End of if if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart]) */ /* In case of timeout already occurred, ACK will release the CTA */ else if (CDDICCOM_SND_TIMEOUT == CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart]) { /* Ack receive, the status can be free now */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart] = CDDICCOM_SND_IDLE; } else { /* Report error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_FATAL, DEM_EVENT_STATUS_FAILED); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulCtrlVal', 'Value': '0x00000000'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LulMsgVal', 'Value': '2048'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_UPPER]', 'Value': '[1]=CDDICCOM_SND_WAITACK'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '[1]=2048'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_UPPER]', 'Value': '[1]=CDDICCOM_SND_IDLE'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_FAST #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_FAST) CddIccom_AckHandle ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, VAR(uint32, AUTOMATIC) LulCtrlVal, VAR(uint32, AUTOMATIC) LulMsgVal ) { VAR(CddIccom_CtaPartType, AUTOMATIC) LenCtaPart; if (CDDICCOM_ACK_BUFF_UPPER == (LulCtrlVal & CDDICCOM_CTRL_ACK_BUFF)) { LenCtaPart = CDDICCOM_CTA_UPPER; } else { LenCtaPart = CDDICCOM_CTA_BOTTOM; } /* Check if status of CTA partition is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart]) /* PRQA S 2824 # JV-01 */ { /* Validate ACK */ if (LulMsgVal == CddIccom_GpChannelStatus[LddChannel].ulSndSize[LenCtaPart]) { /* Ack receive, the status can be free now */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart] = CDDICCOM_SND_IDLE; } else { /* Report error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_INVALID_ACK, DEM_EVENT_STATUS_FAILED); } } /* End of if if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart]) */ /* In case of timeout already occurred, ACK will release the CTA */ else if (CDDICCOM_SND_TIMEOUT == CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart]) { /* Ack receive, the status can be free now */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart] = CDDICCOM_SND_IDLE; } else { /* Report error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_FATAL, DEM_EVENT_STATUS_FAILED); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '2'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulCtrlVal', 'Value': '0x00000008'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LulMsgVal', 'Value': '2048'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_BOTTOM]', 'Value': '[2]=CDDICCOM_SND_WAITACK'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '[2]=2048']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_BOTTOM]', 'Value': '[2]=CDDICCOM_SND_IDLE'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CddIccom_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CddIccom_CODE) CddIccom_Ch3NoticeCallback /* PRQA S 1532 # JV-01 */ ( IccomNoticeType LenType, uint32 LulMsg ) { /* Notice Information structure */ VAR(IccomNoticeInfo, AUTOMATIC) LstNoticeInfo; /* Update notice information */ LstNoticeInfo.Type = LenType; LstNoticeInfo.Message = LulMsg; /* Notify to notice port */ (void)Rte_Send_P_Ch3Notice_NoticeInfo(&LstNoticeInfo); /* PRQA S 3469 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_DATA'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': '*CDDIccom_P_Ch3Notice_NoticeInfo', 'Value': 'NoticeInfo'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CddIccom_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CddIccom_CODE) CddIccom_Ch4ReceiveRun /* PRQA S 1503 # JV-01 */ ( IccomDataPtr LpData, uint32 LulSize ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; LddRetVal = CddIccom_ReceiveRun(CDDICCOM_CH4, LpData, LulSize); return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Input_Param_002': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': 'CDDICCOM_CH4'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_OK'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CddIccom_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CddIccom_CODE) CddIccom_Ch8NoticeCallback /* PRQA S 1532 # JV-01 */ ( IccomNoticeType LenType, uint32 LulMsg ) { /* Notice Information structure */ VAR(IccomNoticeInfo, AUTOMATIC) LstNoticeInfo; /* Update notice information */ LstNoticeInfo.Type = LenType; LstNoticeInfo.Message = LulMsg; /* Notify to notice port */ (void)Rte_Send_P_Ch8Notice_NoticeInfo(&LstNoticeInfo); /* PRQA S 3469 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_DATA'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': '*CDDIccom_P_Ch8Notice_NoticeInfo', 'Value': 'NoticeInfo'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CddIccom_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CddIccom_CODE) CddIccom_Ch9ReceiveRun /* PRQA S 1503 # JV-01 */ ( IccomDataPtr LpData, uint32 LulSize ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; LddRetVal = CddIccom_ReceiveRun(CDDICCOM_CH9, LpData, LulSize); return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Input_Param_002': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_INVALID']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': 'CDDICCOM_CH9'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_INVALID'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_CtaWrite ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, VAR(CddIccom_CtaPartType, AUTOMATIC) LenCtaPart, CONSTP2CONST(uint8, AUTOMATIC, CDDICCOM_APPL_DATA) LpBuff, VAR(uint32, AUTOMATIC) LulSize ) { P2VAR(void, AUTOMATIC, CDDICCOM_DATA) LpCtaPtr; /* PRQA S 3432 # JV-01 */ /* Get CTA address base on Area */ if (CDDICCOM_CTA_UPPER == LenCtaPart) { LpCtaPtr = (P2VAR(void, AUTOMATIC, CDDICCOM_DATA)) /* PRQA S 0314, 3432 # JV-01, JV-01 */ (CddIccom_GpChannelConfig[LddChannel].pCtaTxUpper); /* PRQA S 2824 # JV-01 */ } else { LpCtaPtr = (P2VAR(void, AUTOMATIC, CDDICCOM_DATA)) /* PRQA S 0314, 3432 # JV-01, JV-01 */ (CddIccom_GpChannelConfig[LddChannel].pCtaTxBottom); } /* Copy data to CTA */ CddIccom_RamCpy(LpCtaPtr, LpBuff, LulSize); /* PRQA S 0317 # JV-01 */ #if (CDDICCOM_DEVICE_NAME != RTM8RC79FG) /* Flush cache */ CR7_Flush_DCache_By_Addr((uint32) LpCtaPtr, LulSize); /* PRQA S 0326 # JV-01 */ #endif /* CDDICCOM_DEVICE_NAME != RTM8RC79FG */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '7'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'CDDICCOM_CTA_UPPER..CDDICCOM_CTA_BOTTOM', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_BOTTOM'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpBuff', 'Value': '&ptr_LpBuff[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pCtaTxUpper', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pCtaTxBottom', 'Value': '[7]=0x47FC7800'], 'Input_Param_007': ['Type': 'Macro', 'Range': 'RTM8RC79FG..RTM8RC79FG..CDDICCOM_V4H', 'Name': 'CDDICCOM_DEVICE_NAME', 'Value': 'RTM8RC79FG']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDst', 'Value': '0x47FC7800'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '&ptr_LpBuff[0]'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'start_addr', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'size', 'Value': '-'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_CtaWrite ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, VAR(CddIccom_CtaPartType, AUTOMATIC) LenCtaPart, CONSTP2CONST(uint8, AUTOMATIC, CDDICCOM_APPL_DATA) LpBuff, VAR(uint32, AUTOMATIC) LulSize ) { P2VAR(void, AUTOMATIC, CDDICCOM_DATA) LpCtaPtr; /* PRQA S 3432 # JV-01 */ /* Get CTA address base on Area */ if (CDDICCOM_CTA_UPPER == LenCtaPart) { LpCtaPtr = (P2VAR(void, AUTOMATIC, CDDICCOM_DATA)) /* PRQA S 0314, 3432 # JV-01, JV-01 */ (CddIccom_GpChannelConfig[LddChannel].pCtaTxUpper); /* PRQA S 2824 # JV-01 */ } else { LpCtaPtr = (P2VAR(void, AUTOMATIC, CDDICCOM_DATA)) /* PRQA S 0314, 3432 # JV-01, JV-01 */ (CddIccom_GpChannelConfig[LddChannel].pCtaTxBottom); } /* Copy data to CTA */ CddIccom_RamCpy(LpCtaPtr, LpBuff, LulSize); /* PRQA S 0317 # JV-01 */ #if (CDDICCOM_DEVICE_NAME != RTM8RC79FG) /* Flush cache */ CR7_Flush_DCache_By_Addr((uint32) LpCtaPtr, LulSize); /* PRQA S 0326 # JV-01 */ #endif /* CDDICCOM_DEVICE_NAME != RTM8RC79FG */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '9'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'CDDICCOM_CTA_UPPER..CDDICCOM_CTA_BOTTOM', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_UPPER'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpBuff', 'Value': '&ptr_LpBuff[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pCtaTxUpper', 'Value': '[9]=0x47FC8000'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pCtaTxBottom', 'Value': '-'], 'Input_Param_007': ['Type': 'Macro', 'Range': 'RTM8RC79FG..RTM8RC79FG..CDDICCOM_V4H', 'Name': 'CDDICCOM_DEVICE_NAME', 'Value': 'RTM8RC79FR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDst', 'Value': '0x47FC8000'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '&ptr_LpBuff[0]'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSize', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'start_addr', 'Value': '0x47FC8000'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'size', 'Value': '0'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_CtaWrite ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, VAR(CddIccom_CtaPartType, AUTOMATIC) LenCtaPart, CONSTP2CONST(uint8, AUTOMATIC, CDDICCOM_APPL_DATA) LpBuff, VAR(uint32, AUTOMATIC) LulSize ) { P2VAR(void, AUTOMATIC, CDDICCOM_DATA) LpCtaPtr; /* PRQA S 3432 # JV-01 */ /* Get CTA address base on Area */ if (CDDICCOM_CTA_UPPER == LenCtaPart) { LpCtaPtr = (P2VAR(void, AUTOMATIC, CDDICCOM_DATA)) /* PRQA S 0314, 3432 # JV-01, JV-01 */ (CddIccom_GpChannelConfig[LddChannel].pCtaTxUpper); /* PRQA S 2824 # JV-01 */ } else { LpCtaPtr = (P2VAR(void, AUTOMATIC, CDDICCOM_DATA)) /* PRQA S 0314, 3432 # JV-01, JV-01 */ (CddIccom_GpChannelConfig[LddChannel].pCtaTxBottom); } /* Copy data to CTA */ CddIccom_RamCpy(LpCtaPtr, LpBuff, LulSize); /* PRQA S 0317 # JV-01 */ #if (CDDICCOM_DEVICE_NAME != RTM8RC79FG) /* Flush cache */ CR7_Flush_DCache_By_Addr((uint32) LpCtaPtr, LulSize); /* PRQA S 0326 # JV-01 */ #endif /* CDDICCOM_DEVICE_NAME != RTM8RC79FG */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'CDDICCOM_CTA_UPPER..CDDICCOM_CTA_BOTTOM', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_UPPER'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpBuff', 'Value': '&ptr_LpBuff[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pCtaTxUpper', 'Value': '[1]=0x47FCA000'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pCtaTxBottom', 'Value': '-'], 'Input_Param_007': ['Type': 'Macro', 'Range': 'RTM8RC79FG..RTM8RC79FG..CDDICCOM_V4H', 'Name': 'CDDICCOM_DEVICE_NAME', 'Value': 'CDDICCOM_V4H']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDst', 'Value': '0x47FCA000'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '&ptr_LpBuff[0]'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSize', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'start_addr', 'Value': '0x47FCA000'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'size', 'Value': '0'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_FAST #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_FAST) CddIccom_DataHandle ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, VAR(uint32, AUTOMATIC) LulCtrlVal, VAR(uint32, AUTOMATIC) LulMsgVal ) { VAR(CddIccom_CtaPartType, AUTOMATIC) LenCtaPart; VAR(Std_ReturnType, AUTOMATIC) LddErrCheck; LddErrCheck = E_OK; if (CDDICCOM_SEND_BUFF_UPPER == (LulCtrlVal & CDDICCOM_CTRL_SND_BUFF)) { LenCtaPart = CDDICCOM_CTA_UPPER; } else { LenCtaPart = CDDICCOM_CTA_BOTTOM; } #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Check if current reception is free */ if (CDDICCOM_CTA_NONE == CddIccom_GpChannelStatus[LddChannel].enRcvCtaCurr) /* PRQA S 2824 # JV-01 */ { /* Update indicator */ CddIccom_GpChannelStatus[LddChannel].enRcvCtaCurr = LenCtaPart; } else { /* Check if next reception indicator is free */ if (CDDICCOM_CTA_NONE == CddIccom_GpChannelStatus[LddChannel].enRcvCtaNext) { /* Update indicator */ CddIccom_GpChannelStatus[LddChannel].enRcvCtaNext = LenCtaPart; } else { /* All CTA part are in busy */ LddErrCheck = E_NOT_OK; } } /* End of else if (CDDICCOM_CTA_NONE == * * CddIccom_GpChannelStatus[LddChannel].enRcvCtaCurr) */ if (E_OK == LddErrCheck) { CddIccom_GpChannelStatus[LddChannel].enRcvSta[LenCtaPart] = CDDICCOM_RCV_REQUEST; CddIccom_GpChannelStatus[LddChannel].ulRcvSize[LenCtaPart] = LulMsgVal; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ if (NULL_PTR != CddIccom_GpChannelConfig[LddChannel].pNotification) /* PRQA S 2824 # JV-01 */ { CddIccom_GpChannelConfig[LddChannel].pNotification(ICCOM_NOTICE_DATA, /* PRQA S 2814 # JV-01 */ LulMsgVal); } else { /* No action required */ } } /* End of if (E_OK == LddErrCheck) */ else { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Report error */ (void)Dem_SetEventStatus(CDDICCOM_E_FATAL, DEM_EVENT_STATUS_FAILED); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '2'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulCtrlVal', 'Value': '0x00000000'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LulMsgVal', 'Value': '2048'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[2]=&ISOLATE_void_func_ptr'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'enRcvCtaCurr', 'Value': '[2]=CDDICCOM_CTA_UPPER'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'enRcvCtaNext', 'Value': '[2]=CDDICCOM_CTA_BOTTOM'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[2]=&ISOLATE_void_func_ptr'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pNotification', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'enRcvCtaCurr', 'Value': '-'], 'Output_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'enRcvCtaNext', 'Value': '-'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'enRcvSta[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'enRcvSta[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvSize[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvSize[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_FATAL'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDICCOM_CODE) CddIccom_HWGetCtrl /* PRQA S 1532 # JV-01 */ ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, CONSTP2VAR(uint32, AUTOMATIC, CDDICCOM_DATA) LpValue /* PRQA S 3432 # JV-01 */ ) { /* Get control value and write it to storage place holder */ *LpValue = /* PRQA S 2814 # JV-01 */ *((volatile uint32*)CddIccom_GpChannelConfig[LddChannel].pMFISyICRnReg); /* PRQA S 2814, 2824 # JV-01, JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpValue', 'Value': '&map_LpValue[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'pMFISyICRnReg', 'Value': '[0]=&map_pMFISyICRnReg[0]'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_pMFISyICRnReg[0]', 'Value': '0xD626A500']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpValue[0]', 'Value': '0xD626A500'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDICCOM_CODE) CddIccom_HWInit /* PRQA S 1532 # JV-01 */ ( void ) { /* Local counter variable to count the channels */ VAR(uint8, AUTOMATIC) LucIndex; /* Local variable initialization */ LucIndex = CDDICCOM_ZERO_8; /* PRQA S 2982 # JV-01 */ /* Loop over configured channels */ for (LucIndex = CDDICCOM_ZERO_8; LucIndex < CDDICCOM_TOTAL_CHANNELS_CONFIG; LucIndex++) { /* Initialize MFIS control register */ CddIccom_HWSetCtrl((CddIccom_ChannelType)LucIndex, CDDICCOM_HW_CONTROL_INIT); /* Initialize MFIS message register */ CddIccom_HWSetMsg((CddIccom_ChannelType)LucIndex, (VAR(uint32, AUTOMATIC))CDDICCOM_ZERO_32); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_TOTAL_CHANNELS_CONFIG', 'Value': '9']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '1'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '1'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '2'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '2'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '3'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '3'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '4'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '4'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '5'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '5'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '6'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '6'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '7'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '7'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '8'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_HW_CONTROL_INIT'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '8'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': '-'], 'Output_Param_040': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDICCOM_CODE) CddIccom_HWIntConsistencyCheck /* PRQA S 1532 # JV-01 */ ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { /* Variable to store the return value of function */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Variable to store EIC ISR Register Value */ VAR(uint16, AUTOMATIC) LusEICRegValue; /* Set return value */ LddReturnValue = E_OK; /* Get the value of EIC ISR Register Address */ LusEICRegValue = *((volatile uint16*)CddIccom_GpChannelConfig[LddChannel].pEICReg); /* PRQA S 2814, 2824 # JV-01, JV-01 */ /* Check bit mask for Interrupt Consistency Failure */ if (CDDICCOM_ZERO_16 != (LusEICRegValue & CDDICCOM_EIC_EIMK_MASK)) { (void)Dem_SetEventStatus(CDDICCOM_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); /* Set return value */ LddReturnValue = E_NOT_OK; } else { /* No action required */ } return LddReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDICCOM_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'pEICReg', 'Value': '[0]=&map_pMFISyMBRnReg[0]'], 'Input_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': '0xFFF8009E']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'pEICReg', 'Value': '[0]=&map_pMFISyMBRnReg[0]'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': '0xFFF8009E'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDICCOM_CODE) CddIccom_HWSetMsg ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, VAR(uint32, AUTOMATIC) LulValue ) { #if (CDDICCOM_WRITE_VERIFY_CHECK == STD_ON) /* Local place holder to store register read-back value */ uint32 LulReadBackVal; LulReadBackVal = CDDICCOM_ZERO_32; /* PRQA S 2982 # JV-01 */ #endif /* CDDICCOM_WRITE_VERIFY_CHECK == STD_ON */ /* - RCar S4: Write value to MFISRM<m>EMBR0 register when communication with * S4 G4MH or MFISAREMBR<n> register when communication with AP-System * core by S4 CR52/MFISRM<m>IMBR0 register when communication with * S4 CR52 or MFISAM<m>EMBR<n> register when communication with AP-System * core by S4 G4MH (<m>=0..1, <n>=0..7) * - RCar V4H: Write value to MFISAREMBR<m><n> register when communication with * AP-System core (<m>=0..2, <n>=0..3) */ *((volatile uint32*)CddIccom_GpChannelConfig[LddChannel].pMFISyMBRnReg) = /* PRQA S 2814, 2824 # JV-01, JV-01 */ LulValue; #if (CDDICCOM_WRITE_VERIFY_CHECK == STD_ON) /* Read back value for confirmation */ LulReadBackVal = *((volatile uint32 *)CddIccom_GpChannelConfig[LddChannel].pMFISyMBRnReg); if (LulReadBackVal != LulValue) { (void)Dem_SetEventStatus(CDDICCOM_E_WRITE_VERIFY_FAILURE, DEM_EVENT_STATUS_FAILED); } else { /* No action required */ } #endif /* CDDICCOM_WRITE_VERIFY_CHECK == STD_ON */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulValue', 'Value': '0xE6269460'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDICCOM_WRITE_VERIFY_CHECK', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'pMFISyMBRnReg', 'Value': '[0]=&map_pMFISyMBRnReg[0]'], 'Input_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_pMFISyMBRnReg[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'pMFISyMBRnReg', 'Value': '[0]=&map_pMFISyMBRnReg[0]'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pMFISyMBRnReg[0]', 'Value': '0xE6269460'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CddIccom_START_SEC_CODE #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_InitializeNotice ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { /* Place holder for communication control register value */ VAR(uint32, AUTOMATIC) LddRegVal; VAR(uint32, AUTOMATIC) LulTargetCtrlVal; VAR(uint32, AUTOMATIC) LulLoopCnt; VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; VAR(TickType, AUTOMATIC) LddTimeoutCntTick; /* Initialize Loop Counter */ LulLoopCnt = E_NOT_OK; /* Initialization of local counter */ LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; /* Set register value for Initialize notice */ LddRegVal = CDDICCOM_CTRL_INIT_END | CDDICCOM_CTRL_INT; /* Get start counter value for timeout handling */ (void)GetCounterValue(CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntCurr); /* Store timeout tick counter to calculate timeout */ LddTimeoutCntTick = LddTimeoutCntCurr; /* Write data information and trigger notice */ CddIccom_HWSetCtrl(LddChannel, LddRegVal); while(E_NOT_OK == LulLoopCnt) { CddIccom_HWGetCtrl(LddChannel, &LulTargetCtrlVal); if (CDDICCOM_HW_CONTROL_INIT == (LulTargetCtrlVal & CDDICCOM_CTRL_INT)) { /* Receiver had received initialize message and cleared INT bit * * Ready for communication. Exit while() */ CddIccom_GpChannelStatus[LddChannel].enChSta = CDDICCOM_CH_READY; /* PRQA S 2824 # JV-01 */ LulLoopCnt = E_OK; } else { (void)GetElapsedValue( CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntTick, (TickRefType)&LddTimeoutCntCurr); /* Check if timeout occurred */ if (CDDICCOM_INIT_TIMEOUT < LddTimeoutCntCurr) { /* Report timeout error to DEM */ (void)Dem_SetEventStatus(CDDICCOM_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); /* Exit while, Target timeout */ LulLoopCnt = E_OK; } else { /* No action required */ } } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '4'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_INIT_NOTIFICATION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '[4]=OsCounter'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_005': ['Type': 'Output_Argument', 'Range': '', 'Name': '*Value', 'Value': '10'], 'Input_Param_006': ['Type': 'Output_Argument', 'Range': '', 'Name': '*ElapsedValue', 'Value': '-'], 'Input_Param_007': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '0x00000000']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '10'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '4'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': '17'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '4'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': '[4]=CDDICCOM_CH_READY'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDICCOM_CODE_SLOW) CddIccom_ReceiveRun /* PRQA S 1505 # JV-01 */ ( CddIccom_ChannelType LddChannel, IccomDataPtr LpData, uint32 LulSize ) { /* Place holder for return value */ VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(CddIccom_ReturnType, AUTOMATIC) LddIccomRet; /* Initialize local variables */ LddRetVal = E_OK; LddIccomRet = CDDICCOM_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDICCOM_DEV_ERROR_DETECT == STD_ON) /* Validate driver initialization status */ if (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_UNINIT); LddRetVal = E_NOT_OK; } else { /* Validate of input pointer */ if (NULL_PTR == LpData) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* Validate of input value */ if ((CDDICCOM_ZERO_32 == LulSize) || (CddIccom_GpChannelConfig[LddChannel].uiCtaPartSize < LulSize)) /* PRQA S 2824 # JV-01 */ { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_VALUE); LddRetVal = E_NOT_OK; } else { /* No action is required */ } } } /* End of else (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) */ #endif /* CDDICCOM_DEV_ERROR_DETECT == STD_ON */ if (E_OK == LddRetVal) { LddIccomRet = CddIccom_Receive(LddChannel, LpData, LulSize); if (CDDICCOM_E_OK == LddIccomRet) { LddRetVal = RTE_E_OK; } else if (CDDICCOM_E_NO_DATA == LddIccomRet) { LddRetVal = RTE_E_NO_DATA; } else { LddRetVal = RTE_E_INVALID; } } /* End of if (E_OK == LddRetVal) */ else { /* No action is required since DET checked */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDICCOM_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '2'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'uiCtaPartSize', 'Value': '[2]=2048'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDICCOM_UNINITIALIZED..CDDICCOM_INITIALIZED', 'Name': 'CddIccom_GblDriverStatus', 'Value': 'CDDICCOM_INITIALIZED'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDDICCOM_E_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '2'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDICCOM_CODE_SLOW) CddIccom_ReceiveRun /* PRQA S 1505 # JV-01 */ ( CddIccom_ChannelType LddChannel, IccomDataPtr LpData, uint32 LulSize ) { /* Place holder for return value */ VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(CddIccom_ReturnType, AUTOMATIC) LddIccomRet; /* Initialize local variables */ LddRetVal = E_OK; LddIccomRet = CDDICCOM_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDICCOM_DEV_ERROR_DETECT == STD_ON) /* Validate driver initialization status */ if (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_UNINIT); LddRetVal = E_NOT_OK; } else { /* Validate of input pointer */ if (NULL_PTR == LpData) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* Validate of input value */ if ((CDDICCOM_ZERO_32 == LulSize) || (CddIccom_GpChannelConfig[LddChannel].uiCtaPartSize < LulSize)) /* PRQA S 2824 # JV-01 */ { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_VALUE); LddRetVal = E_NOT_OK; } else { /* No action is required */ } } } /* End of else (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) */ #endif /* CDDICCOM_DEV_ERROR_DETECT == STD_ON */ if (E_OK == LddRetVal) { LddIccomRet = CddIccom_Receive(LddChannel, LpData, LulSize); if (CDDICCOM_E_OK == LddIccomRet) { LddRetVal = RTE_E_OK; } else if (CDDICCOM_E_NO_DATA == LddIccomRet) { LddRetVal = RTE_E_NO_DATA; } else { LddRetVal = RTE_E_INVALID; } } /* End of if (E_OK == LddRetVal) */ else { /* No action is required since DET checked */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDICCOM_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '3'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'uiCtaPartSize', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDICCOM_UNINITIALIZED..CDDICCOM_INITIALIZED', 'Name': 'CddIccom_GblDriverStatus', 'Value': 'CDDICCOM_UNINITIALIZED'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': 'CDDICCOM_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': 'CDDICCOM_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': 'CDDICCOM_CH0RECEIVERUN_SID +3'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': 'CDDICCOM_E_UNINIT'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDICCOM_CODE_SLOW) CddIccom_ReceiveRun /* PRQA S 1505 # JV-01 */ ( CddIccom_ChannelType LddChannel, IccomDataPtr LpData, uint32 LulSize ) { /* Place holder for return value */ VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(CddIccom_ReturnType, AUTOMATIC) LddIccomRet; /* Initialize local variables */ LddRetVal = E_OK; LddIccomRet = CDDICCOM_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDICCOM_DEV_ERROR_DETECT == STD_ON) /* Validate driver initialization status */ if (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_UNINIT); LddRetVal = E_NOT_OK; } else { /* Validate of input pointer */ if (NULL_PTR == LpData) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* Validate of input value */ if ((CDDICCOM_ZERO_32 == LulSize) || (CddIccom_GpChannelConfig[LddChannel].uiCtaPartSize < LulSize)) /* PRQA S 2824 # JV-01 */ { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_VALUE); LddRetVal = E_NOT_OK; } else { /* No action is required */ } } } /* End of else (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) */ #endif /* CDDICCOM_DEV_ERROR_DETECT == STD_ON */ if (E_OK == LddRetVal) { LddIccomRet = CddIccom_Receive(LddChannel, LpData, LulSize); if (CDDICCOM_E_OK == LddIccomRet) { LddRetVal = RTE_E_OK; } else if (CDDICCOM_E_NO_DATA == LddIccomRet) { LddRetVal = RTE_E_NO_DATA; } else { LddRetVal = RTE_E_INVALID; } } /* End of if (E_OK == LddRetVal) */ else { /* No action is required since DET checked */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDICCOM_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '4'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'uiCtaPartSize', 'Value': '[4]=2048'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDICCOM_UNINITIALIZED..CDDICCOM_INITIALIZED', 'Name': 'CddIccom_GblDriverStatus', 'Value': 'CDDICCOM_INITIALIZED'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDDICCOM_E_NO_DATA']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_NO_DATA'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '4'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDICCOM_CODE_SLOW) CddIccom_ReceiveRun /* PRQA S 1505 # JV-01 */ ( CddIccom_ChannelType LddChannel, IccomDataPtr LpData, uint32 LulSize ) { /* Place holder for return value */ VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(CddIccom_ReturnType, AUTOMATIC) LddIccomRet; /* Initialize local variables */ LddRetVal = E_OK; LddIccomRet = CDDICCOM_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDICCOM_DEV_ERROR_DETECT == STD_ON) /* Validate driver initialization status */ if (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_UNINIT); LddRetVal = E_NOT_OK; } else { /* Validate of input pointer */ if (NULL_PTR == LpData) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* Validate of input value */ if ((CDDICCOM_ZERO_32 == LulSize) || (CddIccom_GpChannelConfig[LddChannel].uiCtaPartSize < LulSize)) /* PRQA S 2824 # JV-01 */ { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_VALUE); LddRetVal = E_NOT_OK; } else { /* No action is required */ } } } /* End of else (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) */ #endif /* CDDICCOM_DEV_ERROR_DETECT == STD_ON */ if (E_OK == LddRetVal) { LddIccomRet = CddIccom_Receive(LddChannel, LpData, LulSize); if (CDDICCOM_E_OK == LddIccomRet) { LddRetVal = RTE_E_OK; } else if (CDDICCOM_E_NO_DATA == LddIccomRet) { LddRetVal = RTE_E_NO_DATA; } else { LddRetVal = RTE_E_INVALID; } } /* End of if (E_OK == LddRetVal) */ else { /* No action is required since DET checked */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDICCOM_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '6'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '4294967295'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'uiCtaPartSize', 'Value': '[6]=2048'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDICCOM_UNINITIALIZED..CDDICCOM_INITIALIZED', 'Name': 'CddIccom_GblDriverStatus', 'Value': 'CDDICCOM_INITIALIZED'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': 'CDDICCOM_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': 'CDDICCOM_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': 'CDDICCOM_CH0RECEIVERUN_SID +6'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': 'CDDICCOM_E_PARAM_VALUE'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDICCOM_CODE_SLOW) CddIccom_ReceiveRun /* PRQA S 1505 # JV-01 */ ( CddIccom_ChannelType LddChannel, IccomDataPtr LpData, uint32 LulSize ) { /* Place holder for return value */ VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(CddIccom_ReturnType, AUTOMATIC) LddIccomRet; /* Initialize local variables */ LddRetVal = E_OK; LddIccomRet = CDDICCOM_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDICCOM_DEV_ERROR_DETECT == STD_ON) /* Validate driver initialization status */ if (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_UNINIT); LddRetVal = E_NOT_OK; } else { /* Validate of input pointer */ if (NULL_PTR == LpData) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* Validate of input value */ if ((CDDICCOM_ZERO_32 == LulSize) || (CddIccom_GpChannelConfig[LddChannel].uiCtaPartSize < LulSize)) /* PRQA S 2824 # JV-01 */ { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0RECEIVERUN_SID + LddChannel, CDDICCOM_E_PARAM_VALUE); LddRetVal = E_NOT_OK; } else { /* No action is required */ } } } /* End of else (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) */ #endif /* CDDICCOM_DEV_ERROR_DETECT == STD_ON */ if (E_OK == LddRetVal) { LddIccomRet = CddIccom_Receive(LddChannel, LpData, LulSize); if (CDDICCOM_E_OK == LddIccomRet) { LddRetVal = RTE_E_OK; } else if (CDDICCOM_E_NO_DATA == LddIccomRet) { LddRetVal = RTE_E_NO_DATA; } else { LddRetVal = RTE_E_INVALID; } } /* End of if (E_OK == LddRetVal) */ else { /* No action is required since DET checked */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDICCOM_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '7'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': 'NULL_PTR'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'uiCtaPartSize', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDICCOM_UNINITIALIZED..CDDICCOM_INITIALIZED', 'Name': 'CddIccom_GblDriverStatus', 'Value': 'CDDICCOM_INITIALIZED'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': 'CDDICCOM_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': 'CDDICCOM_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': 'CDDICCOM_CH0RECEIVERUN_SID +7'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': 'CDDICCOM_E_PARAM_POINTER'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(CddIccom_ReturnType, CDDICCOM_CODE_SLOW) CddIccom_Send /* PRQA S 1532 # JV-01 */ ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel, CONSTP2CONST(uint8, AUTOMATIC, CDDICCOM_APPL_DATA) LpData, VAR(uint32, AUTOMATIC) LulSize ) { /* CTA partition indicator */ VAR(CddIccom_CtaPartType, AUTOMATIC) LenCtaPart; /* Error checking status */ VAR(CddIccom_ReturnType, AUTOMATIC) LddErrCheck; /* Current OsCounter value */ VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; /* Initialization of local counter */ LenCtaPart = CDDICCOM_CTA_NONE; /* PRQA S 2982 # JV-01 */ LddErrCheck = CDDICCOM_E_OK; /* PRQA S 2982 # JV-01 */ LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; /* Check Initialization status */ if (CDDICCOM_CH_READY == CddIccom_GpChannelStatus[LddChannel].enChSta) /* PRQA S 2824 # JV-01 */ { LddErrCheck = CDDICCOM_E_OK; } else { LddErrCheck = CDDICCOM_E_BUSY; } if (CDDICCOM_E_OK == LddErrCheck) { /* Get start counter value for timeout handling */ (void) GetCounterValue(CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntCurr); #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Check whether Upper CTA is Idle */ if (CDDICCOM_SND_IDLE == CddIccom_GpChannelStatus[LddChannel].enSndSta[CDDICCOM_CTA_UPPER]) /* PRQA S 2824 # JV-01 */ { LenCtaPart = CDDICCOM_CTA_UPPER; } else { /* Check whether Bottom Cta is Idle */ if (CDDICCOM_SND_IDLE == CddIccom_GpChannelStatus[LddChannel].enSndSta[CDDICCOM_CTA_BOTTOM]) { LenCtaPart = CDDICCOM_CTA_BOTTOM; } else { /* All CTA part are in busy */ LddErrCheck = CDDICCOM_E_BUSY; } } /* Continue process if CTA part available */ if (CDDICCOM_E_OK == LddErrCheck) { /* Check if current transmission CTA is free */ if (CDDICCOM_CTA_NONE == CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) { /* Choose partition for current transmission CTA */ CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr = LenCtaPart; } else { /* Choose partition for next transmission */ CddIccom_GpChannelStatus[LddChannel].enSndCtaNext = LenCtaPart; CddIccom_GpChannelStatus[LddChannel].enSndSta[LenCtaPart] = CDDICCOM_SND_REQUEST; } /* Update send size to internal status, will be used for validate ACK */ CddIccom_GpChannelStatus[LddChannel].ulSndSize[LenCtaPart] = LulSize; /* Write data to CTA */ CddIccom_CtaWrite(LddChannel, LenCtaPart, LpData, LulSize); /* Only notify data when there have no any pending ACK */ if ((CDDICCOM_SND_REQUEST != \\ CddIccom_GpChannelStatus[LddChannel].enSndSta[CDDICCOM_CTA_UPPER]) && /* PRQA S 2824 # JV-01 */ (CDDICCOM_SND_REQUEST != CddIccom_GpChannelStatus[LddChannel].enSndSta[CDDICCOM_CTA_BOTTOM])) { /* Notice to Receiver side */ CddIccom_NoticeData(LddChannel, LenCtaPart, LulSize); } else { /* No action required */ } /* Store timeout tick counter to calculate timeout in scheduler function*/ CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LenCtaPart] = LddTimeoutCntCurr; } /* End of if (CDDICCOM_E_OK == LddErrCheck) */ else { /* There are error occurred, Return the error code */ /* No action required */ } #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ } /* End of if (CDDICCOM_E_OK == LddErrCheck) */ else { /* No action required */ } return LddErrCheck; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '9'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&ptr_LpData[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': '4294967295'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[9]=&ISOLATE_void_func_ptr'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': '[9]=CDDICCOM_CH_WAITINIT'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '-'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '-'], 'Input_Param_012': ['Type': 'Output_Argument', 'Range': '', 'Name': '*Value', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[9]=&ISOLATE_void_func_ptr']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '-'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaNext', 'Value': '-'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpBuff', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '-'], 'Output_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddErrCheck', 'Value': 'CDDICCOM_E_BUSY'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_SendAckProcessing ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint8, AUTOMATIC) LucCtaIndex; for (LucCtaIndex = CDDICCOM_ZERO_8; LucCtaIndex < (uint8)CDDICCOM_CTA_CNT; LucCtaIndex++) { /* Check if whether any CTA partition want to send ACK to other domain */ if (CDDICCOM_RCV_SNDACK == CddIccom_GpChannelStatus[LddChannel].enRcvSta[LucCtaIndex]) /* PRQA S 2824 # JV-01 */ { /* Notify ACK to other domain */ CddIccom_NoticeAck(LddChannel, (CddIccom_CtaPartType)LucCtaIndex); /* PRQA S 4342 # JV-01 */ } else { /* No action required */ } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '6'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CTA_CNT', 'Value': '2'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'enRcvSta[0 to 1]', 'Value': '[6][0 to 1]=CDDICCOM_RCV_IDLE']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulValue', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_SendProcessing ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint8, AUTOMATIC) LucCtaIndex; VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; VAR(TickType, AUTOMATIC) LddTimeoutCntTick; LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; LddTimeoutCntTick = (TickType)CDDICCOM_ZERO_32; /* PRQA S 2982 # JV-01 */ /* Check if send request pending */ if (CDDICCOM_CTA_NONE != CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) /* PRQA S 2824 # JV-01 */ { /* Get current sending partition to notify data to other domain */ LucCtaIndex = (uint8)(CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr); CddIccom_NoticeData(LddChannel, CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr, CddIccom_GpChannelStatus[LddChannel].ulSndSize[LucCtaIndex]); /* PRQA S 2844 # JV-01 */ } /* End of if (CDDICCOM_CTA_NONE != \\ * * CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) */ else { /* No action required */ } /* Timeout detection */ for (LucCtaIndex = CDDICCOM_ZERO_8; LucCtaIndex < (uint8)CDDICCOM_CTA_CNT; LucCtaIndex++) { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Any CTA are is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) /* PRQA S 2824 # JV-01 */ { LddTimeoutCntTick = CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex]; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get elapsed counter tick from data notice to AP-System core domain */ (void)GetElapsedValue( CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntTick, (TickRefType)&LddTimeoutCntCurr); /* Check if timeout occurred */ if (LddTimeoutCntCurr > CddIccom_GpChannelConfig[LddChannel].uiTimeout) /* PRQA S 2824 # JV-01 */ { /* Timeout occurred */ #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex] = /* PRQA S 2824 # JV-01 */ CDDICCOM_SND_TIMEOUT; /* Clear the internal counter tick */ CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex] = CDDICCOM_ZERO_32; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ if (NULL_PTR != CddIccom_GpChannelConfig[LddChannel].pNotification) /* PRQA S 2824 # JV-01 */ { /* Notify timeout */ CddIccom_GpChannelConfig[LddChannel].pNotification(ICCOM_NOTICE_FATAL, /* PRQA S 2814 # JV-01 */ CDDICCOM_ZERO_32); } else { /* No action required */ } /* Report timeout error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* End of if (LddTimeoutCntCurr > * * CddIccom_GpChannelConfig[LddChannel].uiTimeout) */ else { /* No action required */ } } else { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814 # JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ } /* End of if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '[0]=CDDICCOM_CTA_UPPER'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '[0]=2048'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[0][0 to 1]=CDDICCOM_SND_IDLE'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '-'], 'Input_Param_008': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CTA_CNT', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[0]=&ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'uiTimeout', 'Value': '-'], 'Input_Param_012': ['Type': 'Output_Argument', 'Range': '', 'Name': '*ElapsedValue', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[0]=&ISOLATE_void_func_ptr'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pNotification', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_UPPER'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '-'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': '-'], 'Output_Param_026': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_027': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_029': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_SendProcessing ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint8, AUTOMATIC) LucCtaIndex; VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; VAR(TickType, AUTOMATIC) LddTimeoutCntTick; LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; LddTimeoutCntTick = (TickType)CDDICCOM_ZERO_32; /* PRQA S 2982 # JV-01 */ /* Check if send request pending */ if (CDDICCOM_CTA_NONE != CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) /* PRQA S 2824 # JV-01 */ { /* Get current sending partition to notify data to other domain */ LucCtaIndex = (uint8)(CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr); CddIccom_NoticeData(LddChannel, CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr, CddIccom_GpChannelStatus[LddChannel].ulSndSize[LucCtaIndex]); /* PRQA S 2844 # JV-01 */ } /* End of if (CDDICCOM_CTA_NONE != \\ * * CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) */ else { /* No action required */ } /* Timeout detection */ for (LucCtaIndex = CDDICCOM_ZERO_8; LucCtaIndex < (uint8)CDDICCOM_CTA_CNT; LucCtaIndex++) { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Any CTA are is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) /* PRQA S 2824 # JV-01 */ { LddTimeoutCntTick = CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex]; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get elapsed counter tick from data notice to AP-System core domain */ (void)GetElapsedValue( CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntTick, (TickRefType)&LddTimeoutCntCurr); /* Check if timeout occurred */ if (LddTimeoutCntCurr > CddIccom_GpChannelConfig[LddChannel].uiTimeout) /* PRQA S 2824 # JV-01 */ { /* Timeout occurred */ #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex] = /* PRQA S 2824 # JV-01 */ CDDICCOM_SND_TIMEOUT; /* Clear the internal counter tick */ CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex] = CDDICCOM_ZERO_32; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ if (NULL_PTR != CddIccom_GpChannelConfig[LddChannel].pNotification) /* PRQA S 2824 # JV-01 */ { /* Notify timeout */ CddIccom_GpChannelConfig[LddChannel].pNotification(ICCOM_NOTICE_FATAL, /* PRQA S 2814 # JV-01 */ CDDICCOM_ZERO_32); } else { /* No action required */ } /* Report timeout error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* End of if (LddTimeoutCntCurr > * * CddIccom_GpChannelConfig[LddChannel].uiTimeout) */ else { /* No action required */ } } else { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814 # JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ } /* End of if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '2'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '[2]=CDDICCOM_CTA_UPPER'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '[2]=2048'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[2][0 to 1]=CDDICCOM_SND_IDLE'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '-'], 'Input_Param_008': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CTA_CNT', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[2]=&ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'uiTimeout', 'Value': '-'], 'Input_Param_012': ['Type': 'Output_Argument', 'Range': '', 'Name': '*ElapsedValue', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[2]=&ISOLATE_void_func_ptr'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pNotification', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '2'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_UPPER'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '-'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': '-'], 'Output_Param_026': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_027': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_029': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_SendProcessing ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint8, AUTOMATIC) LucCtaIndex; VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; VAR(TickType, AUTOMATIC) LddTimeoutCntTick; LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; LddTimeoutCntTick = (TickType)CDDICCOM_ZERO_32; /* PRQA S 2982 # JV-01 */ /* Check if send request pending */ if (CDDICCOM_CTA_NONE != CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) /* PRQA S 2824 # JV-01 */ { /* Get current sending partition to notify data to other domain */ LucCtaIndex = (uint8)(CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr); CddIccom_NoticeData(LddChannel, CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr, CddIccom_GpChannelStatus[LddChannel].ulSndSize[LucCtaIndex]); /* PRQA S 2844 # JV-01 */ } /* End of if (CDDICCOM_CTA_NONE != \\ * * CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) */ else { /* No action required */ } /* Timeout detection */ for (LucCtaIndex = CDDICCOM_ZERO_8; LucCtaIndex < (uint8)CDDICCOM_CTA_CNT; LucCtaIndex++) { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Any CTA are is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) /* PRQA S 2824 # JV-01 */ { LddTimeoutCntTick = CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex]; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get elapsed counter tick from data notice to AP-System core domain */ (void)GetElapsedValue( CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntTick, (TickRefType)&LddTimeoutCntCurr); /* Check if timeout occurred */ if (LddTimeoutCntCurr > CddIccom_GpChannelConfig[LddChannel].uiTimeout) /* PRQA S 2824 # JV-01 */ { /* Timeout occurred */ #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex] = /* PRQA S 2824 # JV-01 */ CDDICCOM_SND_TIMEOUT; /* Clear the internal counter tick */ CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex] = CDDICCOM_ZERO_32; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ if (NULL_PTR != CddIccom_GpChannelConfig[LddChannel].pNotification) /* PRQA S 2824 # JV-01 */ { /* Notify timeout */ CddIccom_GpChannelConfig[LddChannel].pNotification(ICCOM_NOTICE_FATAL, /* PRQA S 2814 # JV-01 */ CDDICCOM_ZERO_32); } else { /* No action required */ } /* Report timeout error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* End of if (LddTimeoutCntCurr > * * CddIccom_GpChannelConfig[LddChannel].uiTimeout) */ else { /* No action required */ } } else { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814 # JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ } /* End of if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '4'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '[4]=CDDICCOM_CTA_BOTTOM'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '[4]=2048'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[4][0 to 1]=CDDICCOM_SND_WAITACK'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[4][0 to 1]=0x00000001'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '[4]=OsCounter'], 'Input_Param_008': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CTA_CNT', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[4]=&ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'uiTimeout', 'Value': '[4]=0x00000032'], 'Input_Param_012': ['Type': 'Output_Argument', 'Range': '', 'Name': '*ElapsedValue', 'Value': '0x00000033'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[4]=&ISOLATE_void_func_ptr'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pNotification', 'Value': '[4]=&ISOLATE_void_func_ptr_IccomNoticeType__uint32']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '4'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_BOTTOM'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[4][0 to 1]=CDDICCOM_SND_TIMEOUT'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[4][0 to 1]=CDDICCOM_ZERO_32'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_FATAL'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_FATAL'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_026': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_027': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_SendProcessing ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint8, AUTOMATIC) LucCtaIndex; VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; VAR(TickType, AUTOMATIC) LddTimeoutCntTick; LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; LddTimeoutCntTick = (TickType)CDDICCOM_ZERO_32; /* PRQA S 2982 # JV-01 */ /* Check if send request pending */ if (CDDICCOM_CTA_NONE != CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) /* PRQA S 2824 # JV-01 */ { /* Get current sending partition to notify data to other domain */ LucCtaIndex = (uint8)(CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr); CddIccom_NoticeData(LddChannel, CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr, CddIccom_GpChannelStatus[LddChannel].ulSndSize[LucCtaIndex]); /* PRQA S 2844 # JV-01 */ } /* End of if (CDDICCOM_CTA_NONE != \\ * * CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) */ else { /* No action required */ } /* Timeout detection */ for (LucCtaIndex = CDDICCOM_ZERO_8; LucCtaIndex < (uint8)CDDICCOM_CTA_CNT; LucCtaIndex++) { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Any CTA are is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) /* PRQA S 2824 # JV-01 */ { LddTimeoutCntTick = CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex]; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get elapsed counter tick from data notice to AP-System core domain */ (void)GetElapsedValue( CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntTick, (TickRefType)&LddTimeoutCntCurr); /* Check if timeout occurred */ if (LddTimeoutCntCurr > CddIccom_GpChannelConfig[LddChannel].uiTimeout) /* PRQA S 2824 # JV-01 */ { /* Timeout occurred */ #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex] = /* PRQA S 2824 # JV-01 */ CDDICCOM_SND_TIMEOUT; /* Clear the internal counter tick */ CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex] = CDDICCOM_ZERO_32; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ if (NULL_PTR != CddIccom_GpChannelConfig[LddChannel].pNotification) /* PRQA S 2824 # JV-01 */ { /* Notify timeout */ CddIccom_GpChannelConfig[LddChannel].pNotification(ICCOM_NOTICE_FATAL, /* PRQA S 2814 # JV-01 */ CDDICCOM_ZERO_32); } else { /* No action required */ } /* Report timeout error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* End of if (LddTimeoutCntCurr > * * CddIccom_GpChannelConfig[LddChannel].uiTimeout) */ else { /* No action required */ } } else { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814 # JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ } /* End of if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '4'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '[4]=CDDICCOM_CTA_NONE'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[4][0 to 1]=CDDICCOM_SND_WAITACK'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[4][0 to 1]=0x00000001'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '[4]=OsCounter'], 'Input_Param_008': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CTA_CNT', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[4]=&ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'uiTimeout', 'Value': '[4]=0x00000032'], 'Input_Param_012': ['Type': 'Output_Argument', 'Range': '', 'Name': '*ElapsedValue', 'Value': '0x00000033'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[4]=&ISOLATE_void_func_ptr'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pNotification', 'Value': '[4]=&ISOLATE_void_func_ptr_IccomNoticeType__uint32']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[4][0 to 1]=CDDICCOM_SND_TIMEOUT'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[4][0 to 1]=CDDICCOM_ZERO_32'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_FATAL'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_FATAL'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_026': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_027': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_SendProcessing ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint8, AUTOMATIC) LucCtaIndex; VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; VAR(TickType, AUTOMATIC) LddTimeoutCntTick; LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; LddTimeoutCntTick = (TickType)CDDICCOM_ZERO_32; /* PRQA S 2982 # JV-01 */ /* Check if send request pending */ if (CDDICCOM_CTA_NONE != CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) /* PRQA S 2824 # JV-01 */ { /* Get current sending partition to notify data to other domain */ LucCtaIndex = (uint8)(CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr); CddIccom_NoticeData(LddChannel, CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr, CddIccom_GpChannelStatus[LddChannel].ulSndSize[LucCtaIndex]); /* PRQA S 2844 # JV-01 */ } /* End of if (CDDICCOM_CTA_NONE != \\ * * CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) */ else { /* No action required */ } /* Timeout detection */ for (LucCtaIndex = CDDICCOM_ZERO_8; LucCtaIndex < (uint8)CDDICCOM_CTA_CNT; LucCtaIndex++) { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Any CTA are is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) /* PRQA S 2824 # JV-01 */ { LddTimeoutCntTick = CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex]; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get elapsed counter tick from data notice to AP-System core domain */ (void)GetElapsedValue( CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntTick, (TickRefType)&LddTimeoutCntCurr); /* Check if timeout occurred */ if (LddTimeoutCntCurr > CddIccom_GpChannelConfig[LddChannel].uiTimeout) /* PRQA S 2824 # JV-01 */ { /* Timeout occurred */ #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex] = /* PRQA S 2824 # JV-01 */ CDDICCOM_SND_TIMEOUT; /* Clear the internal counter tick */ CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex] = CDDICCOM_ZERO_32; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ if (NULL_PTR != CddIccom_GpChannelConfig[LddChannel].pNotification) /* PRQA S 2824 # JV-01 */ { /* Notify timeout */ CddIccom_GpChannelConfig[LddChannel].pNotification(ICCOM_NOTICE_FATAL, /* PRQA S 2814 # JV-01 */ CDDICCOM_ZERO_32); } else { /* No action required */ } /* Report timeout error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* End of if (LddTimeoutCntCurr > * * CddIccom_GpChannelConfig[LddChannel].uiTimeout) */ else { /* No action required */ } } else { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814 # JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ } /* End of if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '7'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '[7]=CDDICCOM_CTA_UPPER'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '[7]=2048'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[7][0 to 1]=CDDICCOM_SND_WAITACK'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[7][0 to 1]=0x00000001'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '[7]=OsCounter'], 'Input_Param_008': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CTA_CNT', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[7]=&ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'uiTimeout', 'Value': '[7]=0x00000032'], 'Input_Param_012': ['Type': 'Output_Argument', 'Range': '', 'Name': '*ElapsedValue', 'Value': '0x00000033'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[7]=&ISOLATE_void_func_ptr'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pNotification', 'Value': '[7]=NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '7'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_UPPER'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[7][0 to 1]=CDDICCOM_SND_TIMEOUT'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[7][0 to 1]=CDDICCOM_ZERO_32'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': '-'], 'Output_Param_026': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_027': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_SendProcessing ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint8, AUTOMATIC) LucCtaIndex; VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; VAR(TickType, AUTOMATIC) LddTimeoutCntTick; LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; LddTimeoutCntTick = (TickType)CDDICCOM_ZERO_32; /* PRQA S 2982 # JV-01 */ /* Check if send request pending */ if (CDDICCOM_CTA_NONE != CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) /* PRQA S 2824 # JV-01 */ { /* Get current sending partition to notify data to other domain */ LucCtaIndex = (uint8)(CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr); CddIccom_NoticeData(LddChannel, CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr, CddIccom_GpChannelStatus[LddChannel].ulSndSize[LucCtaIndex]); /* PRQA S 2844 # JV-01 */ } /* End of if (CDDICCOM_CTA_NONE != \\ * * CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) */ else { /* No action required */ } /* Timeout detection */ for (LucCtaIndex = CDDICCOM_ZERO_8; LucCtaIndex < (uint8)CDDICCOM_CTA_CNT; LucCtaIndex++) { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Any CTA are is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) /* PRQA S 2824 # JV-01 */ { LddTimeoutCntTick = CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex]; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get elapsed counter tick from data notice to AP-System core domain */ (void)GetElapsedValue( CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntTick, (TickRefType)&LddTimeoutCntCurr); /* Check if timeout occurred */ if (LddTimeoutCntCurr > CddIccom_GpChannelConfig[LddChannel].uiTimeout) /* PRQA S 2824 # JV-01 */ { /* Timeout occurred */ #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex] = /* PRQA S 2824 # JV-01 */ CDDICCOM_SND_TIMEOUT; /* Clear the internal counter tick */ CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex] = CDDICCOM_ZERO_32; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ if (NULL_PTR != CddIccom_GpChannelConfig[LddChannel].pNotification) /* PRQA S 2824 # JV-01 */ { /* Notify timeout */ CddIccom_GpChannelConfig[LddChannel].pNotification(ICCOM_NOTICE_FATAL, /* PRQA S 2814 # JV-01 */ CDDICCOM_ZERO_32); } else { /* No action required */ } /* Report timeout error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* End of if (LddTimeoutCntCurr > * * CddIccom_GpChannelConfig[LddChannel].uiTimeout) */ else { /* No action required */ } } else { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814 # JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ } /* End of if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '9'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '[9]=CDDICCOM_CTA_UPPER'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '[9]=2048'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[9][0 to 1]=CDDICCOM_SND_WAITACK'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[9][0 to 1]=0x00000001'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '[9]=OsCounter'], 'Input_Param_008': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CTA_CNT', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[9]=&ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'uiTimeout', 'Value': '[9]=0x00000032'], 'Input_Param_012': ['Type': 'Output_Argument', 'Range': '', 'Name': '*ElapsedValue', 'Value': '0x00000033'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[9]=&ISOLATE_void_func_ptr'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pNotification', 'Value': '[9]=&ISOLATE_void_func_ptr_IccomNoticeType__uint32']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '9'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_UPPER'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[9][0 to 1]=CDDICCOM_SND_TIMEOUT'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[9][0 to 1]=CDDICCOM_ZERO_32'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_FATAL'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_FATAL'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_026': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_027': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDICCOM_CODE_SLOW) CddIccom_SendProcessing ( VAR(CddIccom_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint8, AUTOMATIC) LucCtaIndex; VAR(TickType, AUTOMATIC) LddTimeoutCntCurr; VAR(TickType, AUTOMATIC) LddTimeoutCntTick; LddTimeoutCntCurr = (TickType)CDDICCOM_ZERO_32; LddTimeoutCntTick = (TickType)CDDICCOM_ZERO_32; /* PRQA S 2982 # JV-01 */ /* Check if send request pending */ if (CDDICCOM_CTA_NONE != CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) /* PRQA S 2824 # JV-01 */ { /* Get current sending partition to notify data to other domain */ LucCtaIndex = (uint8)(CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr); CddIccom_NoticeData(LddChannel, CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr, CddIccom_GpChannelStatus[LddChannel].ulSndSize[LucCtaIndex]); /* PRQA S 2844 # JV-01 */ } /* End of if (CDDICCOM_CTA_NONE != \\ * * CddIccom_GpChannelStatus[LddChannel].enSndCtaCurr) */ else { /* No action required */ } /* Timeout detection */ for (LucCtaIndex = CDDICCOM_ZERO_8; LucCtaIndex < (uint8)CDDICCOM_CTA_CNT; LucCtaIndex++) { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Any CTA are is waiting ACK */ if (CDDICCOM_SND_WAITACK == CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) /* PRQA S 2824 # JV-01 */ { LddTimeoutCntTick = CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex]; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get elapsed counter tick from data notice to AP-System core domain */ (void)GetElapsedValue( CddIccom_GpChannelConfig[LddChannel].ddTimeoutCntId, /* PRQA S 2824 # JV-01 */ (TickRefType)&LddTimeoutCntTick, (TickRefType)&LddTimeoutCntCurr); /* Check if timeout occurred */ if (LddTimeoutCntCurr > CddIccom_GpChannelConfig[LddChannel].uiTimeout) /* PRQA S 2824 # JV-01 */ { /* Timeout occurred */ #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex] = /* PRQA S 2824 # JV-01 */ CDDICCOM_SND_TIMEOUT; /* Clear the internal counter tick */ CddIccom_GpChannelStatus[LddChannel].ulTimeoutCntTick[LucCtaIndex] = CDDICCOM_ZERO_32; #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ if (NULL_PTR != CddIccom_GpChannelConfig[LddChannel].pNotification) /* PRQA S 2824 # JV-01 */ { /* Notify timeout */ CddIccom_GpChannelConfig[LddChannel].pNotification(ICCOM_NOTICE_FATAL, /* PRQA S 2814 # JV-01 */ CDDICCOM_ZERO_32); } else { /* No action required */ } /* Report timeout error to Dem */ (void)Dem_SetEventStatus(CDDICCOM_E_TIMEOUT, DEM_EVENT_STATUS_FAILED); } /* End of if (LddTimeoutCntCurr > * * CddIccom_GpChannelConfig[LddChannel].uiTimeout) */ else { /* No action required */ } } else { #if (CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON) CddIccom_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814 # JV-01 */ #endif /* CDDICCOM_CRITICAL_SECTION_PROTECTION == STD_ON */ } /* End of if (CDDICCOM_SND_WAITACK == * * CddIccom_GpChannelStatus[LddChannel].enSndSta[LucCtaIndex]) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '9'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelStatus', 'Value': '&ptr_CddIccom_GpChannelStatus[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'enSndCtaCurr', 'Value': '[9]=CDDICCOM_CTA_BOTTOM'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_UPPER]', 'Value': '-'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulSndSize[CDDICCOM_CTA_BOTTOM]', 'Value': '[9]=2048'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[9][0 to 1]=CDDICCOM_SND_WAITACK'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[9][0 to 1]=0x00000001'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ddTimeoutCntId', 'Value': '[9]=OsCounter'], 'Input_Param_008': ['Type': 'Macro', 'Range': '', 'Name': 'CDDICCOM_CTA_CNT', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '&ptr_CddIccom_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[9]=&ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'uiTimeout', 'Value': '[9]=0x00000032'], 'Input_Param_012': ['Type': 'Output_Argument', 'Range': '', 'Name': '*ElapsedValue', 'Value': '0x00000033'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[9]=&ISOLATE_void_func_ptr'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pNotification', 'Value': '[9]=&ISOLATE_void_func_ptr_IccomNoticeType__uint32']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '9'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenCtaPart', 'Value': 'CDDICCOM_CTA_BOTTOM'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '2048'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'enSndSta[0 to 1]', 'Value': '[9][0 to 1]=CDDICCOM_SND_TIMEOUT'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ulTimeoutCntTick[0 to 1]', 'Value': '[9][0 to 1]=CDDICCOM_ZERO_32'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_FATAL'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'CounterID', 'Value': 'OsCounter'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '0x00000001'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ElapsedValue', 'Value': '0x00000033'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenType', 'Value': 'ICCOM_NOTICE_FATAL'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMsg', 'Value': 'CDDICCOM_ZERO_32'], 'Output_Param_026': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'CDDICCOM_E_TIMEOUT'], 'Output_Param_027': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDICCOM_START_SEC_CODE_SLOW #include \"CddIccom_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDICCOM_CODE_SLOW) CddIccom_SendRun /* PRQA S 1505 # JV-01 */ ( CddIccom_ChannelType LddChannel, IccomDataPtr LpData, /* PRQA S 3673 # JV-01 */ uint32 LulSize ) { /* Place holder for return value */ VAR(Std_ReturnType, AUTOMATIC) LddRetVal; /* Place holder for ICCOM function return */ VAR(CddIccom_ReturnType, AUTOMATIC) LddIccomRet; /* Initialize local variables */ LddRetVal = E_OK; LddIccomRet = CDDICCOM_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDICCOM_DEV_ERROR_DETECT == STD_ON) /* Validate driver initialization status */ if (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0SENDRUN_SID + LddChannel, CDDICCOM_E_UNINIT); LddRetVal = E_NOT_OK; } else { /* Validate of input pointer */ if (NULL_PTR == LpData) { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0SENDRUN_SID + LddChannel, CDDICCOM_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* Validate of input value */ if ((CDDICCOM_ZERO_32 == LulSize) || (CddIccom_GpChannelConfig[LddChannel].uiCtaPartSize < LulSize)) /* PRQA S 2824 # JV-01 */ { /* Report to DET */ (void)Det_ReportError (CDDICCOM_MODULE_ID, CDDICCOM_INSTANCE_ID, CDDICCOM_CH0SENDRUN_SID + LddChannel, CDDICCOM_E_PARAM_VALUE); LddRetVal = E_NOT_OK; } else { /* No action is required since DET check */ } } /* End of else (NULL_PTR == LpData) */ } /* End of else (CDDICCOM_INITIALIZED != CddIccom_GblDriverStatus) */ if (E_OK == LddRetVal) #endif /* CDDICCOM_DEV_ERROR_DETECT == STD_ON */ { /* Perform Data write */ LddIccomRet = CddIccom_Send(LddChannel, LpData, LulSize); if (CDDICCOM_E_OK == LddIccomRet) { LddRetVal = RTE_E_OK; } else { LddRetVal = RTE_E_LIMIT; } } /* End of if (E_OK == LddRetVal) */ #if (CDDICCOM_DEV_ERROR_DETECT == STD_ON) else { /* No action required since DET checked */ } #endif /* Single exit point */ return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDICCOM_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..9', 'Name': 'LddChannel', 'Value': '2'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulSize', 'Value': 'CDDICCOM_ZERO_32'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'CDDICCOM_UNINITIALIZED..CDDICCOM_INITIALIZED', 'Name': 'CddIccom_GblDriverStatus', 'Value': 'CDDICCOM_INITIALIZED'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'CddIccom_GpChannelConfig', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'uiCtaPartSize', 'Value': '-'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '-', 'Name': 'ModuleId', 'Value': 'CDDICCOM_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '-', 'Name': 'InstanceId', 'Value': 'CDDICCOM_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '-', 'Name': 'ApiId', 'Value': 'CDDICCOM_CH0SENDRUN_SID +2'], 'Output_Param_003': ['Type': 'Error', 'Range': '-', 'Name': 'ErrorId', 'Value': 'CDDICCOM_E_PARAM_VALUE'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSize', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if(CDDIIC_CH0_INTERFACE == CDDIIC_SLAVE_INTERFACE) #define CddIic_START_SEC_CODE #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CddIic_CODE) CddIic_Ch0SlaveInit /* PRQA S 1503 # JV-01 */ ( uint8 LucSlaveOwnAdress, IicSlaveIfPtr LpSlaveInterface ) { Std_ReturnType LddRetVal; LddRetVal = CddIic_SlaveConfiguration(CDDIIC_CH0, LucSlaveOwnAdress, \\ LpSlaveInterface); return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CH0_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'CDDIIC_MASTER_INTERFACE\\nCDDIIC_SLAVE_INTERFACE', 'Name': 'CDDIIC_CH0_INTERFACE', 'Value': 'CDDIIC_SLAVE_INTERFACE'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..127', 'Name': 'LucSlaveOwnAdress', 'Value': '63'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpSlaveInterface', 'Value': '&ptr_LpSlaveInterface[0]'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH0', 'Value': '0x00'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSlaveOwnAdress', 'Value': '63'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveInterface', 'Value': '&ptr_LpSlaveInterface[0]'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if(CDDIIC_CH2_USED == STD_ON) #if(CDDIIC_CH2_INTERFACE == CDDIIC_MASTER_INTERFACE) #define CddIic_START_SEC_CODE #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CddIic_CODE) CddIic_Ch2Write /* PRQA S 1503 # JV-01 */ ( IicSndDataPtr LpData, uint32 LulSndByteNumber, IicSlaveConfigPtr LpSlaveConfig ) { Std_ReturnType LddRetVal; LddRetVal = CddIic_ClockConfiguration(CDDIIC_CH2, LpSlaveConfig, \\ CDDIIC_CH2WRITE_SID); if (RTE_E_OK == LddRetVal) { LddRetVal = CddIic_Write(CDDIIC_CH2, LpData, LulSndByteNumber, \\ LpSlaveConfig); } else { /* No action required */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CH2_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'CDDIIC_MASTER_INTERFACE\\nCDDIIC_SLAVE_INTERFACE', 'Name': 'CDDIIC_CH2_INTERFACE', 'Value': 'CDDIIC_MASTER_INTERFACE'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpData', 'Value': 'NULL_PTR'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulSndByteNumber', 'Value': '2048'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_INVALID']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_INVALID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH2', 'Value': '0x02'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH2WRITE_SID', 'Value': '0x04'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH2', 'Value': '0x02'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': 'NULL_PTR'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSndByteNumber', 'Value': '2048'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if(CDDIIC_CH2_INTERFACE == CDDIIC_MASTER_INTERFACE) #define CddIic_START_SEC_CODE #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CddIic_CODE) CddIic_Ch2WriteRead /* PRQA S 1503 # JV-01 */ ( IicSndDataPtr LpWriteBuff, uint32 LulWriteNumber, IicRcvDataPtr LpReadBuff, uint32 LulReadNumber, IicSlaveConfigPtr LpSlaveConfig ) { Std_ReturnType LddRetVal; CddIic_WriteType LstWriteConfig; CddIic_ReadType LstReadConfig; /* Clock configuration */ LddRetVal = CddIic_ClockConfiguration(CDDIIC_CH2, LpSlaveConfig, \\ CDDIIC_CH2WRITEREAD_SID); if (RTE_E_OK == LddRetVal) { /* Store the information to passing to internal function */ /* Write Buffer */ LstWriteConfig.pWriteBuff = LpWriteBuff; /* Write Number */ LstWriteConfig.ulWriteNumber = LulWriteNumber; /* Read Buffer */ LstReadConfig.pReadBuff = LpReadBuff; /* Read Number */ LstReadConfig.ulReadNumber = LulReadNumber; LddRetVal = CddIic_WriteRead(CDDIIC_CH2, &LstWriteConfig, \\ &LstReadConfig, LpSlaveConfig); } else { /* No action required */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CH2_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'CDDIIC_MASTER_INTERFACE\\nCDDIIC_SLAVE_INTERFACE', 'Name': 'CDDIIC_CH2_INTERFACE', 'Value': 'CDDIIC_MASTER_INTERFACE'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpWriteBuff', 'Value': '&map_LpWriteBuff[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulWriteNumber', 'Value': '2048'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpReadBuff', 'Value': '&map_LpReadBuff[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulReadNumber', 'Value': '2048'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH2', 'Value': '0x02'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH2WRITEREAD_SID', 'Value': '0x32'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH2', 'Value': '0x02'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LstWriteConfig', 'Value': '&map_LpWriteBuff[0]'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LstReadConfig', 'Value': '&map_LpReadBuff[0]'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if(CDDIIC_CH3_USED == STD_ON) #if(CDDIIC_CH3_INTERFACE == CDDIIC_MASTER_INTERFACE) #define CddIic_START_SEC_CODE #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CddIic_CODE) CddIic_Ch3Write /* PRQA S 1503 # JV-01 */ ( IicSndDataPtr LpData, uint32 LulSndByteNumber, IicSlaveConfigPtr LpSlaveConfig ) { Std_ReturnType LddRetVal; LddRetVal = CddIic_ClockConfiguration(CDDIIC_CH3, LpSlaveConfig, \\ CDDIIC_CH3WRITE_SID); if (RTE_E_OK == LddRetVal) { LddRetVal = CddIic_Write(CDDIIC_CH3, LpData, LulSndByteNumber, \\ LpSlaveConfig); } else { /* No action required */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CH3_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'CDDIIC_MASTER_INTERFACE\\nCDDIIC_SLAVE_INTERFACE', 'Name': 'CDDIIC_CH3_INTERFACE', 'Value': 'CDDIIC_MASTER_INTERFACE'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulSndByteNumber', 'Value': 'CDDIIC_ZERO_32'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_INVALID']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_INVALID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH3', 'Value': '0x03'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH3WRITE_SID', 'Value': '0x05'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH3', 'Value': '0x03'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSndByteNumber', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if(CDDIIC_CH3_INTERFACE == CDDIIC_MASTER_INTERFACE) #define CddIic_START_SEC_CODE #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CddIic_CODE) CddIic_Ch3WriteRead /* PRQA S 1503 # JV-01 */ ( IicSndDataPtr LpWriteBuff, uint32 LulWriteNumber, IicRcvDataPtr LpReadBuff, uint32 LulReadNumber, IicSlaveConfigPtr LpSlaveConfig ) { Std_ReturnType LddRetVal; CddIic_WriteType LstWriteConfig; CddIic_ReadType LstReadConfig; /* Clock configuration */ LddRetVal = CddIic_ClockConfiguration(CDDIIC_CH3, LpSlaveConfig, \\ CDDIIC_CH3WRITEREAD_SID); if (RTE_E_OK == LddRetVal) { /* Store the information to passing to internal function */ /* Write Buffer */ LstWriteConfig.pWriteBuff = LpWriteBuff; /* Write Number */ LstWriteConfig.ulWriteNumber = LulWriteNumber; /* Read Buffer */ LstReadConfig.pReadBuff = LpReadBuff; /* Read Number */ LstReadConfig.ulReadNumber = LulReadNumber; LddRetVal = CddIic_WriteRead(CDDIIC_CH3, &LstWriteConfig, \\ &LstReadConfig, LpSlaveConfig); } else { /* No action required */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CH3_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'CDDIIC_MASTER_INTERFACE\\nCDDIIC_SLAVE_INTERFACE', 'Name': 'CDDIIC_CH3_INTERFACE', 'Value': 'CDDIIC_MASTER_INTERFACE'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpWriteBuff', 'Value': '&map_LpWriteBuff[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulWriteNumber', 'Value': '2048'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpReadBuff', 'Value': '&map_LpReadBuff[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulReadNumber', 'Value': '2048'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH3', 'Value': '0x03'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH3WRITEREAD_SID', 'Value': '0x33'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH3', 'Value': '0x03'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LstWriteConfig', 'Value': '&map_LpWriteBuff[0]'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LstReadConfig', 'Value': '&map_LpReadBuff[0]'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if(CDDIIC_CH4_USED == STD_ON) #if(CDDIIC_CH4_INTERFACE == CDDIIC_MASTER_INTERFACE) #define CddIic_START_SEC_CODE #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CDDIIC_CODE_SLOW) CddIic_Ch4Write /* PRQA S 1503 # JV-01 */ ( IicSndDataPtr LpData, uint32 LulSndByteNumber, IicSlaveConfigPtr LpSlaveConfig ) { Std_ReturnType LddRetVal; LddRetVal = CddIic_ClockConfiguration(CDDIIC_CH4, LpSlaveConfig, \\ CDDIIC_CH4WRITE_SID); if (RTE_E_OK == LddRetVal) { LddRetVal = CddIic_Write(CDDIIC_CH4, LpData, LulSndByteNumber, \\ LpSlaveConfig); } else { /* No action required */ } return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CH4_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'CDDIIC_MASTER_INTERFACE\\nCDDIIC_SLAVE_INTERFACE', 'Name': 'CDDIIC_CH4_INTERFACE', 'Value': 'CDDIIC_MASTER_INTERFACE'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpData', 'Value': 'NULL_PTR'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulSndByteNumber', 'Value': '2048'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_INVALID']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_INVALID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH4', 'Value': '0x04'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH4WRITE_SID', 'Value': '0x06'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'CDDIIC_CH4', 'Value': '0x04'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': 'NULL_PTR'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSndByteNumber', 'Value': '2048'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CddIic_START_SEC_CODE #include \"CddIic_MemMap.h\" FUNC(void, CddIic_CODE) CddIic_Ch6NoticeCallBack ( IicNotification LstNoticInfo ) { /* Notify to notice port */ (void)Rte_Call_P_Ch6Notice_NoticeInfo(&LstNoticInfo); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CH6_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL_PTR..Address', 'Name': 'LstNoticInfo', 'Value': 'NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': '*CDDIic_P_Ch6Notice_NoticeInfo', 'Value': 'NoticeInfo'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CDDIIC_CODE_SLOW) CddIic_ClockConfiguration /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig, /* PRQA S 3432 # JV-01 */ VAR (uint8, AUTOMATIC) LucServiceId ) { VAR(uint32, AUTOMATIC) LulSclClkGenDiv; VAR(uint32, AUTOMATIC) LulICCCRegVal; VAR(uint32, AUTOMATIC) LulICCCReg2Val; VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(CddIic_ChStaType, AUTOMATIC) LenChSta; /* Initialize local variables */ LddRetVal = E_OK; /* Initialize local variables */ LulICCCReg2Val = CDDIIC_ZERO_32; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) /* Confirm whether driver has been initialized */ if (CDDIIC_INITIALIZED != CddIic_GblDriverStatus) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ LucServiceId, CDDIIC_E_UNINITIALIZED); /* Return NOK error code */ LddRetVal = E_NOT_OK; /* Confirm current channel is busy or not */ } else { if (NULL_PTR == LpSlaveConfig) { (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ LucServiceId, CDDIIC_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* No action required */ } } if (E_OK == LddRetVal) #else (void) LucServiceId; #endif { #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Get the current channel status */ LenChSta = CddIic_GpChannelStatus[LddChannel].enChSta; /* PRQA S 2824 # JV-01 */ /* If the current channel status is idle */ if (CDDIIC_CH_IDLE == LenChSta) { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_CONFIGURE; #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif if (CDDIIC_FIXED_DUTY == LpSlaveConfig->enClockMode) /* PRQA S 2814 # JV-01 */ { LulSclClkGenDiv = (uint32) (LpSlaveConfig->ucSclClkGenDiv); LulICCCRegVal = \\ (LulSclClkGenDiv << CDDIIC_THREE_32) | CDDIIC_CLOCK_DIVISION_FACTOR; #if(CDDIIC_FAST_MODE_PLUS == STD_ON) LulICCCReg2Val = CDDIIC_FMPE_ENABLE; #endif /* Classify clock mode for clock configuration */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ LulICCCRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCRnReg, LulICCCRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_32_BIT_MASK); #endif CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ LulICCCReg2Val); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, LulICCCReg2Val, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* First bit cycle setup */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle, CDDIIC_8_BIT_MASK); #endif } else { #if(CDDIIC_FAST_MODE_PLUS == STD_ON) /* Disable CDF, Enable HIGH/LOW separate control, enable SCL Mask enable fast mode plus*/ LulICCCReg2Val = CDDIIC_CDF_DISABLE | CDDIIC_HLSE_ENABLE | \\ CDDIIC_SME_ENABLE | CDDIIC_FMPE_ENABLE; #else /* Disable CDF, Enable HIGH/LOW separate control, enable SCL Mask */ LulICCCReg2Val = CDDIIC_CDF_DISABLE | CDDIIC_HLSE_ENABLE | \\ CDDIIC_SME_ENABLE; #endif CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMPRnReg, \\ CDDIIC_SCL_MASK_DIVISION); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMPRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_SCL_MASK_DIVISION, CDDIIC_8_BIT_MASK); #endif /* Write Scl High clock Division into Scl High control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICHPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLHighPeriod); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICHPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLHighPeriod, CDDIIC_16_BIT_MASK); #endif /* Write Scl Low clock division into Scl Low control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICLPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLLowPeriod); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICLPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLLowPeriod, CDDIIC_16_BIT_MASK); #endif /* CDFD = 1, HLSE = 1, SME = 1 */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ LulICCCReg2Val); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, LulICCCReg2Val, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* CDF = 6, SCGD = 0 */ LulICCCRegVal = CDDIIC_CLOCK_DIVISION_FACTOR; /* Write value into clock control register (ICCCR) */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ LulICCCRegVal); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCRnReg, LulICCCRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif } /* First bit set up cycle */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle, CDDIIC_8_BIT_MASK); #endif } else { LddRetVal = RTE_E_COM_BUSY; #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitGlbProtect(); #endif } } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': '-'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_FAST_MODE_PLUS', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GblDriverStatus', 'Value': 'CDDIIC_UNINITIALIZED'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pICCCRnReg', 'Value': '-'], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'pICCCR2nReg', 'Value': '-'], 'Input_Param_009': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pICFBSCRnReg', 'Value': '-'], 'Input_Param_011': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'pICMPRnReg', 'Value': '-'], 'Input_Param_013': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pICHPRnReg', 'Value': '-'], 'Input_Param_015': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'pICLPRnReg', 'Value': '-'], 'Input_Param_017': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '-'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '-'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': '-'], 'Input_Param_022': ['Type': 'Argument', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucSclClkGenDiv', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ucFisrtBitSetupCycle', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulSCLHighPeriod', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulSCLLowPeriod', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'enClockMode', 'Value': '-'], 'Input_Param_028': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': '-'], 'Input_Param_029': ['Type': 'Argument', 'Range': '0..255', 'Name': 'LucServiceId', 'Value': '128']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDIIC_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDIIC_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': ''], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDIIC_E_UNINITIALIZED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_038': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddRetVal', 'Value': 'E_NOT_OK'], 'Output_Param_039': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CDDIIC_CODE_SLOW) CddIic_ClockConfiguration /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig, /* PRQA S 3432 # JV-01 */ VAR (uint8, AUTOMATIC) LucServiceId ) { VAR(uint32, AUTOMATIC) LulSclClkGenDiv; VAR(uint32, AUTOMATIC) LulICCCRegVal; VAR(uint32, AUTOMATIC) LulICCCReg2Val; VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(CddIic_ChStaType, AUTOMATIC) LenChSta; /* Initialize local variables */ LddRetVal = E_OK; /* Initialize local variables */ LulICCCReg2Val = CDDIIC_ZERO_32; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) /* Confirm whether driver has been initialized */ if (CDDIIC_INITIALIZED != CddIic_GblDriverStatus) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ LucServiceId, CDDIIC_E_UNINITIALIZED); /* Return NOK error code */ LddRetVal = E_NOT_OK; /* Confirm current channel is busy or not */ } else { if (NULL_PTR == LpSlaveConfig) { (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ LucServiceId, CDDIIC_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* No action required */ } } if (E_OK == LddRetVal) #else (void) LucServiceId; #endif { #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Get the current channel status */ LenChSta = CddIic_GpChannelStatus[LddChannel].enChSta; /* PRQA S 2824 # JV-01 */ /* If the current channel status is idle */ if (CDDIIC_CH_IDLE == LenChSta) { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_CONFIGURE; #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif if (CDDIIC_FIXED_DUTY == LpSlaveConfig->enClockMode) /* PRQA S 2814 # JV-01 */ { LulSclClkGenDiv = (uint32) (LpSlaveConfig->ucSclClkGenDiv); LulICCCRegVal = \\ (LulSclClkGenDiv << CDDIIC_THREE_32) | CDDIIC_CLOCK_DIVISION_FACTOR; #if(CDDIIC_FAST_MODE_PLUS == STD_ON) LulICCCReg2Val = CDDIIC_FMPE_ENABLE; #endif /* Classify clock mode for clock configuration */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ LulICCCRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCRnReg, LulICCCRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_32_BIT_MASK); #endif CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ LulICCCReg2Val); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, LulICCCReg2Val, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* First bit cycle setup */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle, CDDIIC_8_BIT_MASK); #endif } else { #if(CDDIIC_FAST_MODE_PLUS == STD_ON) /* Disable CDF, Enable HIGH/LOW separate control, enable SCL Mask enable fast mode plus*/ LulICCCReg2Val = CDDIIC_CDF_DISABLE | CDDIIC_HLSE_ENABLE | \\ CDDIIC_SME_ENABLE | CDDIIC_FMPE_ENABLE; #else /* Disable CDF, Enable HIGH/LOW separate control, enable SCL Mask */ LulICCCReg2Val = CDDIIC_CDF_DISABLE | CDDIIC_HLSE_ENABLE | \\ CDDIIC_SME_ENABLE; #endif CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMPRnReg, \\ CDDIIC_SCL_MASK_DIVISION); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMPRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_SCL_MASK_DIVISION, CDDIIC_8_BIT_MASK); #endif /* Write Scl High clock Division into Scl High control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICHPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLHighPeriod); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICHPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLHighPeriod, CDDIIC_16_BIT_MASK); #endif /* Write Scl Low clock division into Scl Low control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICLPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLLowPeriod); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICLPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLLowPeriod, CDDIIC_16_BIT_MASK); #endif /* CDFD = 1, HLSE = 1, SME = 1 */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ LulICCCReg2Val); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, LulICCCReg2Val, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* CDF = 6, SCGD = 0 */ LulICCCRegVal = CDDIIC_CLOCK_DIVISION_FACTOR; /* Write value into clock control register (ICCCR) */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ LulICCCRegVal); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCRnReg, LulICCCRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif } /* First bit set up cycle */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle, CDDIIC_8_BIT_MASK); #endif } else { LddRetVal = RTE_E_COM_BUSY; #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitGlbProtect(); #endif } } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_FAST_MODE_PLUS', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GblDriverStatus', 'Value': 'CDDIIC_INITIALIZED'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pICCCRnReg', 'Value': ''], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'pICCCR2nReg', 'Value': ''], 'Input_Param_009': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pICFBSCRnReg', 'Value': ''], 'Input_Param_011': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'pICMPRnReg', 'Value': ''], 'Input_Param_013': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pICHPRnReg', 'Value': ''], 'Input_Param_015': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'pICLPRnReg', 'Value': ''], 'Input_Param_017': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': ''], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': ''], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '&ptr_CddIic_GpChannelStatus[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': ''], 'Input_Param_022': ['Type': 'Argument', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&map_LpSlaveConfig[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucSclClkGenDiv', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ucFisrtBitSetupCycle', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulSCLHighPeriod', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulSCLLowPeriod', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'enClockMode', 'Value': '-'], 'Input_Param_028': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_029': ['Type': 'Argument', 'Range': '0..255', 'Name': 'LucServiceId', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': ''], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_038': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddRetVal', 'Value': 'RTE_E_COM_BUSY'], 'Output_Param_039': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType , CDDIIC_CODE_SLOW) CddIic_ClockConfiguration /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig, /* PRQA S 3432 # JV-01 */ VAR (uint8, AUTOMATIC) LucServiceId ) { VAR(uint32, AUTOMATIC) LulSclClkGenDiv; VAR(uint32, AUTOMATIC) LulICCCRegVal; VAR(uint32, AUTOMATIC) LulICCCReg2Val; VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(CddIic_ChStaType, AUTOMATIC) LenChSta; /* Initialize local variables */ LddRetVal = E_OK; /* Initialize local variables */ LulICCCReg2Val = CDDIIC_ZERO_32; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) /* Confirm whether driver has been initialized */ if (CDDIIC_INITIALIZED != CddIic_GblDriverStatus) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ LucServiceId, CDDIIC_E_UNINITIALIZED); /* Return NOK error code */ LddRetVal = E_NOT_OK; /* Confirm current channel is busy or not */ } else { if (NULL_PTR == LpSlaveConfig) { (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ LucServiceId, CDDIIC_E_PARAM_POINTER); LddRetVal = E_NOT_OK; } else { /* No action required */ } } if (E_OK == LddRetVal) #else (void) LucServiceId; #endif { #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Get the current channel status */ LenChSta = CddIic_GpChannelStatus[LddChannel].enChSta; /* PRQA S 2824 # JV-01 */ /* If the current channel status is idle */ if (CDDIIC_CH_IDLE == LenChSta) { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_CONFIGURE; #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitGlbProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif if (CDDIIC_FIXED_DUTY == LpSlaveConfig->enClockMode) /* PRQA S 2814 # JV-01 */ { LulSclClkGenDiv = (uint32) (LpSlaveConfig->ucSclClkGenDiv); LulICCCRegVal = \\ (LulSclClkGenDiv << CDDIIC_THREE_32) | CDDIIC_CLOCK_DIVISION_FACTOR; #if(CDDIIC_FAST_MODE_PLUS == STD_ON) LulICCCReg2Val = CDDIIC_FMPE_ENABLE; #endif /* Classify clock mode for clock configuration */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ LulICCCRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCRnReg, LulICCCRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_32_BIT_MASK); #endif CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ LulICCCReg2Val); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, LulICCCReg2Val, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* First bit cycle setup */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle, CDDIIC_8_BIT_MASK); #endif } else { #if(CDDIIC_FAST_MODE_PLUS == STD_ON) /* Disable CDF, Enable HIGH/LOW separate control, enable SCL Mask enable fast mode plus*/ LulICCCReg2Val = CDDIIC_CDF_DISABLE | CDDIIC_HLSE_ENABLE | \\ CDDIIC_SME_ENABLE | CDDIIC_FMPE_ENABLE; #else /* Disable CDF, Enable HIGH/LOW separate control, enable SCL Mask */ LulICCCReg2Val = CDDIIC_CDF_DISABLE | CDDIIC_HLSE_ENABLE | \\ CDDIIC_SME_ENABLE; #endif CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMPRnReg, \\ CDDIIC_SCL_MASK_DIVISION); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMPRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_SCL_MASK_DIVISION, CDDIIC_8_BIT_MASK); #endif /* Write Scl High clock Division into Scl High control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICHPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLHighPeriod); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICHPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLHighPeriod, CDDIIC_16_BIT_MASK); #endif /* Write Scl Low clock division into Scl Low control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICLPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLLowPeriod); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICLPRnReg, /* PRQA S 2824 # JV-01 */ LpSlaveConfig->ulSCLLowPeriod, CDDIIC_16_BIT_MASK); #endif /* CDFD = 1, HLSE = 1, SME = 1 */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ LulICCCReg2Val); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, LulICCCReg2Val, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* CDF = 6, SCGD = 0 */ LulICCCRegVal = CDDIIC_CLOCK_DIVISION_FACTOR; /* Write value into clock control register (ICCCR) */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ LulICCCRegVal); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCRnReg, LulICCCRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif } /* First bit set up cycle */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle); /* Register write verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICFBSCRnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveConfig->ucFisrtBitSetupCycle, CDDIIC_8_BIT_MASK); #endif } else { LddRetVal = RTE_E_COM_BUSY; #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitGlbProtect(); #endif } } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_FAST_MODE_PLUS', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GblDriverStatus', 'Value': 'CDDIIC_INITIALIZED'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pICCCRnReg', 'Value': ''], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'pICCCR2nReg', 'Value': ''], 'Input_Param_009': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pICFBSCRnReg', 'Value': ''], 'Input_Param_011': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'pICMPRnReg', 'Value': ''], 'Input_Param_013': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pICHPRnReg', 'Value': ''], 'Input_Param_015': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'pICLPRnReg', 'Value': ''], 'Input_Param_017': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': ''], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': ''], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '&ptr_CddIic_GpChannelStatus[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': ''], 'Input_Param_022': ['Type': 'Argument', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '&map_LpSlaveConfig[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucSclClkGenDiv', 'Value': '0'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ucFisrtBitSetupCycle', 'Value': '0'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulSCLHighPeriod', 'Value': '0'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulSCLLowPeriod', 'Value': '0'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'enClockMode', 'Value': 'CDDIIC_VARIABLE_DUTY '], 'Input_Param_028': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_029': ['Type': 'Argument', 'Range': '0..255', 'Name': 'LucServiceId', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': ''], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMPRnReg[0]'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_SCL_MASK_DIVISION'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICHPRnReg[0]'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '0'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_16_BIT_MASK'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICLPRnReg[0]'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '0'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_16_BIT_MASK'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICCCR2nReg[0]'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_CDF_DISABLE | CDDIIC_HLSE_ENABLE |           CDDIIC_SME_ENABLE | CDDIIC_FMPE_ENABLE'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICCCRnReg[0]'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '6'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICFBSCRnReg[0]'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '0'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_038': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddRetVal', 'Value': 'E_OK'], 'Output_Param_039': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_FAST #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDIIC_CODE_FAST) CddIic_DmaEnable /* PRQA S 1532 # JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, VAR(CddIic_DmaModeType, AUTOMATIC) LenDmaMode ) { P2VAR(CddIic_DmaConfigType, AUTOMATIC, CDDIIC_DATA) LpDmaConfig; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(uint32, AUTOMATIC) LulRegVal; VAR(uint32, AUTOMATIC) LulDmaTxBaseAddr; VAR(uint32, AUTOMATIC) LulDmaRxBaseAddr; /* Initialize register value */ LulRegVal = CDDIIC_ZERO_32; /* Get the address of channel DMA configuration */ LpDmaConfig = CddIic_GpChannelConfig[LddChannel].pDmaConfiguration; /* PRQA S 2824 # JV-01 */ LulDmaTxBaseAddr = (uint32) (LpDmaConfig->pTxDmaBaseAddr); /* PRQA S 0306, 2814 # JV-01, JV-01 */ LulDmaRxBaseAddr = (uint32) (LpDmaConfig->pRxDmaBaseAddr); /* PRQA S 0306 # JV-01 */ if (CDDIIC_DMA_MODE_MASTER_TRANSMIT == LenDmaMode) { /* Get the value for ICDMAER register */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, \\ &LulRegVal); /* Enable DMA for Master transmission */ LulRegVal |= CDDIIC_DMA_MASTER_TX_ENABLE; /* Write back to ICDMAER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, LulRegVal); /* PRQA S 2824 # JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( \\ CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Get the value from DMACHCR register */ CddIic_HWGetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaTxBaseAddr + CDDIIC_DMACHCR_ADDRESS), /* PRQA S 3383 # JV-01 */ &LulRegVal); /* Start DMA transfer */ LulRegVal |= CDDIIC_DMA_START; /* Write back to DMACHCR register */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaTxBaseAddr + CDDIIC_DMACHCR_ADDRESS), LulRegVal); /* PRQA S 3383 # JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaTxBaseAddr + CDDIIC_DMACHCR_ADDRESS), LulRegVal, /* PRQA S 3383 # JV-01 */ CDDIIC_32_BIT_MASK); #endif } else if (CDDIIC_DMA_MODE_MASTER_RECEIVE == LenDmaMode) { /* Get the value for ICDMAER register */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, \\ &LulRegVal); /* Enable DMA for Master reception */ LulRegVal |= CDDIIC_DMA_MASTER_RX_ENABLE; /* Write back to ICDMAER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, LulRegVal); /* PRQA S 2824 # JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( \\ CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Get the value from DMACHCR register */ CddIic_HWGetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaRxBaseAddr + CDDIIC_DMACHCR_ADDRESS), /* PRQA S 3383 # JV-01 */ &LulRegVal); /* Start DMA transfer */ LulRegVal |= CDDIIC_DMA_START; /* Write back to DMACHCR register */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaRxBaseAddr + CDDIIC_DMACHCR_ADDRESS), /* PRQA S 3383 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaRxBaseAddr + CDDIIC_DMACHCR_ADDRESS), LulRegVal, /* PRQA S 3383 # JV-01 */ CDDIIC_32_BIT_MASK); #endif } else if (CDDIIC_DMA_MODE_SLAVE_TRANSMIT == LenDmaMode) { /* Get the value for ICDMAER register */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, \\ &LulRegVal); /* Enable DMA for Slave transmission */ LulRegVal |= CDDIIC_DMA_SLAVE_TX_ENABLE; /* Write back to ICDMAER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, LulRegVal); /* PRQA S 2824 # JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( \\ CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Get the value from DMACHCR register */ CddIic_HWGetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaTxBaseAddr + CDDIIC_DMACHCR_ADDRESS), /* PRQA S 3383 # JV-01 */ &LulRegVal); /* Start DMA transfer */ LulRegVal |= CDDIIC_DMA_START; /* Write back to DMACHCR register */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaTxBaseAddr + CDDIIC_DMACHCR_ADDRESS), /* PRQA S 3383 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaTxBaseAddr + CDDIIC_DMACHCR_ADDRESS), LulRegVal, /* PRQA S 3383 # JV-01 */ CDDIIC_32_BIT_MASK); #endif } else { /* Get the value for ICDMAER register */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, \\ &LulRegVal); /* Enable DMA for Slave reception */ LulRegVal |= CDDIIC_DMA_SLAVE_RX_ENABLE; /* Write back to ICDMAER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( \\ CddIic_GpChannelConfig[LddChannel].pICDMAERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Get the value from DMACHCR register */ CddIic_HWGetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaRxBaseAddr + CDDIIC_DMACHCR_ADDRESS), /* PRQA S 3383 # JV-01 */ &LulRegVal); /* Start DMA transfer */ LulRegVal |= CDDIIC_DMA_START; /* Write back to DMACHCR register */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaRxBaseAddr + CDDIIC_DMACHCR_ADDRESS), /* PRQA S 3383 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaRxBaseAddr + CDDIIC_DMACHCR_ADDRESS), LulRegVal, /* PRQA S 3383 # JV-01 */ CDDIIC_32_BIT_MASK); #endif } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LenDmaMode', 'Value': 'CDDIIC_DMA_MODE_MASTER_TRANSMIT'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': ''], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pTxDmaBaseAddr', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pRxDmaBaseAddr', 'Value': '1'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pICDMAERnReg', 'Value': ''], 'Input_Param_008': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_009': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '[0 to 1] = 0']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICDMAERnReg[0]'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICDMAERnReg[0]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '1'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': ''], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': ''], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '1'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_32_BIT_MASK'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_Read /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) LpData, /* PRQA S 3432, 3673 # JV-01, JV-01 */ VAR(uint32, AUTOMATIC) LulByteNumber, P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(uint32, AUTOMATIC) LulRegVal; LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) if (NULL_PTR == LpData) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0READ_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if (CDDIIC_ZERO_32 == LulByteNumber) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0READ_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0READ_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { /* Get slave control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable slave interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_SIE_BIT); /* Write value into slave control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Clear status register */ LulRegVal = CDDIIC_ZERO_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMSRnReg, LulRegVal); /* PRQA S 2824 # JV-01 */ if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) /* PRQA S 2814 # JV-01 */ { /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = (uint32) LpSlaveConfig->usSlaveAddress; /* Enable read mode for master interface */ LulRegVal = CDDIIC_READ_MODE | (LulRegVal << CDDIIC_ONE_32); /* Write slave address to Master address register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDRE_BIT | CDDIIC_MNRE_BIT | \\ CDDIIC_MSTE_BIT; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = /* PRQA S 2824 # JV-01 */ CDDIIC_SEVEN_BIT_ADDR; } else { /* Create first byte address in 10-bit slave address */ /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = CDDIIC_FIRST_BYTE_TEN_BIT_ADDR_MASK | \\ ((uint32)(LpSlaveConfig->usSlaveAddress) >> CDDIIC_EIGHT_32); /* Enable writer mode of master interface */ LulRegVal = LulRegVal << CDDIIC_ONE_32; /* Write first byte address in 10-bit slave address to MAR register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, \\ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Create second byte slave address in 10-bit slave address */ LulRegVal = ((uint32) LpSlaveConfig->usSlaveAddress) & \\ CDDIIC_SECOND_BYTE_TEN_BIT_ADDR_MASK; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDEE_BIT | CDDIIC_MDRE_BIT | \\ CDDIIC_MNRE_BIT | CDDIIC_MSTE_BIT; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_TEN_BIT_ADDR; } /* Store the address of user buffer for reception */ CddIic_GaaBufferAddress[LddChannel].pRcvBuffer = /* PRQA S 2844 # JV-01 */ (P2VAR(uint8, TYPEDEF, CDDIIC_APPL_DATA)) LpData; /* PRQA S 3432 # JV-01 */ /* Store the total reception byte to monitor the progress of reception */ CddIic_GpChannelStatus[LddChannel].ulRcvByteNumber = LulByteNumber; /* Set up channel DMA configuration */ #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_ONE_32 != LulByteNumber) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { CddIic_RxDmaConfig(LddChannel, LpData, LulByteNumber); } else { /* No action required */ } } else { /* No action required */ } #endif #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Start the reception opertation */ LddRetVal = CddIic_Start(LddChannel); /* If the START condition issue to IIC bus successfully */ if (RTE_E_OK == LddRetVal) { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_RECEIVING; } else { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_IDLE; } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '!CDDIIC_ZERO_DMA_CONFIG'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'LulByteNumber', 'Value': '0x0000FFFF'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': ''], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'enAddressMode', 'Value': 'CDDIIC_SEVEN_BIT_ADDR'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'usSlaveAddress', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': ''], 'Input_Param_012': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pICMSRnReg', 'Value': ''], 'Input_Param_014': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'pICMARnReg', 'Value': ''], 'Input_Param_016': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'pICMIERnReg', 'Value': ''], 'Input_Param_018': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': '-'], 'Input_Param_020': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': ''], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': ''], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '&ptr_CddIic_GpChannelStatus[0]'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': ''], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': ''], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_COM_BUSY'], 'Input_Param_027': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSCRnReg[0]'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': ''], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '0'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMSRnReg[0]'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMARnReg[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': ''], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMIERnReg[0]'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '83'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'enSlaveAddressMode', 'Value': ''], 'Output_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'pRcvBuffer', 'Value': ''], 'Output_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvByteNumber', 'Value': ''], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': ''], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTransferCnt', 'Value': ''], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Output_Param_033': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': ''], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_035': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddRetVal', 'Value': 'RTE_E_COM_BUSY'], 'Output_Param_036': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_Read /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2VAR(uint8, AUTOMATIC, RTE_APPL_DATA) LpData, /* PRQA S 3432, 3673 # JV-01, JV-01 */ VAR(uint32, AUTOMATIC) LulByteNumber, P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(uint32, AUTOMATIC) LulRegVal; LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) if (NULL_PTR == LpData) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0READ_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if (CDDIIC_ZERO_32 == LulByteNumber) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0READ_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0READ_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { /* Get slave control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable slave interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_SIE_BIT); /* Write value into slave control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Clear status register */ LulRegVal = CDDIIC_ZERO_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMSRnReg, LulRegVal); /* PRQA S 2824 # JV-01 */ if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) /* PRQA S 2814 # JV-01 */ { /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = (uint32) LpSlaveConfig->usSlaveAddress; /* Enable read mode for master interface */ LulRegVal = CDDIIC_READ_MODE | (LulRegVal << CDDIIC_ONE_32); /* Write slave address to Master address register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDRE_BIT | CDDIIC_MNRE_BIT | \\ CDDIIC_MSTE_BIT; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = /* PRQA S 2824 # JV-01 */ CDDIIC_SEVEN_BIT_ADDR; } else { /* Create first byte address in 10-bit slave address */ /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = CDDIIC_FIRST_BYTE_TEN_BIT_ADDR_MASK | \\ ((uint32)(LpSlaveConfig->usSlaveAddress) >> CDDIIC_EIGHT_32); /* Enable writer mode of master interface */ LulRegVal = LulRegVal << CDDIIC_ONE_32; /* Write first byte address in 10-bit slave address to MAR register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, \\ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Create second byte slave address in 10-bit slave address */ LulRegVal = ((uint32) LpSlaveConfig->usSlaveAddress) & \\ CDDIIC_SECOND_BYTE_TEN_BIT_ADDR_MASK; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDEE_BIT | CDDIIC_MDRE_BIT | \\ CDDIIC_MNRE_BIT | CDDIIC_MSTE_BIT; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_TEN_BIT_ADDR; } /* Store the address of user buffer for reception */ CddIic_GaaBufferAddress[LddChannel].pRcvBuffer = /* PRQA S 2844 # JV-01 */ (P2VAR(uint8, TYPEDEF, CDDIIC_APPL_DATA)) LpData; /* PRQA S 3432 # JV-01 */ /* Store the total reception byte to monitor the progress of reception */ CddIic_GpChannelStatus[LddChannel].ulRcvByteNumber = LulByteNumber; /* Set up channel DMA configuration */ #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_ONE_32 != LulByteNumber) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { CddIic_RxDmaConfig(LddChannel, LpData, LulByteNumber); } else { /* No action required */ } } else { /* No action required */ } #endif #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Start the reception opertation */ LddRetVal = CddIic_Start(LddChannel); /* If the START condition issue to IIC bus successfully */ if (RTE_E_OK == LddRetVal) { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_RECEIVING; } else { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_IDLE; } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '!CDDIIC_ZERO_DMA_CONFIG'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': '&map_LpData[0]'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'LulByteNumber', 'Value': '0x0000FFFF'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': ''], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'enAddressMode', 'Value': 'CDDIIC_TEN_BIT_ADDR'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'usSlaveAddress', 'Value': '1'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': ''], 'Input_Param_012': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pICMSRnReg', 'Value': ''], 'Input_Param_014': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'pICMARnReg', 'Value': ''], 'Input_Param_016': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'pICMIERnReg', 'Value': ''], 'Input_Param_018': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': ''], 'Input_Param_020': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': ''], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '&ptr_CddIic_GpChannelStatus[0]'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': ''], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': ''], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK'], 'Input_Param_027': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSCRnReg[0]'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': ''], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '0'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMSRnReg[0]'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMARnReg[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': ''], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICTXRXDnReg[0]'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': ''], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMIERnReg[0]'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '91'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'enSlaveAddressMode', 'Value': ''], 'Output_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'pRcvBuffer', 'Value': ''], 'Output_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvByteNumber', 'Value': ''], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTransferCnt', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Output_Param_033': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': ''], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_035': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddRetVal', 'Value': 'RTE_E_OK'], 'Output_Param_036': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDIIC_CODE_SLOW) CddIic_RxDmaConfig ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) LpData, /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulTransferCnt ) { VAR(uint32, AUTOMATIC) LulDmaBaseAdress; P2VAR(CddIic_DmaConfigType, AUTOMATIC, CDDIIC_DATA) LpDmaConfig; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(uint32, AUTOMATIC) LulRegVal; /* Initialize registter value */ LulRegVal = CDDIIC_ZERO_32; /* Get address of channel DMA configuration */ LpDmaConfig = CddIic_GpChannelConfig[LddChannel].pDmaConfiguration; /* PRQA S 2824 # JV-01 */ /* Get Dma base address in mode master reception of the channel */ LulDmaBaseAdress = (uint32) (LpDmaConfig->pRxDmaBaseAddr); /* PRQA S 0306, 2814 # JV-01, JV-01 */ /* Clear value in DMACHCR register */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMACHCR_ADDRESS), LulRegVal); /* PRQA S 3383 # JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMACHCR_ADDRESS), LulRegVal, CDDIIC_32_BIT_MASK); /* PRQA S 3383 # JV-01 */ #endif /* Configure increasment destination address and enable DMA interrupt*/ LulRegVal = CDDIIC_DMA_DST_ADDR_MODE_INCR | \\ CDDIIC_DMA_SRC_ADDR_MODE_FIXED | CDDIIC_DMA_INT_BIT | \\ CDDIIC_DMA_RS_EXTENDED; CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMACHCR_ADDRESS), LulRegVal); /* PRQA S 3383 # JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMACHCR_ADDRESS), LulRegVal, CDDIIC_32_BIT_MASK); /* PRQA S 3383 # JV-01 */ #endif LulRegVal = (uint32) CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg; /* PRQA S 0306, 2824 # JV-01, JV-01 */ /* Set source address */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMASAR_ADRESS), LulRegVal); /* PRQA S 2985 # JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMASAR_ADRESS), LulRegVal, CDDIIC_32_BIT_MASK); /* PRQA S 2985 # JV-01 */ #endif /* Set destination address */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMADAR_ADRESS), (uint32) LpData); /* PRQA S 0306, 3383 # JV-01, JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMADAR_ADRESS), (uint32) LpData , /* PRQA S 0306, 3383 # JV-01, JV-01 */ CDDIIC_32_BIT_MASK); #endif /* Set Dma transfer count */ LulRegVal = LulTransferCnt - CDDIIC_TWO_32; /* PRQA S 3383 # JV-01 */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMATCR_ADRESS), LulRegVal); /* PRQA S 3383 # JV-01 */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMATCR_ADRESS), LulRegVal, CDDIIC_32_BIT_MASK); /* PRQA S 3383 # JV-01 */ #endif /* Set remaining byte which coppied by IIC */ CddIic_GpChannelStatus[LddChannel].ulRcvByteReceieved = LulRegVal; /* PRQA S 2824 # JV-01 */ /* Mapping DMA to IIC HW unit */ CddIic_HWSetReg((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMARS_ADDRESS), /* PRQA S 3383 # JV-01 */ (uint32) LpDmaConfig->ucRxDmaMapping); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify((P2VAR(uint32, AUTOMATIC, REGSPACE)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ (LulDmaBaseAdress + CDDIIC_DMARS_ADDRESS), /* PRQA S 3383 # JV-01 */ (uint32) LpDmaConfig->ucRxDmaMapping, CDDIIC_32_BIT_MASK); #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': '8'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTRAddress', 'Name': 'LpData', 'Value': '&map_LpData'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'LulTransferCnt', 'Value': '2048'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': '[8]=&map_pDmaConfiguration[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'NULL\u2026Address', 'Name': 'pRxDmaBaseAddr', 'Value': '&map_pRxDmaBaseAddr[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': '[8]=&map_pICTXRXDnReg[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '&ptr_CddIic_GpChannelStatus[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'NULL\u2026Address', 'Name': 'ucRxDmaMapping', 'Value': 'map_ucRxDmaMapping[0]']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMACHCR_ADDRESS'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMACHCR_ADDRESS'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_32_BIT_MASK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMACHCR_ADDRESS'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_DMA_DST_ADDR_MODE_INCR | CDDIIC_DMA_SRC_ADDR_MODE_FIXED | CDDIIC_DMA_INT_BIT | CDDIIC_DMA_RS_EXTENDED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMACHCR_ADDRESS'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_DMA_DST_ADDR_MODE_INCR | CDDIIC_DMA_SRC_ADDR_MODE_FIXED | CDDIIC_DMA_INT_BIT | CDDIIC_DMA_RS_EXTENDED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_32_BIT_MASK'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMASAR_ADRESS'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '&map_pICTXRXDnReg[0]'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMASAR_ADRESS'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '&map_pICTXRXDnReg[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_32_BIT_MASK'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMADAR_ADRESS'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '(uint32) &map_LpData[0]'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMADAR_ADRESS'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '(uint32) &map_LpData[0]'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_32_BIT_MASK'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMATCR_ADRESS'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '2048 - CDDIIC_TWO_32'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMATCR_ADRESS'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '2048 - CDDIIC_TWO_32'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_32_BIT_MASK'], 'Output_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvByteReceieved', 'Value': '[8]=2048 - CDDIIC_TWO_32'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMARS_ADDRESS'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '(uint32) map_ucRxDmaMapping[0]'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '(uint32) &map_pRxDmaBaseAddr[0] + CDDIIC_DMARS_ADDRESS'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '(uint32) map_ucRxDmaMapping[0]'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_32_BIT_MASK'], 'Output_Param_031': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_SlaveConfiguration /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, VAR(uint8, AUTOMATIC) LucSlaveOwnAdress, P2VAR(CddIic_SlaveInterfaceType, AUTOMATIC, CDDIIC_CODE) LpSlaveInterface /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR (uint32, AUTOMATIC) LulRegVal; LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) if (CDDIIC_INITIALIZED != CddIic_GblDriverStatus) { /* Report error to Det when driver is uninitialized */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_UNINITIALIZED); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if (CDDIIC_MAX_7_BIT_ADDRESS < LucSlaveOwnAdress) { (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } if (RTE_E_OK == LddRetVal) { if (NULL_PTR == LpSlaveInterface) { /* * Report error to when the pointer is NULL */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if ((CDDIIC_ZERO_32 == LpSlaveInterface->ulMaxTxByte) || \\ (CDDIIC_ZERO_32 == LpSlaveInterface->ulMaxRxByte)) { (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if ((NULL_PTR == LpSlaveInterface->pRxBuff) || \\ (NULL_PTR == LpSlaveInterface->pTxBuff)) { /* * Report error to when the pointer is NULL */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } } } else { /* No action required */ } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Get master control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICMCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable master interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_MIE_BIT); /* Write value into master control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMCRnReg, CDDIIC_ZERO_32, /* PRQA S 2824 # JV-01 */ CDDIIC_MIE_BIT); #endif /* Clear slave status */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSSRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_ZERO_32); CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_CLOCK_DIVISION_FACTOR); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_CLOCK_DIVISION_FACTOR, CDDIIC_8_BIT_MASK); #endif #if(CDDIIC_FAST_MODE_PLUS == STD_ON) /*Setting Bus Mode*/ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ CDDIIC_FMPE_ENABLE); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ CDDIIC_FMPE_ENABLE, CDDIIC_8_BIT_MASK); #endif #endif /* Slave Device Address */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSARnReg, /* PRQA S 2824 # JV-01 */ (uint32) LucSlaveOwnAdress); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSARnReg, /* PRQA S 2824 # JV-01 */ (uint32) LucSlaveOwnAdress, CDDIIC_8_BIT_MASK); #endif CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveInterface->pTxBuff[CDDIIC_ZERO_32]); /* PRQA S 2814, 2824 # JV-01, JV-01 */ /* Specify the number of byte for slave reception */ CddIic_GpChannelStatus[LddChannel].ulRcvByteNumber = /* PRQA S 2824 # JV-01 */ LpSlaveInterface->ulMaxRxByte; /* Specify the number of byte for slave transmission */ CddIic_GpChannelStatus[LddChannel].ulSndByteNumber = \\ LpSlaveInterface->ulMaxTxByte; /* Set up internal buffer for slave transmission */ CddIic_GaaBufferAddress[LddChannel].pSndBuffer = /* PRQA S 2844 # JV-01 */ LpSlaveInterface->pTxBuff; /* Set up internal buffer for slave reception */ CddIic_GaaBufferAddress[LddChannel].pRcvBuffer = /* PRQA S 2844 # JV-01 */ LpSlaveInterface->pRxBuff; /* DMA configuration for slave interface */ #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { CddIic_DmaSlaveConfig(LddChannel, LpSlaveInterface); } else { /* No action required */ } #endif /* Enable Slave Inteface, general call ACK, slave data buffer select */ LulRegVal = CDDIIC_ZERO_32 | CDDIIC_SIE_BIT | CDDIIC_GCAE_BIT | \\ CDDIIC_SDBS_BIT; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif LulRegVal = CDDIIC_ZERO_32 | CDDIIC_SARE_BIT | CDDIIC_SDRE_BIT | \\ CDDIIC_SDEE_BIT | CDDIIC_SSRE_BIT; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( \\ CddIic_GpChannelConfig[LddChannel].pICSIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '1..9', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '6'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..255', 'Name': 'LucSlaveOwnAdress', 'Value': 'CDDIIC_MAX_7_BIT_ADDRESS'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpSlaveInterface', 'Value': '&map_LpSlaveInterface[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'CDDIIC_INITIALIZED\\nCDDIIC_UNINITIALIZED', 'Name': 'CddIic_GblDriverStatus', 'Value': 'CDDIIC_INITIALIZED'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulMaxTxByte', 'Value': '2048'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulMaxRxByte', 'Value': '2048'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pRxBuff', 'Value': '&map_pRxBuff[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pTxBuff', 'Value': '&map_pTxBuff[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTxBuff[0]', 'Value': '0x00000001'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': '[0]=CDDIIC_DMA_ENABLED'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': '[0]=&map_pDmaConfiguration[0]'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[0]=&ISOLATE_void_func_ptr'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'pICMCRnReg', 'Value': '[0]=&map_pICMCRnReg[0]'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pICSSRnReg', 'Value': '[0]=&map_pICSSRnReg[0]'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pICCCRnReg', 'Value': '[0]=&map_pICCCRnReg[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pICCCR2nReg', 'Value': '[0]=&map_pICCCR2nReg[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pICSARnReg', 'Value': '[0]=&map_pICSARnReg[0]'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': '[0]=&map_pICTXRXDnReg[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '&ptr_CddIic_GpChannelStatus[0]'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': '[0]=&map_pICSCRnReg[0]'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pICSIERnReg', 'Value': '[0]=&map_pICSIERnReg[0]'], 'Input_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[0]=&ISOLATE_void_func_ptr'], 'Input_Param_027': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': 'CDDIIC_ZERO_32']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMCRnReg[0]'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMCRnReg[0]'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32 & ~(CDDIIC_MIE_BIT)'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICMCRnReg[0]'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_MIE_BIT'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSSRnReg[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICCCRnReg[0]'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_CLOCK_DIVISION_FACTOR'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICCCRnReg[0]'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_CLOCK_DIVISION_FACTOR'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICCCR2nReg[0]'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_FMPE_ENABLE'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICCCR2nReg[0]'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_FMPE_ENABLE'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSARnReg[0]'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '(uint32) CDDIIC_MAX_7_BIT_ADDRESS'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICSARnReg[0]'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '(uint32) CDDIIC_MAX_7_BIT_ADDRESS'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICTXRXDnReg[0]'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'map_pTxBuff[0]'], 'Output_Param_032': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvByteNumber', 'Value': '[0]=2048'], 'Output_Param_033': ['Type': 'Array', 'Range': '', 'Name': 'ulSndByteNumber', 'Value': '[0]=2048'], 'Output_Param_034': ['Type': 'Array', 'Range': '', 'Name': 'pSndBuffer', 'Value': '[0]=&map_pTxBuff[0]'], 'Output_Param_035': ['Type': 'Array', 'Range': '', 'Name': 'pRcvBuffer', 'Value': '[0]=&map_pRxBuff[0]'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveIf', 'Value': '&map_LpSlaveInterface[0]'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSCRnReg[0]'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32 | CDDIIC_SIE_BIT | CDDIIC_GCAE_BIT | CDDIIC_SDBS_BIT'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICSCRnReg[0]'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_ZERO_32 | CDDIIC_SIE_BIT | CDDIIC_GCAE_BIT | CDDIIC_SDBS_BIT'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSIERnReg[0]'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32 | CDDIIC_SARE_BIT | CDDIIC_SDRE_BIT | CDDIIC_SDEE_BIT | CDDIIC_SSRE_BIT'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICSIERnReg[0]'], 'Output_Param_046': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_ZERO_32 | CDDIIC_SARE_BIT | CDDIIC_SDRE_BIT | CDDIIC_SDEE_BIT | CDDIIC_SSRE_BIT'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_048': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_049': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_SlaveConfiguration /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, VAR(uint8, AUTOMATIC) LucSlaveOwnAdress, P2VAR(CddIic_SlaveInterfaceType, AUTOMATIC, CDDIIC_CODE) LpSlaveInterface /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR (uint32, AUTOMATIC) LulRegVal; LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) if (CDDIIC_INITIALIZED != CddIic_GblDriverStatus) { /* Report error to Det when driver is uninitialized */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_UNINITIALIZED); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if (CDDIIC_MAX_7_BIT_ADDRESS < LucSlaveOwnAdress) { (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } if (RTE_E_OK == LddRetVal) { if (NULL_PTR == LpSlaveInterface) { /* * Report error to when the pointer is NULL */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if ((CDDIIC_ZERO_32 == LpSlaveInterface->ulMaxTxByte) || \\ (CDDIIC_ZERO_32 == LpSlaveInterface->ulMaxRxByte)) { (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if ((NULL_PTR == LpSlaveInterface->pRxBuff) || \\ (NULL_PTR == LpSlaveInterface->pTxBuff)) { /* * Report error to when the pointer is NULL */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } } } else { /* No action required */ } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0SLAVEINIT_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Get master control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICMCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable master interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_MIE_BIT); /* Write value into master control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMCRnReg, CDDIIC_ZERO_32, /* PRQA S 2824 # JV-01 */ CDDIIC_MIE_BIT); #endif /* Clear slave status */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSSRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_ZERO_32); CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_CLOCK_DIVISION_FACTOR); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_CLOCK_DIVISION_FACTOR, CDDIIC_8_BIT_MASK); #endif #if(CDDIIC_FAST_MODE_PLUS == STD_ON) /*Setting Bus Mode*/ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ CDDIIC_FMPE_ENABLE); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICCCR2nReg, /* PRQA S 2824 # JV-01 */ CDDIIC_FMPE_ENABLE, CDDIIC_8_BIT_MASK); #endif #endif /* Slave Device Address */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSARnReg, /* PRQA S 2824 # JV-01 */ (uint32) LucSlaveOwnAdress); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSARnReg, /* PRQA S 2824 # JV-01 */ (uint32) LucSlaveOwnAdress, CDDIIC_8_BIT_MASK); #endif CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ (uint32) LpSlaveInterface->pTxBuff[CDDIIC_ZERO_32]); /* PRQA S 2814, 2824 # JV-01, JV-01 */ /* Specify the number of byte for slave reception */ CddIic_GpChannelStatus[LddChannel].ulRcvByteNumber = /* PRQA S 2824 # JV-01 */ LpSlaveInterface->ulMaxRxByte; /* Specify the number of byte for slave transmission */ CddIic_GpChannelStatus[LddChannel].ulSndByteNumber = \\ LpSlaveInterface->ulMaxTxByte; /* Set up internal buffer for slave transmission */ CddIic_GaaBufferAddress[LddChannel].pSndBuffer = /* PRQA S 2844 # JV-01 */ LpSlaveInterface->pTxBuff; /* Set up internal buffer for slave reception */ CddIic_GaaBufferAddress[LddChannel].pRcvBuffer = /* PRQA S 2844 # JV-01 */ LpSlaveInterface->pRxBuff; /* DMA configuration for slave interface */ #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { CddIic_DmaSlaveConfig(LddChannel, LpSlaveInterface); } else { /* No action required */ } #endif /* Enable Slave Inteface, general call ACK, slave data buffer select */ LulRegVal = CDDIIC_ZERO_32 | CDDIIC_SIE_BIT | CDDIIC_GCAE_BIT | \\ CDDIIC_SDBS_BIT; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif LulRegVal = CDDIIC_ZERO_32 | CDDIIC_SARE_BIT | CDDIIC_SDRE_BIT | \\ CDDIIC_SDEE_BIT | CDDIIC_SSRE_BIT; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( \\ CddIic_GpChannelConfig[LddChannel].pICSIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '1..9', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '6'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': '3'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..255', 'Name': 'LucSlaveOwnAdress', 'Value': 'CDDIIC_MAX_7_BIT_ADDRESS'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpSlaveInterface', 'Value': '&map_LpSlaveInterface[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'CDDIIC_INITIALIZED\\nCDDIIC_UNINITIALIZED', 'Name': 'CddIic_GblDriverStatus', 'Value': 'CDDIIC_INITIALIZED'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulMaxTxByte', 'Value': '2048'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulMaxRxByte', 'Value': '2048'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pRxBuff', 'Value': '&map_pRxBuff[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pTxBuff', 'Value': '&map_pTxBuff[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTxBuff[0]', 'Value': '0x00000001'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': '[3]=CDDIIC_DMA_DISABLED'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': '-'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '[3]=&ISOLATE_void_func_ptr'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'pICMCRnReg', 'Value': '[3]=&map_pICMCRnReg[0]'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pICSSRnReg', 'Value': '[3]=&map_pICSSRnReg[0]'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pICCCRnReg', 'Value': '[3]=&map_pICCCRnReg[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pICCCR2nReg', 'Value': '[3]=&map_pICCCR2nReg[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pICSARnReg', 'Value': '[3]=&map_pICSARnReg[0]'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': '[3]=&map_pICTXRXDnReg[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '&ptr_CddIic_GpChannelStatus[0]'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': '[3]=&map_pICSCRnReg[0]'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pICSIERnReg', 'Value': '[3]=&map_pICSIERnReg[0]'], 'Input_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '[3]=&ISOLATE_void_func_ptr'], 'Input_Param_027': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': 'CDDIIC_ZERO_32']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMCRnReg[0]'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMCRnReg[0]'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32 & ~(CDDIIC_MIE_BIT)'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICMCRnReg[0]'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_MIE_BIT'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSSRnReg[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICCCRnReg[0]'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_CLOCK_DIVISION_FACTOR'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICCCRnReg[0]'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_CLOCK_DIVISION_FACTOR'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICCCR2nReg[0]'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_FMPE_ENABLE'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICCCR2nReg[0]'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_FMPE_ENABLE'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSARnReg[0]'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '(uint32) CDDIIC_MAX_7_BIT_ADDRESS'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICSARnReg[0]'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '(uint32) CDDIIC_MAX_7_BIT_ADDRESS'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICTXRXDnReg[0]'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'map_pTxBuff[0]'], 'Output_Param_032': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvByteNumber', 'Value': '[3]=2048'], 'Output_Param_033': ['Type': 'Array', 'Range': '', 'Name': 'ulSndByteNumber', 'Value': '[3]=2048'], 'Output_Param_034': ['Type': 'Array', 'Range': '', 'Name': 'pSndBuffer', 'Value': '[3]=&map_pTxBuff[0]'], 'Output_Param_035': ['Type': 'Array', 'Range': '', 'Name': 'pRcvBuffer', 'Value': '[3]=&map_pRxBuff[0]'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSlaveIf', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSCRnReg[0]'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32 | CDDIIC_SIE_BIT | CDDIIC_GCAE_BIT | CDDIIC_SDBS_BIT'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICSCRnReg[0]'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_ZERO_32 | CDDIIC_SIE_BIT | CDDIIC_GCAE_BIT | CDDIIC_SDBS_BIT'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSIERnReg[0]'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32 | CDDIIC_SARE_BIT | CDDIIC_SDRE_BIT | CDDIIC_SDEE_BIT | CDDIIC_SSRE_BIT'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '&map_pICSIERnReg[0]'], 'Output_Param_046': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': 'CDDIIC_ZERO_32 | CDDIIC_SARE_BIT | CDDIIC_SDRE_BIT | CDDIIC_SDEE_BIT | CDDIIC_SSRE_BIT'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_048': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_049': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_FAST #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, CDDIIC_CODE_FAST) CddIic_SlaveInterrupts ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel ) { VAR(uint32, AUTOMATIC) LulRegVal; #if (CDDIIC_UNINTENDED_INTERRUPT_CHECK == STD_ON) VAR(Std_ReturnType, AUTOMATIC) LddErrCheck; VAR(uint32, AUTOMATIC) LulRegValControl; #endif /* CDDIIC_UNINTENDED_INTERRUPT_CHECK == STD_ON */ /* Initialize local variable */ LulRegVal = CDDIIC_ZERO_32; /* Get the currnet status of interrupt */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSSRnReg, /* PRQA S 2824 # JV-01 */ &LulRegVal); #if (CDDIIC_UNINTENDED_INTERRUPT_CHECK == STD_ON) /* Get the current control bits of interrupt */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSIERnReg, /* PRQA S 2824 # JV-01 */ &LulRegValControl); /* Checking whether the interrupt triggered correct or not */ LddErrCheck = CddIic_HWSlaveIrqCheck(LulRegVal, LulRegValControl); /* If there have no issue, proceed the according operation */ if(E_OK == LddErrCheck) { #endif /* CDDIIC_UNINTENDED_INTERRUPT_CHECK == STD_ON */ /* Checking the interrupt source is SAR */ if (CDDIIC_SAR_STATUS_BIT == (LulRegVal & CDDIIC_SAR_STATUS_BIT)) { CddIic_SAR_ISR(LddChannel); } /* Checking the interrupt source is SDE */ else if (CDDIIC_SDE_STATUS_BIT == (LulRegVal & CDDIIC_SDE_STATUS_BIT)) { CddIic_SDE_ISR(LddChannel); } /* Checking the interrupt source is SDR */ else if (CDDIIC_SDR_STATUS_BIT == (LulRegVal & CDDIIC_SDR_STATUS_BIT)) { CddIic_SDR_ISR(LddChannel); } else { /* No action required */ } /* Checking the interrupt source is SSR */ if (CDDIIC_SSR_STATUS_BIT == (LulRegVal & CDDIIC_SSR_STATUS_BIT)) { CddIic_SSR_ISR(LddChannel); } else { /* No action required */ } #if (CDDIIC_UNINTENDED_INTERRUPT_CHECK == STD_ON) } else { /* No action required */ } #endif /* CDDIIC_UNINTENDED_INTERRUPT_CHECK == STD_ON */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_UNINTENDED_INTERRUPT_CHECK', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'CddIic_GpChannelConfig', 'Value': '&map_CddIic_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'pICSSRnReg', 'Value': '&ptr_pICSSRnReg[0]'], 'Input_Param_004': ['Type': 'Register', 'Range': '0.0xFFFFFFFF', 'Name': 'ptr_pICSSRnReg[0]', 'Value': '0xFFFFFFFF'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'pICSSRnReg', 'Value': '-'], 'Input_Param_006': ['Type': 'Register', 'Range': '0.0xFFFFFFFF', 'Name': 'ptr_pICSSRnReg[1]', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'pICSSRnReg', 'Value': '-'], 'Input_Param_008': ['Type': 'Register', 'Range': '0.0xFFFFFFFF', 'Name': 'ptr_pICSSRnReg[5]', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'pICSSRnReg', 'Value': '-'], 'Input_Param_010': ['Type': 'Register', 'Range': '0.0xFFFFFFFF', 'Name': 'ptr_pICSSRnReg[8]', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'pICSIERnReg', 'Value': '&ptr_pICSIERnReg[0]'], 'Input_Param_012': ['Type': 'Register', 'Range': '0.0xFFFFFFFF', 'Name': 'ptr_pICSIERnReg[0]', 'Value': '0xFFFFFFFF'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'pICSIERnReg', 'Value': '-'], 'Input_Param_014': ['Type': 'Register', 'Range': '0.0xFFFFFFFF', 'Name': 'ptr_pICSIERnReg[1]', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'pICSIERnReg', 'Value': '-'], 'Input_Param_016': ['Type': 'Register', 'Range': '0.0xFFFFFFFF', 'Name': 'ptr_pICSIERnReg[5]', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'NULL_PTR..Address', 'Name': 'pICSIERnReg', 'Value': '-'], 'Input_Param_018': ['Type': 'Register', 'Range': '0.0xFFFFFFFF', 'Name': 'ptr_pICSIERnReg[8]', 'Value': '-'], 'Input_Param_019': ['Type': 'Output_Argument', 'Range': '-', 'Name': 'LpRegAdress', 'Value': '[1] = &ptr_pICSSRnReg[0]\\n[2] = &ptr_pICSIERnReg[0]'], 'Input_Param_020': ['Type': 'Output_Argument', 'Range': '-', 'Name': '*LpValue', 'Value': '[1 to 2] = 0x00000000'], 'Input_Param_021': ['Type': 'Return_Value_of', 'Range': '-', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&ptr_pICSSRnReg[0]'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&ptr_pICSIERnReg[0]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulStatusValue', 'Value': '0x00000000'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulControlValue', 'Value': '0x00000000'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '-', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_Write /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) LpData, /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulByteNumber, P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(uint32, AUTOMATIC) LulRegVal; /* Initialize local variable */ LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) /* Pointer validation before de-reference */ if (NULL_PTR == LpData) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITE_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if (CDDIIC_ZERO_32 == LulByteNumber) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITE_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITE_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { /* Get slave control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable slave interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_SIE_BIT); /* Write value into slave control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Clear Master Status register to zero state */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMSRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_ZERO_32); /* Set Master address register */ if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) /* PRQA S 2814 # JV-01 */ { /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = (uint32) LpSlaveConfig->usSlaveAddress; /* Append WRITE bit (0) after slave address */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Set the 1st transmit data */ LulRegVal = LpData[CDDIIC_ZERO_32]; /* PRQA S 2824 # JV-01 */ /* Write value to register ICTXRXD */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Change slave address mode status for channel */ CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = /* PRQA S 2824 # JV-01 */ CDDIIC_SEVEN_BIT_ADDR; } else { /* Create first byte address in 10-bit slave address */ /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = CDDIIC_FIRST_BYTE_TEN_BIT_ADDR_MASK | \\ ((uint32) LpSlaveConfig->usSlaveAddress >> CDDIIC_EIGHT_32); /* Append WRITE bit (0) after first byte slave address */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, \\ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Create second byte slave address in 10-bit slave address */ LulRegVal = ((uint32) LpSlaveConfig->usSlaveAddress) & \\ CDDIIC_SECOND_BYTE_TEN_BIT_ADDR_MASK; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Update the channel status */ CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_TEN_BIT_ADDR; } /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDEE_BIT | CDDIIC_MNRE_BIT | \\ CDDIIC_MSTE_BIT; /* Write the configure value to ICMIER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Register Write Verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Store the number of byte for transmission */ CddIic_GpChannelStatus[LddChannel].ulSndByteNumber = LulByteNumber; /* Check if DMAC enable on the channel */ #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) { CddIic_TxDmaConfig(LddChannel, &LpData[CDDIIC_ONE_32], LulByteNumber); } else { CddIic_TxDmaConfig(LddChannel, &LpData[CDDIIC_ZERO_32], \\ (LulByteNumber + CDDIIC_ONE_32)); /* PRQA S 3383 # JV-01 */ } } else #endif { /* Set up for normal operation */ CddIic_GaaBufferAddress[LddChannel].pSndBuffer = /* PRQA S 2844 # JV-01 */ (P2CONST(uint8, TYPEDEF, CDDIIC_APPL_DATA)) /* PRQA S 3432 # JV-01 */ (&LpData[CDDIIC_ZERO_32]); } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Start IIC Master transmitter communication */ LddRetVal = CddIic_Start(LddChannel); if (RTE_E_OK == LddRetVal) { /* Change the channel status to Sending */ CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_SENDING; } else { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_IDLE; } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '!CDDIIC_ZERO_DMA_CONFIG'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': '-'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': ''], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpData[1]', 'Value': '-'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LulByteNumber', 'Value': '0x0000FFFF'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enAddressMode', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usSlaveAddress', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': ''], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': ''], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': '-'], 'Input_Param_015': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'pICMSRnReg', 'Value': '-'], 'Input_Param_017': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': '-'], 'Input_Param_019': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '-'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pICMIERnReg', 'Value': '-'], 'Input_Param_022': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pICMARnReg', 'Value': '-'], 'Input_Param_024': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '-'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '-'], 'Input_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '-'], 'Input_Param_027': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_028': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDIIC_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDIIC_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': ''], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDIIC_E_PARAM_POINTER'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'enSlaveAddressMode', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'ulSndByteNumber', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTransferCnt', 'Value': '-'], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'pSndBuffer', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_033': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_035': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddRetVal', 'Value': 'RTE_E_INVALID'], 'Output_Param_036': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_Write /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(uint8, AUTOMATIC, RTE_APPL_DATA) LpData, /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulByteNumber, P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR(uint32, AUTOMATIC) LulRegVal; /* Initialize local variable */ LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) /* Pointer validation before de-reference */ if (NULL_PTR == LpData) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITE_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if (CDDIIC_ZERO_32 == LulByteNumber) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITE_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITE_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { /* Get slave control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable slave interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_SIE_BIT); /* Write value into slave control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Clear Master Status register to zero state */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMSRnReg, /* PRQA S 2824 # JV-01 */ CDDIIC_ZERO_32); /* Set Master address register */ if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) /* PRQA S 2814 # JV-01 */ { /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = (uint32) LpSlaveConfig->usSlaveAddress; /* Append WRITE bit (0) after slave address */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Set the 1st transmit data */ LulRegVal = LpData[CDDIIC_ZERO_32]; /* PRQA S 2824 # JV-01 */ /* Write value to register ICTXRXD */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Change slave address mode status for channel */ CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = /* PRQA S 2824 # JV-01 */ CDDIIC_SEVEN_BIT_ADDR; } else { /* Create first byte address in 10-bit slave address */ /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = CDDIIC_FIRST_BYTE_TEN_BIT_ADDR_MASK | \\ ((uint32) LpSlaveConfig->usSlaveAddress >> CDDIIC_EIGHT_32); /* Append WRITE bit (0) after first byte slave address */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, \\ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Create second byte slave address in 10-bit slave address */ LulRegVal = ((uint32) LpSlaveConfig->usSlaveAddress) & \\ CDDIIC_SECOND_BYTE_TEN_BIT_ADDR_MASK; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Update the channel status */ CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_TEN_BIT_ADDR; } /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDEE_BIT | CDDIIC_MNRE_BIT | \\ CDDIIC_MSTE_BIT; /* Write the configure value to ICMIER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Register Write Verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Store the number of byte for transmission */ CddIic_GpChannelStatus[LddChannel].ulSndByteNumber = LulByteNumber; /* Check if DMAC enable on the channel */ #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) { CddIic_TxDmaConfig(LddChannel, &LpData[CDDIIC_ONE_32], LulByteNumber); } else { CddIic_TxDmaConfig(LddChannel, &LpData[CDDIIC_ZERO_32], \\ (LulByteNumber + CDDIIC_ONE_32)); /* PRQA S 3383 # JV-01 */ } } else #endif { /* Set up for normal operation */ CddIic_GaaBufferAddress[LddChannel].pSndBuffer = /* PRQA S 2844 # JV-01 */ (P2CONST(uint8, TYPEDEF, CDDIIC_APPL_DATA)) /* PRQA S 3432 # JV-01 */ (&LpData[CDDIIC_ZERO_32]); } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Start IIC Master transmitter communication */ LddRetVal = CddIic_Start(LddChannel); if (RTE_E_OK == LddRetVal) { /* Change the channel status to Sending */ CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_SENDING; } else { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_IDLE; } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '!CDDIIC_ZERO_DMA_CONFIG'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'LpData', 'Value': ''], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpData[1]', 'Value': '0'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LulByteNumber', 'Value': '0x0000FFFF'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'LpSlaveConfig', 'Value': ''], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enAddressMode', 'Value': 'CDDIIC_TEN_BIT_ADDR'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usSlaveAddress', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': ''], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': ''], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': ''], 'Input_Param_015': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'pICMSRnReg', 'Value': ''], 'Input_Param_017': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': ''], 'Input_Param_019': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '&ptr_CddIic_GpChannelStatus[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pICMIERnReg', 'Value': ''], 'Input_Param_022': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pICMARnReg', 'Value': ''], 'Input_Param_024': ['Type': 'Register', 'Range': '', 'Name': '', 'Value': '0'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': ''], 'Input_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': ''], 'Input_Param_027': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'RTE_E_OK'], 'Input_Param_028': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICSCRnReg[0]'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': 'LpValue'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': ''], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '0'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMSRnReg[0]'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': 'CDDIIC_ZERO_32'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMARnReg[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': ''], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICTXRXDnReg[0]'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': ''], 'Output_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'enSlaveAddressMode', 'Value': ''], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '&map_pICMIERnReg[0]'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '89'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': ''], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': ''], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': 'CDDIIC_8_BIT_MASK'], 'Output_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'ulSndByteNumber', 'Value': ''], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '0x40'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTransferCnt', 'Value': ''], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'pSndBuffer', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Output_Param_033': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': ''], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_035': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddRetVal', 'Value': ''], 'Output_Param_036': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_WriteRead /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(CddIic_WriteType, AUTOMATIC, RTE_APPL_DATA) LpWriteConfig, /* PRQA S 3432 # JV-01 */ P2VAR(CddIic_ReadType, AUTOMATIC, RTE_APPL_DATA) LpReadConfig, /* PRQA S 3432 # JV-01 */ P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR ( uint32, AUTOMATIC) LulRegVal; /* Initialize local variable */ LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) if ((NULL_PTR == LpWriteConfig->pWriteBuff) || /* PRQA S 2814 # JV-01 */ (NULL_PTR == LpReadConfig->pReadBuff) /* PRQA S 2814 # JV-01 */ ) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if((CDDIIC_ZERO_32 == LpWriteConfig->ulWriteNumber) || \\ (CDDIIC_ZERO_32 == LpReadConfig->ulReadNumber)) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { /* Enable repeat START for channel status */ CddIic_GpChannelStatus[LddChannel].enRepeatStartSta = /* PRQA S 2824 # JV-01 */ CDDIIC_SND_RPT_STR_RCV_ENABLE; /* Get slave control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable slave interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_SIE_BIT); /* Write value into slave control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Clear master status register */ LulRegVal = CDDIIC_ZERO_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMSRnReg, LulRegVal); /* PRQA S 2824 # JV-01 */ if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) /* PRQA S 2814 # JV-01 */ { /* Set Master address register */ LulRegVal = (uint32) LpSlaveConfig->usSlaveAddress; /* Enable write mode for Master operation */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Set transmit data registter (ICTXRXD = 1st transmission data */ LulRegVal = (uint32) LpWriteConfig->pWriteBuff[CDDIIC_ZERO_32]; /* PRQA S 2814, 2824 # JV-01, JV-01 */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_SEVEN_BIT_ADDR; } else { /* Create first byte address in 10-bit slave address */ /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = CDDIIC_FIRST_BYTE_TEN_BIT_ADDR_MASK | \\ ((uint32)(LpSlaveConfig->usSlaveAddress) >> CDDIIC_EIGHT_32); /* Enable write mode for master operation */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, \\ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Create second byte slave address in 10-bit slave address */ LulRegVal = ((uint32) LpSlaveConfig->usSlaveAddress) & \\ CDDIIC_SECOND_BYTE_TEN_BIT_ADDR_MASK; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_TEN_BIT_ADDR; } /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDRE_BIT | CDDIIC_MDEE_BIT | \\ CDDIIC_MNRE_BIT | CDDIIC_MSTE_BIT; /* Write the configure value to ICMIER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Register Write Verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Specify number of data transmission bytes */ CddIic_GpChannelStatus[LddChannel].ulSndByteNumber = \\ LpWriteConfig->ulWriteNumber; /* Specify number of data reception bytes */ CddIic_GpChannelStatus[LddChannel].ulRcvByteNumber = \\ LpReadConfig->ulReadNumber; /* PRQA S 2814 # JV-01 */ /* Set up internal buffer for tranmission mode */ CddIic_GaaBufferAddress[LddChannel].pSndBuffer = /* PRQA S 2844 # JV-01 */ LpWriteConfig->pWriteBuff; /* Set up internal buffer for reception mode */ CddIic_GaaBufferAddress[LddChannel].pRcvBuffer = /* PRQA S 2844 # JV-01 */ LpReadConfig->pReadBuff; #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_ONE_32 != (LpReadConfig->ulReadNumber)) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { CddIic_RxDmaConfig(LddChannel, LpReadConfig->pReadBuff, \\ LpReadConfig->ulReadNumber); } else { /* No action required */ } } else { /* No aciton required */ } #endif #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Issue START condition: MDBS = 1, MIE = 1, ESG = 1 */ LddRetVal = CddIic_Start(LddChannel); /* If the START condition issue to I2C bus succesfully */ if (RTE_E_OK == LddRetVal) { /* Change the channel status */ CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_SENDING; } else { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_IDLE; } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '1..9', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '6'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpWriteConfig', 'Value': '&map_LpWriteConfig[0]'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpReadConfig', 'Value': '&map_LpReadConfig[0]'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pWriteBuff', 'Value': '&map_pWriteBuff[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWriteBuff[0]', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pReadBuff', 'Value': '&map_pReadBuff[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulWriteNumber', 'Value': '100'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulReadNumber', 'Value': '100'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': '[0]=CDDIIC_DMA_ENABLED'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': '[0]=NULL_PTR'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '-'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pICMSRnReg', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'CDDIIC_SEVEN_BIT_ADDR\\nCDDIIC_TEN_BIT_ADDR', 'Name': 'enAddressMode', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'usSlaveAddress', 'Value': '-'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pICMARnReg', 'Value': '-'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': '-'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pICMIERnReg', 'Value': '-'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '-'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '-'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_027': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_INVALID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDIIC_MODULE_ID'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDIIC_INSTANCE_ID'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'ApiId', 'Value': 'CDDIIC_CH0WRITEREAD_SID + 0'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDIIC_E_PARAM_POINTER'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enRepeatStartSta', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'enSlaveAddressMode', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_028': ['Type': 'Array', 'Range': '', 'Name': 'ulSndByteNumber', 'Value': '-'], 'Output_Param_029': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvByteNumber', 'Value': '-'], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'pSndBuffer', 'Value': '-'], 'Output_Param_031': ['Type': 'Array', 'Range': '', 'Name': 'pRcvBuffer', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTransferCnt', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_037': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_039': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_WriteRead /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(CddIic_WriteType, AUTOMATIC, RTE_APPL_DATA) LpWriteConfig, /* PRQA S 3432 # JV-01 */ P2VAR(CddIic_ReadType, AUTOMATIC, RTE_APPL_DATA) LpReadConfig, /* PRQA S 3432 # JV-01 */ P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR ( uint32, AUTOMATIC) LulRegVal; /* Initialize local variable */ LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) if ((NULL_PTR == LpWriteConfig->pWriteBuff) || /* PRQA S 2814 # JV-01 */ (NULL_PTR == LpReadConfig->pReadBuff) /* PRQA S 2814 # JV-01 */ ) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if((CDDIIC_ZERO_32 == LpWriteConfig->ulWriteNumber) || \\ (CDDIIC_ZERO_32 == LpReadConfig->ulReadNumber)) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { /* Enable repeat START for channel status */ CddIic_GpChannelStatus[LddChannel].enRepeatStartSta = /* PRQA S 2824 # JV-01 */ CDDIIC_SND_RPT_STR_RCV_ENABLE; /* Get slave control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable slave interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_SIE_BIT); /* Write value into slave control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Clear master status register */ LulRegVal = CDDIIC_ZERO_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMSRnReg, LulRegVal); /* PRQA S 2824 # JV-01 */ if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) /* PRQA S 2814 # JV-01 */ { /* Set Master address register */ LulRegVal = (uint32) LpSlaveConfig->usSlaveAddress; /* Enable write mode for Master operation */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Set transmit data registter (ICTXRXD = 1st transmission data */ LulRegVal = (uint32) LpWriteConfig->pWriteBuff[CDDIIC_ZERO_32]; /* PRQA S 2814, 2824 # JV-01, JV-01 */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_SEVEN_BIT_ADDR; } else { /* Create first byte address in 10-bit slave address */ /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = CDDIIC_FIRST_BYTE_TEN_BIT_ADDR_MASK | \\ ((uint32)(LpSlaveConfig->usSlaveAddress) >> CDDIIC_EIGHT_32); /* Enable write mode for master operation */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, \\ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Create second byte slave address in 10-bit slave address */ LulRegVal = ((uint32) LpSlaveConfig->usSlaveAddress) & \\ CDDIIC_SECOND_BYTE_TEN_BIT_ADDR_MASK; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_TEN_BIT_ADDR; } /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDRE_BIT | CDDIIC_MDEE_BIT | \\ CDDIIC_MNRE_BIT | CDDIIC_MSTE_BIT; /* Write the configure value to ICMIER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Register Write Verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Specify number of data transmission bytes */ CddIic_GpChannelStatus[LddChannel].ulSndByteNumber = \\ LpWriteConfig->ulWriteNumber; /* Specify number of data reception bytes */ CddIic_GpChannelStatus[LddChannel].ulRcvByteNumber = \\ LpReadConfig->ulReadNumber; /* PRQA S 2814 # JV-01 */ /* Set up internal buffer for tranmission mode */ CddIic_GaaBufferAddress[LddChannel].pSndBuffer = /* PRQA S 2844 # JV-01 */ LpWriteConfig->pWriteBuff; /* Set up internal buffer for reception mode */ CddIic_GaaBufferAddress[LddChannel].pRcvBuffer = /* PRQA S 2844 # JV-01 */ LpReadConfig->pReadBuff; #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_ONE_32 != (LpReadConfig->ulReadNumber)) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { CddIic_RxDmaConfig(LddChannel, LpReadConfig->pReadBuff, \\ LpReadConfig->ulReadNumber); } else { /* No action required */ } } else { /* No aciton required */ } #endif #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Issue START condition: MDBS = 1, MIE = 1, ESG = 1 */ LddRetVal = CddIic_Start(LddChannel); /* If the START condition issue to I2C bus succesfully */ if (RTE_E_OK == LddRetVal) { /* Change the channel status */ CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_SENDING; } else { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_IDLE; } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '1..9', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '9'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': '8'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpWriteConfig', 'Value': '&map_LpWriteConfig[0]'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpReadConfig', 'Value': '&map_LpReadConfig[0]'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pWriteBuff', 'Value': '&map_pWriteBuff[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWriteBuff[0]', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pReadBuff', 'Value': 'NULL_PTR'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulWriteNumber', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulReadNumber', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': '-'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '-'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pICMSRnReg', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'CDDIIC_SEVEN_BIT_ADDR\\nCDDIIC_TEN_BIT_ADDR', 'Name': 'enAddressMode', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'usSlaveAddress', 'Value': '-'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pICMARnReg', 'Value': '-'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': '-'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pICMIERnReg', 'Value': '-'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '-'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '-'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_027': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_INVALID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDIIC_MODULE_ID'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDIIC_INSTANCE_ID'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'ApiId', 'Value': 'CDDIIC_CH0WRITEREAD_SID + 8'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDIIC_E_PARAM_POINTER'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enRepeatStartSta', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'enSlaveAddressMode', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_028': ['Type': 'Array', 'Range': '', 'Name': 'ulSndByteNumber', 'Value': '-'], 'Output_Param_029': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvByteNumber', 'Value': '-'], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'pSndBuffer', 'Value': '-'], 'Output_Param_031': ['Type': 'Array', 'Range': '', 'Name': 'pRcvBuffer', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTransferCnt', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_037': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_039': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIIC_START_SEC_CODE_SLOW #include \"CddIic_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIIC_CODE_SLOW) CddIic_WriteRead /* PRQA S 1503, 1532 # JV-01, JV-01 */ ( VAR(CddIic_ChannelType, AUTOMATIC) LddChannel, P2CONST(CddIic_WriteType, AUTOMATIC, RTE_APPL_DATA) LpWriteConfig, /* PRQA S 3432 # JV-01 */ P2VAR(CddIic_ReadType, AUTOMATIC, RTE_APPL_DATA) LpReadConfig, /* PRQA S 3432 # JV-01 */ P2CONST(CddIic_SlaveConfigType, AUTOMATIC, RTE_APPL_DATA) LpSlaveConfig /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddRetVal; VAR ( uint32, AUTOMATIC) LulRegVal; /* Initialize local variable */ LulRegVal = CDDIIC_ZERO_32; LddRetVal = RTE_E_OK; /* PRQA S 2982 # JV-01 */ #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) if ((NULL_PTR == LpWriteConfig->pWriteBuff) || /* PRQA S 2814 # JV-01 */ (NULL_PTR == LpReadConfig->pReadBuff) /* PRQA S 2814 # JV-01 */ ) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { if((CDDIIC_ZERO_32 == LpWriteConfig->ulWriteNumber) || \\ (CDDIIC_ZERO_32 == LpReadConfig->ulReadNumber)) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_VALUE); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (RTE_E_OK == LddRetVal) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { if (NULL_PTR == CddIic_GpChannelConfig[LddChannel].pDmaConfiguration) { /* Report error to Det */ (void) Det_ReportError(CDDIIC_MODULE_ID, CDDIIC_INSTANCE_ID, \\ CDDIIC_CH0WRITEREAD_SID + LddChannel, CDDIIC_E_PARAM_POINTER); /* Return NOK error code */ LddRetVal = RTE_E_INVALID; } else { /* No action required */ } } else { /* No action required */ } } else { /* No action required */ } #endif if (RTE_E_OK == LddRetVal) #endif { /* Enable repeat START for channel status */ CddIic_GpChannelStatus[LddChannel].enRepeatStartSta = /* PRQA S 2824 # JV-01 */ CDDIIC_SND_RPT_STR_RCV_ENABLE; /* Get slave control register value */ CddIic_HWGetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, &LulRegVal); /* PRQA S 2824 # JV-01 */ /* Disable slave interface mode */ LulRegVal = LulRegVal & ~(CDDIIC_SIE_BIT); /* Write value into slave control register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICSCRnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICSCRnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Clear master status register */ LulRegVal = CDDIIC_ZERO_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMSRnReg, LulRegVal); /* PRQA S 2824 # JV-01 */ if (CDDIIC_SEVEN_BIT_ADDR == LpSlaveConfig->enAddressMode) /* PRQA S 2814 # JV-01 */ { /* Set Master address register */ LulRegVal = (uint32) LpSlaveConfig->usSlaveAddress; /* Enable write mode for Master operation */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Set transmit data registter (ICTXRXD = 1st transmission data */ LulRegVal = (uint32) LpWriteConfig->pWriteBuff[CDDIIC_ZERO_32]; /* PRQA S 2814, 2824 # JV-01, JV-01 */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_SEVEN_BIT_ADDR; } else { /* Create first byte address in 10-bit slave address */ /* Casting to uint32 in order to proceed bitwise operation */ LulRegVal = CDDIIC_FIRST_BYTE_TEN_BIT_ADDR_MASK | \\ ((uint32)(LpSlaveConfig->usSlaveAddress) >> CDDIIC_EIGHT_32); /* Enable write mode for master operation */ LulRegVal = LulRegVal << CDDIIC_ONE_32; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMARnReg, \\ LulRegVal); #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMARnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Create second byte slave address in 10-bit slave address */ LulRegVal = ((uint32) LpSlaveConfig->usSlaveAddress) & \\ CDDIIC_SECOND_BYTE_TEN_BIT_ADDR_MASK; CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICTXRXDnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); CddIic_GpChannelStatus[LddChannel].enSlaveAddressMode = \\ CDDIIC_TEN_BIT_ADDR; } /* Set Master Interrupt Enable register */ /* Enable MAT, MDR, MDE, MNR, MST interrupt */ LulRegVal = CDDIIC_MATE_BIT | CDDIIC_MDRE_BIT | CDDIIC_MDEE_BIT | \\ CDDIIC_MNRE_BIT | CDDIIC_MSTE_BIT; /* Write the configure value to ICMIER register */ CddIic_HWSetReg(CddIic_GpChannelConfig[LddChannel].pICMIERnReg, /* PRQA S 2824 # JV-01 */ LulRegVal); /* Register Write Verify */ #if(CDDIIC_REGISTER_WRITE_VERIFY == STD_ON) (void) CddIic_RegisterWriteVerify( CddIic_GpChannelConfig[LddChannel].pICMIERnReg, LulRegVal, /* PRQA S 2824 # JV-01 */ CDDIIC_8_BIT_MASK); #endif /* Specify number of data transmission bytes */ CddIic_GpChannelStatus[LddChannel].ulSndByteNumber = \\ LpWriteConfig->ulWriteNumber; /* Specify number of data reception bytes */ CddIic_GpChannelStatus[LddChannel].ulRcvByteNumber = \\ LpReadConfig->ulReadNumber; /* PRQA S 2814 # JV-01 */ /* Set up internal buffer for tranmission mode */ CddIic_GaaBufferAddress[LddChannel].pSndBuffer = /* PRQA S 2844 # JV-01 */ LpWriteConfig->pWriteBuff; /* Set up internal buffer for reception mode */ CddIic_GaaBufferAddress[LddChannel].pRcvBuffer = /* PRQA S 2844 # JV-01 */ LpReadConfig->pReadBuff; #if (CDDIIC_TOTAL_DMA_CONFIG != CDDIIC_ZERO_DMA_CONFIG) if (CDDIIC_ONE_32 != (LpReadConfig->ulReadNumber)) { if (CDDIIC_DMA_ENABLED == CddIic_GpChannelConfig[LddChannel].enDmaMode) /* PRQA S 2824 # JV-01 */ { CddIic_RxDmaConfig(LddChannel, LpReadConfig->pReadBuff, \\ LpReadConfig->ulReadNumber); } else { /* No action required */ } } else { /* No aciton required */ } #endif #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pEnterRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif /* Issue START condition: MDBS = 1, MIE = 1, ESG = 1 */ LddRetVal = CddIic_Start(LddChannel); /* If the START condition issue to I2C bus succesfully */ if (RTE_E_OK == LddRetVal) { /* Change the channel status */ CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_SENDING; } else { CddIic_GpChannelStatus[LddChannel].enChSta = CDDIIC_CH_IDLE; } #if (CDDIIC_CRITICAL_SECTION_PROTECTION == STD_ON) CddIic_GpChannelConfig[LddChannel].pExitRegProtect(); /* PRQA S 2814, 2824 # JV-01, JV-01 */ #endif } #if (CDDIIC_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif return LddRetVal; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '1..9', 'Name': 'CDDIIC_TOTAL_DMA_CONFIG', 'Value': '9'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_REGISTER_WRITE_VERIFY', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDDIIC_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..8', 'Name': 'LddChannel', 'Value': '8'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpWriteConfig', 'Value': '&map_LpWriteConfig[0]'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpReadConfig', 'Value': '&map_LpReadConfig[0]'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL\u2026Address', 'Name': 'LpSlaveConfig', 'Value': '&ptr_LpSlaveConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pWriteBuff', 'Value': '&map_pWriteBuff[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pWriteBuff[0]', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pReadBuff', 'Value': '&map_pReadBuff[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulWriteNumber', 'Value': '100'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulReadNumber', 'Value': '100'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelConfig', 'Value': '&ptr_CddIic_GpChannelConfig[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'enDmaMode', 'Value': '[8]=CDDIIC_DMA_ENABLED'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'pDmaConfiguration', 'Value': '[8]=NULL_PTR'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'CddIic_GpChannelStatus', 'Value': '-'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'pICSCRnReg', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pICMSRnReg', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'CDDIIC_SEVEN_BIT_ADDR\\nCDDIIC_TEN_BIT_ADDR', 'Name': 'enAddressMode', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'usSlaveAddress', 'Value': '-'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pICMARnReg', 'Value': '-'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pICTXRXDnReg', 'Value': '-'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pICMIERnReg', 'Value': '-'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pEnterGlbProtect', 'Value': '-'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'pExitGlbProtect', 'Value': '-'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_027': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddRetVal', 'Value': 'RTE_E_INVALID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDIIC_MODULE_ID'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDIIC_INSTANCE_ID'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'ApiId', 'Value': 'CDDIIC_CH0WRITEREAD_SID + 8'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDIIC_E_PARAM_POINTER'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enRepeatStartSta', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValue', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'enSlaveAddressMode', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAdress', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegVal', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegisterAddr', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulData', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '-'], 'Output_Param_028': ['Type': 'Array', 'Range': '', 'Name': 'ulSndByteNumber', 'Value': '-'], 'Output_Param_029': ['Type': 'Array', 'Range': '', 'Name': 'ulRcvByteNumber', 'Value': '-'], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'pSndBuffer', 'Value': '-'], 'Output_Param_031': ['Type': 'Array', 'Range': '', 'Name': 'pRcvBuffer', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTransferCnt', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_037': ['Type': 'Array', 'Range': '', 'Name': 'enChSta', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_039': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_FAST #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDIPMMU_CODE_FAST) CddIpmmu_DomErrorDetect(void) /* PRQA S 1532 # JV-01 */ { VAR(CddIpmmu_IMSSTR, AUTOMATIC) LddIMSSTR; /* PRQA S 0759 # JV-01 */ VAR(uint32, AUTOMATIC) LulBaseAdd; VAR(uint8, AUTOMATIC) LucCount; VAR(boolean, AUTOMATIC) LblUnintendedIrqStatus; /* Mask bit array to get domain error */ CONST(uint32, AUTOMATIC)LulIndex[CDDIPMMU_TWELVE] = { CDD_IPMMU_BIT_MASK_00_00, CDD_IPMMU_BIT_MASK_02_02, CDD_IPMMU_BIT_MASK_03_03, CDD_IPMMU_BIT_MASK_05_05, CDD_IPMMU_BIT_MASK_06_06, CDD_IPMMU_BIT_MASK_10_10, CDD_IPMMU_BIT_MASK_11_11, CDD_IPMMU_BIT_MASK_12_12, CDD_IPMMU_BIT_MASK_14_14, CDD_IPMMU_BIT_MASK_15_15, CDD_IPMMU_BIT_MASK_18_18, CDD_IPMMU_BIT_MASK_19_19 }; /* Domains array of IPMMU */ CONST(CddIpmmu_BusDomainType, AUTOMATIC) LenDomainArray[CDDIPMMU_TWELVE] = { CDD_IPMMU_DS0, CDD_IPMMU_HC, CDD_IPMMU_IR, CDD_IPMMU_VIP0, CDD_IPMMU_3DG, CDD_IPMMU_RT, CDD_IPMMU_VIP1, CDD_IPMMU_VC0, CDD_IPMMU_VI0, CDD_IPMMU_VI1 ,CDD_IPMMU_MM, CDD_IPMMU_RT1 }; LulBaseAdd = CddIpmmu_DomGetBaseAddr(CDD_IPMMU_MM); /* Read interrupt status register to get domain error */ LddIMSSTR.INT = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMSSTR(LulBaseAdd)); /* PRQA S 3383, 3469 # JV-01, JV-01 */ /* initial value for interrupt status is Unintended interrupt */ LblUnintendedIrqStatus = CDDIPMMU_TRUE; /* PRQA S 2982 # JV-01 */ LucCount = CDDIPMMU_ZERO; /* PRQA S 2982 # JV-01 */ for (LucCount = CDDIPMMU_ZERO; LucCount < CDDIPMMU_TWELVE; LucCount++) { if (CDDIPMMU_DEFAULT_ZERO != (LddIMSSTR.INT & LulIndex[LucCount])) { /* Check Main Memory domain or other domain */ if (CDD_IPMMU_MM == LenDomainArray[LucCount]) { CddIpmmu_HwMmuErrorDetect(); } else { CddIpmmu_HwPmbErrorDetect(LenDomainArray[LucCount]); } /* Mask Unintended interrupt status as FALSE */ LblUnintendedIrqStatus = CDDIPMMU_FALSE; /* PRQA S 2983 # JV-01 */ } /* (CDDIPMMU_DEFAULT_ZERO != (LddIMSSTR.INT & LulIndex[LucCount])) */ else { /* No action required */ } } /* Unintended interrupt safety mechanism */ #if (CDDIPMMU_UNINTENDED_INTERRUPT_CHECK == STD_ON) if (CDDIPMMU_TRUE == LblUnintendedIrqStatus) { /* Report error to DEM */ (void)Dem_SetEventStatus(CDDIPMMU_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } else { /* No action required */ } #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_IR_DOMAIN_SUPPORT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_UNINTENDED_INTERRUPT_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDDIPMMU_TRUE'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<called>'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': '-'], 'Output_Param_012': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblUnintendedIrqStatus', 'Value': 'CDDIPMMU_FALSE'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_FAST #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(uint32, CDDIPMMU_CODE_FAST) CddIpmmu_DomGetBaseAddr ( CddIpmmu_BusDomainType BusDomain ) { /* CDD IPMMU BusDomain */ CONST(uint32, AUTOMATIC) LulBase[CDD_IPMMU_MAX] = { /* CDD_IPMMU_VI0 */ CDD_IPMMU_REG_BADRR_VI0, /* CDD_IPMMU_VI1 */ CDD_IPMMU_REG_BADRR_VI1, /* CDD_IPMMU_VC */ CDD_IPMMU_REG_BADRR_VC0, /* CDD_IPMMU_IR */ CDD_IPMMU_REG_BADRR_IR, /* CDD_IPMMU_RT */ CDD_IPMMU_REG_BADRR_RT, /* CDD_IPMMU_RT1 */ CDD_IPMMU_REG_BADRR_RT1, /* CDD_IPMMU_DS0 */ CDD_IPMMU_REG_BADRR_DS0, /* CDD_IPMMU_HC */ CDD_IPMMU_REG_BADRR_HC, /* CDD_IPMMU_3DG */ CDD_IPMMU_REG_BADRR_3DG, /* CDD_IPMMU_VIP0 */ CDD_IPMMU_REG_BADRR_VIP0, /* CDD_IPMMU_VIP1 */ CDD_IPMMU_REG_BADRR_VIP1, /* CDD_IPMMU_MM */ CDD_IPMMU_REG_BADRR_MM }; VAR(uint32, AUTOMATIC) LulAddr; if (CDD_IPMMU_MAX <= BusDomain) { /* Out of range (= NULL_PTR) */ LulAddr = CDDIPMMU_DEFAULT_ZERO; } else { LulAddr = LulBase[(uint8)BusDomain]; /* PRQA S 2844 # JV-01 */ } return LulAddr; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VI1']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LulAddr', 'Value': 'CDD_IPMMU_REG_BADRR_VI1'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_FAST #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(uint32, CDDIPMMU_CODE_FAST) CddIpmmu_DomGetBaseAddr ( CddIpmmu_BusDomainType BusDomain ) { /* CDD IPMMU BusDomain */ CONST(uint32, AUTOMATIC) LulBase[CDD_IPMMU_MAX] = { /* CDD_IPMMU_VI0 */ CDD_IPMMU_REG_BADRR_VI0, /* CDD_IPMMU_VI1 */ CDD_IPMMU_REG_BADRR_VI1, /* CDD_IPMMU_VC */ CDD_IPMMU_REG_BADRR_VC0, /* CDD_IPMMU_IR */ CDD_IPMMU_REG_BADRR_IR, /* CDD_IPMMU_RT */ CDD_IPMMU_REG_BADRR_RT, /* CDD_IPMMU_RT1 */ CDD_IPMMU_REG_BADRR_RT1, /* CDD_IPMMU_DS0 */ CDD_IPMMU_REG_BADRR_DS0, /* CDD_IPMMU_HC */ CDD_IPMMU_REG_BADRR_HC, /* CDD_IPMMU_3DG */ CDD_IPMMU_REG_BADRR_3DG, /* CDD_IPMMU_VIP0 */ CDD_IPMMU_REG_BADRR_VIP0, /* CDD_IPMMU_VIP1 */ CDD_IPMMU_REG_BADRR_VIP1, /* CDD_IPMMU_MM */ CDD_IPMMU_REG_BADRR_MM }; VAR(uint32, AUTOMATIC) LulAddr; if (CDD_IPMMU_MAX <= BusDomain) { /* Out of range (= NULL_PTR) */ LulAddr = CDDIPMMU_DEFAULT_ZERO; } else { LulAddr = LulBase[(uint8)BusDomain]; /* PRQA S 2844 # JV-01 */ } return LulAddr; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VIP0']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LulAddr', 'Value': 'CDD_IPMMU_REG_BADRR_VIP0'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_HwMicroTlbGet /* PRQA S 1532 # JV-01 */ ( uint8 uTlb, CddIpmmu_BusDomainType BusDomain, P2VAR(CddIpmmu_MicroTlbSettingType, AUTOMATIC, CDDIPMMU_APPL_DATA) /* PRQA S 3432 # JV-01 */ TlbSettingPtr ) { VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; VAR(uint32, AUTOMATIC) LulIMUCTR; VAR(uint32, AUTOMATIC) LulIMUASID; VAR(uint32, AUTOMATIC) LulBaseAdd; /* Initialize the return value as no error occurred */ LddStdReturnType = E_OK; /* Get Domain base address */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(BusDomain); /* Get Value of register IMUASID */ LulIMUASID = CddIpmmu_ReadReg(CDD_IPMMU_REG_MUASIDn(LulBaseAdd, uTlb)); /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ /* Get value of register IMUCTRn */ LulIMUCTR = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMUCTRn(LulBaseAdd, uTlb)); /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ /* Get the value of ASID0 of stage 1 translation */ TlbSettingPtr->ucTlbASID = (uint8)(LulIMUASID & /* PRQA S 2814 # JV-01 */ CDDIPMMU_UTLB_IMUASID_ASID0_MASK); /* Get the address translation enable */ if (CDDIPMMU_UTLB_IMUCTR_MMUEN == (LulIMUCTR & CDDIPMMU_UTLB_IMUCTR_MMUEN)) { TlbSettingPtr->ucTlbAddressTranslationEnable = CDDIPMMU_ENABLE; } else { TlbSettingPtr->ucTlbAddressTranslationEnable = CDDIPMMU_DISABLE; } TlbSettingPtr->ucTlbTranslationTable = (uint8)((LulIMUCTR & CDDIPMMU_UTLB_IMUCTR_TTSEL_MASK) >> CDD_IPMMU_SHIFT_04); return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_HC'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..63', 'Name': 'uTlb', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'TlbSettingPtr', 'Value': '&ptr_TlbSettingPtr[0]'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDD_IPMMU_REG_BADRR_HC'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0] = 0x00000000\\n[1] = 0x00000001']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_HC'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '[0] = CDD_IPMMU_REG_MUASIDn(CDD_IPMMU_REG_BADRR_HC, 0)\\n[1] = CDD_IPMMU_REG_IMUCTRn(CDD_IPMMU_REG_BADRR_HC, 0)'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucTlbASID', 'Value': '0x00'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucTlbAddressTranslationEnable', 'Value': 'CDDIPMMU_ENABLE'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucTlbTranslationTable', 'Value': '0x00'], 'Output_Param_005': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_OK'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_HwMicroTlbSet /* PRQA S 1532 # JV-01 */ ( CddIpmmu_BusDomainType BusDomain, uint8 uTlb, boolean EnableFlag, boolean UsePmb, uint8 Mmu, uint8 ASID ) { VAR(CddIpmmu_IMUCTRn, AUTOMATIC) LddIMUCTR; /* PRQA S 0759 # JV-01 */ VAR(CddIpmmu_IMUASIDn, AUTOMATIC) LddIMUASID; /* PRQA S 0759 # JV-01 */ VAR(CddIpmmu_IMCTRn, AUTOMATIC) LddIMCTR; /* PRQA S 0759 # JV-01 */ VAR(uint32, AUTOMATIC) LulBaseAdd; VAR(uint32, AUTOMATIC) LulMMBaseAdd; #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) VAR(Std_ReturnType, AUTOMATIC) LddWriteVerifyRet; #endif VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; /* Initialize the return value as no error occurred */ LddStdReturnType = E_OK; /* Getting the domain base address */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(BusDomain); /* Initialize value of u-TLB control registers */ LddIMUCTR.INT = CDDIPMMU_DEFAULT_ZERO; LddIMUASID.INT = CDDIPMMU_DEFAULT_ZERO; /* Modify value for Register(IMUCTR) */ if (CDDIPMMU_TRUE != UsePmb) { /* Setting translation table select as MMUn */ LddIMUCTR.BIT.TTSEL = (Mmu | CDD_IPMMU_MASK_32_BIT); /* PRQA S 2985 # JV-01 */ /* Checking if address translation table of the u-TLB is enabled */ if (CDDIPMMU_TRUE == EnableFlag) { /* Getting base address for MM-domain */ LulMMBaseAdd = CddIpmmu_DomGetBaseAddr(CDD_IPMMU_MM); /* Register read of IMCTR from MM-domain */ LddIMCTR.INT = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMCTRn(LulMMBaseAdd, Mmu)); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ /* Mask to get bit 0, 1 and 2 to set for IPMMU Cache */ LddIMCTR.INT &= CDD_IPMMU_BIT_MASK_02_00; /* Register write(COPY) value of IMCTR to each BUS-domain */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu), LddIMCTR.INT); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ LddWriteVerifyRet = CddIpmmu_WriteVerifyReg (CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu), LddIMCTR.INT); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ /* Check the return value of write verify register */ if (E_NOT_OK == LddWriteVerifyRet) { LddStdReturnType = E_NOT_OK; } else { /* No action required */ } #endif } else { /* No action required */ } } else { /* Setting translation table select as PMB */ LddIMUCTR.BIT.TTSEL = CDD_IPMMU_REG_IMUCTR_TTSEL_PMB; } /* Setting address translation table of the u-TLB */ if (CDDIPMMU_TRUE == EnableFlag) { LddIMUCTR.BIT.MMUEN = CDD_IPMMU_REG_IMUCTR_MMUEN_ENABLE; } else { LddIMUCTR.BIT.MMUEN = CDD_IPMMU_REG_IMUCTR_MMUEN_DISABLE; } /* Modify register(IMUASID), 2nd stage translation is not supported */ LddIMUASID.BIT.ASID1 = CDD_IPMMU_REG_IMUASID_ASID_ZERO; LddIMUASID.BIT.ASID0 = ASID; /* Write configuration value to MUASIDn register */ CddIpmmu_WriteReg(CDD_IPMMU_REG_MUASIDn(LulBaseAdd, uTlb), LddIMUASID.INT); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ LddWriteVerifyRet = CddIpmmu_WriteVerifyReg (CDD_IPMMU_REG_MUASIDn(LulBaseAdd, uTlb), LddIMUASID.INT); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ /* Check the return value of write verify register */ if (E_NOT_OK == LddWriteVerifyRet) { LddStdReturnType = E_NOT_OK; } else { /* No action required */ } #endif /* Write configuration value to IMUCTRn register */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMUCTRn(LulBaseAdd, uTlb), LddIMUCTR.INT); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ LddWriteVerifyRet = CddIpmmu_WriteVerifyReg (CDD_IPMMU_REG_IMUCTRn(LulBaseAdd, uTlb), LddIMUCTR.INT); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ /* Check the return value of write verify register */ if (E_NOT_OK == LddWriteVerifyRet) { LddStdReturnType = E_NOT_OK; } else { /* No action required */ } #endif if ((CDDIPMMU_TRUE != UsePmb) && (CDDIPMMU_TRUE != EnableFlag)) { #if (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDIPMMU_ENTER_CRITICAL_SECTION(CDDIPMMU_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Reading value of IMCTRn to modify */ LddIMCTR.INT = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu)); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ /* Disable the Access Flag */ LddIMCTR.BIT.AFE = CDD_IPMMU_REG_IMCTR_AFE_DISABLE; /* Disable MMU address translation error interrupt */ LddIMCTR.BIT.INTEN = CDD_IPMMU_REG_IMCTR_INTEN_OFF; /* Disable address translation for the MMU */ LddIMCTR.BIT.MMUEN = CDD_IPMMU_REG_IMCTR_MMUEN_DISABLE; /* Write configuration value to IMCTRn register */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu), LddIMCTR.INT); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ LddWriteVerifyRet = CddIpmmu_WriteVerifyReg (CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu), LddIMCTR.INT); /* PRQA S 3384, 3383, 3469 # JV-01, JV-01, JV-01 */ /* Check the return value of write verify register */ if (E_NOT_OK == LddWriteVerifyRet) { LddStdReturnType = E_NOT_OK; } else { /* No action required */ } #endif #if (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDIPMMU_EXIT_CRITICAL_SECTION(CDDIPMMU_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } else { /* No action required */ } return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VI0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..63', 'Name': 'uTlb', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'CDDIPMMU_TRUE..CDDIPMMU_FALSE', 'Name': 'EnableFlag', 'Value': 'CDDIPMMU_TRUE'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'CDDIPMMU_TRUE..CDDIPMMU_FALSE', 'Name': 'UsePmb', 'Value': 'CDDIPMMU_FALSE'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..15', 'Name': 'Mmu', 'Value': '0'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..1', 'Name': 'ASID', 'Value': '0'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0] = CDD_IPMMU_REG_BADRR_VI0\\n[1] = CDD_IPMMU_REG_BADRR_MM'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0 to 2] = E_OK'], 'Input_Param_009': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIPMMU_WRITE_VERIFY_CHECK', 'Value': 'STD_ON']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VI0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_MM'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_VI0, 0)'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000001'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_VI0, 0)'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000001'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_MUASIDn(CDD_IPMMU_REG_BADRR_VI0, 0)'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000000'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_MUASIDn(CDD_IPMMU_REG_BADRR_VI0, 0)'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000000'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMUCTRn(CDD_IPMMU_REG_BADRR_VI0, 0)'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000001'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMUCTRn(CDD_IPMMU_REG_BADRR_VI0, 0)'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000001'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '-'], 'Output_Param_021': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_022': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_OK'], 'Output_Param_023': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_HwMmuEnable /* PRQA S 1532 # JV-01 */ ( uint8 Mmu, boolean AccessFlagUse ) { VAR(CddIpmmu_IMCTRn, AUTOMATIC) LddIMCTR; /* PRQA S 0759 # JV-01 */ VAR(uint32, AUTOMATIC) LulBaseAdd; #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) VAR(Std_ReturnType, AUTOMATIC) LddWriteVerifyRet; #endif VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; /* Initialize the return value as no error occurred */ LddStdReturnType = E_OK; /* Getting domain base address */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(CDD_IPMMU_MM); #if (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDIPMMU_ENTER_CRITICAL_SECTION(CDDIPMMU_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Read value of IMCTRn register to modify */ LddIMCTR.INT = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu)); /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ /* Setting Access Flag Enable for the MMU */ if (CDDIPMMU_TRUE == AccessFlagUse) { LddIMCTR.BIT.AFE = CDD_IPMMU_REG_IMCTR_AFE_ENABLE; } else { LddIMCTR.BIT.AFE = CDD_IPMMU_REG_IMCTR_AFE_DISABLE; } /* Enable interrupt for address translation error */ LddIMCTR.BIT.INTEN = CDD_IPMMU_REG_IMCTR_INTEN_ON; /* Enable address translation for the MMU */ LddIMCTR.BIT.MMUEN = CDD_IPMMU_REG_IMCTR_MMUEN_ENABLE; /* Write configuration value to IMCTRn registers */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu), LddIMCTR.INT); /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ LddWriteVerifyRet = CddIpmmu_WriteVerifyReg (CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu), LddIMCTR.INT); /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ /* Check the return value of write verify register */ if (E_NOT_OK == LddWriteVerifyRet) { LddStdReturnType = E_NOT_OK; } else { /* No action required */ } #endif #if (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDIPMMU_EXIT_CRITICAL_SECTION(CDDIPMMU_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) */ return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_WRITE_VERIFY_CHECK', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..15', 'Name': 'Mmu', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'CDDIPMMU_TRUE .. CDDIPMMU_FALSE', 'Name': 'AccessFlagUse', 'Value': 'CDDIPMMU_TRUE'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDD_IPMMU_REG_BADRR_MM'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_MM'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00010005'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00010005'], 'Output_Param_007': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_008': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_OK'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_FAST #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDIPMMU_CODE_FAST) CddIpmmu_HwMmuErrorDetect(void) /* PRQA S 1505 # JV-01 */ { VAR(CddIpmmu_IMCTRn, AUTOMATIC) LddIMCTR; /* PRQA S 0759 # JV-01 */ VAR(CddIpmmu_IMSTRn, AUTOMATIC) LddIMSTR; /* PRQA S 0759 # JV-01 */ VAR(uint32, AUTOMATIC) LddIMELAR; VAR(CddIpmmu_IMEUARn, AUTOMATIC) LddIMEUAR; /* PRQA S 0759 # JV-01 */ VAR(CddIpmmu_MmuCbkFunctionPtrType, AUTOMATIC) LpMmuCbkFunction; VAR(uint32, AUTOMATIC) LulErrorAddr; VAR(uint8, AUTOMATIC) LucUpperErrorAddr; CONST(CddIpmmu_ErrorCodeType, AUTOMATIC) LenErrorCode[CDDIPMMU_EIGHT] = { CDD_IPMMU_ERRCODE_UNDEFINE, CDD_IPMMU_ERRCODE_TLB_FORMAT_ERROR, CDD_IPMMU_ERRCODE_UNDEFINE, CDD_IPMMU_ERRCODE_UNDEFINE, CDD_IPMMU_ERRCODE_ACCESS_PERMISSION, CDD_IPMMU_ERRCODE_SECURE_ACCESS, CDD_IPMMU_ERRCODE_UNDEFINE, CDD_IPMMU_ERRCODE_UNDEFINE }; VAR(uint32, AUTOMATIC) LulBaseAdd; VAR(uint8, AUTOMATIC) LucCount; VAR(boolean, AUTOMATIC) LblUnintendedIrqStatusEn; #if (CDDIPMMU_UNINTENDED_INTERRUPT_CHECK == STD_ON) VAR(boolean, AUTOMATIC) LblUnintendedIrqStatus; /* initial value for interrupt status is Unintended interrupt */ LblUnintendedIrqStatus = CDDIPMMU_TRUE; #endif /* Getting domain base address */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(CDD_IPMMU_MM); for (LucCount = CDDIPMMU_ZERO; LucCount < CDD_IPMMU_ENT_MAX_MMU; LucCount++) { /* initial value indicate interrupt control bit is enable or not */ LblUnintendedIrqStatusEn = CDDIPMMU_TRUE; LddIMCTR.INT = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMCTRn(LulBaseAdd, LucCount)); /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ #if (CDDIPMMU_UNINTENDED_INTERRUPT_CHECK == STD_ON) /* Check control interrupt bit is enable or not */ if (CDDIPMMU_DEFAULT_ONE != LddIMCTR.BIT.INTEN) { LblUnintendedIrqStatusEn = CDDIPMMU_FALSE; } else { /* No action required */ } #endif if ((CDDIPMMU_DEFAULT_ONE == LddIMCTR.BIT.MMUEN) && /* PRQA S 2995 # JV-01 */ (CDDIPMMU_TRUE == LblUnintendedIrqStatusEn)) { /* Reading value form MMU error registers */ LddIMSTR.INT = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMSTRn(LulBaseAdd, /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ LucCount)); LddIMELAR = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMELARn(LulBaseAdd, /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ LucCount)); LddIMEUAR.INT = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMEUARn(LulBaseAdd, /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ LucCount)); if ((CDDIPMMU_DEFAULT_ZERO != (LddIMSTR.INT & CDDIPMMU_IMSTR_ERROR_MASK)) || (CDDIPMMU_DEFAULT_ZERO != LddIMELAR) || (CDDIPMMU_DEFAULT_ZERO != LddIMEUAR.BIT.EAR)) { /* Getting faulting virtual address */ LulErrorAddr = LddIMELAR; /* Getting upper faulting virtual address */ LucUpperErrorAddr = (uint8)LddIMEUAR.BIT.EAR; /* Getting MMU callback function pointer */ LpMmuCbkFunction = CddIpmmu_MmuGetCallBackFunction((uint8)LucCount); if (NULL_PTR != LpMmuCbkFunction) { /* Callback for application */ LpMmuCbkFunction((uint8)LucCount, LenErrorCode[LddIMSTR.BIT.ERRCODE], (boolean)LddIMSTR.BIT.MHIT, (boolean)LddIMSTR.BIT.ABORT, (boolean)LddIMSTR.BIT.PF, (boolean)LddIMSTR.BIT.TF, LulErrorAddr, LucUpperErrorAddr); } else { /* No action required */ } /* Error clear */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMSTRn(LulBaseAdd, LucCount), /* PRQA S 3469, 3383, 3384 # JV-01, JV-01, JV-01 */ CDDIPMMU_DEFAULT_ZERO); #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ (void)CddIpmmu_WriteVerifyReg (CDD_IPMMU_REG_IMSTRn(LulBaseAdd, LucCount), CDDIPMMU_DEFAULT_ZERO); /* PRQA S 3469, 3383, 3384 # JV-01, JV-01, JV-01 */ #endif #if (CDDIPMMU_UNINTENDED_INTERRUPT_CHECK == STD_ON) /* Mask Unintended interrupt status as FALSE */ LblUnintendedIrqStatus = CDDIPMMU_FALSE; #endif } else { /* No action required */ } } else { /* No action required */ } } /* Unintended interrupt safety mechanism */ #if (CDDIPMMU_UNINTENDED_INTERRUPT_CHECK == STD_ON) if (CDDIPMMU_TRUE == LblUnintendedIrqStatus) { /* Report error to DEM */ (void)Dem_SetEventStatus(CDDIPMMU_E_INTERRUPT_CONTROLLER_FAILURE, DEM_EVENT_STATUS_FAILED); } else { /* No action required */ } #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDD_IPMMU_REG_BADRR_MM'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIPMMU_UNINTENDED_INTERRUPT_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'CDDIPMMU_WRITE_VERIFY_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0 to 3] = 0xFFFFFFFF\\n'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0] = &ptr_LpMmuConfig[0]']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_MM'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '[0] = CDD_IPMMU_REG_IMSTRn(CDD_IPMMU_REG_BADRR_MM, 0)\\n[1] = CDD_IPMMU_REG_IMELARn(CDD_IPMMU_REG_BADRR_MM, 0)\\n[2] = CDD_IPMMU_REG_IMEUARn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Mmu', 'Value': '0'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Mmu', 'Value': '0'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'ErrorCode', 'Value': 'CDD_IPMMU_ERRCODE_UNDEFINE'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'MultiHit', 'Value': '1'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Abort', 'Value': '1'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'PageFault', 'Value': '1'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'TransFault', 'Value': '1'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'ErrorAddr', 'Value': '0xFFFFFFFF'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'UpperErrorAddr', 'Value': '0xFF'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMSTRn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000000'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMSTRn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000000'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'Mmu', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'Mmu', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': '-'], 'Output_Param_044': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblMmuIrqStatus', 'Value': 'CDDIPMMU_TRUE'], 'Output_Param_045': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_HwMmuFlush /* PRQA S 1532 # JV-01 */ ( uint8 Mmu, CddIpmmu_BusDomainType BusDomain ) { VAR(CddIpmmu_IMCTRn, AUTOMATIC) LddIMCTR; /* PRQA S 0759 # JV-01 */ VAR(uint32, AUTOMATIC) LulBaseAdd; /* Get base address for specific domain */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(BusDomain); #if (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDIPMMU_ENTER_CRITICAL_SECTION(CDDIPMMU_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Read value of IMCTRn register to modify */ LddIMCTR.INT = CddIpmmu_ReadReg(CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu)); /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ /* Flush the MMU */ LddIMCTR.BIT.FLUSH = CDD_IPMMU_REG_IMCTR_FLUSH; /* Write configuration value to IMCTRn registers */ /* Note: FLUSH bit in IMCTRn automatically cleared to 0 -> not apply write * verify */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMCTRn(LulBaseAdd, Mmu), LddIMCTR.INT); /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ #if (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDIPMMU_EXIT_CRITICAL_SECTION(CDDIPMMU_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDDIPMMU_CRITICAL_SECTION_PROTECTION == STD_ON) */ return E_OK; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..15', 'Name': 'Mmu', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_IR'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDD_IPMMU_REG_BADRR_IR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_IR'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_IR, 0)'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMCTRn(CDD_IPMMU_REG_BADRR_IR, 0)'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000003'], 'Output_Param_005': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDIPMMU_CODE_SLOW) CddIpmmu_HwTranslationTableInit /* PRQA S 1505 # JV-01 */ ( P2CONST(CddIpmmu_TranslationTableConfigType, AUTOMATIC, CDDIPMMU_APPL_CONST) /* PRQA S 3432 # JV-01 */ TranslationTblConfig ) { VAR(CddIpmmu_IMTTBCRn, AUTOMATIC) LddIMTTBCR; /* PRQA S 0759 # JV-01 */ VAR(CddIpmmu_IMTTLBR0_1n, AUTOMATIC) LddIMTTLBR; /* PRQA S 0759 # JV-01 */ VAR(CddIpmmu_IMTTUBR0_1n, AUTOMATIC) LddIMTTUBR; /* PRQA S 0759 # JV-01 */ VAR(uint32, AUTOMATIC) LulBaseAdd; /* Getting domain base address */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(CDD_IPMMU_MM); /* Initialize value of translation table base address registers */ LddIMTTLBR.INT = CDDIPMMU_DEFAULT_ZERO; LddIMTTUBR.INT = CDDIPMMU_DEFAULT_ZERO; /* Read value of IMTTBCRn register to modify */ LddIMTTBCR.INT = CddIpmmu_ReadReg (CDD_IPMMU_REG_IMTTBCRn(LulBaseAdd, TranslationTblConfig->ucMmuId)); /* PRQA S 3383, 2814, 3469, 3384 # JV-01, JV-01, JV-01, JV-01 */ /* Checking the translation table index */ if (CDDIPMMU_ONE == TranslationTblConfig->ucTranslationTableId) { /* Setting share ability attributes for the translation table 1 */ LddIMTTBCR.BIT.SH1 = ((uint32)(TranslationTblConfig->enMmuShareAbility) | /* PRQA S 2985 # JV-01 */ CDD_IPMMU_MASK_32_BIT); /* Setting Outer Cache ability attribute the translation table 1 */ LddIMTTBCR.BIT.ORGN1 = ((uint32)(TranslationTblConfig->enMmuOuterCacheAbility) | /* PRQA S 2985 # JV-01 */ CDD_IPMMU_MASK_32_BIT); /* Setting Inner Cache ability attribute the translation table 1 */ LddIMTTBCR.BIT.IRGN1 = ((uint32)(TranslationTblConfig->enMmuInnerCacheAbility) | /* PRQA S 2985 # JV-01 */ CDD_IPMMU_MASK_32_BIT); /* Setting the text size for the translation table 1 */ LddIMTTBCR.BIT.TSZ1_32 = TranslationTblConfig->ucMmuTranslationSize; } else /* (0 == TableIndex) */ { /* Setting share ability attributes for the translation table 0 */ LddIMTTBCR.BIT.SH0 = ((uint32)(TranslationTblConfig->enMmuShareAbility) | /* PRQA S 2985 # JV-01 */ CDD_IPMMU_MASK_32_BIT); /* Setting Outer Cache ability attribute the translation table 0 */ LddIMTTBCR.BIT.ORGN0 = ((uint32)(TranslationTblConfig->enMmuOuterCacheAbility) | /* PRQA S 2985 # JV-01 */ CDD_IPMMU_MASK_32_BIT); /* Setting Inner Cache ability attribute the translation table 0 */ LddIMTTBCR.BIT.IRGN0 = ((uint32)(TranslationTblConfig->enMmuInnerCacheAbility) | /* PRQA S 2985 # JV-01 */ CDD_IPMMU_MASK_32_BIT); /* Setting the text size for the translation table 0 */ LddIMTTBCR.BIT.TSZ0_32 = TranslationTblConfig->ucMmuTranslationSize; } /* Setting first 4-bit translation table lower base address */ LddIMTTLBR.BIT.TTBR_1 = ((TranslationTblConfig->ulMmuLowerBaseAddress) & CDD_IPMMU_BIT_MASK_03_00); /* Setting next 16-bit translation table lower base address */ LddIMTTLBR.BIT.TTBR_2 = ((TranslationTblConfig->ulMmuLowerBaseAddress) >> CDD_IPMMU_SHIFT_04); /* Setting translation table upper base address */ LddIMTTUBR.BIT.TTBR = TranslationTblConfig->ucMmuUpperBaseAddress; /* Checking the translation table index */ if (CDDIPMMU_ONE == TranslationTblConfig->ucTranslationTableId) { /* Write configuration value to IMTTUBR1n registers */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMTTUBR1n /* PRQA S 3383, 3469, 3384 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTUBR.INT); #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ (void)CddIpmmu_WriteVerifyReg(CDD_IPMMU_REG_IMTTUBR1n /* PRQA S 3469, 3384, 3383 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTUBR.INT); #endif /* Write configuration value to IMTTLBR1n registers */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMTTLBR1n /* PRQA S 3469, 3383, 3384 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTLBR.INT); #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ (void)CddIpmmu_WriteVerifyReg(CDD_IPMMU_REG_IMTTLBR1n /* PRQA S 3383, 3469, 3384 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTLBR.INT); #endif } else /* (0 == TableIndex) */ { /* Write configuration value to IMTTUBR0n registers */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMTTUBR0n /* PRQA S 3383, 3469, 3384 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTUBR.INT); #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ (void)CddIpmmu_WriteVerifyReg(CDD_IPMMU_REG_IMTTUBR0n /* PRQA S 3469, 3383, 3384 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTUBR.INT); #endif /* Write configuration value to IMTTLBR0n registers */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMTTLBR0n /* PRQA S 3469, 3383, 3384 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTLBR.INT); #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ (void)CddIpmmu_WriteVerifyReg(CDD_IPMMU_REG_IMTTLBR0n /* PRQA S 3383, 3469, 3384 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTLBR.INT); #endif } /* Write configuration value to IMTTBCRn register */ CddIpmmu_WriteReg(CDD_IPMMU_REG_IMTTBCRn /* PRQA S 3383, 3469, 3384 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTBCR.INT); #if (CDDIPMMU_WRITE_VERIFY_CHECK == STD_ON) /* Write verify register */ (void)CddIpmmu_WriteVerifyReg(CDD_IPMMU_REG_IMTTBCRn /* PRQA S 3383, 3384, 3469 # JV-01, JV-01, JV-01 */ (LulBaseAdd, TranslationTblConfig->ucMmuId), LddIMTTBCR.INT); #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'TranslationTblConfig', 'Value': '&ptr_TranslationTblConfig[0]'], 'Input_Param_001': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDD_IPMMU_REG_BADRR_MM'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucMmuId', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucTranslationTableId', 'Value': '0'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_WRITE_VERIFY_CHECK', 'Value': 'STD_ON']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_MM'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMTTBCRn(CDD_IPMMU_REG_BADRR_MM, 0)'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMTTUBR0n(CDD_IPMMU_REG_BADRR_MM,0)'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000055'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMTTUBR0n(CDD_IPMMU_REG_BADRR_MM,0)'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00000055'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMTTLBR0n(CDD_IPMMU_REG_BADRR_MM,0)'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x55555000'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMTTLBR0n(CDD_IPMMU_REG_BADRR_MM,0)'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x55555000'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMTTBCRn(CDD_IPMMU_REG_BADRR_MM,0)'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00001505'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegisterAddr', 'Value': 'CDD_IPMMU_REG_IMTTBCRn(CDD_IPMMU_REG_BADRR_MM,0)'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'Data', 'Value': '0x00001505'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" FUNC(void, CDDIPMMU_CODE_SLOW) CddIpmmu_Init /* PRQA S 1503 # JV-01 */ ( P2CONST(CddIpmmu_ConfigType, AUTOMATIC, CDDIPMMU_APPL_CONST) Config /* PRQA S 3432 # JV-01 */ ) { #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) VAR(boolean, AUTOMATIC) LblErrFlag; #endif #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) /* Initialize the error flag */ LblErrFlag = CDDIPMMU_FALSE; #if (CDDIPMMU_ALREADY_INIT_DET_CHECK == STD_ON) if (CDDIPMMU_INITIALIZED == CddIpmmu_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_INIT_SID, CDDIPMMU_E_ALREADY_INITIALIZED); /* Set the error flag as CDDIPMMU_TRUE */ LblErrFlag = CDDIPMMU_TRUE; } else { /* No action required */ } #endif if (CDDIPMMU_TRUE != LblErrFlag) { /* Report to DET, if Configure pointer is equal to Null */ if (NULL_PTR == Config) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_INIT_SID, CDDIPMMU_E_PARAM_POINTER); /* Set the error status flag to true */ LblErrFlag = CDDIPMMU_TRUE; } else { /* No Action Required */ } } else { /* No Action Required */ } if (CDDIPMMU_TRUE != LblErrFlag) { /* Report to DET, if database is not valid */ if (CDDIPMMU_DBTOC_VALUE != Config->ulStartOfDbToc) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_INIT_SID, CDDIPMMU_E_INVALID_DATABASE); /* Set the error status flag to true */ LblErrFlag = CDDIPMMU_TRUE; } else { /* No Action Required */ } } else { /* No Action Required */ } if (CDDIPMMU_FALSE == LblErrFlag) #endif /* CDDIPMMU_DEV_ERROR_DETECT == STD_ON */ { /* Initialize IPMMU driver configuration */ CddIpmmu_HwInit(Config); /* Store the pointer of IPMMU configuration to global variable */ CddIpmmu_GpConfig = Config; /* Set the driver status into initialized */ CddIpmmu_GblDriverStatus = CDDIPMMU_INITIALIZED; } #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_ALREADY_INIT_DET_CHECK', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'Config', 'Value': '&ptr_Config[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulStartOfDbToc', 'Value': '!CDDIPMMU_DBTOC_VALUE'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'CDDIPMMU_INITIALIZED .. CDDIPMMU_UNINITIALIZED', 'Name': 'CddIpmmu_GblDriverStatus', 'Value': 'CDDIPMMU_UNINITIALIZED']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDIPMMU_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDIPMMU_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CDDIPMMU_INIT_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDIPMMU_E_INVALID_DATABASE'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Config', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'CddIpmmu_GpConfig', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'CddIpmmu_GblDriverStatus', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_MicroTlbGet /* PRQA S 1503 # JV-01 */ ( uint8 uTlb, CddIpmmu_BusDomainType BusDomain, P2VAR(CddIpmmu_MicroTlbSettingType, AUTOMATIC, CDDIPMMU_APPL_DATA) /* PRQA S 3432 # JV-01 */ TlbSettingPtr ) { VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) VAR(uint32, AUTOMATIC) LulBaseAdd; #endif /* initialize the return value as no error occurred */ LddStdReturnType = E_OK; #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) /* Checking whether IPMMU driver is initialized or not */ if (CDDIPMMU_INITIALIZED != CddIpmmu_GblDriverStatus) { /* report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MICRO_TLB_GET_SID, CDDIPMMU_E_UNINIT); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } if ((E_OK == LddStdReturnType) && ((uint8)CDD_IPMMU_ENT_MAX_UTLB <= uTlb)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MICRO_TLB_GET_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } /* Check the Bus Domain Base address */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(BusDomain); if (E_OK == LddStdReturnType) { if ((CDDIPMMU_DEFAULT_ZERO == LulBaseAdd) || (CDD_IPMMU_MM == BusDomain)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MICRO_TLB_GET_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } } else { /* No action required */ } if ((E_OK == LddStdReturnType) && (NULL_PTR == TlbSettingPtr)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MICRO_TLB_GET_SID, CDDIPMMU_E_PARAM_POINTER); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } /* Check the return value */ if (E_OK == LddStdReturnType) #endif /* CDDIPMMU_DEV_ERROR_DETECT == STD_ON */ { /* Execute internal function */ LddStdReturnType = CddIpmmu_HwMicroTlbGet(uTlb, BusDomain, TlbSettingPtr); } #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* return value */ return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VI0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..63', 'Name': 'uTlb', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'TlbSettingPtr', 'Value': '&ptr_TlbSettingPtr[0]'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDD_IPMMU_REG_BADRR_VI0'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDIPMMU_INITIALIZED .. CDDIPMMU_UNINITIALIZED', 'Name': 'CddIpmmu_GblDriverStatus', 'Value': 'CDDIPMMU_INITIALIZED']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VI0'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VI0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'uTlb', 'Value': '0'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'TlbSettingPtr', 'Value': '&ptr_TlbSettingPtr[0]'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_MicroTlbGet /* PRQA S 1503 # JV-01 */ ( uint8 uTlb, CddIpmmu_BusDomainType BusDomain, P2VAR(CddIpmmu_MicroTlbSettingType, AUTOMATIC, CDDIPMMU_APPL_DATA) /* PRQA S 3432 # JV-01 */ TlbSettingPtr ) { VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) VAR(uint32, AUTOMATIC) LulBaseAdd; #endif /* initialize the return value as no error occurred */ LddStdReturnType = E_OK; #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) /* Checking whether IPMMU driver is initialized or not */ if (CDDIPMMU_INITIALIZED != CddIpmmu_GblDriverStatus) { /* report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MICRO_TLB_GET_SID, CDDIPMMU_E_UNINIT); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } if ((E_OK == LddStdReturnType) && ((uint8)CDD_IPMMU_ENT_MAX_UTLB <= uTlb)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MICRO_TLB_GET_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } /* Check the Bus Domain Base address */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(BusDomain); if (E_OK == LddStdReturnType) { if ((CDDIPMMU_DEFAULT_ZERO == LulBaseAdd) || (CDD_IPMMU_MM == BusDomain)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MICRO_TLB_GET_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } } else { /* No action required */ } if ((E_OK == LddStdReturnType) && (NULL_PTR == TlbSettingPtr)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MICRO_TLB_GET_SID, CDDIPMMU_E_PARAM_POINTER); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } /* Check the return value */ if (E_OK == LddStdReturnType) #endif /* CDDIPMMU_DEV_ERROR_DETECT == STD_ON */ { /* Execute internal function */ LddStdReturnType = CddIpmmu_HwMicroTlbGet(uTlb, BusDomain, TlbSettingPtr); } #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* return value */ return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_DS0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..63', 'Name': 'uTlb', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'TlbSettingPtr', 'Value': '&ptr_TlbSettingPtr[0]'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDD_IPMMU_REG_BADRR_DS0'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDIPMMU_INITIALIZED .. CDDIPMMU_UNINITIALIZED', 'Name': 'CddIpmmu_GblDriverStatus', 'Value': 'CDDIPMMU_INITIALIZED']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_DS0'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_DS0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'uTlb', 'Value': '0'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'TlbSettingPtr', 'Value': '&ptr_TlbSettingPtr[0]'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_MmuGetTransTableBase /* PRQA S 1503 # JV-01 */ ( uint8 Mmu, uint8 TableIndex, P2VAR(CddIpmmu_TransTableSettingType, AUTOMATIC, CDDIPMMU_APPL_DATA) /* PRQA S 3432 # JV-01 */ TransTableConfigPtr ) { VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; /* initialize the return value as no error occurred */ LddStdReturnType = E_OK; #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) /* Checking whether IPMMU driver is initialized or not */ if (CDDIPMMU_INITIALIZED != CddIpmmu_GblDriverStatus) { /* report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MMU_GET_TRANS_TABLE_BASE_SID, CDDIPMMU_E_UNINIT); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } if ((E_OK == LddStdReturnType) && ((uint8)CDD_IPMMU_ENT_MAX_MMU <= Mmu)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MMU_GET_TRANS_TABLE_BASE_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } if (E_OK == LddStdReturnType) { if ((CDDIPMMU_ZERO != TableIndex) && (CDDIPMMU_ONE != TableIndex)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MMU_GET_TRANS_TABLE_BASE_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } } else { /* No action required */ } if ((E_OK == LddStdReturnType) && (NULL_PTR == TransTableConfigPtr)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MMU_GET_TRANS_TABLE_BASE_SID, CDDIPMMU_E_PARAM_POINTER); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } /* Check the return value */ if (E_OK == LddStdReturnType) #endif /* CDDIPMMU_DEV_ERROR_DETECT == STD_ON */ { /* Execute internal function */ LddStdReturnType = CddIpmmu_HwMmuGetTransTableBase(Mmu, TableIndex, TransTableConfigPtr); } #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* return value */ return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..15', 'Name': 'Mmu', 'Value': '15'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'TableIndex', 'Value': 'CDDIPMMU_ZERO'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'TransTableConfigPtr', 'Value': '&ptr_TransTableConfigPtr[0]'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'CDDIPMMU_INITIALIZED .. CDDIPMMU_UNINITIALIZED', 'Name': 'CddIpmmu_GblDriverStatus', 'Value': 'CDDIPMMU_INITIALIZED']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Mmu', 'Value': '15'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'TableIndex', 'Value': 'CDDIPMMU_ZERO'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'TransTableConfigPtr', 'Value': '&ptr_TransTableConfigPtr[0]'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_MmuSetMode /* PRQA S 1503 # JV-01 */ ( uint8 Mmu, CddIpmmu_TranslationLevelType Level ) { VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; /* Initialize the return value as no error occurred */ LddStdReturnType = E_OK; #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) /* Checking whether IPMMU driver was initialized or not */ if (CDDIPMMU_INITIALIZED != CddIpmmu_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MMU_SET_MODE_SID, CDDIPMMU_E_UNINIT); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } if (E_OK == LddStdReturnType) { if ((uint8)CDD_IPMMU_ENT_MAX_MMU <= Mmu) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_MMU_SET_MODE_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } } else { /* No action required */ } /* Check the return value */ if (E_OK == LddStdReturnType) #endif /* CDDIPMMU_DEV_ERROR_DETECT == STD_ON */ { /* Execute function */ LddStdReturnType = CddIpmmu_HwMmuSetMode(Mmu, Level); } #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* Return value */ return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..15', 'Name': 'Mmu', 'Value': '16'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Level', 'Value': '-'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'CDDIPMMU_INITIALIZED .. CDDIPMMU_UNINITIALIZED', 'Name': 'CddIpmmu_GblDriverStatus', 'Value': 'CDDIPMMU_INITIALIZED']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDIPMMU_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDIPMMU_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CDDIPMMU_MMU_SET_MODE_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDIPMMU_E_PARAM_VALUE'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Mmu', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Level', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_NOT_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDIPMMU_START_SEC_CODE_SLOW #include \"CddIpmmu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDIPMMU_CODE_SLOW) CddIpmmu_PmbGet /* PRQA S 1503 # JV-01 */ ( uint8 Pmb, CddIpmmu_BusDomainType BusDomain, P2VAR(CddIpmmu_PmbSettingType, AUTOMATIC, CDDIPMMU_APPL_DATA) PmbSettingPtr /* PRQA S 3432 # JV-01 */ ) { VAR(Std_ReturnType, AUTOMATIC) LddStdReturnType; #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) VAR(uint32, AUTOMATIC) LulBaseAdd; #endif /* initialize the return value as no error occurred */ LddStdReturnType = E_OK; #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) /* Checking whether IPMMU driver is initialized or not */ if (CDDIPMMU_INITIALIZED != CddIpmmu_GblDriverStatus) { /* report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_PMB_GET_SID, CDDIPMMU_E_UNINIT); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } if ((E_OK == LddStdReturnType) && ((uint8)CDD_IPMMU_ENT_MAX_PMB <= Pmb)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_PMB_GET_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } /* Check the Bus Domain Base address */ LulBaseAdd = CddIpmmu_DomGetBaseAddr(BusDomain); if (E_OK == LddStdReturnType) { if ((CDDIPMMU_DEFAULT_ZERO == LulBaseAdd) || (CDD_IPMMU_MM == BusDomain)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_PMB_GET_SID, CDDIPMMU_E_PARAM_VALUE); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } } else { /* No action required */ } if ((E_OK == LddStdReturnType) && (NULL_PTR == PmbSettingPtr)) { /* Report to DET */ (void)Det_ReportError(CDDIPMMU_MODULE_ID, CDDIPMMU_INSTANCE_ID, CDDIPMMU_PMB_GET_SID, CDDIPMMU_E_PARAM_POINTER); /* Set the return value as E_NOT_OK */ LddStdReturnType = E_NOT_OK; } else { /* No action required */ } /* Check the return value */ if (E_OK == LddStdReturnType) #endif /* CDDIPMMU_DEV_ERROR_DETECT == STD_ON */ { /* Execute internal function */ LddStdReturnType = CddIpmmu_HwPmbGet(Pmb, BusDomain, PmbSettingPtr); } #if (CDDIPMMU_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* return value */ return LddStdReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF..STD_ON', 'Name': 'CDDIPMMU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VIP0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..15', 'Name': 'Pmb', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'PmbSettingPtr', 'Value': '&ptr_PmbSettingPtr[0]'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'CDD_IPMMU_REG_BADRR_VIP0'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'CDDIPMMU_INITIALIZED .. CDDIPMMU_UNINITIALIZED', 'Name': 'CddIpmmu_GblDriverStatus', 'Value': 'CDDIPMMU_INITIALIZED']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VIP0'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_009': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnType', 'Value': 'E_OK'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'BusDomain', 'Value': 'CDD_IPMMU_VIP0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Pmb', 'Value': '0'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'PmbSettingPtr', 'Value': '&ptr_PmbSettingPtr[0]'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_INF_042] */ /* TRACE [CDDRFSO_DDD_ACT_047] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_CalcCountCycle /* PRQA S 1532 # JV-01 */ ( uint8 ChannelId, uint64 TimeValue, P2VAR (uint32, AUTOMATIC, CDDRFSO_APPL_DATA) CycleValuePtr, /* PRQA S 3432 # JV-01 */ CddRfso_CycleType CycleType ) { VAR(uint64, AUTOMATIC) LudCNT_DIV; VAR(uint64, AUTOMATIC) LudCountCycle; VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint8, AUTOMATIC) LucChannel; /* initializes value for Variables */ LudCNT_DIV = CDDRFSO_64BIT_ZERO; /* PRQA S 2982 # JV-01 */ LddCddRfsoReturnType = CDDRFSO_E_OK; LucChannel = CddRfso_GaaChannelStatus[ChannelId].ucChannelSelection; /* PRQA S 2844 # JV-01 */ LudCountCycle = CDDRFSO_64BIT_ZERO; /* PRQA S 2982 # JV-01 */ /* Check Pointer as NULL_PTR */ if (NULL_PTR != CycleValuePtr) { /* Get value of Frequency Division */ LudCNT_DIV = (uint64)(CddRfso_ReadReg(LucChannel, CDDRFSO_REG_OFST_CNT_DIV)); /* Calculate Count Cycle from TimeValue and Division */ LudCNT_DIV = ((((LudCNT_DIV * CDDRFSO_INTERVAL_CLOCK) / CDDRFSO_TEN) /* PRQA S 3383 # JV-01 */ + CDDRFSO_FIVE) / CDDRFSO_TEN); /* PRQA S 3383 # JV-01 */ /* Guarantee the division is not zero */ if (CDDRFSO_64BIT_ZERO != LudCNT_DIV) { LudCountCycle = (uint64)((TimeValue * CDDRFSO_ONE_HUNDRED) / LudCNT_DIV); /* PRQA S 3383 # JV-01 */ } else { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } if (CDDRFSO_E_OK == LddCddRfsoReturnType) { /* Check LudCountCycle after calculation */ if (((CDDRFSO_INTERVAL_CYCLE == CycleType) || /* PRQA S 0580, 2995 # JV-01, JV-01 */ (CDDRFSO_TIMEOUT_MAX_CYCLE == CycleType)) && ((CDDRFSO_MAX_CYCLE < LudCountCycle) || (CDDRFSO_64BIT_ZERO == LudCountCycle))) { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else if ((CDDRFSO_TIMEOUT_MIN_CYCLE == CycleType) && /* PRQA S 0580, 2995 # JV-01, JV-01 */ ((CDDRFSO_MAX_CYCLE <= LudCountCycle) || (CDDRFSO_64BIT_ONE == LudCountCycle))) { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* * When it is within the range of the count value * (Set 0x00000000 if count is 4294967296 (2^32)) */ *CycleValuePtr = (uint32)(LudCountCycle & CDDRFSO_BIT_MASK_00_31); /* PRQA S 2985 # JV-01 */ LddCddRfsoReturnType = CDDRFSO_E_OK; } /* (CDDRFSO_MAX_CYCLE < LuqCountCycle) */ } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ else { /* No action required */ } } /* End of if (NULL_PTR != CycleValuePtr) */ else { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '-'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0 .. 0xFFFFFFFFFFFFFFFF', 'Name': 'TimeValue', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'CycleValuePtr', 'Value': 'NULL_PTR'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'CDDRFSO_INTERVAL_CYCLE\\nCDDRFSO_TIMEOUT_MAX_CYCLE\\nCDDRFSO_TIMEOUT_MIN_CYCLE', 'Name': 'CycleType', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelSelection', 'Value': '0'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegOffset', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_CycleValuePtr[0]', 'Value': '-'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_NOT_OK'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_INF_042] */ /* TRACE [CDDRFSO_DDD_ACT_047] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_CalcCountCycle /* PRQA S 1532 # JV-01 */ ( uint8 ChannelId, uint64 TimeValue, P2VAR (uint32, AUTOMATIC, CDDRFSO_APPL_DATA) CycleValuePtr, /* PRQA S 3432 # JV-01 */ CddRfso_CycleType CycleType ) { VAR(uint64, AUTOMATIC) LudCNT_DIV; VAR(uint64, AUTOMATIC) LudCountCycle; VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint8, AUTOMATIC) LucChannel; /* initializes value for Variables */ LudCNT_DIV = CDDRFSO_64BIT_ZERO; /* PRQA S 2982 # JV-01 */ LddCddRfsoReturnType = CDDRFSO_E_OK; LucChannel = CddRfso_GaaChannelStatus[ChannelId].ucChannelSelection; /* PRQA S 2844 # JV-01 */ LudCountCycle = CDDRFSO_64BIT_ZERO; /* PRQA S 2982 # JV-01 */ /* Check Pointer as NULL_PTR */ if (NULL_PTR != CycleValuePtr) { /* Get value of Frequency Division */ LudCNT_DIV = (uint64)(CddRfso_ReadReg(LucChannel, CDDRFSO_REG_OFST_CNT_DIV)); /* Calculate Count Cycle from TimeValue and Division */ LudCNT_DIV = ((((LudCNT_DIV * CDDRFSO_INTERVAL_CLOCK) / CDDRFSO_TEN) /* PRQA S 3383 # JV-01 */ + CDDRFSO_FIVE) / CDDRFSO_TEN); /* PRQA S 3383 # JV-01 */ /* Guarantee the division is not zero */ if (CDDRFSO_64BIT_ZERO != LudCNT_DIV) { LudCountCycle = (uint64)((TimeValue * CDDRFSO_ONE_HUNDRED) / LudCNT_DIV); /* PRQA S 3383 # JV-01 */ } else { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } if (CDDRFSO_E_OK == LddCddRfsoReturnType) { /* Check LudCountCycle after calculation */ if (((CDDRFSO_INTERVAL_CYCLE == CycleType) || /* PRQA S 0580, 2995 # JV-01, JV-01 */ (CDDRFSO_TIMEOUT_MAX_CYCLE == CycleType)) && ((CDDRFSO_MAX_CYCLE < LudCountCycle) || (CDDRFSO_64BIT_ZERO == LudCountCycle))) { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else if ((CDDRFSO_TIMEOUT_MIN_CYCLE == CycleType) && /* PRQA S 0580, 2995 # JV-01, JV-01 */ ((CDDRFSO_MAX_CYCLE <= LudCountCycle) || (CDDRFSO_64BIT_ONE == LudCountCycle))) { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* * When it is within the range of the count value * (Set 0x00000000 if count is 4294967296 (2^32)) */ *CycleValuePtr = (uint32)(LudCountCycle & CDDRFSO_BIT_MASK_00_31); /* PRQA S 2985 # JV-01 */ LddCddRfsoReturnType = CDDRFSO_E_OK; } /* (CDDRFSO_MAX_CYCLE < LuqCountCycle) */ } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ else { /* No action required */ } } /* End of if (NULL_PTR != CycleValuePtr) */ else { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '5'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0 .. 0xFFFFFFFFFFFFFFFF', 'Name': 'TimeValue', 'Value': '1000'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'CycleValuePtr', 'Value': '&map_CycleValuePtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'CDDRFSO_INTERVAL_CYCLE\\nCDDRFSO_TIMEOUT_MAX_CYCLE\\nCDDRFSO_TIMEOUT_MIN_CYCLE', 'Name': 'CycleType', 'Value': 'CDDRFSO_INTERVAL_CYCLE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelSelection', 'Value': '0'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '10']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegOffset', 'Value': 'CDDRFSO_REG_OFST_CNT_DIV'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_CycleValuePtr[0]', 'Value': '12500'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_OK'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_INF_042] */ /* TRACE [CDDRFSO_DDD_ACT_047] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_CalcCountCycle /* PRQA S 1532 # JV-01 */ ( uint8 ChannelId, uint64 TimeValue, P2VAR (uint32, AUTOMATIC, CDDRFSO_APPL_DATA) CycleValuePtr, /* PRQA S 3432 # JV-01 */ CddRfso_CycleType CycleType ) { VAR(uint64, AUTOMATIC) LudCNT_DIV; VAR(uint64, AUTOMATIC) LudCountCycle; VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint8, AUTOMATIC) LucChannel; /* initializes value for Variables */ LudCNT_DIV = CDDRFSO_64BIT_ZERO; /* PRQA S 2982 # JV-01 */ LddCddRfsoReturnType = CDDRFSO_E_OK; LucChannel = CddRfso_GaaChannelStatus[ChannelId].ucChannelSelection; /* PRQA S 2844 # JV-01 */ LudCountCycle = CDDRFSO_64BIT_ZERO; /* PRQA S 2982 # JV-01 */ /* Check Pointer as NULL_PTR */ if (NULL_PTR != CycleValuePtr) { /* Get value of Frequency Division */ LudCNT_DIV = (uint64)(CddRfso_ReadReg(LucChannel, CDDRFSO_REG_OFST_CNT_DIV)); /* Calculate Count Cycle from TimeValue and Division */ LudCNT_DIV = ((((LudCNT_DIV * CDDRFSO_INTERVAL_CLOCK) / CDDRFSO_TEN) /* PRQA S 3383 # JV-01 */ + CDDRFSO_FIVE) / CDDRFSO_TEN); /* PRQA S 3383 # JV-01 */ /* Guarantee the division is not zero */ if (CDDRFSO_64BIT_ZERO != LudCNT_DIV) { LudCountCycle = (uint64)((TimeValue * CDDRFSO_ONE_HUNDRED) / LudCNT_DIV); /* PRQA S 3383 # JV-01 */ } else { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } if (CDDRFSO_E_OK == LddCddRfsoReturnType) { /* Check LudCountCycle after calculation */ if (((CDDRFSO_INTERVAL_CYCLE == CycleType) || /* PRQA S 0580, 2995 # JV-01, JV-01 */ (CDDRFSO_TIMEOUT_MAX_CYCLE == CycleType)) && ((CDDRFSO_MAX_CYCLE < LudCountCycle) || (CDDRFSO_64BIT_ZERO == LudCountCycle))) { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else if ((CDDRFSO_TIMEOUT_MIN_CYCLE == CycleType) && /* PRQA S 0580, 2995 # JV-01, JV-01 */ ((CDDRFSO_MAX_CYCLE <= LudCountCycle) || (CDDRFSO_64BIT_ONE == LudCountCycle))) { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* * When it is within the range of the count value * (Set 0x00000000 if count is 4294967296 (2^32)) */ *CycleValuePtr = (uint32)(LudCountCycle & CDDRFSO_BIT_MASK_00_31); /* PRQA S 2985 # JV-01 */ LddCddRfsoReturnType = CDDRFSO_E_OK; } /* (CDDRFSO_MAX_CYCLE < LuqCountCycle) */ } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ else { /* No action required */ } } /* End of if (NULL_PTR != CycleValuePtr) */ else { LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '10'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0 .. 0xFFFFFFFFFFFFFFFF', 'Name': 'TimeValue', 'Value': '0xFFFFFFFFFFFFFFFF'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'CycleValuePtr', 'Value': '&map_CycleValuePtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'CDDRFSO_INTERVAL_CYCLE\\nCDDRFSO_TIMEOUT_MAX_CYCLE\\nCDDRFSO_TIMEOUT_MIN_CYCLE', 'Name': 'CycleType', 'Value': 'CDDRFSO_INTERVAL_CYCLE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelSelection', 'Value': '0'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '10000']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegOffset', 'Value': 'CDDRFSO_REG_OFST_CNT_DIV'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_CycleValuePtr[0]', 'Value': '-'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_NOT_OK'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_ACT_003] */ /* TRACE [CDDRFSO_DDD_DTF_001] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_ChannelClockSet /* PRQA S 1503 # JV-01 */ ( uint8 ChannelId, uint32 FrequencyDiv ) { VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint8, AUTOMATIC) LucSetChannelStateFlag; /* Initialize the return value as no error occurred */ LddCddRfsoReturnType = CDDRFSO_E_OK; LucSetChannelStateFlag = CDDRFSO_FALSE; #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) /* Checking whether RFSO Complex Driver was initialized or not */ if (CDDRFSO_INITIALIZED != CddRfso_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CHANNEL_CLOCK_SET_SID, CDDRFSO_E_UNINIT); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_NUM_CHANNEL_CONFIGURE <= ChannelId)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CHANNEL_CLOCK_SET_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_32BIT_ZERO == FrequencyDiv)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CHANNEL_CLOCK_SET_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDRFSO_ENTER_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Check status of target RFSO channel */ if (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy) { /* Set the return value as CDDRFSO_BUSY */ LddCddRfsoReturnType = CDDRFSO_BUSY; } else { /* Set channel to busy state */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_TRUE; /* Set channel state to true */ LucSetChannelStateFlag = CDDRFSO_TRUE; } #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDRFSO_EXIT_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* Check if channel is in busy state or not */ if (CDDRFSO_BUSY != LddCddRfsoReturnType) { #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && ((CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blIntervalTimerStarted) || (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blTimeoutTimerStarted))) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CHANNEL_CLOCK_SET_SID, CDDRFSO_E_TIMER_MODE); /* Set return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } /* Check the return value */ if (CDDRFSO_E_OK == LddCddRfsoReturnType) #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { /* * Call internal function to access register at low level * to set clock for target RFSO channel */ LddCddRfsoReturnType = CddRfso_HwChannelClockSet(ChannelId, FrequencyDiv); } #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif if (CDDRFSO_TRUE == LucSetChannelStateFlag) { /* Release channel */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_FALSE; } else { /* No action required */ } } /* (CDDRFSO_BUSY != LddCddRfsoReturnType) */ else { /* No action required */ } /* Return value */ return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'FrequencyDiv', 'Value': '1024'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDRFSO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'CDDRFSO_INITIALIZED..\\nCDDRFSO_UNINITIALIZED', 'Name': 'CddRfso_GblDriverStatus', 'Value': 'CDDRFSO_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': 'CDDRFSO_TRUE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blIntervalTimerStarted', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blTimeoutTimerStarted', 'Value': '-'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ChannelId', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'FrequencyDiv', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': 'CDDRFSO_TRUE'], 'Output_Param_009': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_BUSY'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_ACT_055] */ /* TRACE [CDDRFSO_DDD_DTF_005] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_CtrlIntervalTimerInterrupt /* PRQA S 1503 # JV-01 */ ( uint8 ChannelId, boolean IntervalTimerIrqState ) { VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint8, AUTOMATIC) LucSetChannelStateFlag; /* Initialize the return value as no error occurred */ LddCddRfsoReturnType = CDDRFSO_E_OK; LucSetChannelStateFlag = CDDRFSO_FALSE; #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) /* Checking whether RFSO Complex Driver was initialized or not */ if (CDDRFSO_INITIALIZED != CddRfso_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CTRL_INTERVAL_TIMER_INTERRUPT_SID, CDDRFSO_E_UNINIT); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_NUM_CHANNEL_CONFIGURE <= ChannelId)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CTRL_INTERVAL_TIMER_INTERRUPT_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDRFSO_ENTER_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Check status of target RFSO channel */ if (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy) { /* Set the return value as CDDRFSO_BUSY */ LddCddRfsoReturnType = CDDRFSO_BUSY; } else { /* Set channel to busy state */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_TRUE; /* Set channel state to true */ LucSetChannelStateFlag = CDDRFSO_TRUE; } #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDRFSO_EXIT_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ if (CDDRFSO_BUSY != LddCddRfsoReturnType) { #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blIntervalTimerStarted)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CTRL_INTERVAL_TIMER_INTERRUPT_SID, CDDRFSO_E_TIMER_MODE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (IntervalTimerIrqState == CddRfso_GaaChannelStatus[ChannelId].blIntervalTimerInterruptEnable)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CTRL_INTERVAL_TIMER_INTERRUPT_SID, CDDRFSO_E_PARAM_VALUE); /* Set the Return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { /* * Call Internal function to access Registers at low level * to enable/disable time-out interrupt */ CddRfso_HwCtrlIntervalTimerInterrupt(ChannelId, IntervalTimerIrqState); } #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ if (CDDRFSO_TRUE == LucSetChannelStateFlag) { /* Release channel */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_FALSE; } else { /* No action required */ } } /* End of if (CDDRFSO_BUSY != LddCddRfsoReturnType) */ else { /* No action required */ } /* Return value */ return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '5'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'CDDRFSO_TRUE .. \\nCDDRFSO_FALSE', 'Name': 'IntervalTimerIrqState', 'Value': 'CDDRFSO_TRUE'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDRFSO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'CDDRFSO_INITIALIZED..\\nCDDRFSO_UNINITIALIZED', 'Name': 'CddRfso_GblDriverStatus', 'Value': 'CDDRFSO_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': 'CDDRFSO_FALSE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blIntervalTimerStarted', 'Value': 'CDDRFSO_FALSE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blIntervalTimerInterruptEnable', 'Value': 'CDDRFSO_FALSE']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ChannelId', 'Value': '5'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'IntervalTimerIrqState', 'Value': 'CDDRFSO_TRUE'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': 'CDDRFSO_FALSE'], 'Output_Param_009': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_OK'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_ACT_055] */ /* TRACE [CDDRFSO_DDD_DTF_005] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_CtrlIntervalTimerInterrupt /* PRQA S 1503 # JV-01 */ ( uint8 ChannelId, boolean IntervalTimerIrqState ) { VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint8, AUTOMATIC) LucSetChannelStateFlag; /* Initialize the return value as no error occurred */ LddCddRfsoReturnType = CDDRFSO_E_OK; LucSetChannelStateFlag = CDDRFSO_FALSE; #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) /* Checking whether RFSO Complex Driver was initialized or not */ if (CDDRFSO_INITIALIZED != CddRfso_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CTRL_INTERVAL_TIMER_INTERRUPT_SID, CDDRFSO_E_UNINIT); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_NUM_CHANNEL_CONFIGURE <= ChannelId)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CTRL_INTERVAL_TIMER_INTERRUPT_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDRFSO_ENTER_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Check status of target RFSO channel */ if (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy) { /* Set the return value as CDDRFSO_BUSY */ LddCddRfsoReturnType = CDDRFSO_BUSY; } else { /* Set channel to busy state */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_TRUE; /* Set channel state to true */ LucSetChannelStateFlag = CDDRFSO_TRUE; } #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDRFSO_EXIT_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ if (CDDRFSO_BUSY != LddCddRfsoReturnType) { #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blIntervalTimerStarted)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CTRL_INTERVAL_TIMER_INTERRUPT_SID, CDDRFSO_E_TIMER_MODE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (IntervalTimerIrqState == CddRfso_GaaChannelStatus[ChannelId].blIntervalTimerInterruptEnable)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_CTRL_INTERVAL_TIMER_INTERRUPT_SID, CDDRFSO_E_PARAM_VALUE); /* Set the Return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { /* * Call Internal function to access Registers at low level * to enable/disable time-out interrupt */ CddRfso_HwCtrlIntervalTimerInterrupt(ChannelId, IntervalTimerIrqState); } #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ if (CDDRFSO_TRUE == LucSetChannelStateFlag) { /* Release channel */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_FALSE; } else { /* No action required */ } } /* End of if (CDDRFSO_BUSY != LddCddRfsoReturnType) */ else { /* No action required */ } /* Return value */ return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '10'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'CDDRFSO_TRUE .. \\nCDDRFSO_FALSE', 'Name': 'IntervalTimerIrqState', 'Value': 'CDDRFSO_TRUE'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDRFSO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'CDDRFSO_INITIALIZED..\\nCDDRFSO_UNINITIALIZED', 'Name': 'CddRfso_GblDriverStatus', 'Value': 'CDDRFSO_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': 'CDDRFSO_FALSE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blIntervalTimerStarted', 'Value': 'CDDRFSO_FALSE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blIntervalTimerInterruptEnable', 'Value': 'CDDRFSO_FALSE']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ChannelId', 'Value': '10'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'IntervalTimerIrqState', 'Value': 'CDDRFSO_TRUE'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': 'CDDRFSO_FALSE'], 'Output_Param_009': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_OK'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_ACT_015] */ /* TRACE [CDDRFSO_DDD_DTF_006] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_GetCFEPinStatus /* PRQA S 1503 # JV-01 */ ( uint8 ChannelId, P2VAR(CddRfso_CFEStatusType, AUTOMATIC, CDDRFSO_APPL_DATA) CfePinStatusPtr /* PRQA S 3432 # JV-01 */ ) { VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; /* Initialize the return value as no error occurred */ LddCddRfsoReturnType = CDDRFSO_E_OK; #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) /* Checking whether RFSO Complex Driver was initialized or not */ if (CDDRFSO_INITIALIZED != CddRfso_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_GET_CFE_PIN_STATUS_SID, CDDRFSO_E_UNINIT); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_NUM_CHANNEL_CONFIGURE <= ChannelId)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_GET_CFE_PIN_STATUS_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (NULL_PTR == CfePinStatusPtr)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_GET_CFE_PIN_STATUS_SID, CDDRFSO_E_PARAM_POINTER); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { /* Getting status of FSO_CFE# pin */ LddCddRfsoReturnType = CddRfso_HwGetCFEPinStatus(ChannelId, CfePinStatusPtr); } #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* Return value */ return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '(CDDRFSO_NUM_CHANNEL_CONFIGURE+1)'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'CfePinStatusPtr', 'Value': '-'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDRFSO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'CDDRFSO_INITIALIZED..\\nCDDRFSO_UNINITIALIZED', 'Name': 'CddRfso_GblDriverStatus', 'Value': 'CDDRFSO_INITIALIZED'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDRFSO_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDRFSO_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CDDRFSO_GET_CFE_PIN_STATUS_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDRFSO_E_PARAM_VALUE'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'ChannelId', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'CfePinStatusPtr', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_NOT_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_INF_028] */ /* TRACE [CDDRFSO_DDD_ACT_033] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_HwStartIntervalTimer /* PRQA S 1532 # JV-01 */ ( uint8 ChannelId ) { VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint8, AUTOMATIC) LucChannel; /* Variable to store address of register */ VAR(uint32, AUTOMATIC) LulFSO_CMD; LddCddRfsoReturnType = CDDRFSO_E_OK; LulFSO_CMD = CDDRFSO_32BIT_ZERO; /* Get Channel selection */ LucChannel = CddRfso_GaaChannelStatus[ChannelId].ucChannelSelection; /* PRQA S 2844 # JV-01 */ /* Start Interval timer and clear Interval Interrupt flag */ LulFSO_CMD |= (CDDRFSO_FSO_CMD_CNTS_0 | CDDRFSO_FSO_CMD_ITC); #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDRFSO_ENTER_CRITICAL_SECTION(CDDRFSO_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Write to FSO_CMD register */ CddRfso_WriteReg(LucChannel, CDDRFSO_REG_OFST_FSO_CMD, (LulFSO_CMD | CDDRFSO_REG_FSO_KEYCODE)); /* Set status of Interval Timer of RFSO channel to operating */ CddRfso_GaaChannelStatus[ChannelId].blIntervalTimerStarted = CDDRFSO_TRUE; /* PRQA S 2844 # JV-01 */ #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDRFSO_EXIT_CRITICAL_SECTION(CDDRFSO_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Set status of Time-out Timer of RFSO channel to non-operating */ CddRfso_GaaChannelStatus[ChannelId].blTimeoutTimerStarted = CDDRFSO_FALSE; /* PRQA S 2844 # JV-01 */ return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '10'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelSelection', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '0'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegOffset', 'Value': 'CDDRFSO_REG_OFST_FSO_CMD\\n'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Value', 'Value': '(CDDRFSO_FSO_CMD_CNTS_0 | CDDRFSO_FSO_CMD_ITC | CDDRFSO_REG_FSO_KEYCODE)'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blIntervalTimerStarted', 'Value': 'CDDRFSO_TRUE'], 'Output_Param_005': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blTimeoutTimerStarted', 'Value': 'CDDRFSO_FALSE'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_ACT_010] */ /* TRACE [CDDRFSO_DDD_DTF_007] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_TimeoutCycleConfigure /* PRQA S 1503 # JV-01 */ ( uint8 ChannelId, uint64 TimeoutMaxCycle, uint64 TimeoutMinCycle ) { VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint32, AUTOMATIC) LulMaximunCycle; VAR(uint32, AUTOMATIC) LulMinimumCycle; VAR(uint8, AUTOMATIC) LucSetChannelStateFlag; /* Initialize the return value as no error occurred */ LddCddRfsoReturnType = CDDRFSO_E_OK; LulMaximunCycle = CDDRFSO_32BIT_ZERO; /* PRQA S 2982 # JV-01 */ LulMinimumCycle = CDDRFSO_32BIT_ZERO; /* PRQA S 2982 # JV-01 */ LucSetChannelStateFlag = CDDRFSO_FALSE; #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) /* Checking whether RFSO Complex Driver was initialized or not */ if (CDDRFSO_INITIALIZED != CddRfso_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_UNINIT); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_NUM_CHANNEL_CONFIGURE <= ChannelId)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && /* PRQA S 0580, 2995 # JV-01, JV-01 */ ((CDDRFSO_MAX_CYCLE < TimeoutMaxCycle) || (CDDRFSO_MAX_CYCLE <= TimeoutMinCycle))) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value e CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No Action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && /* PRQA S 2996 2992 # JV-01, JV-01 */ ((CDDRFSO_64BIT_ZERO == TimeoutMaxCycle) || (CDDRFSO_64BIT_ONE == TimeoutMinCycle))) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, /* PRQA S 2880 # JV-01 */ CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && /* PRQA S 2996, 2992 # JV-01, JV-01 */ (TimeoutMaxCycle <= TimeoutMinCycle)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, /* PRQA S 2880 # JV-01 */ CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) /* PRQA S 2996, 2992 # JV-01, JV-01 */ #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDRFSO_ENTER_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); /* PRQA S 2880 # JV-01 */ #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Check status of target RFSO channel */ if (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy) { /* Set the return value as CDDRFSO_BUSY */ LddCddRfsoReturnType = CDDRFSO_BUSY; } else { /* Set channel to busy state */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_TRUE; /* Set channel state to true */ LucSetChannelStateFlag = CDDRFSO_TRUE; } #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDRFSO_EXIT_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* Check if channel is in busy state or not */ /* PRQA S 2995, 2991 # JV-01, JV-01 */ if (CDDRFSO_BUSY != LddCddRfsoReturnType) { #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && ((CDDRFSO_TRUE == /* PRQA S 2996, 2992 # JV-01, JV-01 */ CddRfso_GaaChannelStatus[ChannelId].blTimeoutTimerStarted) && (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blIntervalTimerStarted))) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, /* PRQA S 2880 # JV-01 */ CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_TIMER_MODE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) /* PRQA S 2992, 2996 # JV-01, JV-01 */ #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { /* * When it is within the range of the count value * (Set 0x00000000 if count is 4294967296 (2^32)) */ /* Check value for maximum Cycle of Time-out timer */ LulMaximunCycle = (uint32)(CDDRFSO_BIT_MASK_00_31 & TimeoutMaxCycle); /* PRQA S 2880 # JV-01 */ LulMinimumCycle = (uint32)(TimeoutMinCycle); /* * Call Internal function to set Time-out timer * maximum and minimum Cycle */ LddCddRfsoReturnType = CddRfso_HwTimeoutConfigure(ChannelId, LulMaximunCycle, LulMinimumCycle); } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif if (CDDRFSO_TRUE == LucSetChannelStateFlag) /* PRQA S 2992, 2996 # JV-01, JV-01 */ { /* Release channel */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_FALSE; /* PRQA S 2880 # JV-01 */ } else { /* No action required */ } } /* End of if (CDDRFSO_BUSY != LddCddRfsoReturnType) */ else { /* No action required */ } /* Return value */ return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0 .. 18446744073709551615', 'Name': 'TimeoutMaxCycle', 'Value': 'CDDRFSO_64BIT_ZERO'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0 .. 18446744073709551615', 'Name': 'TimeoutMinCycle', 'Value': 'CDDRFSO_64BIT_ONE'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDRFSO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'CDDRFSO_INITIALIZED..\\nCDDRFSO_UNINITIALIZED', 'Name': 'CddRfso_GblDriverStatus', 'Value': 'CDDRFSO_INITIALIZED'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blTimeoutTimerStarted', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blIntervalTimerStarted', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDRFSO_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDRFSO_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDRFSO_E_PARAM_VALUE'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ChannelId', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeoutMaxCycle', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeoutMinCycle', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': '-'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_NOT_OK'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDDRFSO_START_SEC_CODE_SLOW #include \"CddRfso_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* TRACE [CDDRFSO_DDD_ACT_010] */ /* TRACE [CDDRFSO_DDD_DTF_007] */ FUNC(CddRfso_ReturnType, CDDRFSO_CODE_SLOW) CddRfso_TimeoutCycleConfigure /* PRQA S 1503 # JV-01 */ ( uint8 ChannelId, uint64 TimeoutMaxCycle, uint64 TimeoutMinCycle ) { VAR(CddRfso_ReturnType, AUTOMATIC) LddCddRfsoReturnType; VAR(uint32, AUTOMATIC) LulMaximunCycle; VAR(uint32, AUTOMATIC) LulMinimumCycle; VAR(uint8, AUTOMATIC) LucSetChannelStateFlag; /* Initialize the return value as no error occurred */ LddCddRfsoReturnType = CDDRFSO_E_OK; LulMaximunCycle = CDDRFSO_32BIT_ZERO; /* PRQA S 2982 # JV-01 */ LulMinimumCycle = CDDRFSO_32BIT_ZERO; /* PRQA S 2982 # JV-01 */ LucSetChannelStateFlag = CDDRFSO_FALSE; #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) /* Checking whether RFSO Complex Driver was initialized or not */ if (CDDRFSO_INITIALIZED != CddRfso_GblDriverStatus) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_UNINIT); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && (CDDRFSO_NUM_CHANNEL_CONFIGURE <= ChannelId)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && /* PRQA S 0580, 2995 # JV-01, JV-01 */ ((CDDRFSO_MAX_CYCLE < TimeoutMaxCycle) || (CDDRFSO_MAX_CYCLE <= TimeoutMinCycle))) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value e CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No Action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && /* PRQA S 2996 2992 # JV-01, JV-01 */ ((CDDRFSO_64BIT_ZERO == TimeoutMaxCycle) || (CDDRFSO_64BIT_ONE == TimeoutMinCycle))) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, /* PRQA S 2880 # JV-01 */ CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && /* PRQA S 2996, 2992 # JV-01, JV-01 */ (TimeoutMaxCycle <= TimeoutMinCycle)) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, /* PRQA S 2880 # JV-01 */ CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_PARAM_VALUE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) /* PRQA S 2996, 2992 # JV-01, JV-01 */ #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter critical section */ CDDRFSO_ENTER_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); /* PRQA S 2880 # JV-01 */ #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Check status of target RFSO channel */ if (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy) { /* Set the return value as CDDRFSO_BUSY */ LddCddRfsoReturnType = CDDRFSO_BUSY; } else { /* Set channel to busy state */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_TRUE; /* Set channel state to true */ LucSetChannelStateFlag = CDDRFSO_TRUE; } #if (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit critical section */ CDDRFSO_EXIT_CRITICAL_SECTION(CDDRFSO_RAM_DATA_PROTECTION); #endif /* (CDDRFSO_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif /* Check if channel is in busy state or not */ /* PRQA S 2995, 2991 # JV-01, JV-01 */ if (CDDRFSO_BUSY != LddCddRfsoReturnType) { #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) if ((CDDRFSO_E_OK == LddCddRfsoReturnType) && ((CDDRFSO_TRUE == /* PRQA S 2996, 2992 # JV-01, JV-01 */ CddRfso_GaaChannelStatus[ChannelId].blTimeoutTimerStarted) && (CDDRFSO_TRUE == CddRfso_GaaChannelStatus[ChannelId].blIntervalTimerStarted))) { /* Report to DET */ (void)Det_ReportError(CDDRFSO_MODULE_ID, CDDRFSO_INSTANCE_ID, /* PRQA S 2880 # JV-01 */ CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID, CDDRFSO_E_TIMER_MODE); /* Set the return value as CDDRFSO_E_NOT_OK */ LddCddRfsoReturnType = CDDRFSO_E_NOT_OK; } else { /* No action required */ } if (CDDRFSO_E_OK == LddCddRfsoReturnType) /* PRQA S 2992, 2996 # JV-01, JV-01 */ #endif /* CDDRFSO_DEV_ERROR_DETECT == STD_ON */ { /* * When it is within the range of the count value * (Set 0x00000000 if count is 4294967296 (2^32)) */ /* Check value for maximum Cycle of Time-out timer */ LulMaximunCycle = (uint32)(CDDRFSO_BIT_MASK_00_31 & TimeoutMaxCycle); /* PRQA S 2880 # JV-01 */ LulMinimumCycle = (uint32)(TimeoutMinCycle); /* * Call Internal function to set Time-out timer * maximum and minimum Cycle */ LddCddRfsoReturnType = CddRfso_HwTimeoutConfigure(ChannelId, LulMaximunCycle, LulMinimumCycle); } /* End of if (CDDRFSO_E_OK == LddCddRfsoReturnType) */ #if (CDDRFSO_DEV_ERROR_DETECT == STD_ON) else { /* No action required */ } #endif if (CDDRFSO_TRUE == LucSetChannelStateFlag) /* PRQA S 2992, 2996 # JV-01, JV-01 */ { /* Release channel */ CddRfso_GaaChannelStatus[ChannelId].blChannelIsBusy = CDDRFSO_FALSE; /* PRQA S 2880 # JV-01 */ } else { /* No action required */ } } /* End of if (CDDRFSO_BUSY != LddCddRfsoReturnType) */ else { /* No action required */ } /* Return value */ return LddCddRfsoReturnType; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0 .. 18446744073709551615', 'Name': 'TimeoutMaxCycle', 'Value': 'CDDRFSO_64BIT_ZERO'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0 .. 18446744073709551615', 'Name': 'TimeoutMinCycle', 'Value': '1024'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON..STD_OFF', 'Name': 'CDDRFSO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'CDDRFSO_INITIALIZED..\\nCDDRFSO_UNINITIALIZED', 'Name': 'CddRfso_GblDriverStatus', 'Value': 'CDDRFSO_INITIALIZED'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blTimeoutTimerStarted', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blIntervalTimerStarted', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDDRFSO_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDDRFSO_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CDDRFSO_TIMEOUT_CYCLE_CONFIGURE_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDDRFSO_E_PARAM_VALUE'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ChannelId', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeoutMaxCycle', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeoutMinCycle', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelIsBusy', 'Value': '-'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddCddRfsoReturnType', 'Value': 'CDDRFSO_E_NOT_OK'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if (CDD_THS_THERMAL_INTERRUPTION == STD_ON) #define CDD_THS_START_SEC_CODE_SLOW #include \"CddThs_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, CDDTHS_CODE_SLOW) CddThs_ClearTemperatureErrorStatus( /* PRQA S 1503 # JV-01 */ CddThs_ThermalChannelId ChannelId) { /* Declare local variable */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpRegisterPointer; /* PRQA S 3432 # JV-01 */ #if (CDD_THS_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if driver is uninitialized */ if (CDD_THS_UNINITIALIZED == CddThs_GucDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, CDD_THS_CLEARERRORSTATUS_SID, CDD_THS_E_UNINIT); } /* Report to DET, if Channel Identifier is invalid*/ else if (CDD_THS_MAX_CHANNEL_ID <= ChannelId) { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, CDD_THS_CLEARERRORSTATUS_SID, CDD_THS_E_INVALID_CHANNEL); } else if (NULL_PTR == CddThs_GpConfigPtr) { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, CDD_THS_CLEARERRORSTATUS_SID, CDD_THS_E_PARAM_POINTER); } else if (NULL_PTR == CddThs_GpConfigPtr->pThermalInterruptionConfig) { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, CDD_THS_CLEARERRORSTATUS_SID, CDD_THS_E_PARAM_POINTER); } else if (STD_OFF == (CddThs_GpConfigPtr->pThermalInterruptionConfig + /* PRQA S 0488 # JV-01 */ ChannelId)->biChannelStatus) { /* Channel is disable at initialization, Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, CDD_THS_CLEARERRORSTATUS_SID, CDD_THS_E_DISABLED_CHANNEL); } else #endif /* CDD_THS_DEV_ERROR_DETECT == STD_ON */ { LpRegisterPointer = ((P2VAR(volatile uint32, AUTOMATIC, REGSPACE)) /* PRQA S 3432, 0303 # JV-01, JV-01 */ CDD_THS_IRQSTR_ADDRESS); *(LpRegisterPointer) = CDD_THS_INT_STS_CLEARED_MASK(ChannelId); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDD_THS_DEV_ERROR_DETECT', 'Value': ''], 'Input_Param_001': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': ''], 'Input_Param_002': ['Type': 'Variable', 'Range': 'CDD_THS_INITIALIZED\\nCDD_THS_UNINITIALIZED', 'Name': 'CddThs_GucDriverStatus', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': 'NULL_PTR .. Address', 'Name': 'CddThs_GpConfigPtr', 'Value': ''], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL_PTR .. Address', 'Name': 'pThermalInterruptionConfig', 'Value': ''], 'Input_Param_005': ['Type': 'Array', 'Range': 'STD_ON.. STD_OFF', 'Name': 'biChannelStatus', 'Value': '']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': ''], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': ''], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': ''], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': ''], 'Output_Param_004': ['Type': 'Variable', 'Range': 'CDD_THS_INITIALIZED\\nCDD_THS_UNINITIALIZED', 'Name': 'CddThs_GucDriverStatus', 'Value': ''], 'Output_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR .. Address', 'Name': 'CddThs_GpConfigPtr', 'Value': ''], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #define CDD_THS_START_SEC_CODE_SLOW #include \"CddThs_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDTHS_CODE_SLOW) CddThs_ConfigureThermalInterruption /* PRQA S 1503 # JV-01 */ (CddThs_ThermalChannelId ChannelId, CddThs_InterruptionType InterruptionType, sint16 InterruptionValue) { /* Initialize return value */ Std_ReturnType LddStdReturnValue; LddStdReturnValue = E_NOT_OK; #if (CDD_THS_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if driver is uninitialized */ if (CDD_THS_UNINITIALIZED == CddThs_GucDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_CONFIGURETHERMALINTERRUPTION_SID, CDD_THS_E_UNINIT); } /* Report to DET, if Channel Identifier is invalid*/ else if (CDD_THS_MAX_CHANNEL_ID <= ChannelId) { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_CONFIGURETHERMALINTERRUPTION_SID, CDD_THS_E_INVALID_CHANNEL); } else if (NULL_PTR == CddThs_GpConfigPtr) { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_CONFIGURETHERMALINTERRUPTION_SID, CDD_THS_E_PARAM_POINTER); } else if (NULL_PTR == CddThs_GpConfigPtr->pThermalInterruptionConfig) { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_CONFIGURETHERMALINTERRUPTION_SID, CDD_THS_E_PARAM_POINTER); } else if (CDD_THS_UPPER_BOUND < InterruptionType) { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_CONFIGURETHERMALINTERRUPTION_SID, CDD_THS_E_INVALID_PARAM); } else if ((CDD_THS_THERMAL_INT_MIN > InterruptionValue) \\ || (CDD_THS_THERMAL_INT_MAX < InterruptionValue)) { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_CONFIGURETHERMALINTERRUPTION_SID, CDD_THS_E_INVALID_VALUE); } else #endif /*CDD_THS_DEV_ERROR_DETECT == STD_ON*/ { /* check channel status */ if (STD_ON == (CddThs_GpConfigPtr->pThermalInterruptionConfig + /* PRQA S 0488 # JV-01 */ ChannelId)->biChannelStatus) { #if (CDD_THS_CRITICAL_SECTION_PROTECTION == STD_ON) CDD_THS_ENTER_CRITICAL_SECTION(CDDTHS_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDD_THS_CRITICAL_SECTION_PROTECTION == STD_ON) */ /*Set config value to register*/ LddStdReturnValue = CddThs_SetThermalInterruptConfig(ChannelId, \\ InterruptionType, InterruptionValue); #if (CDD_THS_CRITICAL_SECTION_PROTECTION == STD_ON) CDD_THS_EXIT_CRITICAL_SECTION(CDDTHS_INTERRUPT_CONTROL_PROTECTION); #endif /* (CDD_THS_CRITICAL_SECTION_PROTECTION == STD_ON) */ } else { #if (CDD_THS_DEV_ERROR_DETECT == STD_ON) /* channel is disable at initialization */ /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_CONFIGURETHERMALINTERRUPTION_SID, CDD_THS_E_DISABLED_CHANNEL); #endif /*CDD_THS_DEV_ERROR_DETECT == STD_ON*/ } } return (LddStdReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDD_THS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDD_THS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'ChannelId', 'Value': 'CDD_THS_THERMAL_CH1'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0 .. 255', 'Name': 'InterruptionType', 'Value': 'CDD_THS_LOWER_BOUND'], 'Input_Param_004': ['Type': 'Argument', 'Range': '-32768 .. 32767', 'Name': 'InterruptionValue', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'CDD_THS_INITIALIZED\\nCDD_THS_UNINITIALIZED', 'Name': 'CddThs_GucDriverStatus', 'Value': 'CDD_THS_INITIALIZED'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'NULL_PTR .. Address', 'Name': 'CddThs_GpConfigPtr', 'Value': '&ptr_CddThs_GpConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'NULL_PTR .. Address', 'Name': 'pThermalInterruptionConfig', 'Value': '&ptr_pThermalInterruptionConfig[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'biChannelStatus', 'Value': '[1] = STD_OFF'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'returnValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'CDD_THS_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'CDD_THS_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'CDD_THS_CONFIGURETHERMALINTERRUPTION_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'CDD_THS_E_DISABLED_CHANNEL'], 'Output_Param_004': ['Type': 'Variable', 'Range': 'CDD_THS_INITIALIZED\\nCDD_THS_UNINITIALIZED', 'Name': 'CddThs_GucDriverStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': 'NULL.. Address', 'Name': 'CddThs_GpConfigPtr', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ChannelId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'InterruptionType', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'InterruptionValue', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if (CDD_THS_VOLTAGE_INFO == STD_ON) #define CDD_THS_START_SEC_CODE_SLOW #include \"CddThs_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, CDDTHS_CODE_SLOW) CddThs_GetCurrentVoltage /* PRQA S 1503 # JV-01 */ (P2VAR(uint16, AUTOMATIC, CDDTHS_APPL_DATA) CurrentVoltage) /* PRQA S 3432 # JV-01 */ { /* Declare local variables */ Std_ReturnType LddStdReturnValue; uint16 LusCurrentVoltage; LddStdReturnValue = E_OK; #if (CDD_THS_DEV_ERROR_DETECT == STD_ON) if (NULL_PTR == CurrentVoltage) { /* Report to DET */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_GETCURRENTVOLTAGE_SID, CDD_THS_E_PARAM_POINTER); LddStdReturnValue = E_NOT_OK; } else #endif { #if (CDD_THS_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if driver is uninitialized */ if (CDD_THS_UNINITIALIZED == CddThs_GucDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_GETCURRENTVOLTAGE_SID, CDD_THS_E_UNINIT); LddStdReturnValue = E_NOT_OK; } else #endif { #if (CDD_THS_CRITICAL_SECTION_PROTECTION == STD_ON) CDD_THS_ENTER_CRITICAL_SECTION(CDDTHS_RAM_DATA_PROTECTION); #endif /* (CDD_THS_CRITICAL_SECTION_PROTECTION == STD_ON) */ if (CDD_THS_IDLE != CddThs_GddOperatingState) /* PRQA S 3416 # JV-01 */ { /* Convert to temperature value, Celcius degree unit */ LusCurrentVoltage = CddThs_GetHWCurrentVoltage(); if (CDD_THS_UINT16_ZERO == LusCurrentVoltage) { /* Return E_NOT_OK in case of division by zero */ LddStdReturnValue = E_NOT_OK; } else { /* Return current voltage */ (*CurrentVoltage) = LusCurrentVoltage; } } else { #if (CDD_THS_DEV_ERROR_DETECT == STD_ON) /* Raise Det error */ (void) Det_ReportError(CDD_THS_MODULE_ID, CDD_THS_INSTANCE_ID, \\ CDD_THS_GETCURRENTVOLTAGE_SID, CDD_THS_E_STATE_NOT_ACTIVE); #endif LddStdReturnValue = E_NOT_OK; } #if (CDD_THS_CRITICAL_SECTION_PROTECTION == STD_ON) CDD_THS_EXIT_CRITICAL_SECTION(CDDTHS_RAM_DATA_PROTECTION); #endif /* (CDD_THS_CRITICAL_SECTION_PROTECTION == STD_ON) */ } } return (LddStdReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDD_THS_DEV_ERROR_DETECT', 'Value': ''], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'CDD_THS_CRITICAL_SECTION_PROTECTION', 'Value': ''], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR .. Address', 'Name': 'CurrentVoltage', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': '0 .. 65535', 'Name': 'ptr_CurrentVoltage[0]', 'Value': ''], 'Input_Param_004': ['Type': 'Variable', 'Range': 'CDD_THS_INITIALIZED\\nCDD_THS_UNINITIALIZED', 'Name': 'CddThs_GucDriverStatus', 'Value': ''], 'Input_Param_005': ['Type': 'Variable', 'Range': 'CDD_THS_IDLE\\nCDD_THS_NORMAL', 'Name': 'CddThs_GddOperatingState', 'Value': ''], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '0 .. 65535', 'Name': 'return', 'Value': '']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': ''], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': ''], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': ''], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': ''], 'Output_Param_004': ['Type': 'Variable', 'Range': 'CDD_THS_INITIALIZED\\nCDD_THS_UNINITIALIZED', 'Name': 'CddThs_GucDriverStatus', 'Value': ''], 'Output_Param_005': ['Type': 'Variable', 'Range': 'CDD_THS_IDLE\\nCDD_THS_NORMAL', 'Name': 'CddThs_GddOperatingState', 'Value': ''], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': ''], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': ''], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': ''], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': ''], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': ''], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': ''], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': ''], 'Output_Param_013': ['Type': 'Variable', 'Range': '0 .. 65535', 'Name': 'ptr_CurrentVoltage[0]', 'Value': ''], 'Output_Param_014': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddStdReturnValue', 'Value': ''], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if ((CDD_THS_TEMPERATURE_INFO == STD_ON) || (CDD_THS_VOLTAGE_INFO == STD_ON)) #define CDD_THS_START_SEC_CODE_SLOW #include \"CddThs_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(sint16, CDDTHS_CODE_SLOW) CddThs_GetHWCurrentTemperature(void) /* PRQA S 1532 # JV-01 */ { /* Declare local variables */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpRegisterPointer; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint32 LulTempValue; uint32 LulPtat1Value; uint32 LulPtat2Value; uint32 LulPtat3Value; uint32 LulThcode1Value; uint32 LulThcode2Value; uint32 LulThcode3Value; sint16 LssCurrentTemperature; /* Assign THSSR register address */ LpRegisterPointer = \\ ((P2VAR(volatile uint32, AUTOMATIC, REGSPACE)) CDD_THS_TEMP_ADDRESS); /* PRQA S 3432, 0303 # JV-01, JV-01 */ /* Read THSSR register TEMP_CODE[11:0] */ LulTempValue = (uint32)((*LpRegisterPointer) & CDD_THS_TEMP_CODE_MASK); /* Get value of adjusting parameter from THCODE1 to 3 and PTAT1 to 3 registers */ LulPtat1Value = CDD_THS_PTAT1 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulPtat2Value = CDD_THS_PTAT2 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulPtat3Value = CDD_THS_PTAT3 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulThcode1Value = CDD_THS_THCODE1 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulThcode2Value = CDD_THS_THCODE2 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulThcode3Value = CDD_THS_THCODE3 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ if(CDD_THS_THSCP_COR_PARA_VLD_MASK != (CDD_THS_THSCP & /* PRQA S 0303 # JV-01 */ CDD_THS_THSCP_COR_PARA_VLD_MASK)) { /* Return error because cannot calculate temperature when COR_PARA_VLD != 11 */ LssCurrentTemperature = CDD_THS_INVALID_TEMPERATURE; } else { /* Check condition to avoid dividing by zero */ if (LulPtat3Value != LulPtat1Value) { if ((LulTempValue < LulThcode2Value) && (LulThcode3Value != LulThcode2Value)) { LssCurrentTemperature = (sint16)(((sint32)(CDD_THS_ONE_SIX_SEVEN * ((sint32)LulPtat3Value - (sint32)LulPtat2Value) * ((sint32)LulThcode3Value - (sint32)LulTempValue))) / ((sint32)(((sint32)LulPtat3Value - (sint32)LulPtat1Value) /* PRQA S 2834 # JV-01 */ * ((sint32)LulThcode3Value - (sint32)LulThcode2Value)))) - (sint16)CDD_THS_FORTYONE; } else if ((LulTempValue >= LulThcode2Value) && (LulThcode1Value != LulThcode2Value)) { LssCurrentTemperature = (sint16)(((sint32)(CDD_THS_ONE_SIX_SEVEN * ((sint32)LulPtat1Value - (sint32)LulPtat2Value) * ((sint32)LulThcode1Value - (sint32)LulTempValue))) / ((sint32)(((sint32)LulPtat1Value - (sint32)LulPtat3Value) /* PRQA S 2834 # JV-01 */ * ((sint32)LulThcode2Value - (sint32)LulThcode1Value)))) + (sint16)CDD_THS_ONE_TWO_SIX; } else { /* Return error because of division by zero */ LssCurrentTemperature = CDD_THS_INVALID_TEMPERATURE; } } else { /* Return error because of division by zero */ LssCurrentTemperature = CDD_THS_INVALID_TEMPERATURE; } } return (LssCurrentTemperature); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_TEMP', 'Value': '0x00000000'], 'Input_Param_001': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_THSCP', 'Value': '0x00000000'], 'Input_Param_002': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_PTAT1', 'Value': '-'], 'Input_Param_003': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_PTAT2', 'Value': '-'], 'Input_Param_004': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_PTAT3', 'Value': '-'], 'Input_Param_005': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_THCODE1', 'Value': '-'], 'Input_Param_006': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_THCODE2', 'Value': '-'], 'Input_Param_007': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_THCODE3', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LssCurrentTemperature', 'Value': 'CDD_THS_INVALID_TEMPERATURE'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if ((CDD_THS_TEMPERATURE_INFO == STD_ON) || (CDD_THS_VOLTAGE_INFO == STD_ON)) #define CDD_THS_START_SEC_CODE_SLOW #include \"CddThs_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(sint16, CDDTHS_CODE_SLOW) CddThs_GetHWCurrentTemperature(void) /* PRQA S 1532 # JV-01 */ { /* Declare local variables */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpRegisterPointer; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint32 LulTempValue; uint32 LulPtat1Value; uint32 LulPtat2Value; uint32 LulPtat3Value; uint32 LulThcode1Value; uint32 LulThcode2Value; uint32 LulThcode3Value; sint16 LssCurrentTemperature; /* Assign THSSR register address */ LpRegisterPointer = \\ ((P2VAR(volatile uint32, AUTOMATIC, REGSPACE)) CDD_THS_TEMP_ADDRESS); /* PRQA S 3432, 0303 # JV-01, JV-01 */ /* Read THSSR register TEMP_CODE[11:0] */ LulTempValue = (uint32)((*LpRegisterPointer) & CDD_THS_TEMP_CODE_MASK); /* Get value of adjusting parameter from THCODE1 to 3 and PTAT1 to 3 registers */ LulPtat1Value = CDD_THS_PTAT1 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulPtat2Value = CDD_THS_PTAT2 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulPtat3Value = CDD_THS_PTAT3 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulThcode1Value = CDD_THS_THCODE1 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulThcode2Value = CDD_THS_THCODE2 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ LulThcode3Value = CDD_THS_THCODE3 & CDD_THS_FIXED_PARAMETER_BITS_MASK; /* PRQA S 0303 # JV-01 */ if(CDD_THS_THSCP_COR_PARA_VLD_MASK != (CDD_THS_THSCP & /* PRQA S 0303 # JV-01 */ CDD_THS_THSCP_COR_PARA_VLD_MASK)) { /* Return error because cannot calculate temperature when COR_PARA_VLD != 11 */ LssCurrentTemperature = CDD_THS_INVALID_TEMPERATURE; } else { /* Check condition to avoid dividing by zero */ if (LulPtat3Value != LulPtat1Value) { if ((LulTempValue < LulThcode2Value) && (LulThcode3Value != LulThcode2Value)) { LssCurrentTemperature = (sint16)(((sint32)(CDD_THS_ONE_SIX_SEVEN * ((sint32)LulPtat3Value - (sint32)LulPtat2Value) * ((sint32)LulThcode3Value - (sint32)LulTempValue))) / ((sint32)(((sint32)LulPtat3Value - (sint32)LulPtat1Value) /* PRQA S 2834 # JV-01 */ * ((sint32)LulThcode3Value - (sint32)LulThcode2Value)))) - (sint16)CDD_THS_FORTYONE; } else if ((LulTempValue >= LulThcode2Value) && (LulThcode1Value != LulThcode2Value)) { LssCurrentTemperature = (sint16)(((sint32)(CDD_THS_ONE_SIX_SEVEN * ((sint32)LulPtat1Value - (sint32)LulPtat2Value) * ((sint32)LulThcode1Value - (sint32)LulTempValue))) / ((sint32)(((sint32)LulPtat1Value - (sint32)LulPtat3Value) /* PRQA S 2834 # JV-01 */ * ((sint32)LulThcode2Value - (sint32)LulThcode1Value)))) + (sint16)CDD_THS_ONE_TWO_SIX; } else { /* Return error because of division by zero */ LssCurrentTemperature = CDD_THS_INVALID_TEMPERATURE; } } else { /* Return error because of division by zero */ LssCurrentTemperature = CDD_THS_INVALID_TEMPERATURE; } } return (LssCurrentTemperature); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_TEMP', 'Value': '100'], 'Input_Param_001': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_THSCP', 'Value': 'CDD_THS_THSCP_COR_PARA_VLD_MASK'], 'Input_Param_002': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_PTAT1', 'Value': '2500'], 'Input_Param_003': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_PTAT2', 'Value': '1500'], 'Input_Param_004': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_PTAT3', 'Value': '400'], 'Input_Param_005': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_THCODE1', 'Value': '3500'], 'Input_Param_006': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_THCODE2', 'Value': '3000'], 'Input_Param_007': ['Type': 'Register', 'Range': '0x00000000 .. 0xFFFFFFFF', 'Name': 'map_CDD_THS_THCODE3', 'Value': '3000']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LssCurrentTemperature', 'Value': 'CDD_THS_INVALID_TEMPERATURE'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (DIO_FLIP_CHANNEL_API == STD_ON) #define DIO_START_SEC_PRIVATE_CODE #include \"Dio_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* Implementation of the Dio_PFCFlipChannel function */ FUNC(Dio_PortLevelType, DIO_PRIVATE_CODE) Dio_PFCFlipChannel( /* PRQA S 1532 # JV-01 */ P2CONST(Dio_PortGroupType, AUTOMATIC, DIO_CONFIG_DATA) LpPortGroup, Dio_PortMaskType LddMask) /* PRQA S 3432 # JV-01 */ { /* * Declare local variable to save the port mode * (General input/output or interrupt) level */ uint32 LulGpioOrInterruptModeLevel; /* Declare local variable to save the port mode level */ uint32 LulPortModeLevel; /* Declare local variable to save the choosing output register*/ uint32 LulPortChoosingOutput; /* Declare local variable to save the return port level */ Dio_PortLevelType LddPortLevel; /* Declare local variable to save the value of OUTDTH register */ uint32 LddOUTDTHLevel; /* Declare local variable to save the value of OUTDTL register */ uint32 LddOUTDTLLevel; #if (DIO_EXCLUSIVE_CONTROL == STD_ON) VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; #endif /* Define local pointer to store port register offsets */ P2CONST(volatile Dio_PFCHwRegOffsetType, AUTOMATIC, DIO_CONFIG_DATA) LpHwRegOffset; /* PRQA S 3432 # JV-01 */ LpHwRegOffset = &Dio_GstPFCRegOffset; /* Initialize value for LddPortLevel */ LddPortLevel = STD_LOW; #if (DIO_EXCLUSIVE_CONTROL == STD_ON) LddReturnValue = Dio_ExclusiveControl(DIO_GET_EXCLUSIVE); if (E_OK == LddReturnValue) { #endif /* #if (STD_ON == DIO_EXCLUSIVE_CONTROL) */ /* Enter critical section to protect port registers */ #if (DIO_CRITICAL_SECTION_PROTECTION == STD_ON) DIO_ENTER_CRITICAL_SECTION(DIO_INTERRUPT_CONTROL_PROTECTION); #endif /* * Get port mode level: * 0: GPIO mode * 1: Interrupt mode */ LulGpioOrInterruptModeLevel = \\ (uint32)(*(LpPortGroup->pPortAddress + LpHwRegOffset->ulIOINTSEL)) & LddMask; /* PRQA S 2814, 0488 # JV-01, JV-01 */\\ /* * Get GPIO port mode level: * 0: Input mode * 1: Output mode */ LulPortModeLevel = (uint32)(*(LpPortGroup->pPortAddress + LpHwRegOffset->ulINOUTSEL)) & LddMask; /* PRQA S 0488 # JV-01 */\\ /* * Get choosing output: * 0: OUTDT mode * 1: OUTDTH/OUTDTL mode */ LulPortChoosingOutput = \\ (uint32)(*(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDTSEL)) & LddMask; /* PRQA S 0488 # JV-01 */\\ /* Check these pins are GPIO purpose */ if (DIO_GPIO_MODE == LulGpioOrInterruptModeLevel) { /* Check these pins are used as the output mode */ if (DIO_INPUT_MODE != LulPortModeLevel) { /* OUTDT register is used to output the data */ if (DIO_OUTPUT_MODE == LulPortChoosingOutput) { /* Flip OUTDT register */ *(volatile uint32 *)(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDT) ^= LddMask; /* PRQA S 0488 # JV-01 */ /* Read the port value from OUTDT register */ LddPortLevel = (Dio_PortLevelType)(*(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDT)); /* PRQA S 0488 # JV-01 */ } else { /* No action is required */ } /* OUTDTH/L register is used to output the data */ if (DIO_OUTPUT_MODE != LulPortChoosingOutput) { /* Read the port value from OUTDTH register */ LddOUTDTHLevel = (Dio_PortLevelType)(*(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDTH)) & LddMask; /* PRQA S 0488 # JV-01 */ /* Read the port value from OUTDTL register */ LddOUTDTLLevel = (Dio_PortLevelType)(*(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDTL)) & LddMask; /* PRQA S 0488 # JV-01 */ /* Only writing 1 to OUTDTH is effective */ if (DIO_ZERO == LddOUTDTHLevel) { /* Flip OUTDTH register */ *(volatile uint32 *)(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDTH) ^= LddMask; /* PRQA S 0488 # JV-01 */ } else { /* No action is required */ } /* Only writing 0 to OUTDTL is effective */ if (DIO_ZERO != LddOUTDTLLevel) { /* Flip OUTDTL register */ *(volatile uint32 *)(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDTL) ^= LddMask; /* PRQA S 0488 # JV-01 */ } else { /* No action is required */ } /* Read the port value from OUTDTH/OUTDTL register after flipping */ LddPortLevel = (Dio_PortLevelType)(*(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDTH)) /* PRQA S 0404, 0488 # JV-01, JV-01 */\\ | (*(LpPortGroup->pPortAddress + LpHwRegOffset->ulOUTDTL)); /* PRQA S 0488 # JV-01 */ } else { /* No action is required */ } } /* Check these pins are used as the input mode */ if (DIO_INPUT_MODE == LulPortModeLevel) { /* Read the port value from INDT register */ LddPortLevel = (Dio_PortLevelType)(*(LpPortGroup->pPortAddress + LpHwRegOffset->ulINDT)); /* PRQA S 0488 # JV-01 */ } } else { /* Do nothing */ } /* Exit critical section */ #if (DIO_CRITICAL_SECTION_PROTECTION == STD_ON) DIO_EXIT_CRITICAL_SECTION(DIO_INTERRUPT_CONTROL_PROTECTION); #endif #if (DIO_EXCLUSIVE_CONTROL == STD_ON) /* Release control to another CPU for GPIO module */ (void) Dio_ExclusiveControl(DIO_RELEASE_EXCLUSIVE); } else { (void) Dio_ExclusiveControl(DIO_RELEASE_EXCLUSIVE); } /* End of if (E_OK == LddReturnValue) */ #endif /* #if (STD_ON == DIO_EXCLUSIVE_CONTROL) */ /* * Mask the port value for required Channel bit position and * clear other bit positions */ LddPortLevel = LddPortLevel & LddMask; /* Return port level */ return LddPortLevel; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_FLIP_CHANNEL_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LpPortGroup', 'Value': '&Dio_GaaPortGroup[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddMask', 'Value': '0x0F'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GaaPortGroup', 'Value': '&Dio_GaaPortGroup[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pPortAddress', 'Value': '&map_pPortAddress[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GstPFCRegOffset', 'Value': '&Dio_GstPFCRegOffset'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulIOINTSEL', 'Value': '0x00'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulINOUTSEL', 'Value': '0x01'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulOUTDTSEL', 'Value': '0x02'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulOUTDT', 'Value': '0x03'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulOUTDTH', 'Value': '0x04'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulOUTDTL', 'Value': '0x05'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulINDT', 'Value': '0x06'], 'Input_Param_015': ['Type': 'Array', 'Range': 'uint32', 'Name': 'map_pPortAddress[0 to 6]', 'Value': '[0] = 0x0000000F\\n[1] = 0x00000000\\n[2] = 0x0000000F\\n[3] = 0xFFFFFFFF\\n[4] = 0x0000000F\\n[5] = 0x00000000\\n[6] = 0x000000F0'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenExclusiveType', 'Value': 'DIO_GET_EXCLUSIVE'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenExclusiveType', 'Value': 'DIO_RELEASE_EXCLUSIVE'], 'Output_Param_004': ['Type': 'Array', 'Range': 'uint32', 'Name': 'map_pPortAddress[0 to 6]', 'Value': '[0] = 0x0000000F\\n[1] = 0x00000000\\n[2] = 0x0000000F\\n[3] = 0xFFFFFFFF\\n[4] = 0x0000000F\\n[5] = 0x00000000\\n[6] = 0x000000F0'], 'Output_Param_005': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddPortLevel', 'Value': '0x00000000'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (DIO_FLIP_CHANNEL_API == STD_ON) #define DIO_START_SEC_PRIVATE_CODE #include \"Dio_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* Implementation of the Dio_PGCFlipChannel function */ FUNC(Dio_PortLevelType, DIO_PRIVATE_CODE) Dio_PGCFlipChannel( /* PRQA S 1532 # JV-01 */\\ P2CONST(Dio_PortGroupType, AUTOMATIC, DIO_CONFIG_DATA) LpPortGroup, Dio_PortMaskType LddMask) /* PRQA S 3432 # JV-01 */ { P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpPortAddress; /* PRQA S 3678 # JV-01 */ Dio_PortLevelType LddPortLevel; uint32 LulPortModeLevel; uint32 LulPortGroupNumber; /* Define local pointer to store port register offsets */ P2CONST(volatile Dio_PGCHwRegOffsetType, AUTOMATIC, DIO_CONFIG_DATA) LpHwRegOffset; /* PRQA S 3432 # JV-01 */ LpHwRegOffset = &Dio_GstPGCRegOffset; LpPortAddress = LpPortGroup->pPortAddress; /* PRQA S 2814 # JV-01 */ /* Check if the required port is JTAG port */ if (DIO_JTAGPORT == LpPortGroup->ucPortType) { #if (DIO_CRITICAL_SECTION_PROTECTION == STD_ON) DIO_ENTER_CRITICAL_SECTION(DIO_INTERRUPT_CONTROL_PROTECTION); #endif LulPortModeLevel = (uint32)(*(&LpPortAddress[(uint32)(LpHwRegOffset->ucPMSRJTAG)])) & LddMask; /* PRQA S 2824 # JV-01 */ /* Check if the required port is Output mode */ if ((uint32)DIO_OUTPUT_MODE_PIN_EXISTENCE_CHECK == LulPortModeLevel) { /* * Write the PNOT register by adding offset to PSR register address * for JTAG Port */ *((volatile uint8 *)(&LpPortAddress[(uint32)(LpHwRegOffset->ucPNOTJTAG)])) = (uint8)(LddMask); /* PRQA S 0751 # JV-01 */ } /* else no operation required */ /* * Read the port value from PPR register by adding offset to * PSR register address for JTAG Port */ LddPortLevel = (Dio_PortLevelType)(*((P2VAR(volatile uint8, AUTOMATIC, DIO_PRIVATE_DATA)) /* PRQA S 0751 # JV-01 */ & LpPortAddress[(uint32)(LpHwRegOffset->ucPPRJTAG)])); #if (DIO_CRITICAL_SECTION_PROTECTION == STD_ON) DIO_EXIT_CRITICAL_SECTION(DIO_INTERRUPT_CONTROL_PROTECTION); #endif } /* (DIO_NORMALPORT == LpPortGroup->ucPortType) */ else { #if (DIO_CRITICAL_SECTION_PROTECTION == STD_ON) DIO_ENTER_CRITICAL_SECTION(DIO_INTERRUPT_CONTROL_PROTECTION); #endif LulPortModeLevel = (uint32)(*(&LpPortAddress[(uint32)(LpHwRegOffset->ucPMSRNONJTAG)])) & LddMask; if ((uint32)DIO_OUTPUT_MODE_PIN_EXISTENCE_CHECK == LulPortModeLevel) { /* Get the Port Group Number */ LulPortGroupNumber = LpPortGroup->ulPortGroupNum; /* PWE Write Enable for each Port Group */ Dio_SetPweMode(LulPortGroupNumber, DIO_PWE_EACH_WRITE_ENABLE); /* * Write the PNOT register by adding offset to PSR register address * for for Numeric/Alphabetic Port */ *((volatile uint16 *)(&LpPortAddress[(uint32)(LpHwRegOffset->ucPNOTNONJTAG)])) = LddMask; /* PRQA S 0310 # JV-01 */ /* PWE Write Disable for each Port Group */ Dio_SetPweMode(LulPortGroupNumber, DIO_PWE_EACH_WRITE_DISABLE); } /* else no operation required */ /* * Read the port value from PPR register by adding offset to * PSR register address for Numeric/Alphabetic Port */ LddPortLevel = (Dio_PortLevelType)(*((P2VAR(volatile uint16, AUTOMATIC, DIO_PRIVATE_DATA)) /* PRQA S 0310 # JV-01 */ & LpPortAddress[(uint32)(LpHwRegOffset->ucPPRNONJTAG)])); #if (DIO_CRITICAL_SECTION_PROTECTION == STD_ON) DIO_EXIT_CRITICAL_SECTION(DIO_INTERRUPT_CONTROL_PROTECTION); #endif } /* Return port level */ return LddPortLevel; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_FLIP_CHANNEL_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpPortGroup', 'Value': '&Dio_GaaPortGroup[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LddMask', 'Value': '0x00FF'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GaaPortGroup', 'Value': '&Dio_GaaPortGroup[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pPortAddress', 'Value': '&map_pPortAddress[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'DIO_NORMALPORT(2)\\nDIO_JTAGPORT(1)\\nDIO_INPUTPORT(0)', 'Name': 'ucPortType', 'Value': 'DIO_JTAGPORT'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GstPGCRegOffset', 'Value': '&Dio_GstPGCRegOffset'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucPMSRJTAG', 'Value': '0x00'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucPMSRNONJTAG', 'Value': '0x01'], 'Input_Param_010': ['Type': 'Array', 'Range': 'uint16', 'Name': 'map_pPortAddress[0 to 6]', 'Value': '[0] = 0x0001\\n[1] = 0x0001\\n'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'uint32', 'Name': 'ulPortGroupNum', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulGroup', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucMode', 'Value': '-'], 'Output_Param_003': ['Type': 'Array', 'Range': 'uint32', 'Name': 'map_pPortAddress[0 to 6]', 'Value': '[0] = 0x0001\\n[1] = 0x0001'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulGroup', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucMode', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddPortLevel', 'Value': '0x0001'], 'Output_Param_007': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define DIO_START_SEC_PUBLIC_CODE #include \"Dio_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Dio_PortLevelType, DIO_PUBLIC_CODE) Dio_ReadChannelGroup(P2CONST(Dio_ChannelGroupType, AUTOMATIC, DIO_CONST) ChannelGroupIdPtr) /* PRQA S 1503, 3432, 1532 # JV-01, JV-01, JV-01 */ { #if (DIO_CHANNELGROUP_CONFIGURED == STD_ON) /* Create local variable to store PortChannelGroup information */ P2CONST(Dio_ChannelGroupType, AUTOMATIC, DIO_APPL_CONST) LpChannelGroupPtr; /* PRQA S 3432 # JV-01 */ /* Create local variable to store PortGroup information */ P2CONST(Dio_PortGroupType, AUTOMATIC, DIO_CONFIG_DATA) LpPortGroup; /* PRQA S 3432 # JV-01 */ /* Create local variable to store HwConfig information */ P2CONST(Dio_HwConfigType, AUTOMATIC, DIO_CONFIG_DATA) LpHwConfig; /* PRQA S 3432 # JV-01 */ #endif /* Create local variable to store PortLevel information */ Dio_PortLevelType LddPortLevel; /* When channel group are not configured, casting void to avoid unused parameter error */ #if (DIO_CHANNELGROUP_CONFIGURED == STD_OFF) (void)ChannelGroupIdPtr; #endif #if (DIO_CHANNELGROUP_CONFIGURED == STD_ON) #if (DIO_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucDetErrFlag; LucDetErrFlag = E_NOT_OK; #endif #endif /* Set the return value to 0 */ LddPortLevel = DIO_LOW_LEVEL_OUTPUT; /* PRQA S 2982 # JV-01 */ /* Check if at least one ChannelGroup is configured */ #if (DIO_CHANNELGROUP_CONFIGURED == STD_ON) /* Check whether DIO_DEV_ERROR_DETECT is enabled */ #if (DIO_DEV_ERROR_DETECT == STD_ON) /* Check whether LpChannelGroupPtr is NULL_PTR */ if (NULL_PTR == ChannelGroupIdPtr) { /* Report Error to DET */ (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_READ_CHANNEL_GROUP_SID, DIO_E_PARAM_POINTER); LucDetErrFlag = E_OK; } else { LpChannelGroupPtr = ChannelGroupIdPtr; } if (E_NOT_OK == LucDetErrFlag) #else LpChannelGroupPtr = ChannelGroupIdPtr; #endif /* (DIO_DEV_ERROR_DETECT == STD_ON) */ { /* Get the Port Address in which the Channel is configured */ LpPortGroup = &Dio_GaaPortGroup[LpChannelGroupPtr->ucPortIndex]; /* PRQA S 2814 # JV-02 */ /* Get the pointer to the configuration of HW IP */ LpHwConfig = &Dio_GstHwConfig; /* Call pHwReadPort */ LddPortLevel = LpHwConfig->pHwFunc->pHwReadPort(LpPortGroup, /* PRQA S 2814 # JV-02 */\\ (LpPortGroup->ddModeMask) & (LpChannelGroupPtr->ddMask)); /* Rotate right to get the corresponding ChannelGroup value */ /* Rotate right to get the corresponding ChannelGroup value */ LddPortLevel = LddPortLevel >> (LpChannelGroupPtr->ucOffset); } /* else No action required */ #else #if (DIO_DEV_ERROR_DETECT == STD_ON) /* Report Error to DET */ (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_READ_CHANNEL_GROUP_SID, DIO_E_PARAM_INVALID_GROUP); #endif /* (DIO_CHANNELGROUP_CONFIGURED == STD_ON) */ #endif /* Return the ChannelGroup Level */ return (LddPortLevel); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_CHANNELGROUP_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL_PTR..Not NULL_PTR', 'Name': 'ChannelGroupIdPtr', 'Value': '&map_ChannelGroupIdPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucPortIndex', 'Value': '5'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ddMask', 'Value': '0xFF'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucOffset', 'Value': '0xFF'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GaaPortGroup', 'Value': '&Dio_GaaPortGroup[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ddModeMask', 'Value': '[5] = 5']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '0..255', 'Name': 'LddPortLevel', 'Value': 'DIO_LOW_LEVEL_OUTPUT'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPortGroup', 'Value': '&Dio_GaaPortGroup[5]'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddMask', 'Value': '5U'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (DIO_READ_CHANNEL_OUTPUT_VALUE_API == STD_ON) #define DIO_START_SEC_PUBLIC_CODE #include \"Dio_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Dio_LevelType, DIO_PUBLIC_CODE) Dio_ReadChannelOutputValue(const Dio_ChannelType LddChannelId) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if (DIO_CHANNEL_CONFIGURED == STD_ON) /* Create local variable to store PortChannel information */ P2CONST(Dio_PortChannelType, AUTOMATIC, DIO_CONFIG_DATA) LpPortChannel; /* PRQA S 3432 # JV-01 */ /* Create local variable to store PortGroup information */ P2CONST(Dio_PortGroupType, AUTOMATIC, DIO_CONFIG_DATA) LpPortGroup; /* PRQA S 3432 # JV-01 */ /* Create local variable to store HwConfig information */ P2CONST(Dio_HwConfigType, AUTOMATIC, DIO_CONFIG_DATA) LpHwConfig; /* PRQA S 3432 # JV-01 */ /* Create local variable to store PortLevel information */ Dio_PortLevelType LusPortRegValue; #endif Dio_LevelType LddLevel; #if (DIO_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucDetErrFlag; LucDetErrFlag = E_NOT_OK; /* PRQA S 2982 # JV-01 */ #endif /* When channels are not configured, casting void to avoid unused parameter error */ #if (DIO_CHANNEL_CONFIGURED == STD_OFF) (void)LddChannelId; #endif /* Initialize the return value to STD_LOW */ LddLevel = STD_LOW; #if (DIO_DEV_ERROR_DETECT == STD_ON) #if (DIO_CHANNEL_CONFIGURED == STD_ON) /* Check whether the Channel Id is out of range */ if (DIO_MAXNOOFCHANNEL <= LddChannelId) #endif { /* Report Error to DET */ (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_READ_CHANNEL_OUTPUT_VALUE_SID, DIO_E_PARAM_INVALID_CHANNEL_ID); LucDetErrFlag = E_OK; } /* else No action required */ if (E_NOT_OK == LucDetErrFlag) /* PRQA S 2996, 2992 # JV-01, JV-01 */ #endif /* (DIO_DEV_ERROR_DETECT == STD_ON) */ { /* Check if at least one Channel is configured */ #if (DIO_CHANNEL_CONFIGURED == STD_ON) /* Get the pointer to the required Channel */ LpPortChannel = &Dio_GaaPortChannel[LddChannelId]; /* PRQA S 2934 # JV-01 */ /* Get the Port Address from Port to which the Channel belongs */ LpPortGroup = &Dio_GaaPortGroup[LpPortChannel->ucPortIndex]; /* PRQA S 2844 # JV-01 */ /* Get the pointer to the configuration of HW IP */ LpHwConfig = &Dio_GstHwConfig; /* Call pHwReadOutputValue */ LusPortRegValue = LpHwConfig->pHwFunc->pHwReadOutputValue(LpPortGroup); /* PRQA S 2814 # JV-02 */ /* * Mask the port level value for required Channel bit position and * clear other bit positions */ LusPortRegValue = LusPortRegValue & (LpPortChannel->ddMask); /* Check whether value is not equal to zero */ if (DIO_LOW_LEVEL_OUTPUT != LusPortRegValue) { /* Set the return value to STD_HIGH */ LddLevel = STD_HIGH; } /* else No action required */ #endif /* (DIO_CHANNEL_CONFIGURED == STD_ON) */ } /* else No action required */ /* Return the Channel Level */ return LddLevel; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_CHANNEL_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..(DIO_MAXNOOFCHANNEL-1)', 'Name': 'LddChannelId', 'Value': 'DIO_MAXNOOFCHANNEL - 1'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GaaPortChannel', 'Value': '&Dio_GaaPortChannel[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GaaPortGroup', 'Value': '&Dio_GaaPortGroup[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucPortIndex', 'Value': '[199]=5'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ddMask', 'Value': '[199]=1'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPortGroup', 'Value': '&Dio_GaaPortGroup[5]'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '0..255', 'Name': 'LddLevel', 'Value': 'STD_HIGH'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (DIO_READ_CHANNEL_OUTPUT_VALUE_API == STD_ON) #define DIO_START_SEC_PUBLIC_CODE #include \"Dio_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Dio_LevelType, DIO_PUBLIC_CODE) Dio_ReadChannelOutputValue(const Dio_ChannelType LddChannelId) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if (DIO_CHANNEL_CONFIGURED == STD_ON) /* Create local variable to store PortChannel information */ P2CONST(Dio_PortChannelType, AUTOMATIC, DIO_CONFIG_DATA) LpPortChannel; /* PRQA S 3432 # JV-01 */ /* Create local variable to store PortGroup information */ P2CONST(Dio_PortGroupType, AUTOMATIC, DIO_CONFIG_DATA) LpPortGroup; /* PRQA S 3432 # JV-01 */ /* Create local variable to store HwConfig information */ P2CONST(Dio_HwConfigType, AUTOMATIC, DIO_CONFIG_DATA) LpHwConfig; /* PRQA S 3432 # JV-01 */ /* Create local variable to store PortLevel information */ Dio_PortLevelType LusPortRegValue; #endif Dio_LevelType LddLevel; #if (DIO_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucDetErrFlag; LucDetErrFlag = E_NOT_OK; /* PRQA S 2982 # JV-01 */ #endif /* When channels are not configured, casting void to avoid unused parameter error */ #if (DIO_CHANNEL_CONFIGURED == STD_OFF) (void)LddChannelId; #endif /* Initialize the return value to STD_LOW */ LddLevel = STD_LOW; #if (DIO_DEV_ERROR_DETECT == STD_ON) #if (DIO_CHANNEL_CONFIGURED == STD_ON) /* Check whether the Channel Id is out of range */ if (DIO_MAXNOOFCHANNEL <= LddChannelId) #endif { /* Report Error to DET */ (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_READ_CHANNEL_OUTPUT_VALUE_SID, DIO_E_PARAM_INVALID_CHANNEL_ID); LucDetErrFlag = E_OK; } /* else No action required */ if (E_NOT_OK == LucDetErrFlag) /* PRQA S 2996, 2992 # JV-01, JV-01 */ #endif /* (DIO_DEV_ERROR_DETECT == STD_ON) */ { /* Check if at least one Channel is configured */ #if (DIO_CHANNEL_CONFIGURED == STD_ON) /* Get the pointer to the required Channel */ LpPortChannel = &Dio_GaaPortChannel[LddChannelId]; /* PRQA S 2934 # JV-01 */ /* Get the Port Address from Port to which the Channel belongs */ LpPortGroup = &Dio_GaaPortGroup[LpPortChannel->ucPortIndex]; /* PRQA S 2844 # JV-01 */ /* Get the pointer to the configuration of HW IP */ LpHwConfig = &Dio_GstHwConfig; /* Call pHwReadOutputValue */ LusPortRegValue = LpHwConfig->pHwFunc->pHwReadOutputValue(LpPortGroup); /* PRQA S 2814 # JV-02 */ /* * Mask the port level value for required Channel bit position and * clear other bit positions */ LusPortRegValue = LusPortRegValue & (LpPortChannel->ddMask); /* Check whether value is not equal to zero */ if (DIO_LOW_LEVEL_OUTPUT != LusPortRegValue) { /* Set the return value to STD_HIGH */ LddLevel = STD_HIGH; } /* else No action required */ #endif /* (DIO_CHANNEL_CONFIGURED == STD_ON) */ } /* else No action required */ /* Return the Channel Level */ return LddLevel; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_CHANNEL_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..(DIO_MAXNOOFCHANNEL-1)', 'Name': 'LddChannelId', 'Value': 'DIO_MAXNOOFCHANNEL'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GaaPortChannel', 'Value': '&Dio_GaaPortChannel[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GaaPortGroup', 'Value': '&Dio_GaaPortGroup[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucPortIndex', 'Value': '[328] = 5\\n'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ddMask', 'Value': '[328] = 0\\n'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPortGroup', 'Value': '-'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '0..255', 'Name': 'LddLevel', 'Value': 'STD_LOW'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'DIO_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'DIO_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'DIO_READ_CHANNEL_OUTPUT_VALUE_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'DIO_E_PARAM_INVALID_CHANNEL_ID'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define DIO_START_SEC_PUBLIC_CODE #include \"Dio_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, DIO_PUBLIC_CODE) Dio_WriteChannelGroup(P2CONST(Dio_ChannelGroupType, AUTOMATIC, DIO_CONST) ChannelGroupIdPtr, Dio_PortLevelType Level) /* PRQA S 1503, 3432, 1532 # JV-01, JV-01, JV-01 */ { /* When channel group are not configured, casting void to avoid unused parameter error */ #if (DIO_CHANNELGROUP_CONFIGURED == STD_OFF) (void)ChannelGroupIdPtr; (void)Level; #endif #if (DIO_CHANNELGROUP_CONFIGURED == STD_ON) /* Create local variable to store PortChannelGroup information */ P2CONST(Dio_ChannelGroupType, AUTOMATIC, DIO_APPL_CONST) LpChannelGroupPtr; /* PRQA S 3432 # JV-01 */ /* Create local variable to store PortGroup information */ P2CONST(Dio_PortGroupType, AUTOMATIC, DIO_CONFIG_DATA) LpPortGroup; /* PRQA S 3432 # JV-01 */ /* Create local variable to store HwConfig information */ P2CONST(Dio_HwConfigType, AUTOMATIC, DIO_CONFIG_DATA) LpHwConfig; /* PRQA S 3432 # JV-01 */ #if (DIO_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucDetErrFlag; LucDetErrFlag = E_NOT_OK; /* Check whether ChannelGroupIdPtr is NULL_PTR */ if (NULL_PTR == ChannelGroupIdPtr) { /* Report Error to DET */ (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_WRITE_CHANNEL_GROUP_SID, DIO_E_PARAM_POINTER); LucDetErrFlag = E_OK; } /* else No action required */ if (E_NOT_OK == LucDetErrFlag) #endif /* (DIO_DEV_ERROR_DETECT == STD_ON) */ { /* Get the pointer to corresponding index in the array Dio_GaaChannelGroupData */ LpChannelGroupPtr = ChannelGroupIdPtr; /* Get the pointer to port group to which the channel belongs */ LpPortGroup = &Dio_GaaPortGroup[LpChannelGroupPtr->ucPortIndex]; /* PRQA S 2814 # JV-02 */ /* Get the pointer to the configuration of HW IP */ LpHwConfig = &Dio_GstHwConfig; /* Call pHwWritePort */ LpHwConfig->pHwFunc->pHwWritePort /* PRQA S 2814 # JV-02 */\\ (LpPortGroup, Level << (LpChannelGroupPtr->ucOffset), \\ (LpPortGroup->ddModeMask) & (LpChannelGroupPtr->ddMask)); } /* (DIO_DEV_ERROR_DETECT == STD_ON) */ #else #if (DIO_DEV_ERROR_DETECT == STD_ON) /* Report Error to DET */ (void)Det_ReportError(DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_WRITE_CHANNEL_GROUP_SID, DIO_E_PARAM_INVALID_GROUP); #endif /* (DIO_CHANNELGROUP_CONFIGURED == STD_ON) */ #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'DIO_CHANNELGROUP_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Level', 'Value': '0x0000'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR..Not NULL_PTR', 'Name': 'ChannelGroupIdPtr', 'Value': ''], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucPortIndex', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ddMask', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucOffset', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Dio_GaaPortGroup', 'Value': '&Dio_GaaPortGroup[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ddModeMask', 'Value': '[0] = 5']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPortGroup', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddLevel', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddMask', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'DIO_MODULE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'DIO_INSTANCE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'DIO_WRITE_CHANNEL_GROUP_SID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'DIO_E_PARAM_POINTER'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ETH_START_SEC_CODE_FAST #include \"Eth_MemMap.h\" #if (ETH_AVB0_DATA_ISR == STD_ON) /* Defines the CAT2 interrupt mapping */ #if defined (Os_ETH_AVB0DATAISR_CAT2) || (ETH_ISR_CATEGORY_2 == STD_ON) ISR(ETH_AVB0DATAISR_CAT2) /* PRQA S 3408, 1503 # JV-01, JV-01 */ #else _INTERRUPT_ FUNC(void, ETH_CODE_FAST) ETH_AVB0DATAISR(void) /* PRQA S 1503 # JV-01 */ #endif { #if (ETH_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if (((ETH_EIC_CONSISTENCY_MASK & ~ETH_EIC_EIMK_MASK) != (Eth_GaaETNBEICRegs[ETHAVB0]->usDATA & ETH_EIC_CONSISTENCY_MASK)) /* PRQA S 2814 # JV-01 */ #if (ETH_CTRL_ENABLE_RX_INTERRUPT == STD_ON) || ((0UL != (Eth_GaaETNBRegs[ETHAVB0]->ulRIS0 & (uint32)(~ETH_RX_QUEUE_CONFIG_0))) /* PRQA S 2814 # JV-01 */ && (ETH_ENABLE == Eth_GpEthConfigPtr[ETHAVB0].enRxInterruptMode)) #endif #if (ETH_CTRL_ENABLE_TX_INTERRUPT == STD_ON) || ((0UL != (Eth_GaaETNBRegs[ETHAVB0]->ulDIS & (uint16)(~ETH_TX_QUEUE_CONFIG_0))) /* PRQA S 2814 # JV-01 */ && (ETH_ENABLE == Eth_GpEthConfigPtr[ETHAVB0].enTxInterruptMode)) #endif ) { Eth_DemConfigCheck(Eth_GaaDemEventIntInconsistent[ETHAVB0], DEM_EVENT_STATUS_FAILED); } else #endif { if (ETH_ENABLE == Eth_GpEthConfigPtr[ETHAVB0].enTxInterruptMode) { Eth_HwTxConfirmation(ETHAVB0); } /* else: No action required */ #if (ETH_CTRL_ENABLE_RX_INTERRUPT == STD_ON) if (ETH_ENABLE == Eth_GpEthConfigPtr[ETHAVB0].enRxInterruptMode) { Eth_Hw_Etnb_RxIrqHdlr(ETHAVB0); } /* else: No action required */ #endif } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'defined\\nundefined', 'Name': 'Os_ETH_AVB0DATAISR_CAT2', 'Value': 'undefined'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'ETH_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'ETH_AVB0_DATA_ISR', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'ETH_UNINTENDED_INTERRUPT_CHECK', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'ETH_CTRL_ENABLE_TX_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'ETH_CTRL_ENABLE_RX_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': '-', 'Name': 'ETH_AVB_ISS_MASK', 'Value': '0xFFFE0001UL'], 'Input_Param_007': ['Type': 'Macro', 'Range': '-', 'Name': 'ETH_TX_QUEUE_CONFIG_0', 'Value': '0x0000001EUL'], 'Input_Param_008': ['Type': 'Macro', 'Range': '-', 'Name': 'ETH_RX_QUEUE_CONFIG_0', 'Value': '0x0000000FUL'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'ulISS', 'Value': '0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'ulDIS', 'Value': '0x00000000'], 'Input_Param_011': ['Type': 'Variable', 'Range': '-', 'Name': 'Eth_GpEthConfigPtr', 'Value': '&map_Eth_GpEthConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'ETH_ENABLE\\nETH_DISABLE', 'Name': 'enTxInterruptMode', 'Value': 'ETH_ENABLE'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'ulRIS0', 'Value': '0x00000000'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'ETH_ENABLE\\nETH_DISABLE', 'Name': 'enRxInterruptMode', 'Value': 'ETH_DISABLE']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'ETHAVB0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ /* Defines the CAT2 interrupt mapping */ #if defined (Os_ETH_AVB2ERRISR_CAT2) || (ETH_ISR_CATEGORY_2 == STD_ON) ISR(ETH_AVB2ERRISR_CAT2) /* PRQA S 1503, 3408 # JV-01, JV-01 */ #else _INTERRUPT_ FUNC(void, ETH_CODE_FAST) ETH_AVB2ERRISR(void) /* PRQA S 1503 # JV-01 */ #endif { /* Check interrupt status is masked, this interrupt is wrong */ #if (ETH_UNINTENDED_INTERRUPT_CHECK == STD_ON) if(0UL == (Eth_GaaAVBRegs[ETHAVB2]->ulEIS & ETH_EIS_QEF_MASK)) /* PRQA S 2814 # JV-01 */ { Eth_DemConfigCheck(Eth_GaaDemEventUnintendedInt[ETHAVB2], DEM_EVENT_STATUS_FAILED); } else #endif /* (ETH_UNINTENDED_INTERRUPT_CHECK == STD_ON) */ { /* Read EIS */ if(ETH_EIS_QEF_MASK == (Eth_GaaAVBRegs[ETHAVB2]->ulEIS & ETH_EIS_QEF_MASK)) /* PRQA S 2814 # JV-01 */ { if(ETH_AVB_ESR_ERROR_MASK != (Eth_GaaAVBRegs[ETHAVB2]->ulESR & ETH_AVB_ESR_ERROR_MASK)) { /* No action required */ } else { /* Critical error detection on the MAC controller */ Eth_DemConfigCheck(Eth_GaaDemEventDmaError[ETHAVB2], DEM_EVENT_STATUS_FAILED); } /* Clear Queue Error Flag */ Eth_GaaAVBRegs[ETHAVB2]->ulEIS &= ~ETH_AVB_EIC_ERROR; } /* else: No action required */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'defined\\nundefined', 'Name': 'Os_ETH_AVB2ERRISR_CAT2', 'Value': 'undefined'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'ETH_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'ETH_AVB2_ERR_ISR', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'ETH_UNINTENDED_INTERRUPT_CHECK', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '-', 'Name': 'ETH_EIS_QEF_MASK', 'Value': '0x00000004UL'], 'Input_Param_005': ['Type': 'Macro', 'Range': '-', 'Name': 'ETH_AVB_ESR_ERROR_MASK', 'Value': '0x00000300UL'], 'Input_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'ulEIS', 'Value': 'ETH_EIS_QEF_MASK'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'ulESR', 'Value': 'ETH_AVB_ESR_ERROR_MASK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': 'Eth_GaaDemEventUnintendedInt[ETHAVB2]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_004': ['Type': 'Variable', 'Range': '-', 'Name': 'ulEIS', 'Value': '(ETH_EIS_QEF_MASK)&(~ETH_AVB_EIC_ERROR)'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, ETH_PUBLIC_CODE) Eth_EnableEgressTimeStamp( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, Eth_BufIdxType BufIdx) { P2VAR(Eth_BufHandlerType, AUTOMATIC, ETH_APPL_DATA) LpBufHandlerPtr; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucErrorValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the DET value */ LucErrorValue = Eth_CommonDetCheck(ETH_ENEGRESSTS_SID, CtrlIdx); if (E_OK != LucErrorValue) { /* No action required */ } else #endif { LucErrorValue = Eth_CheckProvideBuffer((uint32)CtrlIdx, (uint32)BufIdx); /* Invalid Buffer */ if (E_OK != LucErrorValue) { #if (ETH_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_ENEGRESSTS_SID, ETH_E_INV_PARAM); #endif } else { /* This will be written in the Ram Descriptor on the next Eth_Transmit call */ LpBufHandlerPtr = Eth_FindTxBufferHandler((uint32)CtrlIdx, (uint32)BufIdx); if (NULL_PTR != LpBufHandlerPtr) { LpBufHandlerPtr->blbenableTS = ETH_TRUE; } /* else: No action required */ } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GLOBAL_TIME_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nE2x: 0\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '0x1'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..0x0F', 'Name': 'BufIdx', 'Value': '0x01'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_NOT_OK'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': 'NULL, !=NULL', 'Name': 'return', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': 'NULL, !=NULL', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_ENEGRESSTS_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '0x1'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'BufIdx', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'BufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'blbenableTS', 'Value': '-'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ETH_START_SEC_CODE_FAST #include \"Eth_MemMap.h\" #if ((ETH_CTRL_ENABLE_TX_INTERRUPT == STD_ON) || \\ (ETH_CTRL_ENABLE_RX_INTERRUPT == STD_ON)) #if defined (Os_ETH_ETNC0_CAT2_ISR) || (ETH_ISR_CATEGORY_2 == STD_ON) /* Defines the CAT2 interrupt mapping */ ISR(ETH_ETNC0_CAT2_ISR) /* PRQA S 3408, 1503 # JV-01, JV-01 */ #else /* Defines the CAT1 interrupt mapping */ _INTERRUPT_ FUNC(void, ETH_CODE_FAST) ETH_ETNC0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { #if (ETH_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((((uint16)ETH_EIC_CONSISTENCY_MASK & (uint16)~ETH_EIC_EIMK_MASK) != (*Eth_GaaETNCEICRegs[0] & (uint16)ETH_EIC_CONSISTENCY_MASK)) || /* PRQA S 2814 # JV-01 */ (0UL == (Eth_GaaETNCRegs[0]->ulEESR & (0UL /* PRQA S 2814 # JV-01 */ #if (ETH_CTRL_ENABLE_RX_INTERRUPT == STD_ON) | ETH_ETNC_FR #endif #if (ETH_CTRL_ENABLE_TX_INTERRUPT == STD_ON) | ETH_ETNC_TWB #endif )))) { Eth_DemConfigCheck(Eth_GaaDemEventIntInconsistent[0], DEM_EVENT_STATUS_FAILED); } else #endif { #if (ETH_CTRL_ENABLE_RX_INTERRUPT == STD_ON) /* Frame Receive Flag*/ if (0UL != (Eth_GaaETNCRegs[0]->ulEESR & ETH_ETNC_FR)) { /* RX Handler */ Eth_HwRxIsrHandler(0U); } /* else: No action required */ #endif #if (ETH_CTRL_ENABLE_TX_INTERRUPT == STD_ON) /* Frame Transfer Complete Flag */ if (0UL != (Eth_GaaETNCRegs[0]->ulEESR & ETH_ETNC_TWB)) { /* TX Handler */ Eth_HwTxIsrHandler(0U); } /* else: No action required */ #endif } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'Os_ETH_ETNC0_CAT2_ISR', 'Value': '<Not Defined>'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_CTRL_ENABLE_RX_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_CTRL_ENABLE_TX_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0..0xFFFF', 'Name': 'map_Eth_GaaETNCEICRegs[0]', 'Value': '0x1000'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'ulEESR', 'Value': 'ETH_ETNC_FR'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0..0xFF', 'Name': 'Eth_GaaDemEventIntInconsistent[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE)Eth_GetCounterValues( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, P2VAR(Eth_CounterType, AUTOMATIC, ETH_APPL_DATA) CounterPtr) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_GETCOUNTERVALUES_SID, CtrlIdx); /* Report Error to DET, if the stherStats pointer value is NULL */ if (NULL_PTR == CounterPtr) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_GETCOUNTERVALUES_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { Eth_HwGetCounterValues((uint32)CtrlIdx, CounterPtr); LucReturnValue = E_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GET_COUNTER_VALUES_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1', 'Name': 'CtrlIdx', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'CounterPtr', 'Value': 'NULL_PTR'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_CounterPtr[0]', 'Value': '-'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_GETCOUNTERVALUES_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '0'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ETH_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ETH_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ETH_GETCOUNTERVALUES_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ETH_E_PARAM_POINTER'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCounterPtr', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCounterPtr', 'Value': '-'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE) Eth_GetCurrentTime( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, P2VAR(Eth_TimeStampQualType, AUTOMATIC, ETH_APPL_DATA) timeQualPtr, /* PRQA S 3432 # JV-01 */ P2VAR(Eth_TimeStampType, AUTOMATIC, ETH_APPL_DATA) timeStampPtr) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_GETCURRENTTIME_SID, CtrlIdx); if ((NULL_PTR == timeQualPtr) || (NULL_PTR == timeStampPtr)) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_GETCURRENTTIME_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No Action required */ } else #endif { if (ETH_MODE_ACTIVE != Eth_GaaCtrlStat[CtrlIdx].enMode) /* PRQA S 2844 # JV-01 */ { #if (ETH_DEV_ERROR_DETECT == STD_ON) /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_GETCURRENTTIME_SID, ETH_E_INV_MODE); #endif LucReturnValue = E_NOT_OK; } else { LucReturnValue = Eth_HwGetCurrentTime((uint32)CtrlIdx, timeQualPtr, timeStampPtr); } } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GLOBAL_TIME_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nE2x: 0\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '0x0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'timeQualPtr', 'Value': '&map_timeQualPtr[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'timeStampPtr', 'Value': '&map_timeStampPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'CtrlIdx', 'Name': 'x', 'Value': ''], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ETH_MODE_DOWN,\\nETH_MODE_ACTIVE,\\nETH_MODE_STANDBY', 'Name': 'enMode', 'Value': 'ETH_MODE_DOWN'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_timeQualPtr[0]', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_timeStampPtr[0]', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': 'E_OK'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': 'E_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': 'E_OK', 'Name': 'returnValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_GETCURRENTTIME_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '0x0'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ETH_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ETH_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ETH_GETCURRENTTIME_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ETH_E_INV_MODE'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'timeQualPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'timeStampPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'timeQualPtr', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'timeStampPtr', 'Value': '-'], 'Output_Param_012': ['Type': 'Return_Value', 'Range': '', 'Name': 'returnValue', 'Value': 'E_NOT_OK'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, ETH_PUBLIC_CODE) Eth_GetPhysAddr( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, P2VAR(uint8, AUTOMATIC, ETH_APPL_DATA) PhysAddrPtr) /* PRQA S 3432 # JV-01 */ { #if (ETH_DEV_ERROR_DETECT == STD_ON) Std_ReturnType LucReturnValue; LucReturnValue = Eth_CommonDetCheck(ETH_GETPHYSADDR_SID, CtrlIdx); /* Report Error to DET, if the PhysAddrPtr pointer value is NULL */ if (NULL_PTR == PhysAddrPtr) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_GETPHYSADDR_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; }/* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif /* (ETH_DEV_ERROR_DETECT == STD_ON) */ { ETH_UNPACK_ADDRESS_TO_8(Eth_GaaCtrlStat[CtrlIdx].stMacAddr, PhysAddrPtr); /* PRQA S 2824, 2844, 3469 # JV-01, JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nE2x: 0\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'PhysAddrPtr', 'Value': '&map_PhysAddrPtr[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '0..0xFFFFFFFF', 'Name': 'ulH32', 'Value': '[0] = 0UL'], 'Input_Param_004': ['Type': 'Array', 'Range': '0..0xFFFF', 'Name': 'ulL16', 'Value': '[0] =0UL'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_GETPHYSADDR_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '0'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'map_PhysAddrPtr[0 to 5]', 'Value': '[0] = 0x00\\n[1] = 0x00\\n[2] = 0x00\\n[3] = 0x00\\n[4] = 0x00\\n[5] = 0x00'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE)Eth_GetRxStats( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, P2VAR(Eth_RxStatsType, AUTOMATIC, ETH_APPL_DATA) RxStats) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_GETRXSTATS_SID, CtrlIdx); /* Report Error to DET, if the stherStats pointer value is NULL */ if (NULL_PTR == RxStats) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_GETRXSTATS_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { Eth_HwGetRxStats((uint32)CtrlIdx, RxStats); LucReturnValue = E_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GET_RX_STATS_API', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'RxStats', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_RxStats[0]', 'Value': '-'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRxStats', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRxStats', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '-']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE)Eth_GetRxStats( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, P2VAR(Eth_RxStatsType, AUTOMATIC, ETH_APPL_DATA) RxStats) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_GETRXSTATS_SID, CtrlIdx); /* Report Error to DET, if the stherStats pointer value is NULL */ if (NULL_PTR == RxStats) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_GETRXSTATS_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { Eth_HwGetRxStats((uint32)CtrlIdx, RxStats); LucReturnValue = E_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GET_RX_STATS_API', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'RxStats', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_RxStats[0]', 'Value': '-'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRxStats', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRxStats', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '-']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE)Eth_GetTxStats( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, P2VAR(Eth_TxStatsType, AUTOMATIC, ETH_APPL_DATA) TxStats) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_GETTXSTATS_SID, CtrlIdx); /* Report Error to DET, if the stherStats pointer value is NULL */ if (NULL_PTR == TxStats) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_GETTXSTATS_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { Eth_HwGetTxStats((uint32)CtrlIdx, TxStats); LucReturnValue = E_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GET_TX_STATS_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '2'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'TxStats', 'Value': '&map_TxStats[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_TxStats[0]', 'Value': '-'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_GETTXSTATS_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '2'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpTxStats', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpTxStats', 'Value': '-'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE)Eth_GetTxStats( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, P2VAR(Eth_TxStatsType, AUTOMATIC, ETH_APPL_DATA) TxStats) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_GETTXSTATS_SID, CtrlIdx); /* Report Error to DET, if the stherStats pointer value is NULL */ if (NULL_PTR == TxStats) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_GETTXSTATS_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { Eth_HwGetTxStats((uint32)CtrlIdx, TxStats); LucReturnValue = E_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GET_TX_STATS_API', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'TxStats', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_TxStats[0]', 'Value': '-'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpTxStats', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpTxStats', 'Value': '-'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '-']]]"}
{"Input": "/ FUNC(void, ETH_PRIVATE_CODE) Eth_HwRxIsrHandler( /* PRQA S 1505, 1503 # JV-01, JV-01 */ CONST(uint32, AUTOMATIC) LulCtrlIdx) { uint32 LulDescIdx; uint32 LulRD0; uint32 LulFrameLenByte; P2VAR(volatile Eth_ETNCRxDescriptorType, AUTOMATIC, ETH_VAR_NO_INIT) LpDesc; /* PRQA S 3432 # JV-01 */ #if (ETH_REGISTER_CHECK_RUNTIME == STD_ON) uint32 LulResult; uint32 LulExpectedRD0; /* Initialize the register error check result */ LulResult = 0UL; #endif /* EESR.FR flag is referred when interrupt mode only */ /* Clear Frame Receive Flag */ Eth_GaaETNCRegs[0]->ulEESR = ETH_ETNC_FR; /* PRQA S 2814 # JV-01 */ /* Do dummy read and SYNCP */ Eth_GaaETNCRegs[0]->ulEESR; EXECUTE_SYNCP(); /* Load the global var to the local var to improve performance */ LulDescIdx = Eth_GaaCtrlStat[LulCtrlIdx].stHwStat.ucRxDescIdxHead; /* PRQA S 2844 # JV-01 */ /* Scan received frames */ LulRD0 = Eth_GaaRxDescriptor[LulDescIdx].ulRD0; /* PRQA S 2844 # JV-01 */ /* When interrupt mode, scan all received frames */ while ((0UL == (LulRD0 & ETH_ETNC_RACT)) && (ETH_ETNC_RFL_WORKAROUND_VALUE != ETH_ETNC_RFL_GET(Eth_GaaRxDescriptor[LulDescIdx].ulRD1))) /* PRQA S 3469 # JV-01 */ { LpDesc = &Eth_GaaRxDescriptor[LulDescIdx]; /* PRQA S 2934 # JV-01 */ #if (ETH_REGISTER_CHECK_RUNTIME == STD_ON) /* Confirm RD0, RDLE has not be changed, RACT is cleared, RFP0, RFP1 are set by the HW */ if (((uint32)ETH_RX_BUF_TOTAL_0 - 1UL) == LulDescIdx) { LulExpectedRD0 = ETH_ETNC_RDLE | ETH_ETNC_RFP1 | ETH_ETNC_RFP0; } else { LulExpectedRD0 = ETH_ETNC_RFP1 | ETH_ETNC_RFP0; } LulResult |= ((LulExpectedRD0 ^ LpDesc->ulRD0) /* PRQA S 2844 # JV-01 */ & ETH_ETNC_RD0_CHECK_MASK); #endif /* (ETH_REGISTER_CHECK_RUNTIME == STD_ON) */ /* When the following error occurs, discard this frame: - CRC error - PHY-LSI receive error - Too long frame received - Too short frame received - Receive abort - Rx FIFO overflow The AUTOSAR only requires to discard a frame when CRC error occurs. However rx data is not available when the above errors occur, discard it also the above case. */ if (0UL != (LulRD0 & (ETH_ETNC_RFS9_RFOF | ETH_ETNC_RFS8_RABT | ETH_ETNC_RFS3_RTLF | ETH_ETNC_RFS2_RTSF | ETH_ETNC_RFS1_PRE | ETH_ETNC_RFS0_CERF))) { /* If any error occurred, discard this frame */ } else if ((0UL != (LulRD0 & ETH_ETNC_RFS7_RMAF)) #if (ETH_UPDATE_PHYS_ADDR_FILTER == STD_ON) && (0UL == Eth_GaaCtrlStat[LulCtrlIdx].ulActiveFilterBits) /* PRQA S 2844 # JV-01 */ && (ETH_FALSE == Eth_GaaCtrlStat[LulCtrlIdx].blPromiscuous) #endif ) { /* Discard multicast frames when the filtering is off */ } else { /* Indicate a frame to EthIf */ LulFrameLenByte = ETH_ETNC_RFL_GET(LpDesc->ulRD1); /* PRQA S 3469 # JV-01 */ /* The 2nd parameter is BufferIdx, it is same as DescIdx on Rx side */ Eth_RxIndication(LulCtrlIdx, LulDescIdx, LulFrameLenByte); } /* Set 0xFFFF to RFL field as the workaround */ LpDesc->ulRD1 = ETH_ETNC_RBL(ETH_INTERNAL_RX_BUFFER_BYTE) | /* PRQA S 3469 # JV-01 */ ETH_ETNC_RFL_WORKAROUND_VALUE; /* Set RACT bit to mark this descriptor is empty */ LpDesc->ulRD0 = (LpDesc->ulRD0 & ~ETH_ETNC_RFS_MASK) | ETH_ETNC_RACT; /* Increment the ring pointer */ LulDescIdx = (LulDescIdx + 1UL) % (uint32)ETH_RX_BUF_TOTAL_0; /* PRQA S 3383 # JV-01 */ /* Load RD0 of the next descriptor */ LulRD0 = Eth_GaaRxDescriptor[LulDescIdx].ulRD0; } /* Update the global var */ /* Since the maximum value of descriptor index is 254, casting to uint8 does no problem. */ Eth_GaaCtrlStat[LulCtrlIdx].stHwStat.ucRxDescIdxHead = (uint8)LulDescIdx; /* PRQA S 2844 # JV-01 */ /* If descriptor overflow has been occurred, the receive operation is stopped. Set RR bit hear in case of such case. */ Eth_GaaETNCRegs[LulCtrlIdx]->ulEDRRR = ETH_ETNC_RR; /* PRQA S 2844 # JV-01 */ #if (ETH_REGISTER_CHECK_RUNTIME == STD_ON) /* If any object didn't have expected values, set the error flag */ if (0UL != LulResult) { /* Set the flag, DEM error will be reported at the next MainFunction */ Eth_GaaCtrlStat[LulCtrlIdx].stHwStat.blErrDetected = ETH_TRUE; /* PRQA S 2844 # JV-01 */ } /* else: No action required */ #endif /* (ETH_REGISTER_CHECK_RUNTIME == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_REGISTER_CHECK_RUNTIME', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0', 'Name': 'LulCtrlIdx', 'Value': '0UL'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0..0x0F', 'Name': 'stHwStat.ucRxDescIdxHead', 'Value': '0x00'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'ulActiveFilterBits', 'Value': '0x00000000'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'ETH_FALSE, ETH_TRUE', 'Name': 'blPromiscuous', 'Value': 'ETH_FALSE'], 'Input_Param_005': ['Type': 'Array', 'Range': '0..0xFFFFFFFF', 'Name': 'ulRD0', 'Value': '[0] = 0x00000080\\n[1] = 0xFFFFFFFF'], 'Input_Param_006': ['Type': 'Array', 'Range': '0..0xFFFFFFFF', 'Name': 'ulRD1', 'Value': '[0] = 0x00000000']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulEESR', 'Value': 'ETH_ETNC_FR'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulEDRRR', 'Value': 'ETH_ETNC_RR'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxDescIdxHead', 'Value': '0x01'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'blErrDetected', 'Value': '-'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulRD0', 'Value': '[0] = ETH_ETNC_RACT'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ulRD1', 'Value': '[0] = 0x0600FFFF'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFrameLenByte', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PRIVATE_CODE) Eth_Hw_Avb_SingleDescFrameSend( /* PRQA S 1532 # JV-01 */ CONST(uint32, AUTOMATIC) LulCtrlIdx, CONSTP2VAR(Eth_BufHandlerType, AUTOMATIC, ETH_APPL_DATA) LpTxBufHdr) /* PRQA S 3432, 3673 # JV-01, JV-01 */ { uint32 LulBufIdx; Std_ReturnType LucTxBufferProvide; P2VAR(Eth_DataDescType, AUTOMATIC, ETH_APPL_DATA) LpDataDesc; /* PRQA S 3432 # JV-01 */ Eth_TxRxCtrl LunTxCtrl; /* PRQA S 0759 # JV-01 */ Std_ReturnType LucReturnValue; LucTxBufferProvide = E_NOT_OK; LucReturnValue = E_OK; /* Get next free descriptor */ LpDataDesc = (P2VAR(Eth_DataDescType, AUTOMATIC, ETH_APPL_DATA)) /* PRQA S 0306, 3432 # JV-01, JV-01 */ Eth_GaaCtrlStat[LulCtrlIdx].stHwStat.aaLastTxDesc[LpTxBufHdr->enChannel]; /* PRQA S 2844, 2814 # JV-01, JV-01 */ if (0UL != LpDataDesc->ulDptr) /* PRQA S 2844, 2814 # JV-01, JV-01 */ { /* Check previous TxBuffer release status (The memory leak protect) */ LulBufIdx = (uint32)((LpDataDesc->stHeader.ulCtrl) & ETH_DESCR_TAG_MASK); LucTxBufferProvide = Eth_CheckProvideBuffer(LulCtrlIdx, LulBufIdx); } /* else: No action required */ if ((ETH_DESC_FEMPTY == LpDataDesc->stHeader.ulDt) && (E_NOT_OK == LucTxBufferProvide)) { LunTxCtrl.ulWord = 0UL; if (ETH_TRUE == LpTxBufHdr->blbenableTS) { LunTxCtrl.stTxCtrl.ulTsr = ETH_DESC_RETAIN_TS; } /* else: No action required */ /* Justify typecast to smaller datatype */ LunTxCtrl.stTxCtrl.ulTag = LpTxBufHdr->ulbufIdx; /* build the descriptor */ LpDataDesc->stHeader.ulDt = ETH_DESC_FSINGLE; LpDataDesc->stHeader.ulDie = (uint32)LpTxBufHdr->enChannel + 1UL; /* PRQA S 3383 # JV-01 */ LpDataDesc->stHeader.ulCtrl = LunTxCtrl.ulWord; LpDataDesc->stHeader.ulDs = LpTxBufHdr->ulTxLength; LpDataDesc->ulDptr = LpTxBufHdr->ulbufAddr; /* Set next descriptor */ LpDataDesc++; /* PRQA S 0489, 2824, 2934 # JV-01, JV-01, JV-01 */ while ((LpDataDesc->stHeader.ulDt == ETH_DESC_LINKFIX) || (LpDataDesc->stHeader.ulDt == ETH_DESC_LINK)) /* PRQA S 2844, 2814 # JV-01, JV-01 */ { LpDataDesc = (P2VAR(Eth_DataDescType, AUTOMATIC, ETH_APPL_DATA)) LpDataDesc->ulDptr; /* PRQA S 0306, 3432, 2844, 2814 # JV-01, JV-01, JV-01, JV-01 */ } Eth_GaaCtrlStat[LulCtrlIdx].stHwStat.aaLastTxDesc[LpTxBufHdr->enChannel] = (uint32)LpDataDesc; /* PRQA S 0306, 2844 # JV-01, JV-01 */ ETH_ENTER_CRITICAL_SECTION(ETH_RAM_DATA_PROTECTION); /* PRQA S 3138, 3141 # JV-01, JV-01 */ /* Increase the number of buffer of current Tx queue */ Eth_GaaCtrlStat[LulCtrlIdx].stHwStat.aaBufTxCnt[LpTxBufHdr->enChannel]++; /* PRQA S 2844, 2883, 3383, 3387 # JV-01, JV-01, JV-01, JV-01 */ ETH_EXIT_CRITICAL_SECTION(ETH_RAM_DATA_PROTECTION); /* PRQA S 3138, 3141 # JV-01, JV-01 */ /* Transmit start request */ Eth_GaaAVBRegs[LulCtrlIdx]->ulTCCR |= (uint32)(1UL << (uint32)LpTxBufHdr->enChannel); /* PRQA S 2814, 2844 # JV-01, JV-01 */ } else { LucReturnValue = E_NOT_OK; } return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '-', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpTxBufHdr', 'Value': '&map_LpTxBufHdr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enChannel', 'Value': 'ETH_TX_NC'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'blbenableTS', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulbufIdx', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulTxLength', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulbufAddr', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'stHwStat.aaLastTxDesc[ 0 to 3]', 'Value': '[1] = &map_LpDataDesc[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'stHwStat.aaBufTxCnt[0 to 3]', 'Value': '[1] = 0'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ulDptr', 'Value': '[0] = 0xFFFFFFFE'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'stHeader.ulCtrl', 'Value': '[0] = ETH_DESCR_TAG_MASK'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'stHeader.ulDt', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulTCCR', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'stHeader.ulDt', 'Value': 'ETH_DESC_FEMPTY'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_ulbufAddr[0]', 'Value': '-'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'ETH_DESCR_TAG_MASK'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_004': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'stHeader.ulDt ', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'stHeader.ulDie ', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'stHeader.ulCtrl', 'Value': 'ETH_DESCR_TAG_MASK'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'stHeader.ulDs', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulDptr', 'Value': '0xFFFFFFFE'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'stHwStat.aaLastTxDesc[0 to 3]', 'Value': '[1] = &map_LpDataDesc[0]'], 'Output_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'stHwStat.aaBufTxCnt[0 to 3]', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulTCCR', 'Value': '-'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC (void, ETH_PRIVATE_CODE) Eth_Hw_Avb_WriteIntoSFPReg( CONST(uint32,AUTOMATIC) LulCtrlIdx, CONSTP2CONST(uint8, AUTOMATIC, ETH_APPL_DATA) LpMacAddrPtr, /* PRQA S 3432 # JV-01 */ CONST(uint8,AUTOMATIC) LucQueueIdx) { uint32 LulValHigh; uint32 LulValLow; uint32 LulVal; uint8 LucSFPidx; /* PRQA S 3204 # JV-01 */ / Little Endian Core / LucSFPidx = LucQueueIdx - ETH_RX_QUEUE_INDEX_AVAILABLE_FILTER; /* PRQA S 3383 # JV-01 */ /* Write into SFP1,3,...31 */ if (ETH_ENABLE == Eth_GaaAvbConfig[LulCtrlIdx].stRxConfig.enSRPTalkerFiltering) /* PRQA S 2844 # JV-01 */ { LulValHigh = ((uint32)LpMacAddrPtr[5] << 8U) | ((uint32)LpMacAddrPtr[4]); /* PRQA S 3120, 0492, 2824 # JV-01, JV-01, JV-01 */ } else { LulValHigh = ((uint32)LpMacAddrPtr[7] << 24U) | ((uint32)LpMacAddrPtr[6] << 16U) | ((uint32)LpMacAddrPtr[5] << 8U) | ((uint32)LpMacAddrPtr[4]); /* PRQA S 3120, 0492 # JV-01, JV-01 */ } /* Write into SFP0,2,..30 */ LulValLow = ((uint32)LpMacAddrPtr[3] << 24U) | ((uint32)LpMacAddrPtr[2] << 16U) | ((uint32)LpMacAddrPtr[1] << 8U) | ((uint32)LpMacAddrPtr[0]); /* PRQA S 3120, 0492 # JV-01, JV-01 */ /* Read Opc */ if (ETH_OPERATION == Eth_GaaCtrlStat[LulCtrlIdx].stHwStat.enDevStatus) /* PRQA S 2844 # JV-01 */ { Eth_GaaAVBRegs[LulCtrlIdx]->ulSFV[0] = LulValLow; /* PRQA S 2844, 2814 # JV-01, JV-01 */ Eth_GaaAVBRegs[LulCtrlIdx]->ulSFV[1] = LulValHigh; /* Check it can be updated */ do { LulVal = Eth_GaaAVBRegs[LulCtrlIdx]->ulSFL; } while (ETH_NO_LOAD_REQ != (LulVal & ETH_SFL_MASK)); /* SFP update request */ LulVal = (uint32)LucSFPidx; Eth_GaaAVBRegs[LulCtrlIdx]->ulSFL = LulVal; } else { Eth_GaaAVBRegs[LulCtrlIdx]->ulSFP[ETH_AVB_GET_LOW_SFPi(LucSFPidx)] = LulValLow; /* PRQA S 3383, 3469 # JV-01, JV-01 */ Eth_GaaAVBRegs[LulCtrlIdx]->ulSFP[ETH_AVB_GET_HIGH_SFPi(LucSFPidx)] = LulValHigh; /* PRQA S 3383, 3469 # JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '-', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpMacAddrPtr', 'Value': '&map_LpMacAddrPtr[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucQueueIdx', 'Value': '2'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'map_LpMacAddrPtr[0 to 7]', 'Value': '[0 to 7] = 1'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'stRxConfig.enSRPTalkerFiltering', 'Value': '[0] = ETH_DISABLE'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ulSFL', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '-', 'Name': 'stHwStat.enDevStatus', 'Value': '[0] = ETH_CONFIG']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'ulSFV[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'ulSFV[1]', 'Value': '-'], 'Output_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'ulSFL', 'Value': '-'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ulSFP[0 to 5]', 'Value': '[0][0 to 1] = 1'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(boolean, ETH_PRIVATE_CODE) Eth_Hw_Etnb_RxQueueProcess( /* PRQA S 1505, 1532 # JV-01, JV-01 */ CONST(uint32, AUTOMATIC) LulCtrlIdx, CONST(uint8, AUTOMATIC) LucQidx) { uint32 LulDescAddr; boolean LblRxFrameValid; P2CONST(Eth_RxChConfigType, AUTOMATIC, ETH_APPL_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ #if (ETH_GET_RX_STATS_API == STD_ON) uint32 LulLengthWithFCS; #endif #if (ETH_ETHSWITCH_MANAGEMENT_SUPPORT == STD_ON) Eth_BufIdxType LulBufIdx; P2VAR(uint8, AUTOMATIC, ETH_APPL_DATA) LpDataPtr; /* PRQA S 3432 # JV-01 */ boolean LblIsMgmtFrameOnlyPtr; uint16 LusLength; Std_ReturnType LucReturnValue; #endif LblRxFrameValid = ETH_TRUE; /*Get Rx queue configuration */ LpChConfig = &Eth_GaaRxConfig[LucQidx]; /* PRQA S 2934 # JV-01 */ LulDescAddr = Eth_GaaCtrlStat[LulCtrlIdx].stHwStat.aaNextRxDesc[LpChConfig->ucChNum]; /* PRQA S 2844 # JV-01 */ if (ETH_BECHANNEL == LpChConfig->ucChNum) { /* best effort channel */ RxBeProcess(LulCtrlIdx, &Eth_GaaRxFrame[LulCtrlIdx], LulDescAddr); /* PRQA S 2934 # JV-01 */ #if (ETH_UPDATE_PHYS_ADDR_FILTER == STD_ON) /* check whether received frame is valid or not */ LblRxFrameValid = IsRxFrameValid(LulCtrlIdx, &Eth_GaaRxFrame[LulCtrlIdx]); /* PRQA S 2934 # JV-01 */ #endif } else if (ETH_NCCHANNEL == LpChConfig->ucChNum) { /* network control channel */ RxNcProcess(LulCtrlIdx, &Eth_GaaRxFrame[LulCtrlIdx], LulDescAddr); } else { /* stream channel */ RxSProcess(LulCtrlIdx, &Eth_GaaRxFrame[LulCtrlIdx], (uint32)LpChConfig->ucChNum, LulDescAddr); #if (ETH_UPDATE_PHYS_ADDR_FILTER == STD_ON) /* check whether received frame is valid or not */ LblRxFrameValid = IsRxFrameValid(LulCtrlIdx, &Eth_GaaRxFrame[LulCtrlIdx]); /* PRQA S 2934 # JV-01 */ #endif } /* Decrement ETNBnUFCD.DVr by 1 */ Eth_GaaETNBRegs[LulCtrlIdx]->ulUFCD[ETH_ETNB_GET_UFCDi(LucQidx)] = ETH_ETNB_SET_UFCDi_DVr(1UL, LucQidx); /* PRQA S 2844, 2814, 3469, 3384 # JV-01, JV-01, JV-01, JV-01 */ if (ETH_TRUE == LblRxFrameValid) { #if (ETH_GET_RX_STATS_API == STD_ON) Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulRxStatsPkts++; /* PRQA S 2844, 3383 # JV-01, JV-01 */ LulLengthWithFCS = Eth_GaaRxFrame[LulCtrlIdx].ulFrameLength + ETH_FCS_LENGTH; /* PRQA S 2844, 3383 # JV-01, JV-01 */ Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulRxStatsOctets += LulLengthWithFCS; /* PRQA S 2844, 3383 # JV-01, JV-01 */ if (LulLengthWithFCS <= 64UL) { /* Since the receive data size that does not include padding data is set in the receive descriptor, frames of 64 or less are collected by the statistical counter. */ Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulRxStatsPkts64Octets++; /* PRQA S 2844, 3383 # JV-01, JV-01 */ } else if (LulLengthWithFCS <= 127UL) { Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulRxStatsPkts65to127Octets++; /* PRQA S 3383 # JV-01 */ } else if (LulLengthWithFCS <= 255UL) { Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulRxStatsPkts128to255Octets++; /* PRQA S 3383 # JV-01 */ } else if (LulLengthWithFCS <= 511UL) { Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulRxStatsPkts256to511Octets++; /* PRQA S 3383 # JV-01 */ } else if (LulLengthWithFCS <= 1023UL) { Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulRxStatsPkts512to1023Octets++; /* PRQA S 3383 # JV-01 */ } else { /* When VLAN tag is supported, the maximum data size is 1522. */ /* The maximum frame size that HW can receive is set to 1522. */ Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulRxStatsPkts1024to1518Octets++; /* PRQA S 3383 # JV-01 */ } #endif #if (ETH_ETHSWITCH_MANAGEMENT_SUPPORT == STD_ON) LulBufIdx = *(P2VAR(Eth_BufIdxType, AUTOMATIC, ETH_APPL_DATA)) /* PRQA S 0306, 2814, 3432 # JV-01, JV-01, JV-01 */ (Eth_GaaRxFrame[LulCtrlIdx].ulFrameAddr - sizeof(Eth_BufIdxType) - ETH_RX_DPTR_OFFSET); /* PRQA S 3383, 3384 # JV-01, JV-01 */ LpDataPtr = (P2VAR(uint8, AUTOMATIC, ETH_APPL_DATA))Eth_GaaRxFrame[LulCtrlIdx].ulEthTypeAddr; /* PRQA S 0306, 3432 # JV-01, JV-01 */ /* Since the maximum value of buffer size is 1518, casting to uint16 does no problem. */ LusLength = (uint16)(Eth_GaaRxFrame[LulCtrlIdx].ulFrameLength - ETH_HEADER_SIZE); /* PRQA S 3383 # JV-01 */ LblIsMgmtFrameOnlyPtr = ETH_FALSE; /* Since the maximum value of controller index is 1, casting to uint8 does no problem. */ LucReturnValue = EthSwt_EthRxProcessFrame((uint8)LulCtrlIdx, LulBufIdx, &LpDataPtr, &LusLength, &LblIsMgmtFrameOnlyPtr); if (E_OK == LucReturnValue) { Eth_GaaRxFrame[LulCtrlIdx].ulEthTypeAddr = (uint32)LpDataPtr; /* PRQA S 0306, 2844 # JV-01, JV-01 */ Eth_GaaRxFrame[LulCtrlIdx].ulFrameLength = (uint32)(LusLength + ETH_HEADER_SIZE); /* PRQA S 3383, 2844 # JV-01, JV-01 */ if (ETH_FALSE == LblIsMgmtFrameOnlyPtr) { /* Call EthIf if the Frame Received is valid */ RxCallEthIf(LulCtrlIdx, &Eth_GaaRxFrame[LulCtrlIdx]); /* PRQA S 2934 # JV-01 */ } else { /* Must not be the Rx processed */ /* Since the maximum value of controller index is 1, casting to uint8 does no problem. */ (void)EthSwt_EthRxFinishedIndication((uint8)LulCtrlIdx, LulBufIdx); } } else { /* Normal operation if E_NOT_OK */ RxCallEthIf(LulCtrlIdx, &Eth_GaaRxFrame[LulCtrlIdx]); /* PRQA S 2934 # JV-01 */ } #else /* Call EthIf if the Frame Received is valid */ RxCallEthIf(LulCtrlIdx, &Eth_GaaRxFrame[LulCtrlIdx]); /* PRQA S 2934 # JV-01 */ #endif } /* else: No action required */ /* update descriptor chain */ (void)RxDescChainUpdate(LulCtrlIdx, LulDescAddr, LpChConfig); return LblRxFrameValid; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '-', 'Name': 'ETH_ETHSWITCH_MANAGEMENT_SUPPORT\\nETH_UPDATE_PHYS_ADDR_FILTER', 'Value': 'STD_OFF\\nSTD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '-', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '-', 'Name': 'LucQidx', 'Value': '0'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ucChNum', 'Value': '[0] = ETH_BECHANNEL'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'stHwStat.aaNextRxDesc[0 to 2]', 'Value': '[0] = &map_LulDescAddr[0]'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': 'ETH_FALSE'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'LpSingleRxFramePtr->ulFrameAddr', 'Value': 'map_LstRxFrame[0].ulFrameAddr'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'LpSingleRxFramePtr->ulFrameLength', 'Value': 'map_LstRxFrame[0].ulFrameLength'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'LpSingleRxFramePtr->ulFrameAddr', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'LpSingleRxFramePtr->ulFrameLength', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'LpSingleRxFramePtr->ulFrameAddr', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'LpSingleRxFramePtr->ulFrameLength', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*IsMgmtFrameOnlyPtr', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFrameAddr', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFrameAddr', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFrameLength', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_LulDescAddr[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFrameLength', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsOctets', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts64Octets', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts65to127Octets', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts128to255Octets', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts256to511Octets', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts512to1023Octets', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts1024to1518Octets', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSingleRxFramePtr', 'Value': '&Eth_GaaRxFrame[0]'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDescPtr', 'Value': '&map_LulDescAddr[0]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSingleRxFramePtr', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDescPtr', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSingleRxFramePtr', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulChannelNum', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDescPtr', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRxFrame', 'Value': '&Eth_GaaRxFrame[0]'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'BufIdx', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': '**DataPtr', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': '*LengthPtr', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpFrame', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDescPtr', 'Value': '&map_LulDescAddr[0]'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '&Eth_GaaRxConfig[0]'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_Eth_GaaETNBRegs[CURRENT_TEST.LulCtrlIdx].ulUFCD[0]', 'Value': '1 << 0'], 'Output_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts', 'Value': '-'], 'Output_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsOctets', 'Value': '-'], 'Output_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts64Octets', 'Value': '-'], 'Output_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts65to127Octets', 'Value': '-'], 'Output_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts128to255Octets', 'Value': '-'], 'Output_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts256to511Octets', 'Value': '-'], 'Output_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts512to1023Octets', 'Value': '-'], 'Output_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ulRxStatsPkts1024to1518Octets', 'Value': '-'], 'Output_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ulEthTypeAddr', 'Value': '-'], 'Output_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'ulFrameLength', 'Value': '-'], 'Output_Param_034': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'ETH_FALSE'], 'Output_Param_035': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, ETH_PUBLIC_CODE) Eth_Init( /* PRQA S 1503, 1532 # JV-01, JV-01 */ P2CONST(Eth_ConfigType, AUTOMATIC, ETH_APPL_CONST) CfgPtr) /* PRQA S 3432 # JV-01 */ { uint32 LulCtrlIdx; Std_ReturnType LucResult; LucResult = E_OK; /* PRQA S 2982 # JV-01 */ #if (ETH_DEV_ERROR_DETECT == STD_ON) if (NULL_PTR == CfgPtr) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_INIT_SID, ETH_E_PARAM_POINTER); } /* Check whether the existing database is correct */ else if (ETH_DBTOC_VALUE != CfgPtr->ulStartOfDbToc) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_INIT_SID, ETH_E_INVALID_DATABASE); } else #endif /* (ETH_DEV_ERROR_DETECT == STD_ON) */ { /* Assign the config pointer value to global pointer */ Eth_GpCtrlConfigPtr = CfgPtr->pCtrlConfig; /* PRQA S 2814 # JV-01 */ Eth_GpEthConfigPtr = Eth_GpCtrlConfigPtr->pEthConfig; /* PRQA S 2814 # JV-01 */ #ifdef ETH_HW_COMMON_INIT LucResult = Eth_HwCommonInit(); for (LulCtrlIdx = 0UL; (LulCtrlIdx < (uint32)ETH_TOTAL_CTRL_CONFIG) && (E_NOT_OK == LucResult); LulCtrlIdx++) /* PRQA S 2877 # JV-01 */ { Eth_DemConfigCheck(Eth_GaaDemEventAccess[LulCtrlIdx], DEM_EVENT_STATUS_PREFAILED); } #endif for (LulCtrlIdx = 0UL; (LulCtrlIdx < (uint32)ETH_TOTAL_CTRL_CONFIG) && (E_OK == LucResult); LulCtrlIdx++) /* PRQA S 2877 # JV-01 */ { /* Copy the configured MAC address as inital value */ ETH_PACK_ADDRESS_FROM_8(Eth_GpCtrlConfigPtr[LulCtrlIdx].aaEthMACAddr, /* PRQA S 2824, 3469, 3464 # JV-01, JV-01, JV-01 */ Eth_GaaCtrlStat[LulCtrlIdx].stMacAddr); /* Initialize controller state as DOWN */ Eth_GaaCtrlStat[LulCtrlIdx].enMode = ETH_MODE_DOWN; /* Initialize address filter */ #if (ETH_UPDATE_PHYS_ADDR_FILTER == STD_ON) Eth_ClearAllAddressFilters(LulCtrlIdx); #endif /* Initialize Tx/Rx buffer pool */ Eth_InitializeBuffer(LulCtrlIdx); /* Initialize low-level driver */ LucResult = Eth_HwInit(LulCtrlIdx); if (E_OK == LucResult) { /* Report PASS to DEM */ Eth_DemConfigCheck(Eth_GaaDemEventAccess[LulCtrlIdx], DEM_EVENT_STATUS_PREPASSED); } else { Eth_DemConfigCheck(Eth_GaaDemEventAccess[LulCtrlIdx], DEM_EVENT_STATUS_PREFAILED); } } if (E_OK == LucResult) { /* Initialize the Driver State to INIT */ Eth_SetStatus(ETH_STATE_INIT); } /* else: No action required */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_UPDATE_PHYS_ADDR_FILTER', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'CfgPtr', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'ulStartOfDbToc', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '!=NULL', 'Name': 'pCtrlConfig', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '!=NULL', 'Name': 'pEthConfig', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '0..0xFF', 'Name': 'aaEthMACAddr[0 to 5]', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '!=NULL', 'Name': 'pEthConfig', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '0..0xFF', 'Name': 'aaEthMACAddr[0 to 5]', 'Value': '-'], 'Input_Param_009': ['Type': 'Array', 'Range': '0..0xFF', 'Name': 'aaEthMACAddr[0 to 5]', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '0x00..0xFF', 'Name': 'Eth_GaaDemEventAccess[0 to 2]', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEthConfig[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenStatus', 'Value': '-'], 'Output_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'Eth_GpCtrlConfigPtr', 'Value': '-'], 'Output_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'Eth_GpEthConfigPtr', 'Value': '-'], 'Output_Param_035': ['Type': 'Array', 'Range': '', 'Name': 'stMacAddr.ulH32', 'Value': '-'], 'Output_Param_036': ['Type': 'Array', 'Range': '', 'Name': 'stMacAddr.ulL16', 'Value': '-'], 'Output_Param_037': ['Type': 'Array', 'Range': '', 'Name': 'enMode', 'Value': '-'], 'Output_Param_038': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, ETH_PUBLIC_CODE) Eth_MainFunction(void) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { Eth_StateType LenState; LenState = Eth_GenDriverState; if (ETH_STATE_INIT != LenState) { /* No Action required */ } else { /* Error check and device specific operations */ Eth_HwMainFunction(); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': 'ETH_STATE_UNINIT,\\nETH_STATE_INIT', 'Name': 'Eth_GenDriverState', 'Value': 'ETH_STATE_INIT']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, ETH_PRIVATE_CODE) Eth_RemoveAddressFilter( /* PRQA S 1532 # JV-01 */ CONST(uint32, AUTOMATIC) LulCtrlIdx, CONST(uint32, AUTOMATIC) LulFilterIdx) { /* Clear an active bit */ Eth_GaaCtrlStat[LulCtrlIdx].ulActiveFilterBits &= ~(1UL << LulFilterIdx); /* PRQA S 2844 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..31', 'Name': 'LulFilterIdx', 'Value': '30'], 'Input_Param_002': ['Type': 'Array', 'Range': '0..0xFFFFFFFF', 'Name': 'ulActiveFilterBits', 'Value': '[0] = 0xFFFFFFFF']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'ulActiveFilterBits', 'Value': '[0] = 0xBFFFFFFF'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, ETH_PRIVATE_CODE) Eth_RxIndication( /* PRQA S 1532 # JV-01 */ CONST(uint32, AUTOMATIC) LulCtrlIdx, CONST(uint32, AUTOMATIC) LulBufferIdx, CONST(uint32, AUTOMATIC) LulLenByte) { Eth_MacAddressType LstDstAddress; boolean LblBroadcast; Eth_FrameType LusFrameType; #if (ETH_UPDATE_PHYS_ADDR_FILTER == STD_ON) boolean LblPass; uint32 LulFilterIdx; uint32 LulRemainBits; #endif /* Pack MAC address from BYTE to WORD to quicken comparing operation */ ETH_PACK_ADDRESS_FROM_8(&Eth_GaaRxBuffer[LulCtrlIdx][LulBufferIdx][ETH_DST_MACADDR_OFFSET], LstDstAddress); /* PRQA S 0404, 3469, 3464, 2844 # JV-01, JV-01, JV-01, JV-01 */ /* Check whether broadcast */ /* Since this value is passed to EthIf, use TRUE/FALSE instead of ETH_TRUE/ETH_FALSE */ if (0UL == ETH_COMPARE_MAC(LstDstAddress, Eth_GstBroadcastAddr)) /* PRQA S 3469 # JV-01 */ { LblBroadcast = (boolean)TRUE; /* Increment the total number of bradcast frames */ #if (ETH_GET_ETHER_STATS_API == STD_ON) if (Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulStatsBroadcastPkts < ETH_UINT32_MAXVALUE) /* PRQA S 2844 # JV-01 */ { Eth_GaaCtrlStat[LulCtrlIdx].stTxRxStat.ulStatsBroadcastPkts++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } /* else: No action required */ #endif } else { LblBroadcast = (boolean)FALSE; } #if (ETH_UPDATE_PHYS_ADDR_FILTER == STD_ON) LblPass = ETH_FALSE; /* In the following case, accept unconditionally: - Filtering is off (unicast only, multicast is discarded by LLDriver) - Promiscuous mode - Broadcast frame */ if ((0UL == Eth_GaaCtrlStat[LulCtrlIdx].ulActiveFilterBits) || /* PRQA S 2844 # JV-01 */ (ETH_TRUE == Eth_GaaCtrlStat[LulCtrlIdx].blPromiscuous) || ((boolean)TRUE == LblBroadcast)) { LblPass = ETH_TRUE; } else { /* When unicast frame for this node, accept it */ if (0UL == ETH_COMPARE_MAC(LstDstAddress, Eth_GaaCtrlStat[LulCtrlIdx].stMacAddr)) /* PRQA S 3469, 3464 # JV-01, JV-01 */ { LblPass = ETH_TRUE; } else { /* Otherwise, do the filter operation */ /* To skip empty filters efficiently, copy active bits to the local var */ LulRemainBits = Eth_GaaCtrlStat[LulCtrlIdx].ulActiveFilterBits; LulFilterIdx = 0UL; /* Loop until any filter hits or pass all active filters */ while ((0UL != LulRemainBits) && (LblPass == ETH_FALSE)) { if ((0UL != (LulRemainBits & (1UL << LulFilterIdx))) && /* PRQA S 0404 # JV-01 */ (0UL == ETH_COMPARE_MAC(LstDstAddress, Eth_GaaAddressFilters[LulCtrlIdx][LulFilterIdx]))) /* PRQA S 3469, 3464, 2844 # JV-01, JV-01, JV-01 */ { LblPass = ETH_TRUE; } /* else: No action required */ /* Clear the compared filter bit */ LulRemainBits &= ~(1UL << LulFilterIdx); LulFilterIdx++; /* PRQA S 3383 # JV-01 */ } } } if (ETH_FALSE == LblPass) { /* Discard this frame */ } else #endif /* (ETH_UPDATE_PHYS_ADDR_FILTER == STD_ON) */ { /* Get FrameType with little endian */ /* Since the frame type is 16bit, casting to uint16 does no problem. */ LusFrameType = (uint16)((uint32)Eth_GaaRxBuffer[LulCtrlIdx][LulBufferIdx][ETH_FRAMETYPE_OFFSET] << (uint32)ETH_BYTE_BITS); LusFrameType |= Eth_GaaRxBuffer[LulCtrlIdx][LulBufferIdx][ETH_FRAMETYPE_OFFSET + 1UL]; /* Indicate to the upper layer */ /* Since the maximum value of buffer size is 1518, casting to uint16 does no problem. */ /* Since the maximum value of controller index is 1, casting to uint8 does no problem. */ EthIf_RxIndication((uint8)LulCtrlIdx, LusFrameType, LblBroadcast, (P2CONST(uint8, AUTOMATIC, ETH_APPL_DATA)) &Eth_GaaRxBuffer[LulCtrlIdx][LulBufferIdx][ETH_SRC_MACADDR_OFFSET], /* PRQA S 0312 # JV-01 */ (P2VAR(Eth_DataType, AUTOMATIC, ETH_APPL_DATA)) &Eth_GaaRxBuffer[LulCtrlIdx][LulBufferIdx][ETH_PAYLOAD_OFFSET], /* PRQA S 0312, 3432 # JV-01, JV-01 */ (uint16)(LulLenByte - (uint32)ETH_HEADER_SIZE)); /* PRQA S 3383 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_GET_ETHER_STATS_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_UPDATE_PHYS_ADDR_FILTER', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..0x0F', 'Name': 'LulBufferIdx', 'Value': '0x00'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..0xFFFFFFFF', 'Name': 'LulLenByte', 'Value': '0x00000000'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'LulBufferIdx', 'Name': 'x', 'Value': ''], 'Input_Param_006': ['Type': 'Array', 'Range': '0..0xFF', 'Name': 'Eth_GaaRxBuffer[0][CURRENT_TEST.x][0 to 16]', 'Value': '[2 to 7] = 0xFF\\n[14] = 0x00\\n[15] = 0x00'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'stTxRxStat.ulStatsBroadcastPkts', 'Value': '0x00000000'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'ulActiveFilterBits', 'Value': '0x00000001'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ETH_TRUE, ETH_FALSE', 'Name': 'blPromiscuous', 'Value': 'ETH_FALSE'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'ulH32', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0..0xFFFF', 'Name': 'ulL16', 'Value': '-'], 'Input_Param_012': ['Type': 'Array', 'Range': '0..0xFFFFFFFF', 'Name': 'ulH32', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '0..0xFFFF', 'Name': 'ulL16', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulStatsBroadcastPkts', 'Value': '0x00000001'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': '0'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'FrameType', 'Value': '0x0000'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'IsBroadcast', 'Value': '(boolean)TRUE'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'PhysAddrPtr', 'Value': '&Eth_GaaRxBuffer[0][0][ETH_SRC_MACADDR_OFFSET]'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'DataPtr', 'Value': '&Eth_GaaRxBuffer[0][0][ETH_PAYLOAD_OFFSET]'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenByte', 'Value': '0xFFF2'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE) Eth_SetControllerMode( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, Eth_ModeType CtrlMode) { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_SETCONTROLLERMODE_SID, CtrlIdx); #if (ETH_AR_VERSION == ETH_AR_R22_11_VERSION) /* Report Error to DET, if the given mode is invalid */ if ((ETH_MODE_ACTIVE != CtrlMode) && (ETH_MODE_DOWN != CtrlMode) && (ETH_MODE_STANDBY != CtrlMode)) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_SETCONTROLLERMODE_SID, ETH_E_INV_MODE); LucReturnValue = E_NOT_OK; } /* else: No action required */ #endif /* ETH_AR_VERSION == ETH_AR_R22_11_VERSION */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { LucReturnValue = E_OK; if (Eth_GaaCtrlStat[CtrlIdx].enMode != CtrlMode) /* PRQA S 2844 # JV-01 */ { if (ETH_MODE_ACTIVE == CtrlMode) { /* Activate HW */ LucReturnValue = Eth_HwEnableController((uint32)CtrlIdx); if (E_OK == LucReturnValue) { /* Set source MAC address to all Tx Buffers in advance */ Eth_PreprocessBuffer((uint32)CtrlIdx); /* To prevent MainFunction be executed during the transition, set the controller state as ACTIVE after the transition. */ Eth_GaaCtrlStat[CtrlIdx].enMode = ETH_MODE_ACTIVE; /* PRQA S 2844 # JV-01 */ } else { Eth_DemConfigCheck(Eth_GaaDemEventAccess[CtrlIdx], DEM_EVENT_STATUS_PREFAILED); /* PRQA S 2844 # JV-01 */ } } else { /* To prevent MainFunction be executed during the transition, set the controller state as DOWN before the transition. */ Eth_GaaCtrlStat[CtrlIdx].enMode = CtrlMode; /* PRQA S 2844 # JV-01 */ /* Stop HW */ LucReturnValue = Eth_HwDisableController((uint32)CtrlIdx); /* Retreive all provided Tx Buffers */ if (E_OK == LucReturnValue) { Eth_InitializeBuffer((uint32)CtrlIdx); } else { Eth_DemConfigCheck(Eth_GaaDemEventAccess[CtrlIdx], DEM_EVENT_STATUS_PREFAILED); /* PRQA S 2844 # JV-01 */ } } if (E_OK == LucReturnValue) { /* Since this function is implemented as synchronous, indicate a mode switch to EthIf here */ EthIf_CtrlModeIndication(CtrlIdx, CtrlMode); Eth_DemConfigCheck(Eth_GaaDemEventAccess[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ Eth_DemConfigCheck(Eth_GaaDemEventRxFramesLost[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ Eth_DemConfigCheck(Eth_GaaDemEventCRC[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ Eth_DemConfigCheck(Eth_GaaDemEventUnderSizeFrame[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ Eth_DemConfigCheck(Eth_GaaDemEventOverSizeFrame[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ Eth_DemConfigCheck(Eth_GaaDemEventAlignment[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ Eth_DemConfigCheck(Eth_GaaDemEventSinglecollision[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ Eth_DemConfigCheck(Eth_GaaDemEventMultiplecollision[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ Eth_DemConfigCheck(Eth_GaaDemEventLatecollision[CtrlIdx], DEM_EVENT_STATUS_PREPASSED); /* PRQA S 2844 # JV-01 */ } /* else: No action required */ } /* else: No action required */ } return(LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nE2x: 0\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'ETH_MODE_DOWN,\\nETH_MODE_ACTIVE,\\nETH_MODE_STANDBY', 'Name': 'CtrlMode', 'Value': 'ETH_MODE_STANDBY'], 'Input_Param_003': ['Type': 'Array', 'Range': 'ETH_MODE_DOWN,\\nETH_MODE_ACTIVE,\\nETH_MODE_STANDBY', 'Name': 'enMode', 'Value': '[1] = ETH_MODE_ACTIVE'], 'Input_Param_004': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventAccess[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_005': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventRxFramesLost[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_006': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventCRC[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_007': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventUnderSizeFrame[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_008': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventOverSizeFrame[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_009': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventAlignment[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_010': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventSinglecollision[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_011': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventMultiplecollision[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_012': ['Type': 'Array', 'Range': '0..255', 'Name': 'Eth_GaaDemEventLatecollision[0 to 1]', 'Value': '[1] = 0'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_NOT_OK'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_019': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_SETCONTROLLERMODE_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '1'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '1'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlMode', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '[1] = Eth_GaaDemEventAccess[1]'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '[1] = DEM_EVENT_STATUS_PREFAILED'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'enMode', 'Value': '[1] = ETH_MODE_STANDBY'], 'Output_Param_018': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_019': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE) Eth_SetOffsetTimeForGptp( /* PRQA S 1503 # JV-01 */ CONST(uint8, AUTOMATIC) CtrlIdx, CONSTP2CONST(Eth_TimeStampType, AUTOMATIC, ETH_APPL_DATA) pTimeOffsetPtr) { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the DET value */ LucReturnValue = Eth_CommonDetCheck(ETH_SETOFFSETTIMEFORGPTP_SID, CtrlIdx); if (NULL_PTR == pTimeOffsetPtr) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_SETOFFSETTIMEFORGPTP_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { if (ETH_MODE_ACTIVE != Eth_GaaCtrlStat[CtrlIdx].enMode) /* PRQA S 2844 # JV-01 */ { #if (ETH_DEV_ERROR_DETECT == STD_ON) /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_SETOFFSETTIMEFORGPTP_SID, ETH_E_INV_MODE); #endif LucReturnValue = E_NOT_OK; } else { LucReturnValue = Eth_HwSetOffsetTimeForGptp((uint32)CtrlIdx, pTimeOffsetPtr); } } return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GLOBAL_TIME_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'ETH_AR_431_VERSION\\nETH_AR_1911_VERSION', 'Name': 'ETH_AR_VERSION', 'Value': 'ETH_AR_1911_VERSION'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'U2x: 0, 1\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '0x0'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'pTimeOffsetPtr', 'Value': '&map_pTimeOffsetPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'CtrlIdx', 'Name': 'x', 'Value': ''], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ETH_MODE_DOWN,\\nETH_MODE_ACTIVE,\\nETH_MODE_STANDBY', 'Name': 'enMode', 'Value': 'ETH_MODE_DOWN'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTimeOffsetPtr[0]', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_StreamIdPtr[0]', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_SETOFFSETTIMEFORGPTP_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '0x0'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ETH_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ETH_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ETH_SETOFFSETTIMEFORGPTP_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ETH_E_INV_MODE'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpTimeOffsetPtr', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpTimeOffsetPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE) Eth_SetOffsetTimeForGptp( /* PRQA S 1503 # JV-01 */ CONST(uint8, AUTOMATIC) CtrlIdx, CONSTP2CONST(Eth_TimeStampType, AUTOMATIC, ETH_APPL_DATA) pTimeOffsetPtr) { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the DET value */ LucReturnValue = Eth_CommonDetCheck(ETH_SETOFFSETTIMEFORGPTP_SID, CtrlIdx); if (NULL_PTR == pTimeOffsetPtr) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_SETOFFSETTIMEFORGPTP_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { if (ETH_MODE_ACTIVE != Eth_GaaCtrlStat[CtrlIdx].enMode) /* PRQA S 2844 # JV-01 */ { #if (ETH_DEV_ERROR_DETECT == STD_ON) /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_SETOFFSETTIMEFORGPTP_SID, ETH_E_INV_MODE); #endif LucReturnValue = E_NOT_OK; } else { LucReturnValue = Eth_HwSetOffsetTimeForGptp((uint32)CtrlIdx, pTimeOffsetPtr); } } return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_GLOBAL_TIME_SUPPORT', 'Value': '-'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'ETH_AR_431_VERSION\\nETH_AR_1911_VERSION', 'Name': 'ETH_AR_VERSION', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'U2x: 0, 1\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'pTimeOffsetPtr', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'CtrlIdx', 'Name': 'x', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ETH_MODE_DOWN,\\nETH_MODE_ACTIVE,\\nETH_MODE_STANDBY', 'Name': 'enMode', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTimeOffsetPtr[0]', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_StreamIdPtr[0]', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpTimeOffsetPtr', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpTimeOffsetPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE) Eth_Transmit( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, Eth_BufIdxType BufIdx, Eth_FrameType FrameType, boolean TxConfirmation, uint16 LenByte, P2CONST(uint8, AUTOMATIC, ETH_APPL_DATA) PhysAddrPtr) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_TRANSMIT_SID, CtrlIdx); /* Report Error to DET, if the PhysAddrPtr pointer value is NULL */ if (NULL_PTR == PhysAddrPtr) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_TRANSMIT_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ /* ETNC need #define ETH_TX_DESC_MAX ETH_TX_BUF_TOTAL_0 */ /* Report Error to DET, if the BufIdx is out of range */ #if (ETH_USING_MACRO == ETH_MACRO_ETNC || ETH_USING_MACRO == ETH_MACRO_ETNB || ETH_USING_MACRO == ETH_MACRO_AVB) if ((uint32)ETH_TX_DESC_MAX <= BufIdx) #else if (Eth_GaaTxBufferTotal[CtrlIdx] <= BufIdx) #endif { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_TRANSMIT_SID, ETH_E_INV_PARAM); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { /* Report Error to DET, if the controller mode Is not Active */ if (ETH_MODE_ACTIVE != Eth_GaaCtrlStat[CtrlIdx].enMode) /* PRQA S 2844 # JV-01 */ { #if (ETH_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_TRANSMIT_SID, ETH_E_INV_MODE); #endif LucReturnValue = E_NOT_OK; } else { LucReturnValue = Eth_CheckProvideBuffer((uint32)CtrlIdx, (uint32)BufIdx); /* If the buffer has not been provided, report the error */ if (E_OK != LucReturnValue) { #if (ETH_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_TRANSMIT_SID, ETH_E_INV_PARAM); #endif } else { /* Prepare a frame for transmission.*/ #if (ETH_AR_VERSION >= ETH_AR_431_VERSION) Eth_PreprocessFrame((uint32)CtrlIdx, (uint32)BufIdx, (uint32)FrameType, PhysAddrPtr, &LenByte); /* PRQA S 1339 # JV-01 */ #else Eth_PreprocessFrame((uint32)CtrlIdx, (uint32)BufIdx, (uint32)FrameType, PhysAddrPtr); #endif /* Send a transmit request to the low level driver */ LucReturnValue = Eth_HwTransmit((uint32)CtrlIdx, (uint32)BufIdx, (uint32)LenByte, TxConfirmation); } } } return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '-', 'Name': 'ETH_AR_VERSION', 'Value': 'ETH_AR_431_VERSION\\nETH_AR_422_VERSION'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x: 0, 1\\nE2x: 0', 'Name': 'CtrlIdx', 'Value': '1'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'U2x:0..511\\nE2x:0..255', 'Name': 'BufIdx', 'Value': '511'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..0xFFFF', 'Name': 'FrameType', 'Value': '-'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'ETH_TRUE,\\nETH_FALSE', 'Name': 'TxConfirmation', 'Value': '-'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..0xFFFF', 'Name': 'LenByte', 'Value': '-'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'PhysAddrPtr', 'Value': '&map_PhysAddrPtr[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': ' ETH_MODE_ACTIVE,\\nETH_MODE_DOWN,\\nETH_MODE_STANDBY', 'Name': 'enMode', 'Value': '[1] = ETH_MODE_STANDBY'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': 'E_OK'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_TRANSMIT_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '1'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ETH_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ETH_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ETH_TRANSMIT_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ETH_E_INV_MODE'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFrameType', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPhysAddrPtr', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPayloadLen', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFrameType', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPhysAddrPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFrameType', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPhysAddrPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPayloadLen', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulLenByte', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblConfirmation', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulLenByte', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblConfirmation', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulLenByte', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblConfirmation', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_046': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_047': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE) Eth_Transmit( /* PRQA S 1503, 1532 # JV-01, JV-01 */ uint8 CtrlIdx, Eth_BufIdxType BufIdx, Eth_FrameType FrameType, boolean TxConfirmation, uint16 LenByte, P2CONST(uint8, AUTOMATIC, ETH_APPL_DATA) PhysAddrPtr) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_TRANSMIT_SID, CtrlIdx); /* Report Error to DET, if the PhysAddrPtr pointer value is NULL */ if (NULL_PTR == PhysAddrPtr) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_TRANSMIT_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ /* ETNC need #define ETH_TX_DESC_MAX ETH_TX_BUF_TOTAL_0 */ /* Report Error to DET, if the BufIdx is out of range */ #if (ETH_USING_MACRO == ETH_MACRO_ETNC || ETH_USING_MACRO == ETH_MACRO_ETNB || ETH_USING_MACRO == ETH_MACRO_AVB) if ((uint32)ETH_TX_DESC_MAX <= BufIdx) #else if (Eth_GaaTxBufferTotal[CtrlIdx] <= BufIdx) #endif { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_TRANSMIT_SID, ETH_E_INV_PARAM); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { /* Report Error to DET, if the controller mode Is not Active */ if (ETH_MODE_ACTIVE != Eth_GaaCtrlStat[CtrlIdx].enMode) /* PRQA S 2844 # JV-01 */ { #if (ETH_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_TRANSMIT_SID, ETH_E_INV_MODE); #endif LucReturnValue = E_NOT_OK; } else { LucReturnValue = Eth_CheckProvideBuffer((uint32)CtrlIdx, (uint32)BufIdx); /* If the buffer has not been provided, report the error */ if (E_OK != LucReturnValue) { #if (ETH_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_TRANSMIT_SID, ETH_E_INV_PARAM); #endif } else { /* Prepare a frame for transmission.*/ #if (ETH_AR_VERSION >= ETH_AR_431_VERSION) Eth_PreprocessFrame((uint32)CtrlIdx, (uint32)BufIdx, (uint32)FrameType, PhysAddrPtr, &LenByte); /* PRQA S 1339 # JV-01 */ #else Eth_PreprocessFrame((uint32)CtrlIdx, (uint32)BufIdx, (uint32)FrameType, PhysAddrPtr); #endif /* Send a transmit request to the low level driver */ LucReturnValue = Eth_HwTransmit((uint32)CtrlIdx, (uint32)BufIdx, (uint32)LenByte, TxConfirmation); } } } return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '-', 'Name': 'ETH_AR_VERSION', 'Value': 'ETH_AR_431_VERSION\\nETH_AR_422_VERSION'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x: 0, 1\\nE2x: 0', 'Name': 'CtrlIdx', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'U2x:0..511\\nE2x:0..255', 'Name': 'BufIdx', 'Value': '0'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..0xFFFF', 'Name': 'FrameType', 'Value': '-'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'ETH_TRUE,\\nETH_FALSE', 'Name': 'TxConfirmation', 'Value': '-'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..0xFFFF', 'Name': 'LenByte', 'Value': '-'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'PhysAddrPtr', 'Value': '&map_PhysAddrPtr[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': ' ETH_MODE_ACTIVE,\\nETH_MODE_DOWN,\\nETH_MODE_STANDBY', 'Name': 'enMode', 'Value': '[0] = ETH_MODE_ACTIVE'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': 'E_NOT_OK'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': 'E_OK'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'returnValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_TRANSMIT_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '0'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '0'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ETH_MODULE_ID'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ETH_INSTANCE_ID'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ETH_TRANSMIT_SID'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ETH_E_INV_PARAM'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFrameType', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPhysAddrPtr', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPayloadLen', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFrameType', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPhysAddrPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulFrameType', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPhysAddrPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPayloadLen', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulLenByte', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblConfirmation', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulLenByte', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblConfirmation', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBufIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulLenByte', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblConfirmation', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_046': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_047': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE) Eth_UpdateStreamFilter( /* PRQA S 1503, 1532 # JV-01, JV-01 */ CONST(uint8, AUTOMATIC) CtrlIdx, CONST(uint8, AUTOMATIC) QueIdx, CONSTP2CONST(uint8, AUTOMATIC, ETH_APPL_DATA) StreamIdPtr) { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_UPDATESTREAMFILTER_SID, CtrlIdx); if (E_OK == LucReturnValue) { LucReturnValue = Eth_HwCheckRxStreamQueueIndex((uint32)CtrlIdx, (uint32)QueIdx); if (E_OK != LucReturnValue) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_UPDATESTREAMFILTER_SID, ETH_E_INV_PARAM); } /* else: No action required */ } /* else: No action required */ if (NULL_PTR == StreamIdPtr) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_UPDATESTREAMFILTER_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { if ((ETH_MODE_ACTIVE != Eth_GaaCtrlStat[CtrlIdx].enMode) /* PRQA S 2844 # JV-01 */ && (ETH_MODE_DOWN != Eth_GaaCtrlStat[CtrlIdx].enMode)) { #if (ETH_DEV_ERROR_DETECT == STD_ON) /* Report Error to DET, if the controller mode Is Standby */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_UPDATESTREAMFILTER_SID, ETH_E_INV_MODE); #endif LucReturnValue = E_NOT_OK; } else { /* Update Filter Pattern for the specific Rx queue */ Eth_HwUpdateStreamFilter((uint32)CtrlIdx, (uint32)QueIdx, StreamIdPtr); LucReturnValue = E_OK; } } return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_STREAM_FILTERING', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x: 0, 1\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '0x0'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..0xFF', 'Name': 'QueIdx', 'Value': '0x1'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'StreamIdPtr', 'Value': 'map_StreamIdPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'CtrlIdx', 'Name': 'x', 'Value': ''], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ETH_MODE_DOWN,\\nETH_MODE_ACTIVE,\\nETH_MODE_STANDBY', 'Name': 'enMode', 'Value': 'ETH_MODE_STANDBY'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_UPDATESTREAMFILTER_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '0x0'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '0x0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueIdx', 'Value': '0x1'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ETH_MODULE_ID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ETH_INSTANCE_ID'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ETH_UPDATESTREAMFILTER_SID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ETH_E_INV_MODE'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'QueIdx', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'StreamIdPtr', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'QueIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'StreamIdPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE) Eth_UpdateStreamFilter( /* PRQA S 1503, 1532 # JV-01, JV-01 */ CONST(uint8, AUTOMATIC) CtrlIdx, CONST(uint8, AUTOMATIC) QueIdx, CONSTP2CONST(uint8, AUTOMATIC, ETH_APPL_DATA) StreamIdPtr) { Std_ReturnType LucReturnValue; #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_UPDATESTREAMFILTER_SID, CtrlIdx); if (E_OK == LucReturnValue) { LucReturnValue = Eth_HwCheckRxStreamQueueIndex((uint32)CtrlIdx, (uint32)QueIdx); if (E_OK != LucReturnValue) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_UPDATESTREAMFILTER_SID, ETH_E_INV_PARAM); } /* else: No action required */ } /* else: No action required */ if (NULL_PTR == StreamIdPtr) { /* Report Error to DET */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_UPDATESTREAMFILTER_SID, ETH_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif { if ((ETH_MODE_ACTIVE != Eth_GaaCtrlStat[CtrlIdx].enMode) /* PRQA S 2844 # JV-01 */ && (ETH_MODE_DOWN != Eth_GaaCtrlStat[CtrlIdx].enMode)) { #if (ETH_DEV_ERROR_DETECT == STD_ON) /* Report Error to DET, if the controller mode Is Standby */ (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_UPDATESTREAMFILTER_SID, ETH_E_INV_MODE); #endif LucReturnValue = E_NOT_OK; } else { /* Update Filter Pattern for the specific Rx queue */ Eth_HwUpdateStreamFilter((uint32)CtrlIdx, (uint32)QueIdx, StreamIdPtr); LucReturnValue = E_OK; } } return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_STREAM_FILTERING', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x: 0, 1\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..0xFF', 'Name': 'QueIdx', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'StreamIdPtr', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'CtrlIdx', 'Name': 'x', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'ETH_MODE_DOWN,\\nETH_MODE_ACTIVE,\\nETH_MODE_STANDBY', 'Name': 'enMode', 'Value': '-'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueIdx', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'QueIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'StreamIdPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'QueIdx', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'StreamIdPtr', 'Value': '-'], 'Output_Param_016': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': '-'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ETH_START_SEC_PRIVATE_CODE #include \"Eth_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, ETH_PRIVATE_CODE) Eth_Util_InsertToList( /* PRQA S 1503 # JV-01 */ CONSTP2VAR(Eth_ListType, AUTOMATIC, ETH_APPL_DATA) LpList, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(void, AUTOMATIC, ETH_APPL_DATA) LpSrc, /* PRQA S 3673 # JV-01 */ CONSTP2VAR(void, AUTOMATIC, ETH_APPL_DATA) LpElem, /* PRQA S 3673 # JV-01 */ CONST(uint16, AUTOMATIC) LusFlag) { CONSTP2VAR(Eth_DListNodeType, AUTOMATIC, ETH_APPL_DATA) LpSrcNode = /* PRQA S 3432 # JV-01 */ (P2VAR(Eth_DListNodeType, AUTOMATIC, ETH_APPL_DATA))LpSrc; /* PRQA S 0316, 3432 # JV-01, JV-01 */ CONSTP2VAR(Eth_DListNodeType, AUTOMATIC, ETH_APPL_DATA) LpNode = /* PRQA S 3432 # JV-01 */ (P2VAR(Eth_DListNodeType, AUTOMATIC, ETH_APPL_DATA))LpElem; /* PRQA S 0316, 3432 # JV-01, JV-01 */ Std_ReturnType LucReturnValue; LucReturnValue = E_NOT_OK; if ((NULL_PTR != LpList) && (NULL_PTR != LpSrcNode) && (NULL_PTR != LpNode) && (ETH_LIST_MAX_NODES != LpList->ulCount) && (0U != (LusFlag & (ETH_LIST_PREV | ETH_LIST_NEXT)))) { if (0U != (LusFlag & ETH_LIST_NEXT)) { /* Re-chain insert node at LpSrcNode->pNext */ LpNode->pPrev = LpSrcNode; LpNode->pNext = LpSrcNode->pNext; if (NULL_PTR == LpSrcNode->pNext) { LpList->pLast = LpNode; } else { LpSrcNode->pNext->pPrev = LpNode; /* PRQA S 2814 # JV-01 */ } LpSrcNode->pNext = LpNode; } else { /* Re-chain insert node at LpSrcNode->pPrev */ LpNode->pPrev = LpSrcNode->pPrev; LpNode->pNext = LpSrcNode; if (NULL_PTR == LpSrcNode->pPrev) { LpList->pHead = LpNode; } else { LpSrcNode->pPrev->pNext = LpNode; /* PRQA S 2814 # JV-01 */ } LpSrcNode->pPrev = LpNode; } LpList->ulCount++; /* PRQA S 3383 # JV-01 */ LucReturnValue = E_OK; } /* else: No action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'LpList', 'Value': '&map_LpList[0]'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'LpSrc', 'Value': '&map_LpSrc[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'LpElem', 'Value': '&map_LpElem[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'ETH_LIST_PREV(0x0001),\\nETH_LIST_NEXT(0x0002)', 'Name': 'LusFlag', 'Value': '0x0001'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'ulCount', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL, !=NULL', 'Name': 'pNext', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'NULL, !=NULL', 'Name': 'pPrev', 'Value': 'NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulCount', 'Value': '1'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'pHead', 'Value': '&map_LpElem[0]'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pLast', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pNext', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pPrev', 'Value': '&map_LpElem[0]'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pNext', 'Value': '&map_LpSrc[0]'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pPrev', 'Value': 'NULL_PTR'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pNext', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pPrev', 'Value': '-'], 'Output_Param_009': ['Type': 'Return_Value', 'Range': '', 'Name': 'LpNode', 'Value': 'E_OK'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ETH_START_SEC_PRIVATE_CODE #include \"Eth_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, ETH_PRIVATE_CODE) Eth_Util_RemoveToList( /* PRQA S 1503, 1532 # JV-01, JV-01 */ CONSTP2VAR(Eth_ListType, AUTOMATIC, ETH_APPL_DATA) LpList, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(void *, AUTOMATIC, ETH_APPL_DATA) LpElem) /* PRQA S 3432, 3673 # JV-01, JV-01 */ { CONSTP2VAR(Eth_DListNodeType *, AUTOMATIC, ETH_APPL_DATA) LpNode = /* PRQA S 3432 # JV-01 */ (P2VAR(Eth_DListNodeType *, AUTOMATIC, ETH_APPL_DATA))LpElem; /* PRQA S 0310, 3432 # JV-01, JV-01 */ P2VAR(Eth_DListNodeType, AUTOMATIC, ETH_APPL_DATA) LpRmvNode; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; LucReturnValue = E_NOT_OK; if ((NULL_PTR != LpList) && (NULL_PTR != LpNode) && (NULL_PTR != *LpNode)) { if (0UL != LpList->ulCount) { /* Re-chain */ LpRmvNode = *LpNode; if (NULL_PTR == LpRmvNode->pPrev) /* PRQA S 2814 # JV-01 */ { LpList->pHead = LpRmvNode->pNext; } else { LpRmvNode->pPrev->pNext = LpRmvNode->pNext; /* PRQA S 2814 # JV-01 */ } if (NULL_PTR == LpRmvNode->pNext) { LpList->pLast = LpRmvNode->pPrev; } else { LpRmvNode->pNext->pPrev = LpRmvNode->pPrev; /* PRQA S 2814 # JV-01 */ } LpList->ulCount--; *LpNode = LpRmvNode->pNext; LucReturnValue = E_OK; } /* else: No action required */ } /* else: No action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'LpList', 'Value': '&map_LpList[0]'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !=NULL', 'Name': 'LpElem', 'Value': '&map_LpElemPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL, !=NULL', 'Name': 'map_LpElemPtr[0]', 'Value': '&map_LpNodes[1]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'ulCount', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL, !=NULL', 'Name': 'pPrev', 'Value': 'NULL_PTR'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL, !=NULL', 'Name': 'pNext', 'Value': 'NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulCount', 'Value': '0'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'pHead', 'Value': 'NULL_PTR'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pLast', 'Value': 'NULL_PTR'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpElemPtr[0]', 'Value': 'NULL_PTR'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pNext', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pPrev', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LulReturnValue', 'Value': 'E_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE)Eth_WriteMii( /* PRQA S 1503 # JV-01 */ uint8 CtrlIdx, uint8 TrcvIdx, uint8 RegIdx, uint16 RegVal) { Std_ReturnType LucReturnValue; #ifndef ETH_HW_NOT_LEGACY_MDIO /* Local variable only used in E2x and U2Ax devices */ uint32 LulBitCount; uint32 LulHeader; uint32 LulBit; #endif #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_WRITEMII_SID, CtrlIdx); /* Check for the valid TrcvIdx */ if (ETH_PHY_MAX_PHYAD_IDX < TrcvIdx) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_WRITEMII_SID, ETH_E_INV_PARAM); LucReturnValue = E_NOT_OK; } /* else: No action required */ /* Check for the valid RegIdx */ if (ETH_PHY_MAX_REGAD_IDX < RegIdx) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_WRITEMII_SID, ETH_E_INV_PARAM); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif /* (ETH_DEV_ERROR_DETECT == STD_ON) */ #ifdef ETH_HW_NOT_LEGACY_MDIO { LucReturnValue = Eth_HwWriteMii((uint32)CtrlIdx, TrcvIdx, RegIdx, RegVal); if (E_OK == LucReturnValue) { /* Since this function is implemented as synchronous, call EthTrcv here */ EthTrcv_WriteMiiIndication(CtrlIdx, TrcvIdx, RegIdx); } /* else: No action required */ } #else { /* PRE */ for (LulBitCount = (uint32)ETH_PHY_PREAMBLE_SIZE; LulBitCount > 0UL; LulBitCount--) { Eth_HwWriteMiiBit((uint32)CtrlIdx, 1UL); } /* ST, OP, PHYAD, REGAD */ LulHeader = ETH_PHY_WHEADER(TrcvIdx, RegIdx); /* PRQA S 3469 # JV-01 */ for (LulBitCount = (uint32)ETH_PHY_HEADER_SIZE; LulBitCount > 0UL; LulBitCount--) { /* Pickup the bit which should be output next, MSB first */ LulBit = (LulHeader >> (LulBitCount - 1UL)) & 1UL; /* PRQA S 3383 # JV-01 */ Eth_HwWriteMiiBit((uint32)CtrlIdx, LulBit); } /* TA: 10 */ Eth_HwWriteMiiBit((uint32)CtrlIdx, 1UL); Eth_HwWriteMiiBit((uint32)CtrlIdx, 0UL); /* DATA */ for (LulBitCount = (uint32)ETH_PHY_DATA_SIZE; LulBitCount > 0UL; LulBitCount--) { /* Pickup the bit which should be output next, MSB first */ LulBit = ((uint32)RegVal >> (LulBitCount - 1UL)) & 1UL; /* PRQA S 3383 # JV-01 */ Eth_HwWriteMiiBit((uint32)CtrlIdx, LulBit); } /* Bus release (MDIO = Z) and IDLE cycle, it is same as read cycle */ (void)Eth_HwReadMiiBit((uint32)CtrlIdx); /* Since this function is implemented as synchronous, call EthTrcv here */ EthTrcv_WriteMiiIndication(CtrlIdx, TrcvIdx, RegIdx); LucReturnValue = E_OK; } #endif /* #ifdef ETH_HW_NOT_LEGACY_MDIO */ return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_CTRL_ENABLE_MII', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nE2x: 0\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..0xFF', 'Name': 'TrcvIdx', 'Value': '0x00'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..0xFF', 'Name': 'RegIdx', 'Value': '0x20'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..0xFFFF', 'Name': 'RegVal', 'Value': '0x0000'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': 'ETH_WRITEMII_SID'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '0'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'ETH_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ETH_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ETH_WRITEMII_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ETH_E_INV_PARAM'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'TrcvIdx', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegIdx', 'Value': '-'], 'Output_Param_036': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_037': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, ETH_PUBLIC_CODE)Eth_WriteMii( /* PRQA S 1503 # JV-01 */ uint8 CtrlIdx, uint8 TrcvIdx, uint8 RegIdx, uint16 RegVal) { Std_ReturnType LucReturnValue; #ifndef ETH_HW_NOT_LEGACY_MDIO /* Local variable only used in E2x and U2Ax devices */ uint32 LulBitCount; uint32 LulHeader; uint32 LulBit; #endif #if (ETH_DEV_ERROR_DETECT == STD_ON) LucReturnValue = Eth_CommonDetCheck(ETH_WRITEMII_SID, CtrlIdx); /* Check for the valid TrcvIdx */ if (ETH_PHY_MAX_PHYAD_IDX < TrcvIdx) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_WRITEMII_SID, ETH_E_INV_PARAM); LucReturnValue = E_NOT_OK; } /* else: No action required */ /* Check for the valid RegIdx */ if (ETH_PHY_MAX_REGAD_IDX < RegIdx) { (void)Det_ReportError(ETH_MODULE_ID, ETH_INSTANCE_ID, ETH_WRITEMII_SID, ETH_E_INV_PARAM); LucReturnValue = E_NOT_OK; } /* else: No action required */ if (E_OK != LucReturnValue) { /* No action required */ } else #endif /* (ETH_DEV_ERROR_DETECT == STD_ON) */ #ifdef ETH_HW_NOT_LEGACY_MDIO { LucReturnValue = Eth_HwWriteMii((uint32)CtrlIdx, TrcvIdx, RegIdx, RegVal); if (E_OK == LucReturnValue) { /* Since this function is implemented as synchronous, call EthTrcv here */ EthTrcv_WriteMiiIndication(CtrlIdx, TrcvIdx, RegIdx); } /* else: No action required */ } #else { /* PRE */ for (LulBitCount = (uint32)ETH_PHY_PREAMBLE_SIZE; LulBitCount > 0UL; LulBitCount--) { Eth_HwWriteMiiBit((uint32)CtrlIdx, 1UL); } /* ST, OP, PHYAD, REGAD */ LulHeader = ETH_PHY_WHEADER(TrcvIdx, RegIdx); /* PRQA S 3469 # JV-01 */ for (LulBitCount = (uint32)ETH_PHY_HEADER_SIZE; LulBitCount > 0UL; LulBitCount--) { /* Pickup the bit which should be output next, MSB first */ LulBit = (LulHeader >> (LulBitCount - 1UL)) & 1UL; /* PRQA S 3383 # JV-01 */ Eth_HwWriteMiiBit((uint32)CtrlIdx, LulBit); } /* TA: 10 */ Eth_HwWriteMiiBit((uint32)CtrlIdx, 1UL); Eth_HwWriteMiiBit((uint32)CtrlIdx, 0UL); /* DATA */ for (LulBitCount = (uint32)ETH_PHY_DATA_SIZE; LulBitCount > 0UL; LulBitCount--) { /* Pickup the bit which should be output next, MSB first */ LulBit = ((uint32)RegVal >> (LulBitCount - 1UL)) & 1UL; /* PRQA S 3383 # JV-01 */ Eth_HwWriteMiiBit((uint32)CtrlIdx, LulBit); } /* Bus release (MDIO = Z) and IDLE cycle, it is same as read cycle */ (void)Eth_HwReadMiiBit((uint32)CtrlIdx); /* Since this function is implemented as synchronous, call EthTrcv here */ EthTrcv_WriteMiiIndication(CtrlIdx, TrcvIdx, RegIdx); LucReturnValue = E_OK; } #endif /* #ifdef ETH_HW_NOT_LEGACY_MDIO */ return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'ETH_DEV_ERROR_DETECT', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON', 'Name': 'ETH_CTRL_ENABLE_MII', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'U2x:0, 1\\nE2x: 0\\nS4_G4MH: 0', 'Name': 'CtrlIdx', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..0xFF', 'Name': 'TrcvIdx', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..0xFF', 'Name': 'RegIdx', 'Value': '-'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..0xFFFF', 'Name': 'RegVal', 'Value': '-'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': 'E_OK, E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucSID', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCtrlIdx', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulBit', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCtrlIdx', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'CtrlIdx', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'TrcvIdx', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegIdx', 'Value': '-'], 'Output_Param_036': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': '-'], 'Output_Param_037': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_BlankCheck(Fls_AddressType TargetAddress, Fls_LengthType Length) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if (FLS_DEV_ERROR_DETECT == STD_ON) uint32 LulFlsMaxLength; uint32 LulFlsLimitAddress; #endif Fls_AddressType LddTargetAddress; /* Local variable to hold the DET return value */ Std_ReturnType LddReturnValue; #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GetControlResultType LddGetControlResult; #endif LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Local variable to hold the blank check start address */ LddTargetAddress = TargetAddress + FLS_BASE_ADDRESS; /* PRQA S 2985, 3383 # JV-01, JV-01 */ #if (FLS_DEV_ERROR_DETECT == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LulFlsLimitAddress = (FLS_BASE_ADDRESS + FLS_TOTAL_SIZE) - FLS_ONE_LONG_WORD; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulFlsMaxLength = (uint32)((FLS_TOTAL_SIZE - TargetAddress) * FLS_TWO_LONG_WORD); /* PRQA S 3384, 3383 # JV-01, JV-01 */ #else LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - TargetAddress; /* PRQA S 3383 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulFlsLimitAddress = FLS_BASE_ADDRESS + (FLS_TOTAL_SIZE / FLS_TWO_LONG_WORD) - FLS_ONE_LONG_WORD; LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - (TargetAddress * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_BLANK_CHECK_SID, FLS_E_UNINIT); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) /* Check if the driver is busy by servicing another request */ else if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET if the driver is currently busy */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_BLANK_CHECK_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) */ /* Check if the start address is lies within the specified lower and * upper flash address boundaries. */ else if (LulFlsLimitAddress < LddTargetAddress) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_BLANK_CHECK_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Check if the length is greater than 0 and that the end address * (start address + length) lies within the specified upper flash * address boundary. */ else if ((FLS_ZERO_LONG_WORD == Length) || (LulFlsMaxLength < Length)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_BLANK_CHECK_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { /* No DET error */ LddReturnValue = E_OK; } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ #endif /* (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) /* Check if the driver is busy by servicing another request */ if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET Runtime if the driver is currently busy */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_BLANK_CHECK_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) */ /* Check whether any error is reported to DET */ if (E_OK == LddReturnValue) { /* Check status of get exclusive control/get semaphore * with critical section */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) LddGetControlResult = Fls_GetControl(); /* If get exclusive or get semaphore are successfully */ if (FLS_GOT_NOTHING != LddGetControlResult) { #endif /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif Fls_GstVarProperties.ulFlashAddress = LddTargetAddress; /* Set the current length of bytes to be processed */ Fls_GstVarProperties.ulLength = Length; /* Initiate a blank check job */ Fls_GstVarProperties.enCommand = FLS_COMMAND_BLANKCHECK; /* set the driver state to busy */ Fls_GenState = MEMIF_BUSY; /* set the job result as pending */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_PENDING; Fls_GstVarProperties.ddMainJobFlag = E_OK; #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_GstVarProperties.blExtSpaceRead = FLS_TRUE; #endif Fls_GstVarProperties.enJobStatus = FLS_BUSY; /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) } else { LddReturnValue = E_NOT_OK; } /* End of if (FLS_GOT_NOTHING != LddGetControlResult) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BLANKCHECK_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BASE_ADDRESS_ZERO', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_007': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_008': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXTERNAL_SPACE_READ', 'Value': 'STD_ON'], 'Input_Param_009': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '1'], 'Input_Param_010': ['Type': 'Argument', 'Range': '', 'Name': 'TargetAddress', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'return', 'Value': 'FLS_GOT_NOTHING']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blExtSpaceRead', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_EraseJobHandler(void) { Std_ReturnType LddReturnValue; Std_ReturnType LddProcessStatus; #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) Fls_CompareStatusType LenVerifyStatus; #endif Fls_StatusRegType LenEraseStatus; uint32 LulSectorSize; uint32 LulFlashAddress; LulFlashAddress = Fls_GstVarProperties.ulFlashAddress; LulSectorSize = Fls_GstVarProperties.ulSectorSize; /* Default state of Erase Job: is not finished */ LddReturnValue = E_NOT_OK; /* If length still valid */ if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) { #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) /*--------------------- Write Enable and wait the status -----------------*/ LddProcessStatus = Fls_SfWriteEnable(); if (E_OK == LddProcessStatus) { /* Waiting for flash device enable */ LenEraseStatus = Fls_SfWaitStatusReg((uint32)FLS_READ_TIME, FLS_STATUS_PROTECT); /* PRQA S 2905 # JV-01 */ } else { LenEraseStatus = FLS_STT_TIMEOUT; } /*--------------- Send the Erase command and wait the status -------------*/ if (FLS_STT_FREE == LenEraseStatus) { LddProcessStatus = Fls_SfSectorErase(LulFlashAddress); if (E_OK == LddProcessStatus) { /* Waiting for erase successful */ LenEraseStatus = Fls_SfWaitStatusReg((uint32)FLS_ERASE_TIME, FLS_STATUS_ERASE); /* PRQA S 2905 # JV-01 */ } else { LenEraseStatus = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { /* No action required */ } /* End of if (FLS_STT_FREE == LenEraseStatus) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) /*--------------- Send the Erase command and wait the status -------------*/ LddProcessStatus = Fls_HfSectorErase(LulFlashAddress); if (E_OK == LddProcessStatus) { /* Waiting for erase successful */ LenEraseStatus = Fls_HfWaitStatusReg((uint32)FLS_ERASE_TIME, FLS_STATUS_ERASE); /* PRQA S 2905 # JV-01 */ } else { LenEraseStatus = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ /*------------------ Check, If job has any errors ------------------------*/ if (FLS_STT_FREE != LenEraseStatus) { /* End this job */ LddReturnValue = E_OK; /* Send error status to main function */ switch (LenEraseStatus) { case FLS_STT_TIMEOUT: Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; case FLS_STT_ERROR: Fls_GstVarProperties.enJobStatus = FLS_ERR_ERASE; break; case FLS_ERR_NG: #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Report error to Det */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_PARAM_DATA); #endif break; default: /* NOT REACHED */ break; } /* End of switch (LenEraseStatus) */ } else { #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) /* After a flash block has been erased, this function shall compare the * contents of the addressed memory area against the value of an * erased flash cell to check that the block has been completely erased. */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LenVerifyStatus = Fls_SfVerifyEraseArea(LulSectorSize * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #else LenVerifyStatus = Fls_SfVerifyEraseArea(LulSectorSize); #endif /* (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenVerifyStatus = Fls_HfVerifyEraseArea(LulSectorSize); #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ switch (LenVerifyStatus) { /* Flash cell is not erased */ case FLS_INCONSISTENT: /* End this job */ LddReturnValue = E_OK; Fls_GstVarProperties.enJobStatus = FLS_ERR_VERIFY_ERASE; break; /* Blank check timeout */ case FLS_COMPARE_TIMEOUT: /* End this job */ LddReturnValue = E_OK; Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; /* Flash cell has been erased */ case FLS_CONSISTENT: default: /* Report status is OK */ Fls_GstVarProperties.enJobStatus = FLS_OK; break; } /* End of switch (LenVerifyStatus) */ #else /* Report status is OK */ Fls_GstVarProperties.enJobStatus = FLS_OK; #endif /* End of #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && * (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) */ } /* End of if (FLS_STT_FREE != LenEraseStatus) */ /*---------------------- If job on-going ---------------------------------*/ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) if (((LulSectorSize * FLS_TWO_LONG_WORD) <= Fls_GstVarProperties.ulLength) && (E_NOT_OK == LddReturnValue)) /* PRQA S 3383 # JV-01 */ #else if ((LulSectorSize <= Fls_GstVarProperties.ulLength) && (E_NOT_OK == LddReturnValue)) #endif /* #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) if ((LulSectorSize <= Fls_GstVarProperties.ulLength) && (E_NOT_OK == LddReturnValue)) #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ { #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) Fls_GstVarProperties.ulFlashAddress += LulSectorSize; /* PRQA S 3384 # JV-01 */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_GstVarProperties.ulLength -= (LulSectorSize * FLS_TWO_LONG_WORD); /* PRQA S 3384, 3383 # JV-01, JV-01 */ #else Fls_GstVarProperties.ulLength -= LulSectorSize; /* PRQA S 3384 # JV-01 */ #endif /* #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) Fls_GstVarProperties.ulFlashAddress += (uint32)(LulSectorSize / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ Fls_GstVarProperties.ulLength -= LulSectorSize; /* PRQA S 3384 # JV-01 */ #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ } else { /* No action required */ } /* End of checking the length */ } else { /* No action required */ } /* End of if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) */ /* If length not valid */ if (FLS_ZERO_LONG_WORD == Fls_GstVarProperties.ulLength) { /* Job has been finished */ LddReturnValue = E_OK; } else { /* No action required */ } return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_ERASE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlashAddress', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulSectorSize', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulLength', 'Value': '4294967295'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': ' FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': '[1] = FLS_STT_FREE\\n[2] = FLS_STT_FREE'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': ' FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': 'FLS_INCONSISTENT'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'enStatus', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'called\\n'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': 'FLS_ERR_VERIFY_ERASE'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_EraseJobHandler(void) { Std_ReturnType LddReturnValue; Std_ReturnType LddProcessStatus; #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) Fls_CompareStatusType LenVerifyStatus; #endif Fls_StatusRegType LenEraseStatus; uint32 LulSectorSize; uint32 LulFlashAddress; LulFlashAddress = Fls_GstVarProperties.ulFlashAddress; LulSectorSize = Fls_GstVarProperties.ulSectorSize; /* Default state of Erase Job: is not finished */ LddReturnValue = E_NOT_OK; /* If length still valid */ if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) { #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) /*--------------------- Write Enable and wait the status -----------------*/ LddProcessStatus = Fls_SfWriteEnable(); if (E_OK == LddProcessStatus) { /* Waiting for flash device enable */ LenEraseStatus = Fls_SfWaitStatusReg((uint32)FLS_READ_TIME, FLS_STATUS_PROTECT); /* PRQA S 2905 # JV-01 */ } else { LenEraseStatus = FLS_STT_TIMEOUT; } /*--------------- Send the Erase command and wait the status -------------*/ if (FLS_STT_FREE == LenEraseStatus) { LddProcessStatus = Fls_SfSectorErase(LulFlashAddress); if (E_OK == LddProcessStatus) { /* Waiting for erase successful */ LenEraseStatus = Fls_SfWaitStatusReg((uint32)FLS_ERASE_TIME, FLS_STATUS_ERASE); /* PRQA S 2905 # JV-01 */ } else { LenEraseStatus = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { /* No action required */ } /* End of if (FLS_STT_FREE == LenEraseStatus) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) /*--------------- Send the Erase command and wait the status -------------*/ LddProcessStatus = Fls_HfSectorErase(LulFlashAddress); if (E_OK == LddProcessStatus) { /* Waiting for erase successful */ LenEraseStatus = Fls_HfWaitStatusReg((uint32)FLS_ERASE_TIME, FLS_STATUS_ERASE); /* PRQA S 2905 # JV-01 */ } else { LenEraseStatus = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ /*------------------ Check, If job has any errors ------------------------*/ if (FLS_STT_FREE != LenEraseStatus) { /* End this job */ LddReturnValue = E_OK; /* Send error status to main function */ switch (LenEraseStatus) { case FLS_STT_TIMEOUT: Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; case FLS_STT_ERROR: Fls_GstVarProperties.enJobStatus = FLS_ERR_ERASE; break; case FLS_ERR_NG: #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Report error to Det */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_PARAM_DATA); #endif break; default: /* NOT REACHED */ break; } /* End of switch (LenEraseStatus) */ } else { #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) /* After a flash block has been erased, this function shall compare the * contents of the addressed memory area against the value of an * erased flash cell to check that the block has been completely erased. */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LenVerifyStatus = Fls_SfVerifyEraseArea(LulSectorSize * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #else LenVerifyStatus = Fls_SfVerifyEraseArea(LulSectorSize); #endif /* (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenVerifyStatus = Fls_HfVerifyEraseArea(LulSectorSize); #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ switch (LenVerifyStatus) { /* Flash cell is not erased */ case FLS_INCONSISTENT: /* End this job */ LddReturnValue = E_OK; Fls_GstVarProperties.enJobStatus = FLS_ERR_VERIFY_ERASE; break; /* Blank check timeout */ case FLS_COMPARE_TIMEOUT: /* End this job */ LddReturnValue = E_OK; Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; /* Flash cell has been erased */ case FLS_CONSISTENT: default: /* Report status is OK */ Fls_GstVarProperties.enJobStatus = FLS_OK; break; } /* End of switch (LenVerifyStatus) */ #else /* Report status is OK */ Fls_GstVarProperties.enJobStatus = FLS_OK; #endif /* End of #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && * (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) */ } /* End of if (FLS_STT_FREE != LenEraseStatus) */ /*---------------------- If job on-going ---------------------------------*/ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) if (((LulSectorSize * FLS_TWO_LONG_WORD) <= Fls_GstVarProperties.ulLength) && (E_NOT_OK == LddReturnValue)) /* PRQA S 3383 # JV-01 */ #else if ((LulSectorSize <= Fls_GstVarProperties.ulLength) && (E_NOT_OK == LddReturnValue)) #endif /* #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) if ((LulSectorSize <= Fls_GstVarProperties.ulLength) && (E_NOT_OK == LddReturnValue)) #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ { #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) Fls_GstVarProperties.ulFlashAddress += LulSectorSize; /* PRQA S 3384 # JV-01 */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_GstVarProperties.ulLength -= (LulSectorSize * FLS_TWO_LONG_WORD); /* PRQA S 3384, 3383 # JV-01, JV-01 */ #else Fls_GstVarProperties.ulLength -= LulSectorSize; /* PRQA S 3384 # JV-01 */ #endif /* #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) Fls_GstVarProperties.ulFlashAddress += (uint32)(LulSectorSize / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ Fls_GstVarProperties.ulLength -= LulSectorSize; /* PRQA S 3384 # JV-01 */ #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ } else { /* No action required */ } /* End of checking the length */ } else { /* No action required */ } /* End of if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) */ /* If length not valid */ if (FLS_ZERO_LONG_WORD == Fls_GstVarProperties.ulLength) { /* Job has been finished */ LddReturnValue = E_OK; } else { /* No action required */ } return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_ERASE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlashAddress', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulSectorSize', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulLength', 'Value': '4294967295'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': ' FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': '[1] = FLS_STT_FREE\\n[2] = FLS_ERR_NG'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': ' FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'enStatus', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'called\\n'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FLS_MODULE_ID'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FLS_INSTANCE_ID'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FLS_MAINFUNCTION_SID'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FLS_E_PARAM_DATA'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_GetControlResultType, FLS_CODE_SLOW) Fls_GetControl(void) /* PRQA S 1532 # JV-01 */ { Fls_GetControlResultType LddGetControlResult; #if (FLS_EXCLUSIVE_CONTROL == STD_ON) /* Status of FLS's exclusive control */ Std_ReturnType LddFlsExclusiveStatus; #endif #if (FLS_SEMAPHORE == STD_ON) /* Status of FLS's semaphore */ Std_ReturnType LddFlsSemaphoreStatus; #endif /* Set default value, got nothing */ LddGetControlResult = FLS_GOT_NOTHING; #if (FLS_SEMAPHORE == STD_ON) LddFlsSemaphoreStatus = E_NOT_OK; /* PRQA S 2982 # JV-01 */ #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) && (FLS_SEMAPHORE == STD_ON)) /* Get exclusive control */ LddFlsExclusiveStatus = Fls_ExclusiveControl(FLS_GET_EXCLUSIVE); if (E_OK == LddFlsExclusiveStatus) { /* Get Semaphore */ LddFlsSemaphoreStatus = Fls_Semaphore(FLS_GET_SEMAPHORE); if (E_NOT_OK == LddFlsSemaphoreStatus) { /* Release acquired control */ (void)Fls_ExclusiveControl(FLS_RELEASE_EXCLUSIVE); } else { /* No action required */ } } else { /* Release acquired control */ (void)Fls_ExclusiveControl(FLS_RELEASE_EXCLUSIVE); } /* End of if (E_OK == LddFlsExclusiveStatus) */ /* Check status of get exclusive control/get semaphore */ if ((E_OK == LddFlsExclusiveStatus) && (E_OK == LddFlsSemaphoreStatus)) { LddGetControlResult = FLS_GOT_SEMAPHORE_EXCLUSIVE; } else { /* No action required */ } #elif (FLS_EXCLUSIVE_CONTROL == STD_ON) /* Get exclusive control */ LddFlsExclusiveStatus = Fls_ExclusiveControl(FLS_GET_EXCLUSIVE); if (E_OK == LddFlsExclusiveStatus) { LddGetControlResult = FLS_GOT_EXCLUSIVE; } else { /* Release acquired control */ (void)Fls_ExclusiveControl(FLS_RELEASE_EXCLUSIVE); } #elif (FLS_SEMAPHORE == STD_ON) /* Get Semaphore */ LddFlsSemaphoreStatus = Fls_Semaphore(FLS_GET_SEMAPHORE); if (E_OK == LddFlsSemaphoreStatus) { LddGetControlResult = FLS_GOT_SEMAPHORE; } else { /* No action required */ } #endif /* End of #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) && * (FLS_SEMAPHORE == STD_ON)) */ /* Store get control result */ Fls_GstVarProperties.ddGlobalControlResult = LddGetControlResult; return (LddGetControlResult); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': 'E_NOT_OK'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'enExclusiveType', 'Value': '[1] = FLS_GET_EXCLUSIVE\\n[2] = FLS_RELEASE_EXCLUSIVE'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'Semaphore', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'enExclusiveType', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'ddGlobalControlResult', 'Value': 'FLS_GOT_NOTHING'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddGetControlResult', 'Value': 'FLS_GOT_NOTHING'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_GetIndexSectorMap (const uint32 ulTargetAddress, CONSTP2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) ulIndexSectorMap) /* PRQA S 3432 # JV-01 */ /* END Msg(2:3432)-5 */ { uint32 LulCounterLoop; uint32 LulIndexSectorMap; boolean LblLoopCondition; Std_ReturnType LenReturnValue; LblLoopCondition = FLS_TRUE; LenReturnValue = E_NOT_OK; for (LulCounterLoop = FLS_ZERO_LONG_WORD; (LulCounterLoop < Fls_GpConfigPtr->ulNumberOfSectorPartition) && (FLS_TRUE == LblLoopCondition); LulCounterLoop++) /* PRQA S 2814 # JV-01 */ { if ((Fls_SectorMap[LulCounterLoop].ulSectorStartAddress <= ulTargetAddress) /* PRQA S 2844 # JV-01 */ && (Fls_SectorMap[LulCounterLoop].ulSectorEndAddress >= ulTargetAddress)) { LulIndexSectorMap = LulCounterLoop; LblLoopCondition = FLS_FALSE; } else { /* No action required */ } } /* End of for (LulCounterLoop = FLS_ZERO_LONG_WORD; (LulCounterLoop < Fls_GpConfigPtr->ulNumberOfSectorPartition) && (FLS_TRUE == LblLoopCondition); LulCounterLoop++) */ if (FLS_FALSE == LblLoopCondition) { *ulIndexSectorMap = LulIndexSectorMap; /* PRQA S 2814, 2963 # JV-01, JV-01 */ LenReturnValue = E_OK; } else { *ulIndexSectorMap = FLS_ZERO; } return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'ulTargetAddress', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'ulIndexSectorMap', 'Value': '&map_ulIndexSectorMap[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulNumberOfSectorPartition', 'Value': '1UL'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Fls_SectorMap', 'Value': '&Fls_SectorMap[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorStartAddress', 'Value': '0x7FFFFFFF'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorEndAddress', 'Value': '0x7FFFFFFF'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorStartAddress', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorEndAddress', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorStartAddress', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorEndAddress', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_ulIndexSectorMap[0]', 'Value': 'FLS_ZERO'], 'Output_Param_002': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_HfCheckStatusRegister /* PRQA S 1532 # JV-01 */ (const Fls_FlashReadStatusType enStatusType, const uint32 Timeout) { Fls_StatusRegType LenReturnValue; Std_ReturnType LddProcessStatus; uint32 LulStatusRegValue; uint8 LucStatusRegValue; uint8 LucCycleIndex; /* This variable used to set the manual configuration */ Fls_HfSetConfigManualModeType LddSetManualConfig; /* Set the default value */ LddProcessStatus = E_OK; /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pHfConfig->pHfReadStatusRegConfig; /* PRQA S 2814 # JV-01 */ /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif LddSetManualConfig.ulTimeout = Timeout; /* Send command operation */ LddSetManualConfig.enOperation = FLS_SEND_CMD_OPERATION; /* Send the setup command */ for (LucCycleIndex = FLS_ZERO; (E_OK == LddProcessStatus) && \\ (Fls_GpConfigPtr->pHfConfig->ucHfReadStatusSetupNumberCycle > LucCycleIndex); LucCycleIndex++) { /* Assign to address transaction of current cycle */ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig-> /* PRQA S 2814 # JV-01 */ pHfReadStatusSetupCycle[LucCycleIndex].ulTransactionAddress; /* PRQA S 2824 # JV-01 */ /* Assign data transaction of current cycle to the pointer of application */ LddSetManualConfig.pData = (uint32 *)&Fls_GpConfigPtr->pHfConfig-> /* PRQA S 0311, 3305, 0310 # JV-01, JV-01, JV-01 */ pHfReadStatusSetupCycle[LucCycleIndex].usTransactionData; /* Call the API below to start send command by user configuration */ LddProcessStatus = Fls_HfSetConfigManualMode(LddSetManualConfig); } /* Get the data if the send command is finished */ if (E_OK == LddProcessStatus) { /* Send read operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; /* The address is not care */ LddSetManualConfig.ulAddress = FLS_ZERO_LONG_WORD; /* Call the API below to start read transaction by user configuration */ LddProcessStatus = Fls_HfSetConfigManualMode(LddSetManualConfig); if(E_OK == LddProcessStatus) { /* Read the SMRDR1 register */ LulStatusRegValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Data information locate on SMRDR1[15:8], shift to low byte */ LucStatusRegValue = (uint8)((LulStatusRegValue & FLS_BIT8_TO_BIT15_MASK) >> FLS_BIT_INDEX_8); } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ if (E_OK == LddProcessStatus) { switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pHfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pHfConfig->ucProgramErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pHfConfig->ucDeviceReadyBitPositionMask) == Fls_GpConfigPtr->pHfConfig->ucDeviceReadyBitPositionMask) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } } /* End of if ((LucStatusRegValue & * Fls_GpConfigPtr->pHfConfig->ucProgramErrorBitPositionMask) * == Fls_GpConfigPtr->pHfConfig->ucProgramErrorBitPositionMask */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pHfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pHfConfig->ucEraseErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pHfConfig->ucDeviceReadyBitPositionMask) == Fls_GpConfigPtr->pHfConfig->ucDeviceReadyBitPositionMask) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } } /* End of if ((LucStatusRegValue & * Fls_GpConfigPtr->pHfConfig->ucEraseErrorBitPositionMask) * == Fls_GpConfigPtr->pHfConfig->ucEraseErrorBitPositionMask) */ break; default: /* No action required */ break; } /* End of switch (enStatusType) */ } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ return (LenReturnValue); /* PRQA S 2962 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PROGRAM_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'ERASE_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'enStatusType', 'Value': 'FLS_STATUS_WRITE'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'Timeout', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pHfConfig', 'Value': '&map_pHfConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pHfReadStatusRegConfig', 'Value': '&map_Fls_HfReadStatusRegConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pHfReadStatusSetupCycle', 'Value': '&map_pHfReadStatusSetupCycle[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucProgramErrorBitPositionMask', 'Value': '0x10U'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucEraseErrorBitPositionMask', 'Value': '0x20U'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucDeviceReadyBitPositionMask', 'Value': '0x80U'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '0x00008000UL'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucHfReadStatusSetupNumberCycle', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '-'], 'Input_Param_022': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': 'SetManualConfig'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_STT_FREE'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_HfCheckStatusRegister /* PRQA S 1532 # JV-01 */ (const Fls_FlashReadStatusType enStatusType, const uint32 Timeout) { Fls_StatusRegType LenReturnValue; Std_ReturnType LddProcessStatus; uint32 LulStatusRegValue; uint8 LucStatusRegValue; uint8 LucCycleIndex; /* This variable used to set the manual configuration */ Fls_HfSetConfigManualModeType LddSetManualConfig; /* Set the default value */ LddProcessStatus = E_OK; /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pHfConfig->pHfReadStatusRegConfig; /* PRQA S 2814 # JV-01 */ /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif LddSetManualConfig.ulTimeout = Timeout; /* Send command operation */ LddSetManualConfig.enOperation = FLS_SEND_CMD_OPERATION; /* Send the setup command */ for (LucCycleIndex = FLS_ZERO; (E_OK == LddProcessStatus) && \\ (Fls_GpConfigPtr->pHfConfig->ucHfReadStatusSetupNumberCycle > LucCycleIndex); LucCycleIndex++) { /* Assign to address transaction of current cycle */ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig-> /* PRQA S 2814 # JV-01 */ pHfReadStatusSetupCycle[LucCycleIndex].ulTransactionAddress; /* PRQA S 2824 # JV-01 */ /* Assign data transaction of current cycle to the pointer of application */ LddSetManualConfig.pData = (uint32 *)&Fls_GpConfigPtr->pHfConfig-> /* PRQA S 0311, 3305, 0310 # JV-01, JV-01, JV-01 */ pHfReadStatusSetupCycle[LucCycleIndex].usTransactionData; /* Call the API below to start send command by user configuration */ LddProcessStatus = Fls_HfSetConfigManualMode(LddSetManualConfig); } /* Get the data if the send command is finished */ if (E_OK == LddProcessStatus) { /* Send read operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; /* The address is not care */ LddSetManualConfig.ulAddress = FLS_ZERO_LONG_WORD; /* Call the API below to start read transaction by user configuration */ LddProcessStatus = Fls_HfSetConfigManualMode(LddSetManualConfig); if(E_OK == LddProcessStatus) { /* Read the SMRDR1 register */ LulStatusRegValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Data information locate on SMRDR1[15:8], shift to low byte */ LucStatusRegValue = (uint8)((LulStatusRegValue & FLS_BIT8_TO_BIT15_MASK) >> FLS_BIT_INDEX_8); } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ if (E_OK == LddProcessStatus) { switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pHfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pHfConfig->ucProgramErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pHfConfig->ucDeviceReadyBitPositionMask) == Fls_GpConfigPtr->pHfConfig->ucDeviceReadyBitPositionMask) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } } /* End of if ((LucStatusRegValue & * Fls_GpConfigPtr->pHfConfig->ucProgramErrorBitPositionMask) * == Fls_GpConfigPtr->pHfConfig->ucProgramErrorBitPositionMask */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pHfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pHfConfig->ucEraseErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pHfConfig->ucDeviceReadyBitPositionMask) == Fls_GpConfigPtr->pHfConfig->ucDeviceReadyBitPositionMask) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } } /* End of if ((LucStatusRegValue & * Fls_GpConfigPtr->pHfConfig->ucEraseErrorBitPositionMask) * == Fls_GpConfigPtr->pHfConfig->ucEraseErrorBitPositionMask) */ break; default: /* No action required */ break; } /* End of switch (enStatusType) */ } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ return (LenReturnValue); /* PRQA S 2962 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PROGRAM_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'ERASE_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'enStatusType', 'Value': 'FLS_STATUS_WRITE'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'Timeout', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pHfConfig', 'Value': '&map_pHfConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pHfReadStatusRegConfig', 'Value': '&map_Fls_HfReadStatusRegConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pHfReadStatusSetupCycle', 'Value': '&map_pHfReadStatusSetupCycle[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucProgramErrorBitPositionMask', 'Value': '0x00U'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucEraseErrorBitPositionMask', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucDeviceReadyBitPositionMask', 'Value': '0x00U'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '0x00000000UL'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucHfReadStatusSetupNumberCycle', 'Value': '3'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '0x00000555UL'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '0x00AAU'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '0x000002AAUL'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '0x0055U'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '0x00000555UL'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '0x00C7U'], 'Input_Param_022': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '[0 to 3] = E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '[0 to 3] = SetManualConfig'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_STT_ERROR'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_HfPPNormal (const Fls_AddressType TargetAddress, CONSTP2CONST(uint32, AUTOMATIC, FLS_APPL_CONST) pWriteData, const Fls_LengthType Length) { Fls_StatusRegType LenWriteStatus; Fls_AddressType LddTargetAddress; uint32 LulLoops; P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) LpWriteData; /* PRQA S 3432 # JV-01 */ uint32 LaaRemainBytes[FLS_TWO_BYTES] = {FLS_ERASED_VALUE, FLS_ERASED_VALUE}; /* PRQA S 3678 # JV-01 */ const uint8 LucRemainBytes = (uint8)(Length % FLS_SIZE_OF_TWO_LONG_WORD); LulLoops = (Length - LucRemainBytes) / FLS_SIZE_OF_TWO_LONG_WORD; /* PRQA S 3383 # JV-01 */ LpWriteData = (P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA)) pWriteData; /* PRQA S 3432, 0311 # JV-01, JV-01 */ LddTargetAddress = TargetAddress; LenWriteStatus = FLS_STT_FREE; while ((FLS_ZERO_LONG_WORD != LulLoops) && (FLS_STT_FREE == LenWriteStatus)) { LenWriteStatus = Fls_HfProcessPPNormal(LddTargetAddress, LpWriteData, (uint8)FLS_SIZE_OF_TWO_LONG_WORD); /* PRQA S 0488 # JV-01 */ LpWriteData += FLS_TWO_LONG_WORD; /* PRQA S 0488, 2824 # JV-01, JV-01 */ LddTargetAddress += FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 3383 # JV-01 */ LulLoops--; } /* End of while ((FLS_ZERO_LONG_WORD != LulLoops) && * (FLS_STT_FREE == LenWriteStatus)) */ if ((FLS_ZERO != LucRemainBytes) && (FLS_STT_FREE == LenWriteStatus)) { /* Fill the remaining data into LaaRemainBytes array */ Fls_MemCopyUseLoop((uint8 *)&LaaRemainBytes, LpWriteData, (uint32)LucRemainBytes); /* PRQA S 0310, 0751, 0315 # JV-01, JV-01, JV-01 */ LenWriteStatus = Fls_HfProcessPPNormal(LddTargetAddress, (uint32 *)&LaaRemainBytes, LucRemainBytes); /* PRQA S 0310, 0751, 0315 # JV-01, JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_ZERO != LucRemainBytes) */ return (LenWriteStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x00..0xFFFFFFFF', 'Name': 'TargetAddress', 'Value': '0'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0x00..0xFFFFFFFF', 'Name': 'pWriteData', 'Value': '&map_pWriteData'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0x00..0xFFFFFFFF', 'Name': 'Length', 'Value': '16'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = FLS_STT_FREE\\n[2] = FLS_STT_TIMEOUT']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': '[1] = 0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': '[1] = &map_pWriteData'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '[1] = FLS_SIZE_OF_TWO_LONG_WORD'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': '[2] = FLS_SIZE_OF_A_LONG_WORD'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': '[2] = pWriteData'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '[2] = FLS_SIZE_OF_TWO_LONG_WORD'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenWriteStatus', 'Value': 'FLS_STT_TIMEOUT'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_HfProcessPPNormal (const Fls_AddressType TargetAddress, CONSTP2CONST(uint32, AUTOMATIC, FLS_APPL_CONST) pWriteData, const uint8 Length) { TickType LddWriteTime; Std_ReturnType LddProcessStatus; Fls_StatusRegType LenWriteStatus; uint8 LucCycleIndex; /* This variable used to save the user configuration for page program * operation */ Fls_HfSetConfigManualModeType LddSetManualConfig; LddProcessStatus = E_OK; /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pHfConfig->pHfProgramConfig; /* PRQA S 2814 # JV-01 */ /* The length not used */ LddSetManualConfig.Length = FLS_ZERO; /* Send command operation */ LddSetManualConfig.enOperation = FLS_SEND_CMD_OPERATION; LddSetManualConfig.ulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* Send the setup command */ for (LucCycleIndex = FLS_ZERO; (E_OK == LddProcessStatus) && \\ (Fls_GpConfigPtr->pHfConfig->ucHfProgramSetupNumberCycle > LucCycleIndex); LucCycleIndex++) { /* Assign to address transaction of current cycle */ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig-> /* PRQA S 2814 # JV-01 */ pHfProgramSetupCycle[LucCycleIndex].ulTransactionAddress; /* PRQA S 2824 # JV-01 */ /* Assign data transaction of current cycle to the pointer of application */ LddSetManualConfig.pData = (uint32 *)&Fls_GpConfigPtr->pHfConfig-> /* PRQA S 0310, 0311, 3305 # JV-01, JV-01, JV-01 */ pHfProgramSetupCycle[LucCycleIndex].usTransactionData; /* Call the API below to start send command by user configuration */ LddProcessStatus = Fls_HfSetConfigManualMode(LddSetManualConfig); } if (E_OK == LddProcessStatus) { /* Send write operation */ LddSetManualConfig.ulAddress = TargetAddress; LddSetManualConfig.pData = (P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA))pWriteData; /* PRQA S 3432, 0311 # JV-01, JV-01 */ LddSetManualConfig.enOperation = FLS_WRITE_OPERATION; LddSetManualConfig.ulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ LddSetManualConfig.Length = Length; /* Call the API below to start page program by user configuration */ LddProcessStatus = Fls_HfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { LddWriteTime = Fls_GetMaxWriteTime(TargetAddress, (uint32)Length); LenWriteStatus = Fls_HfWaitStatusReg(LddWriteTime, FLS_STATUS_WRITE); } else { LenWriteStatus = FLS_STT_TIMEOUT; } } else { LenWriteStatus = FLS_STT_TIMEOUT; } /* End of if (FLS_STT_FREE == LenWriteStatus) */ return (LenWriteStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x00..0xFFFFFFFF', 'Name': 'TargetAddress', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x00..0xFFFFFFFF', 'Name': 'pWriteData', 'Value': '0'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0x00..0xFF', 'Name': 'Length', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pHfConfig', 'Value': '&map_pHfConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHfProgramConfig', 'Value': ''], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucHfProgramSetupNumberCycle', 'Value': '1'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pHfProgramSetupCycle', 'Value': '&map_pHfProgramSetupCycle[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '0x00000000'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '0'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0] = E_OK\\n[1] = E_OK'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '0'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FLS_STT_FREE']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '[1] = SetManualConfig'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '[2] = SetManualConfig'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulFlsAddress', 'Value': '0'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSize', 'Value': '0'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'called'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenWriteStatus', 'Value': 'FLS_STT_FREE'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_HfReadHardwareId /* PRQA S 1532 # JV-01 */ (CONSTP2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) pHardwareID) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LddProcessStatus; Fls_HfSetConfigManualModeType LddSetManualConfig; uint8 LucArrayCountHwId; uint32 LulSMRDR1Value; /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pHfConfig->pHfReadHwIdConfig; /* PRQA S 2814 # JV-01 */ /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif /* Assign to address Enter CFI */ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig->pHfEnterCFI->ulTransactionAddress; /* PRQA S 2814 # JV-01 */ /* Assign data transaction of Enter CFI to the pointer of application */ LddSetManualConfig.pData = (uint32 *)&Fls_GpConfigPtr->pHfConfig->pHfEnterCFI->usTransactionData; /* PRQA S 3305, 0310, 0311 # JV-01, JV-01, JV-01 */ /* Command operation */ LddSetManualConfig.enOperation = FLS_SEND_CMD_OPERATION; LddSetManualConfig.ulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* Call the API below to start Enter CFI by user configuration */ LddProcessStatus = Fls_HfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { /* Read operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; for (LucArrayCountHwId = FLS_ZERO; (FLS_EXPECTED_HW_ID_LEN > LucArrayCountHwId)&& (E_OK == LddProcessStatus); LucArrayCountHwId++) { /* Assign to address HW ID */ switch (LucArrayCountHwId) { case FLS_ZERO: /* Assign to address HW ID zero*/ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig->pHfIDReadAddress->ulIDReadAddress0; /* PRQA S 2814 # JV-01 */ break; #if (FLS_EXPECTED_HW_ID_LEN >= 2) case FLS_ONE: /* Assign to address HW ID one*/ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig->pHfIDReadAddress->ulIDReadAddress1; break; #endif #if (FLS_EXPECTED_HW_ID_LEN >= 3) case FLS_TWO: /* Assign to address HW ID two*/ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig->pHfIDReadAddress->ulIDReadAddress2; break; #endif #if (FLS_EXPECTED_HW_ID_LEN == 4) case FLS_THREE: /* Assign to address HW ID three*/ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig->pHfIDReadAddress->ulIDReadAddress3; break; #endif default: /* NOT REACHED */ break; } /* Call the API below to start read HW Id by user configuration */ LddProcessStatus = Fls_HfSetConfigManualMode(LddSetManualConfig); if(E_OK == LddProcessStatus) { /* Read the SMRDR1 register */ LulSMRDR1Value = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* HW-ID information locate on SMRDR1[15:8], shift to low byte */ LulSMRDR1Value = (LulSMRDR1Value & FLS_BIT8_TO_BIT15_MASK) >> FLS_BIT_INDEX_8; /* assign value to HW ID value with shift oder */ pHardwareID[FLS_ZERO] = (pHardwareID[FLS_ZERO]) | (LulSMRDR1Value << (FLS_BIT_INDEX_8 * LucArrayCountHwId)); /* PRQA S 3383, 2824 # JV-01, JV-01 */ } else { /* No action required */ } } } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ /* Assign to address Exit CFI */ LddSetManualConfig.ulAddress = Fls_GpConfigPtr->pHfConfig->pHfExitCFI->ulTransactionAddress; /* PRQA S 2814 # JV-01 */ /* Assign data transaction of Exit CFI to the pointer of application */ LddSetManualConfig.pData = (uint32 *)&Fls_GpConfigPtr->pHfConfig->pHfExitCFI->usTransactionData; /* PRQA S 0310, 0311, 3305 # JV-01, JV-01, JV-01 */ /* Read operation */ LddSetManualConfig.enOperation = FLS_SEND_CMD_OPERATION; /* Call the API below to start Exit CFI by user configuration */ LddProcessStatus |= Fls_HfSetConfigManualMode(LddSetManualConfig); return (LddProcessStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE\\nFLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'pHardwareID', 'Value': '&map_pHardwareID[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pHfConfig', 'Value': '&map_pHfConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pHfReadHwIdConfig', 'Value': '&map_pHfReadHwIdConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pHfEnterCFI', 'Value': '&map_pHfEnterCFI[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHfIDReadAddress', 'Value': '&map_pHfIDReadAddress[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pHfExitCFI', 'Value': '&map_pHfExitCFI[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0x00..0xFFFFFFFF', 'Name': 'ulTransactionAddress', 'Value': '0x00000001'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0x00..0xFFFFFFFF', 'Name': 'ulIDReadAddress0', 'Value': '0x00000011'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0x00..0xFFFFFFFF', 'Name': 'ulIDReadAddress1', 'Value': '0x00000111'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0x00..0xFFFFFFFF', 'Name': 'ulIDReadAddress2', 'Value': '0x00001111'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0x00..0xFFFFFFFF', 'Name': 'ulIDReadAddress3', 'Value': '0x00011111'], 'Input_Param_014': ['Type': 'Variable', 'Range': '0x00..0xFFFFFFFF', 'Name': 'ulTransactionAddress', 'Value': '0x00111111'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0x00..0xFFFF', 'Name': 'usTransactionData', 'Value': '0x0010'], 'Input_Param_016': ['Type': 'Variable', 'Range': '0x00..0xFFFF', 'Name': 'usTransactionData', 'Value': '0x1010'], 'Input_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '0x00001111'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'return', 'Value': '[1]=E_OK\\n[2]=E_OK\\n[3]=E_OK\\n[4]=E_NOT_OK\\n[5]=E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '[1]=SetManualConfig\\n[2]=SetManualConfig\\n[3]=SetManualConfig\\n[4]=SetManualConfig\\n[5]=SetManualConfig'], 'Output_Param_001': ['Type': 'Variable', 'Range': '0x00..0xFFFFFFFF', 'Name': 'pHardwareID[0]', 'Value': '-'], 'Output_Param_002': ['Type': 'Return_Value', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'LddProcessStatus', 'Value': 'E_NOT_OK'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': 'V4H modified']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_HfReadManualMode (const uint32 ReadAddress, CONSTP2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) pReadData, /* PRQA S 3432 # JV-01 */ const uint32 ReadDataSize) { Std_ReturnType LddReturnStatus; Fls_HfSetConfigManualModeType LddSetReadConfig; /* Apply the user configuration */ LddSetReadConfig.pUserConfig = Fls_GpConfigPtr->pHfConfig->pHfReadConfig; /* PRQA S 2814 # JV-01 */ LddSetReadConfig.ulAddress = ReadAddress; LddSetReadConfig.enOperation = FLS_READ_OPERATION; LddSetReadConfig.ulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ LddSetReadConfig.pData = pReadData; /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetReadConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetReadConfig.Length = FLS_ZERO; #endif /* Call the API below to start read by user configuration */ LddReturnStatus = Fls_HfSetConfigManualMode(LddSetReadConfig); if (E_OK == LddReturnStatus) { /* Fill read data to pData pointer */ LddReturnStatus = Fls_HfGetDataManualMode((uint32 *)LddSetReadConfig.pData, ReadDataSize, LddSetReadConfig.ulAddress); } else { /* No action required */ } return (LddReturnStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_EXTERNAL_SPACE_READ', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'ReadAddress', 'Value': '0'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'pReadData', 'Value': ''], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'ReadDataSize', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHfConfig', 'Value': '&map_pHfConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pHfReadConfig', 'Value': ''], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDistData', 'Value': '&map_pData[0]'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'DataSize', 'Value': '1024'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'ReadAddress', 'Value': '0x7FFFFFFF'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnStatus', 'Value': 'E_OK'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_HfSetSpecificConfig /* PRQA S 1532 # JV-01 */ (CONSTP2CONST(Fls_HfSpecificConfigType, AUTOMATIC, FLS_APPL_CONST) SpecificConfigPtr, CONSTP2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) DataAddressPtr, /* PRQA S 3432 # JV-01 */ const uint8 Length) { /* Local variable to hold the return value */ Std_ReturnType LddReturnValue; uint8 LucOperation; uint32 LulTimeout; uint32 LulSMWDR0Value; uint32 LulSMRDR0Value; uint32 LulSMWDR1Value; uint32 LulSMRDR1Value; #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) uint32 LulRegRealValue; uint32 LulOrMaskValRegister; #endif uint32 LulRegData; uint8 LucCycleIndex; /* Get the SPIRE bit value, if it configured as 1, read operation enabled. * Else, write operation enabled */ LucOperation = (uint8)(SpecificConfigPtr->ulSMCRRegValue & FLS_SMCR_SPIRE_MASK); /* PRQA S 2814 # JV-01 */ /* Timeout monitor */ LulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* ---------------Waiting for data transfer has ended --------------------*/ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); #if (FLS_CPG_CLOCK_SETTING == STD_ON) if (E_OK == LddReturnValue) { /* clock setting with waiting for data transfer has ended */ LddReturnValue = Fls_ClockSetting( (uint32)(SpecificConfigPtr->ucRPCCKCRRegValue)); } else { /* No action required */ } #endif /* End of #if (FLS_CPG_CLOCK_SETTING == STD_ON) */ /* If transfer has been finished */ if (E_OK == LddReturnValue) { /* --------------------------Initialize manual mode---------------------- */ /* Configure PHYOFFSET1 register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, FLS_PHYOFFSET1_DDRTMG_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, SpecificConfigPtr->ulPHYOFFSET1RegValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYOFFSET1_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulPHYOFFSET1RegValue, FLS_PHYOFFSET1_DDRTMG_MASK); #endif /* Configure PHYCNT register */ /* Set PHYCNT user configuration */ LulRegData = SpecificConfigPtr->ulPHYCNTRegValue; /* Set PHYCNT.CAL = 0 */ LulRegData &= ~(FLS_PHYCNT_CAL_MASK); FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYCNT_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Configure CMNCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_CMNCR_ADDR, FLS_CMNCR_MD_MASK /* PRQA S 3469, 0303 # JV-01, JV-01 */ | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_CMNCR_ADDR, SpecificConfigPtr->ulCMNCRRegValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_CMNCR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulCMNCRRegValue, LulOrMaskValRegister); #endif /* Configure SSLDR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SSLDR_ADDR, /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SSLDR_ADDR, SpecificConfigPtr->ulSSLDRRegValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SSLDR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSSLDRRegValue, LulOrMaskValRegister); #endif /* Configure SMDRENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDRENR_ADDR, /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDRENR_ADDR, SpecificConfigPtr->ulSMDRENRValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDRENR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDRENRValue, LulOrMaskValRegister); #endif /* Configure SMENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMENR_ADDR, /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMENR_ADDR, SpecificConfigPtr->ulSMENRRegValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMENR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMENRRegValue, LulOrMaskValRegister); #endif /* Configure SMDMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDMCR_ADDR, FLS_SMDMCR_DMCYC_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_SMDMCR_DMCYC_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDMCR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_ZERO_LONG_WORD, LulOrMaskValRegister); #endif /* Set command */ LulRegData = FLS_ZERO_LONG_WORD; /* Set the CA[47] to 0 for write transaction */ LulRegData &= ~(FLS_SMCMR_CMD7_MASK); /* Set the CA[46] to 0 for memory space */ LulRegData &= ~(FLS_SMCMR_CMD6_MASK); /* Set the CA[45] to 0 for wrapped burst */ LulRegData &= ~(FLS_SMCMR_CMD5_MASK); FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCMR_ADDR, FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCMR_ADDR, LulRegData); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCMR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Clear DME, SPIDE bits first */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMENR_ADDR, FLS_SMENR_SPIDE_MASK | FLS_SMENR_DME_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Enable 16 bits transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMENR_ADDR, FLS_SMENR_SPIDE_16_BIT); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_SMENR_SPIDE_MASK | FLS_SMENR_DME_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMENR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_SMENR_SPIDE_16_BIT, LulOrMaskValRegister); #endif /* Send the setup command */ for (LucCycleIndex = FLS_ZERO; (E_OK == LddReturnValue) && \\ (SpecificConfigPtr->ucHfSpecificNumberCycle > LucCycleIndex); \\ LucCycleIndex++) { /* Set the target address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, SpecificConfigPtr-> /* PRQA S 2824, 3469, 0303 # JV-01, JV-01, JV-01 */ pHfSpecificSetupCycle[LucCycleIndex].ulTransactionAddress); #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr-> pHfSpecificSetupCycle[LucCycleIndex].ulTransactionAddress, LulOrMaskValRegister); #endif /* End of #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) */ LulRegData = FLS_ZERO_LONG_WORD; /* PRQA S 2982 # JV-01 */ /* Write DQ6 (low byte) value to SMWDR0[31:24] register */ LulRegData = ((uint32)SpecificConfigPtr-> pHfSpecificSetupCycle[LucCycleIndex].usTransactionData & FLS_ONE_BYTE_MASK) << FLS_BIT_INDEX_24; /* Write DQ7 (high byte) value to SMWDR0[23:16] register */ LulRegData |= ((uint32)SpecificConfigPtr-> pHfSpecificSetupCycle[LucCycleIndex].usTransactionData & FLS_BIT8_TO_BIT15_MASK) << FLS_BIT_INDEX_8; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, LulRegData); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Set CAL bit in PHYCNT to 1 for executing the physical calibration */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_PHYCNT_ADDR, FLS_PHYCNT_CAL_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Configure SMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK, LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ } else { /* No action required */ } } if ((E_OK == LddReturnValue) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { /* Set the target address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, SpecificConfigPtr->ulSMADRRegValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMADRRegValue, LulOrMaskValRegister); #endif /* End of #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) */ /* Configure SMENR register */ /* Clear DME, SPIDE bits first */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMENR_ADDR, FLS_SMENR_SPIDE_MASK | FLS_SMENR_DME_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMENR_ADDR, SpecificConfigPtr->ulSMENRRegValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMENR_SPIDE_MASK | FLS_SMENR_DME_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMENR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMENRRegValue, LulOrMaskValRegister); #endif /* Set dummy cycles */ /* Configure SMDMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDMCR_ADDR, FLS_SMDMCR_DMCYC_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDMCR_ADDR, SpecificConfigPtr->ulSMDMCRValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_SMDMCR_DMCYC_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDMCR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDMCRValue, LulOrMaskValRegister); #endif /* Set command */ LulRegData = FLS_ZERO_LONG_WORD; /* Set the CA[46] to 0 for memory space */ LulRegData &= ~(FLS_SMCMR_CMD6_MASK); /* Set the CA[45] to 1 for linear burst */ LulRegData |= (FLS_SMCMR_CMD5_MASK); if (FLS_ZERO == LucOperation) { /* Set the CA[47] to 0 for write transaction */ LulRegData &= ~(FLS_SMCMR_CMD7_MASK); } else { /* Set the CA[47] to 1 for read transaction */ LulRegData |= (FLS_SMCMR_CMD7_MASK); } FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCMR_ADDR, FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCMR_ADDR, LulRegData); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCMR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Write operation */ if (FLS_ZERO == LucOperation) { /* If 64 bits transferred, copies to SMWDR1 and SMWDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, copies data[31:0] to SMWDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR1Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR1Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 0310, 3305 # JV-01, JV-01, JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR1_ADDR, LulSMWDR1Value); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR1Value, LulOrMaskValRegister); #endif FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, FLS_ERASED_VALUE); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_ERASED_VALUE, LulOrMaskValRegister); #endif } else { /* Otherwise, copies data[63:32] to SMWDR0, data[31:0] to SMWDR1 */ Fls_MemCopyUseLoop ((uint32 *)FLS_RPC_SMWDR1_ADDR, (uint32 *)DataAddressPtr, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0306, 0315, 0310, 3305 # JV-01, JV-01, JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, (*(uint32 *)DataAddressPtr), LulOrMaskValRegister); /* PRQA S 2814, 0310, 3305 # JV-01, JV-01, JV-01 */ #endif LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMWDR0Value, /* PRQA S 0315 # JV-01 */ (uint32 *)(DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD),(uint32)Length - FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 0310, 3305, 0488, 2824, 3383 # JV-01, JV-01, JV-01, JV-01, JV-01, JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, LulSMWDR0Value); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR0Value, LulOrMaskValRegister); #endif } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, copies to SMWDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 0310, 3305 # JV-01, JV-01, JV-01 */ if (ONE_UNIT_DATA == SpecificConfigPtr->ucDataLength) { LulSMWDR0Value = ((uint32)LulSMWDR0Value & FLS_TWO_BYTES_MASK) << FLS_BIT_INDEX_16; } else { /* No action required */ } FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, LulSMWDR0Value); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR0Value, LulOrMaskValRegister); #endif } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ } else { /* No action required */ } /* End of if (FLS_ZERO == LucOperation)*/ /* -----Enable Read/Write Operation and Start transfer----- */ /* Set CAL bit in PHYCNT to 1 for executing the physical calibration */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_PHYCNT_ADDR, FLS_PHYCNT_CAL_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Configure SMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, SpecificConfigPtr->ulSMCRRegValue); /* PRQA S 3469, 0303 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCRRegValue, LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* If read operation */ if (FLS_ZERO != LucOperation) { /* If 64 bits transferred, read from SMRDR1 and SMRDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, read data[31:0] from SMRDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR1 register*/ LulSMRDR1Value = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR1Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* Else read data[63:32] from SMRDR0, data[31:0] from SMRDR1 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)FLS_RPC_SMRDR1_ADDR, (uint32)FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LulSMRDR0Value= FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR0_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_MemCopyUseLoop (DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD, (uint32 *)&LulSMRDR0Value, /* PRQA S 0315, 0488 # JV-01, JV-01 */ (uint32)(Length - FLS_SIZE_OF_A_LONG_WORD)); /* PRQA S 4391, 3383 # JV-01, JV-01 */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, read directly from SMRDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register*/ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0306, 0315 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ } else { /* No action required */ } /* End of if (FLS_ZERO != LucOperation)*/ } else { /* No action required */ } /* if (E_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if if ((E_OK == LddReturnValue) && (NOT_USED != SpecificConfigPtr->ucDataLength))*/ } else { /* No action required */ } /* if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEND_SPEC_CONFIG_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CPG_CLOCK_SETTING', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_VERIFY_ENABLE', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': '&map_HfSpecificConfigPtr[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'DataAddressPtr', 'Value': '&map_DataAddressPtr[0]'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '5'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHfSpecificSetupCycle', 'Value': '&map_pHfSpecificSetupCycle[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucHfSpecificNumberCycle', 'Value': '3'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYCNTRegValue', 'Value': '0x88038003UL'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulCMNCRRegValue', 'Value': '0x80FF0301UL'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMADRRegValue', 'Value': '0x00F00000UL'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMENRRegValue', 'Value': '0xA222540FUL'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulSSLDRRegValue', 'Value': '0x00000400UL'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDMCRValue', 'Value': '0x00000000UL'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '0x00005101UL'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCRRegValue', 'Value': '0x00000003UL'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYOFFSET1RegValue', 'Value': '0x20000000UL'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucRPCCKCRRegValue', 'Value': '0x13U'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucDataLength', 'Value': 'FOUR_UNITS_DATA'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '0x00000555UL'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '0x00AAU'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '0x000002AAUL'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '0x0055U'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulTransactionAddress', 'Value': '0x00000555UL'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'usTransactionData', 'Value': '0x00A0U'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '0x03020100'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '0x07060504'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '-'], 'Input_Param_030': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '[0 to 1] = *((uint32 *)pSrc)'], 'Input_Param_031': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0] = E_OK\\n[1] = E_OK\\n[2] = E_OK\\n[3] = E_OK\\n[4] = E_OK'], 'Input_Param_032': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0x65555555UL'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_PHYCNT_ADDR[0]', 'Value': '0x88038003UL'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0xD5FF5755UL'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0x55505450UL'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0]', 'Value': '0x55555545UL'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0xA666540FUL'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0x55555540UL'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0x55205500UL'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMADR_ADDR[0]', 'Value': '0x00F00000UL'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0X55555452UL'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '0x03020100'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '0x07060504'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRPCCKCRRegValue', 'Value': '0x13U'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_PHYOFFSET1_ADDR[0]\\n[1] = map_FLS_RPC_PHYCNT_ADDR[0]\\n[2] = map_FLS_RPC_CMNCR_ADDR[0]\\n[3] = map_FLS_RPC_SSLDR_ADDR[0]\\n[4] = map_FLS_RPC_SMDRENR_ADDR[0]\\n[5] = map_FLS_RPC_SMENR_ADDR[0]\\n[6] = map_FLS_RPC_SMDMCR_ADDR[0]\\n[7] = map_FLS_RPC_SMCMR_ADDR[0]\\n[8] = map_FLS_RPC_SMENR_ADDR[0]'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_HfSpecificConfigPtr[0].ulPHYOFFSET1RegValue\\n[1] = (map_HfSpecificConfigPtr[0].ulPHYCNTRegValue & ~(FLS_PHYCNT_CAL_MASK))\\n[2] = map_HfSpecificConfigPtr[0].ulCMNCRRegValue\\n[3] = map_HfSpecificConfigPtr[0].ulSSLDRRegValue\\n[4] = map_HfSpecificConfigPtr[0].ulSMDRENRValue\\n[5] = map_HfSpecificConfigPtr[0].ulSMENRRegValue\\n[6] = FLS_ZERO_LONG_WORD\\n[7] = 0x00000000\\n[8] = FLS_SMENR_SPIDE_16_BIT'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_PHYOFFSET1_DDRTMG_MASK\\n[1] = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK)\\n[2] = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK)\\n[3] = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK)\\n[4] = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)\\n[5] = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK)\\n[6] = FLS_SMDMCR_DMCYC_MASK\\n[7] = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK)\\n[8] = (FLS_SMENR_SPIDE_MASK | FLS_SMENR_DME_MASK)'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_SMADR_ADDR[0]\\n[1] = map_FLS_RPC_SMWDR0_ADDR[0]\\n[2] = map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_pHfSpecificSetupCycle[0].ulTransactionAddress\\n[1] = ((map_pHfSpecificSetupCycle[0].usTransactionData & FLS_ONE_BYTE_MASK) << FLS_BIT_INDEX_24) | ((map_pHfSpecificSetupCycle[0].usTransactionData & FLS_BIT8_TO_BIT15_MASK) << FLS_BIT_INDEX_8)\\n[2] = (FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK)'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_A_LONG_WORD_MASK\\n[1] = FLS_A_LONG_WORD_MASK\\n[2] = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_SMADR_ADDR[0]\\n[1] = map_FLS_RPC_SMWDR0_ADDR[0]\\n[2] = map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_pHfSpecificSetupCycle[1].ulTransactionAddress\\n[1] = ((map_pHfSpecificSetupCycle[1].usTransactionData & FLS_ONE_BYTE_MASK) << FLS_BIT_INDEX_24) | ((map_pHfSpecificSetupCycle[1].usTransactionData & FLS_BIT8_TO_BIT15_MASK) << FLS_BIT_INDEX_8)\\n[2] = (FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK)'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_A_LONG_WORD_MASK\\n[1] = FLS_A_LONG_WORD_MASK\\n[2] = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_SMADR_ADDR[0]\\n[1] = map_FLS_RPC_SMWDR0_ADDR[0]\\n[2] = map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_pHfSpecificSetupCycle[2].ulTransactionAddress\\n[1] = ((map_pHfSpecificSetupCycle[2].usTransactionData & FLS_ONE_BYTE_MASK) << FLS_BIT_INDEX_24) | ((map_pHfSpecificSetupCycle[2].usTransactionData & FLS_BIT8_TO_BIT15_MASK) << FLS_BIT_INDEX_8)\\n[2] = (FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK)'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_A_LONG_WORD_MASK\\n[1] = FLS_A_LONG_WORD_MASK\\n[2] = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_SMADR_ADDR[0]\\n[1] = map_FLS_RPC_SMENR_ADDR[0]\\n[2] = map_FLS_RPC_SMDMCR_ADDR[0]\\n[3] = map_FLS_RPC_SMCMR_ADDR[0]'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_HfSpecificConfigPtr[0].ulSMADRRegValue\\n[1] = map_HfSpecificConfigPtr[0].ulSMENRRegValue\\n[2] = map_HfSpecificConfigPtr[0].ulSMDMCRValue\\n[3] = 0x00200000'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_A_LONG_WORD_MASK\\n[1] = (FLS_SMENR_SPIDE_MASK | FLS_SMENR_DME_MASK)\\n[2] = FLS_SMDMCR_DMCYC_MASK\\n[3] = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK)'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': 'FLS_RPC_SMWDR1_ADDR'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '&map_DataAddressPtr[0]'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': 'FLS_SIZE_OF_A_LONG_WORD'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': 'map_FLS_RPC_SMWDR1_ADDR[0]'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': 'map_DataAddressPtr[0]'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': 'FLS_A_LONG_WORD_MASK'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': 'pDest'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '&map_DataAddressPtr[1]'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '1'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_SMWDR0_ADDR[0]\\n[1] = map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_DataAddressPtr[1]\\n[1] = map_HfSpecificConfigPtr[0].ulSMCRRegValue'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_A_LONG_WORD_MASK\\n[1] = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_046': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_048': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_049': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_050': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_051': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FLS_CODE_SLOW) Fls_MainFunction(void) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { Std_ReturnType LddJobStatus; Fls_JobStatusType LddCurrentJobStatus; #if (FLS_CPG_CLOCK_SETTING == STD_ON) Std_ReturnType LddSaveClockSettingStatus; #endif /* Check if any job is being processed */ if ((E_OK == Fls_GstVarProperties.ddMainJobFlag) && (MEMIF_BUSY == Fls_GenState)) { Fls_GenState = MEMIF_BUSY_INTERNAL; LddCurrentJobStatus = Fls_GstVarProperties.enJobStatus; if ((FLS_BUSY == LddCurrentJobStatus) || (FLS_OK == LddCurrentJobStatus)) { #if (FLS_CPG_CLOCK_SETTING == STD_ON) /* Save current clock setting */ LddSaveClockSettingStatus = Fls_SaveClockSetting(); if (E_OK == LddSaveClockSettingStatus) { #endif /* Invokes this API to get status of job */ LddJobStatus = Fls_JobHandlers(); #if (FLS_CPG_CLOCK_SETTING == STD_ON) /* Restore clock setting */ (void)Fls_RestoreClockSetting(); } else { /* End this job */ LddJobStatus = E_OK; /* Update the status of job */ Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; } /* End of if (E_OK == LddSaveClockSettingStatus) */ #endif /* End of #if (FLS_CPG_CLOCK_SETTING == STD_ON) */ } else { /* End this job */ LddJobStatus = E_OK; } /* End of if ((FLS_BUSY == LddCurrentJobStatus) || (FLS_OK == LddCurrentJobStatus)) */ /* If Job has been finished */ if (E_OK == LddJobStatus) { /* Update main job's status */ Fls_GstVarProperties.ddMainJobFlag = Fls_VerifyJobStatus(); } else { /* No action required */ } /* Release the semaphore/exclusive control if no job is running */ if (MEMIF_JOB_PENDING != Fls_GstVarProperties.enJobResult) { #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GstVarProperties.ddMainJobFlag |= Fls_ReleaseControl(); #endif /* Release resource for other job */ Fls_GenState = MEMIF_IDLE; } else { /* Release internal control */ Fls_GenState = MEMIF_BUSY; } /* End of if (MEMIF_JOB_PENDING != Fls_GstVarProperties.enJobResult) */ } else { /* No action required */ } /* End of if any job is being processed */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CPG_CLOCK_SETTING', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'E_OK/E_NOT_OK', 'Name': 'ddMainJobFlag', 'Value': 'E_OK'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'FLS_OK/FLS_BUSY/FLS_ERR_WRITE/FLS_ERR_ERASE/FLS_ERR_BLANKCHECK/FLS_CANCELLED/FLS_TIME_OUT/FLS_ERR_VERIFY_ERASE/FLS_ERR_VERIFY_WRITE', 'Name': 'enJobStatus', 'Value': 'FLS_BUSY'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'MEMIF_JOB_OK              MEMIF_JOB_FAILED    MEMIF_JOB_PENDING MEMIF_JOB_CANCELED  MEMIF_BLOCK_INCONSISTENT  MEMIF_BLOCK_INVALID                   ', 'Name': 'enJobResult', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_BUSY'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': 'E_OK..E_NOT_OK', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': 'E_OK..E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK..E_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_010': ['Type': 'Output_Argument', 'Range': '  MEMIF_JOB_OK\\n  MEMIF_JOB_FAILED\\n  MEMIF_JOB_PENDING\\n  MEMIF_JOB_CANCELED  \\n  MEMIF_BLOCK_INCONSISTENT\\n  MEMIF_BLOCK_INVALID', 'Name': 'Fls_GstVarProperties.enJobResult', 'Value': 'MEMIF_BLOCK_INVALID']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'Std_ReturnType', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': 'MEMIF_BLOCK_INVALID'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Std_ReturnType', 'Value': 'Called'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_008': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_IDLE'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_CompareStatusType, FLS_CODE_SLOW) Fls_MemCompare /* PRQA S 1505, 3408 # JV-01, JV-01 */ (CONSTP2VAR(void, AUTOMATIC, FLS_APPL_DATA) pDest, CONSTP2VAR(void, AUTOMATIC, FLS_APPL_DATA) pSrc, /* PRQA S 3673 # JV-01 */ const uint32 Length, const boolean blSrcIsAConstNumber) { Fls_CompareStatusType LenReturnValue; P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) LpDest; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint32 LulSrcValue; uint32 LulDestValue; P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) LpSrc; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint32 LulLength; uint32 LulLoops; /* Get the remaining loops */ uint8 LucRemainLoops; uint32 LulCount; /* Store the pSrc to uint32 when it is a constant number */ uint32 LulSrcConst; LulLength = Length; LenReturnValue = FLS_CONSISTENT; /* Assigned the input pointers for the local pointer */ LpDest = (P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)) pDest; /* PRQA S 3432, 0316 # JV-01, JV-01 */ if (FLS_FALSE == blSrcIsAConstNumber) { LpSrc = (P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)) pSrc; /* PRQA S 3432, 0316 # JV-01, JV-01 */ } else { Fls_MemCopyUseLoop((uint32 *)&LulSrcConst, (uint32 *)pSrc, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 0316 # JV-01, JV-01 */ LpSrc = (P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA)) &LulSrcConst; /* PRQA S 0751, 3432 # JV-01, JV-01 */ } /* Loop to compare byte by byte until the address is even with word length */ while (((FLS_ZERO_LONG_WORD != ((uint32)LpDest % FLS_SIZE_OF_A_LONG_WORD)) /* PRQA S 0306 # JV-01 */ || (FLS_ZERO_LONG_WORD != ((uint32)LpSrc % FLS_SIZE_OF_A_LONG_WORD))) /* PRQA S 0306 # JV-01 */ && (FLS_ZERO_LONG_WORD < LulLength) && (FLS_CONSISTENT == LenReturnValue)) { if (FLS_ZERO_LONG_WORD == ((uint32)LpSrc % FLS_SIZE_OF_A_LONG_WORD)) /* PRQA S 0306 # JV-01 */ { /* If source address is even word size, read 4-byte to avoid endian */ for (LulCount = FLS_ZERO_LONG_WORD;(LulCount < FLS_SIZE_OF_A_LONG_WORD) && (FLS_ZERO_LONG_WORD < LulLength) && (FLS_CONSISTENT == LenReturnValue); LulCount++) { LulDestValue = FLS_READ_1BYTE_FROM_ADDR(LpDest); /* PRQA S 3469 # JV-01 */ LulSrcValue = FLS_READ_4BYTES_FROM_ADDR(LpSrc); /* PRQA S 0310, 2844, 3305, 3469, 2814 # JV-01, JV-01, JV-01, JV-01, JV-01 */ LulSrcValue = (LulSrcValue >> (FLS_BIT_INDEX_8 * LulCount)) & FLS_ONE_BYTE_MASK; /* PRQA S 3383 # JV-01 */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, LulSrcValue); /* PRQA S 3469 # JV-01 */ LpDest++; LulLength--; } /* End of for (LulCount = FLS_ZERO_LONG_WORD; * (LulCount < FLS_SIZE_OF_A_LONG_WORD) * && (FLS_ZERO_LONG_WORD < LulLength) * && (FLS_CONSISTENT == LenReturnValue); LulCount++) */ if (FLS_FALSE == blSrcIsAConstNumber) { LpSrc += FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 2824, 0488 # JV-01, JV-01 */ } else { /* Do nothing */ } } else if (FLS_ZERO_LONG_WORD == ((uint32)LpDest % FLS_SIZE_OF_A_LONG_WORD)) /* PRQA S 0306 # JV-01 */ { /* If dest address is even word size, integrate to variable before copy */ LulDestValue = FLS_READ_4BYTES_FROM_ADDR(LpDest); /* PRQA S 2814, 0310, 3305, 3469 # JV-01, JV-01, JV-01, JV-01 */ /* Store the dest data to LulSrcValue to keep the non-compare bytes * is consistent */ LulSrcValue = LulDestValue; for (LulCount = FLS_ZERO_LONG_WORD; (LulCount < FLS_SIZE_OF_A_LONG_WORD) && (FLS_ZERO_LONG_WORD < LulLength); LulCount++) { /* Clear data in the target byte */ LulSrcValue &= ~(FLS_ONE_BYTE_MASK << (FLS_BIT_INDEX_8 * LulCount)); /* PRQA S 3383 # JV-01 */ LulSrcValue |= ((uint32)FLS_READ_1BYTE_FROM_ADDR(LpSrc) << (FLS_BIT_INDEX_8 * LulCount)); /* PRQA S 3469, 2844, 3383 # JV-01, JV-01, JV-01 */ LpSrc++; /* PRQA S 2934 # JV-01 */ LulLength--; /* PRQA S 3383 # JV-01 */ } /* End of for (LulCount = FLS_ZERO_LONG_WORD; * (LulCount < FLS_SIZE_OF_A_LONG_WORD) * && (FLS_ZERO_LONG_WORD < LulLength); LulCount++) */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, LulSrcValue); /* PRQA S 3469 # JV-01 */ LpDest += FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 2824, 0488 # JV-01, JV-01 */ } else { LulSrcValue = FLS_READ_1BYTE_FROM_ADDR(LpSrc); /* PRQA S 3469 # JV-01 */ LulDestValue = FLS_READ_1BYTE_FROM_ADDR(LpDest); /* PRQA S 3469 # JV-01 */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, LulSrcValue); /* PRQA S 3469 # JV-01 */ LpDest++; LpSrc++; LulLength--; /* PRQA S 3383 # JV-01 */ } /* End of if (FLS_ZERO_LONG_WORD == * ((uint32)LpSrc % FLS_SIZE_OF_A_LONG_WORD)) */ } /* End of while (((FLS_ZERO_LONG_WORD != (LpDest % FLS_SIZE_OF_A_LONG_WORD)) * || (FLS_ZERO_LONG_WORD != (LpSrc % FLS_SIZE_OF_A_LONG_WORD))) * && (FLS_ZERO_LONG_WORD < LulLength) * && (FLS_CONSISTENT == LenReturnValue)) */ /* Set the current 'for' loops */ LulLoops = (LulLength / FLS_SIZE_OF_A_LONG_WORD); LucRemainLoops = (uint8)(LulLength % FLS_SIZE_OF_A_LONG_WORD); if (FLS_FALSE == blSrcIsAConstNumber) { while ((FLS_CONSISTENT == LenReturnValue) && (FLS_ZERO_LONG_WORD != LulLoops)) { LulSrcValue = FLS_READ_4BYTES_FROM_ADDR(LpSrc); /* PRQA S 2814, 3305, 2844, 3469, 0310 # JV-01, JV-01, JV-01, JV-01, JV-01 */ LulDestValue = FLS_READ_4BYTES_FROM_ADDR(LpDest); /* PRQA S 2814, 3305, 2844, 3469, 0310 # JV-01, JV-01, JV-01, JV-01, JV-01 */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, LulSrcValue); /* PRQA S 3469 # JV-01 */ LulLoops--; LpDest += FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 0488, 2934, 2824 # JV-01, JV-01, JV-01 */ LpSrc += FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 0488, 2934, 2824 # JV-01, JV-01, JV-01 */ } /* End of while ((FLS_CONSISTENT == LenReturnValue) && (FLS_ZERO_LONG_WORD != LulLoops)) */ } else { if ((FLS_CONSISTENT == LenReturnValue) && (FLS_ZERO_LONG_WORD != LulLoops)) { LulSrcValue = FLS_READ_4BYTES_FROM_ADDR(LpSrc); /* PRQA S 2814, 3305, 2844, 3469, 0310 # JV-01, JV-01, JV-01, JV-01, JV-01 */ } else { /* Do nothing */ } while ((FLS_CONSISTENT == LenReturnValue) && (FLS_ZERO_LONG_WORD != LulLoops)) { LulDestValue = FLS_READ_4BYTES_FROM_ADDR(LpDest); /* PRQA S 2814, 3305, 2844, 3469, 0310 # JV-01, JV-01, JV-01, JV-01, JV-01 */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, LulSrcValue); /* PRQA S 3469 # JV-01 */ LulLoops--; LpDest += FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 0488, 2934, 2824 # JV-01, JV-01, JV-01 */ } /* End of while ((FLS_CONSISTENT == LenReturnValue) && (FLS_ZERO_LONG_WORD != LulLoops)) */ } /* End of if (FLS_FALSE == blSrcIsAConstNumber) */ if ((FLS_CONSISTENT == LenReturnValue) && (FLS_ZERO != LucRemainLoops)) { LulSrcValue = FLS_READ_4BYTES_FROM_ADDR(LpSrc); /* PRQA S 0310, 2814, 3469, 2844, 3305 # JV-01, JV-01, JV-01, JV-01, JV-01 */ switch(LucRemainLoops) { case FLS_ONE: LulSrcValue = LulSrcValue & FLS_ONE_BYTE_MASK; LulDestValue = FLS_READ_1BYTE_FROM_ADDR(LpDest); /* PRQA S 3469, 2814, 2844 # JV-01, JV-01, JV-01 */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, LulSrcValue); /* PRQA S 3469 # JV-01 */ break; case FLS_TWO: LulSrcValue = LulSrcValue & FLS_TWO_BYTES_MASK; LulDestValue = FLS_READ_2BYTES_FROM_ADDR(LpDest); /* PRQA S 3305, 0310, 3469 # JV-01, JV-01, JV-01 */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, LulSrcValue); /* PRQA S 3469 # JV-01 */ break; case FLS_THREE: LulDestValue = FLS_READ_2BYTES_FROM_ADDR(LpDest); /* PRQA S 0310, 3305, 3469 # JV-01, JV-01, JV-01 */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, (LulSrcValue & FLS_TWO_BYTES_MASK)); /* PRQA S 3469 # JV-01 */ if (FLS_CONSISTENT == LenReturnValue) { LpDest += FLS_SIZE_OF_A_WORD; /* PRQA S 0488, 2824, 2934 # JV-01, JV-01, JV-01 */ LulSrcValue = (LulSrcValue / FLS_BIT_INDEX_16_MASK) & FLS_ONE_BYTE_MASK; LulDestValue = FLS_READ_1BYTE_FROM_ADDR(LpDest); /* PRQA S 3469, 2844 # JV-01, JV-01 */ LenReturnValue = FLS_CHECK_CONSISTENT_TWO_VALUE(LulDestValue, LulSrcValue); /* PRQA S 3469 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_CONSISTENT == LenReturnValue) */ break; default: /* NOT REACHED */ break; } /* End of switch(LucRemainLoops) */ } else { /* No action required */ } /* End of if ((FLS_CONSISTENT == LenReturnValue) && * (FLS_ZERO != LucRemainLoops)) */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_ERASE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BLANKCHECK_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'pDest', 'Value': '(uint8 *)&map_pDest[0] + 3'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'pSrc', 'Value': '(uint8 *)&map_pSrc[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDest[0]', 'Value': '0x00555555'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDest[1]', 'Value': '0x04030201'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDest[2]', 'Value': '0x08070605'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDest[3]', 'Value': '0x0C0B0A09'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDest[4]', 'Value': '0x100F0E0D'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDest[5]', 'Value': '0x55131211'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSrc[0]', 'Value': '0x03020100'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSrc[1]', 'Value': '0x07060504'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSrc[2]', 'Value': '0x0B0A0908'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSrc[3]', 'Value': '0x0F0E0D0C'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSrc[4]', 'Value': '0x13121110'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSrc[5]', 'Value': '-'], 'Input_Param_018': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '20'], 'Input_Param_019': ['Type': 'Argument', 'Range': '', 'Name': 'blSrcIsAConstNumber', 'Value': 'FLS_FALSE'], 'Input_Param_020': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint8 *)pDest)', 'Value': '-'], 'Input_Param_021': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint8 *)pDest + 1)', 'Value': '-'], 'Input_Param_022': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint8 *)pDest + 2)', 'Value': '-'], 'Input_Param_023': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint8 *)pDest + 3)', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_CONSISTENT'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_Read /* PRQA S 1503, 1532 # JV-01, JV-01 */ (Fls_AddressType SourceAddress, P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr, Fls_LengthType Length) /* PRQA S 3432 # JV-01 */ { #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the compare value */ uint32 LulFlsMaxLength; uint32 LulFlsLimitAddress; #endif Fls_AddressType LddSourceAddress; #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GetControlResultType LddGetControlResult; #endif /* Local variable to hold the DET return value */ Std_ReturnType LddReturnValue; LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Local variable to hold the read start address */ LddSourceAddress = SourceAddress + FLS_BASE_ADDRESS; /* PRQA S 2985, 3383 # JV-01, JV-01 */ /* Check if the read length is greater than 0 and that the read end * address (read start address + length) lies within the specified * upper flash address boundary. */ #if (FLS_DEV_ERROR_DETECT == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LulFlsLimitAddress = (FLS_BASE_ADDRESS + FLS_TOTAL_SIZE) - FLS_ONE_LONG_WORD; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulFlsMaxLength = (uint32)(FLS_TOTAL_SIZE - SourceAddress) * FLS_TWO_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ #else LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - SourceAddress; /* PRQA S 3383 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulFlsLimitAddress = FLS_BASE_ADDRESS + (FLS_TOTAL_SIZE / FLS_TWO_LONG_WORD) - FLS_ONE_LONG_WORD; LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - (SourceAddress * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_UNINIT); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) /* Check if the driver is busy by servicing another request */ else if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET if the driver is currently busy */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) */ /* Check if the read start address is lies within the specified lower and * upper flash address boundaries. */ else if (LulFlsLimitAddress < LddSourceAddress) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Check whether the target address pointer is a null pointer */ else if (NULL_PTR == TargetAddressPtr) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_PARAM_DATA); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else if ((FLS_ZERO_LONG_WORD == Length) || (LulFlsMaxLength < Length)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { /* No DET error */ LddReturnValue = E_OK; } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ #endif /* (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) /* Check if the driver is busy by servicing another request */ if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET Runtime if the driver is currently busy */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) */ /* Check whether any error is reported to DET */ if (E_OK == LddReturnValue) { /* Check status of get exclusive control/get semaphore * with critical section */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) LddGetControlResult = Fls_GetControl(); /* If get exclusive or get semaphore are successfully */ if (FLS_GOT_NOTHING != LddGetControlResult) { #endif /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif Fls_GstVarProperties.ulFlashAddress = LddSourceAddress; /* Set the global variable which used to store read * target address pointer */ Fls_GstVarProperties.pVarAddress = TargetAddressPtr; /* Set the current length of bytes to be processed */ Fls_GstVarProperties.ulLength = Length; /* Initiate a read job to Read */ Fls_GstVarProperties.enCommand = FLS_COMMAND_READ; /* set the driver state to busy */ Fls_GenState = MEMIF_BUSY; /* set the job result as pending */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_PENDING; /* Turn on external space read mode */ #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_GstVarProperties.blExtSpaceRead = FLS_TRUE; #endif Fls_GstVarProperties.ddMainJobFlag = E_OK; Fls_GstVarProperties.enJobStatus = FLS_BUSY; /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) } else { LddReturnValue = E_NOT_OK; } /* End of if (FLS_GOT_NOTHING != LddGetControlResult) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BASE_ADDRESS_ZERO', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXTERNAL_SPACE_READ', 'Value': 'STD_ON'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '0'], 'Input_Param_009': ['Type': 'Argument', 'Range': 'NULL_PTR \u2026 Address', 'Name': 'TargetAddressPtr', 'Value': '1'], 'Input_Param_010': ['Type': 'Argument', 'Range': '', 'Name': 'SourceAddress', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Output_Param_001': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'blExtSpaceRead', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FLS_MODULE_ID'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FLS_INSTANCE_ID'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FLS_READ_SID'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FLS_E_PARAM_LENGTH'], 'Output_Param_017': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_019': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_Read /* PRQA S 1503, 1532 # JV-01, JV-01 */ (Fls_AddressType SourceAddress, P2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) TargetAddressPtr, Fls_LengthType Length) /* PRQA S 3432 # JV-01 */ { #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the compare value */ uint32 LulFlsMaxLength; uint32 LulFlsLimitAddress; #endif Fls_AddressType LddSourceAddress; #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GetControlResultType LddGetControlResult; #endif /* Local variable to hold the DET return value */ Std_ReturnType LddReturnValue; LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Local variable to hold the read start address */ LddSourceAddress = SourceAddress + FLS_BASE_ADDRESS; /* PRQA S 2985, 3383 # JV-01, JV-01 */ /* Check if the read length is greater than 0 and that the read end * address (read start address + length) lies within the specified * upper flash address boundary. */ #if (FLS_DEV_ERROR_DETECT == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LulFlsLimitAddress = (FLS_BASE_ADDRESS + FLS_TOTAL_SIZE) - FLS_ONE_LONG_WORD; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulFlsMaxLength = (uint32)(FLS_TOTAL_SIZE - SourceAddress) * FLS_TWO_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ #else LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - SourceAddress; /* PRQA S 3383 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulFlsLimitAddress = FLS_BASE_ADDRESS + (FLS_TOTAL_SIZE / FLS_TWO_LONG_WORD) - FLS_ONE_LONG_WORD; LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - (SourceAddress * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_UNINIT); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) /* Check if the driver is busy by servicing another request */ else if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET if the driver is currently busy */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) */ /* Check if the read start address is lies within the specified lower and * upper flash address boundaries. */ else if (LulFlsLimitAddress < LddSourceAddress) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Check whether the target address pointer is a null pointer */ else if (NULL_PTR == TargetAddressPtr) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_PARAM_DATA); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else if ((FLS_ZERO_LONG_WORD == Length) || (LulFlsMaxLength < Length)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { /* No DET error */ LddReturnValue = E_OK; } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ #endif /* (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) /* Check if the driver is busy by servicing another request */ if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET Runtime if the driver is currently busy */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_READ_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) */ /* Check whether any error is reported to DET */ if (E_OK == LddReturnValue) { /* Check status of get exclusive control/get semaphore * with critical section */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) LddGetControlResult = Fls_GetControl(); /* If get exclusive or get semaphore are successfully */ if (FLS_GOT_NOTHING != LddGetControlResult) { #endif /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif Fls_GstVarProperties.ulFlashAddress = LddSourceAddress; /* Set the global variable which used to store read * target address pointer */ Fls_GstVarProperties.pVarAddress = TargetAddressPtr; /* Set the current length of bytes to be processed */ Fls_GstVarProperties.ulLength = Length; /* Initiate a read job to Read */ Fls_GstVarProperties.enCommand = FLS_COMMAND_READ; /* set the driver state to busy */ Fls_GenState = MEMIF_BUSY; /* set the job result as pending */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_PENDING; /* Turn on external space read mode */ #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_GstVarProperties.blExtSpaceRead = FLS_TRUE; #endif Fls_GstVarProperties.ddMainJobFlag = E_OK; Fls_GstVarProperties.enJobStatus = FLS_BUSY; /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) } else { LddReturnValue = E_NOT_OK; } /* End of if (FLS_GOT_NOTHING != LddGetControlResult) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BASE_ADDRESS_ZERO', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXTERNAL_SPACE_READ', 'Value': 'STD_ON'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '0'], 'Input_Param_009': ['Type': 'Argument', 'Range': 'NULL_PTR \u2026 Address', 'Name': 'TargetAddressPtr', 'Value': '1'], 'Input_Param_010': ['Type': 'Argument', 'Range': '', 'Name': 'SourceAddress', 'Value': '0x7FFFFFFF'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Output_Param_001': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'blExtSpaceRead', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FLS_MODULE_ID'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FLS_INSTANCE_ID'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FLS_READ_SID'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FLS_E_PARAM_LENGTH'], 'Output_Param_017': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_019': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_ReadJobHandler(void) { Std_ReturnType LddReturnValue; Std_ReturnType LddProcessStatus; Fls_LengthType LddMaxReadLength; Fls_LengthType LddMaxBytesToRead; Fls_LengthType LddLength; /* Default state of Reading Job: is not finished */ LddReturnValue = E_NOT_OK; LddMaxBytesToRead = Fls_GstVarProperties.ulLengthPerACycle; LddLength = Fls_GstVarProperties.ulLength; /* If length still valid */ if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) { /* Select the maximum length to read */ LddMaxReadLength = FLS_GET_MIN_NUMBER(LddLength, LddMaxBytesToRead); /* PRQA S 3469 # JV-01 */ / SERIAL FLASH / #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) /* Invoked this function to select the read mode: manual or external */ LddProcessStatus = Fls_SfSwitchReadMode(LddMaxReadLength); / HYPER FLASH / #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) /* Invoked this function to select the read mode: manual or external */ LddProcessStatus = Fls_HfSwitchReadMode(LddMaxReadLength); #endif /* #if (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) */ if (E_OK == LddProcessStatus) { /* Report status is OK */ Fls_GstVarProperties.enJobStatus = FLS_OK; /* Decrease the read length, * increase address of Flash device and user buffer */ Fls_GstVarProperties.ulLength -= LddMaxReadLength; /* PRQA S 3384 # JV-01 */ Fls_GstVarProperties.pVarAddress += LddMaxReadLength; /* PRQA S 0488 # JV-01 */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_GstVarProperties.ulFlashAddress += LddMaxReadLength; /* PRQA S 3384 # JV-01 */ #else Fls_GstVarProperties.ulFlashAddress += (uint32)(LddMaxReadLength / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ #endif /* (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) Fls_GstVarProperties.ulFlashAddress += (uint32)(LddMaxReadLength / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ } else { Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; /* Job has been finished */ LddReturnValue = E_OK; } /* End of if (E_OK == LddProcessStatus) */ } else { /* No action required */ }/* End of if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) */ if (FLS_ZERO_LONG_WORD == Fls_GstVarProperties.ulLength) { /* Job has been finished */ LddReturnValue = E_OK; } else { /* No action required */ } return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0..4294967294', 'Name': 'ulLengthPerACycle', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulLength', 'Value': '4294967295'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': '(uint8*) 0x0000UL'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlashAddress', 'Value': '0'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_NOT_OK'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxReadLength', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxReadLength', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': 'FLS_TIME_OUT'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FLS_CODE_SLOW) Fls_Resume(void) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GetControlResultType LddGetControlResult; #endif #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_RESUME_SID, FLS_E_UNINIT); } else #endif /* FLS_DEV_ERROR_DETECT == STD_ON */ { /* Check if the driver state is Idle and a job has been suspended */ if ((FLS_SUSPENDED == Fls_GstVarProperties.enBackUpJobStatus) && (MEMIF_IDLE == Fls_GenState)) { /* Check status of get exclusive control/get semaphore * with critical section */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) LddGetControlResult = Fls_GetControl(); /* If get exclusive or get semaphore are successfully */ if (FLS_GOT_NOTHING != LddGetControlResult) { #endif /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif /* Set job status as ok */ Fls_GstVarProperties.enJobStatus = FLS_OK; /* Set backup job status as ok */ Fls_GstVarProperties.enBackUpJobStatus = FLS_OK; /* Set the command to back up command data */ Fls_GstVarProperties.enCommand = Fls_GstVarProperties.enBackUpCmd; Fls_GstVarProperties.pVarAddress = Fls_GstVarProperties.pBackUpVarAddress; Fls_GstVarProperties.pContAddress = Fls_GstVarProperties.pBackUpContAddress; Fls_GstVarProperties.ulLength = Fls_GstVarProperties.ulBackUpLength; Fls_GstVarProperties.ulFlashAddress = Fls_GstVarProperties.ulBackUpFlashAddress; /* Set the backup command to none */ Fls_GstVarProperties.enBackUpCmd = FLS_COMMAND_NONE; /* Set the driver state to busy */ Fls_GenState = MEMIF_BUSY; /* Set the job Result to pending */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_PENDING; /* External space read mode is ON */ #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_GstVarProperties.blExtSpaceRead = FLS_TRUE; #endif Fls_GstVarProperties.ddMainJobFlag = E_OK; /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) } else { /* No action required */ } /* End of if (FLS_GOT_NOTHING != LddGetControlResult) */ #endif } else { /* No action required */ } /* End of Check if the driver state is Idle * and a job has been suspended */ } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SUSPEND_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_JOB_NOTIF_CONFIG', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpJobStatus', 'Value': 'FLS_ERR_VERIFY_WRITE'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Output_Param_001': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pBackUpVarAddress', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpJobStatus', 'Value': 'FLS_ERR_VERIFY_WRITE'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blExtSpaceRead', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulBackUpFlashAddress', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pBackUpContAddress', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpCmd', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulBackUpLength', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_022': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_023': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_024': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_SfCheckStatusRegister /* PRQA S 1532 # JV-01 */ (const Fls_FlashReadStatusType enStatusType, const uint32 Timeout, const boolean blEnableConfig) { Fls_StatusRegType LenReturnValue; Std_ReturnType LddProcessStatus; uint32 LulStatusRegValue; #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) uint8 LucStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint8 LucStatusRegValue001; uint8 LucStatusRegValue002; #endif /* This variable used to set the manual configuration */ Fls_SfSetConfigManualModeType LddSetManualConfig; /* ----------------Only configure at the first time------------------------ */ if (FLS_TRUE == blEnableConfig) { /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfReadStatusRegConfig; /* PRQA S 2814 # JV-01 */ /* The data not used */ LddSetManualConfig.pData = NULL_PTR; /* The option data not used */ LddSetManualConfig.ulOptionalData = FLS_ZERO_LONG_WORD; /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif /* The address not used */ LddSetManualConfig.ulAddress = FLS_ZERO_LONG_WORD; /* write command operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; LddSetManualConfig.ulTimeout = Timeout; #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER == (LddSetManualConfig.pUserConfig->ulSMDRENRValue & /* PRQA S 2814 # JV-01 */ FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_TRUE; } #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ /* Call the API below to start read status reg command by * user configuration */ LddProcessStatus = Fls_SfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Fill read data to pData pointer */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_TWO); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { /* ---------------Waiting for data transfer has ended --------------------*/ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Enable transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_TWO); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } /* End of if (FLS_TRUE == blEnableConfig) */ if (E_OK == LddProcessStatus) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) */ break; case FLS_STATUS_PROTECT: default: if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) */ } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (ERASE_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) */ break; case FLS_STATUS_PROTECT: default: if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) && ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition)) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_SERIAL_HYPER_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'PROGRAM_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ERASE_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DDR_CALIB_FEATURE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'enStatusType', 'Value': 'FLS_STATUS_PROTECT'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'Timeout', 'Value': '6'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'blEnableConfig', 'Value': 'FLS_TRUE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucProgramErrorBitPositionMask', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucEraseErrorBitPositionMask', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucWriteEnableBitPosition', 'Value': '0x02'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucBusyBitPositionMask', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pSfReadStatusRegConfig', 'Value': '&map_pSfReadStatusRegConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': 'FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': 'E_OK'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-'], 'Input_Param_019': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '0x00000002']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': 'SetManualConfig'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': 'pDest'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '(uint32 *)FLS_RPC_SMRDR0_ADDR'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': 'FLS_ONE'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x55555554'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_STT_FREE'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_SfCheckStatusRegister /* PRQA S 1532 # JV-01 */ (const Fls_FlashReadStatusType enStatusType, const uint32 Timeout, const boolean blEnableConfig) { Fls_StatusRegType LenReturnValue; Std_ReturnType LddProcessStatus; uint32 LulStatusRegValue; #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) uint8 LucStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint8 LucStatusRegValue001; uint8 LucStatusRegValue002; #endif /* This variable used to set the manual configuration */ Fls_SfSetConfigManualModeType LddSetManualConfig; /* ----------------Only configure at the first time------------------------ */ if (FLS_TRUE == blEnableConfig) { /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfReadStatusRegConfig; /* PRQA S 2814 # JV-01 */ /* The data not used */ LddSetManualConfig.pData = NULL_PTR; /* The option data not used */ LddSetManualConfig.ulOptionalData = FLS_ZERO_LONG_WORD; /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif /* The address not used */ LddSetManualConfig.ulAddress = FLS_ZERO_LONG_WORD; /* write command operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; LddSetManualConfig.ulTimeout = Timeout; #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER == (LddSetManualConfig.pUserConfig->ulSMDRENRValue & /* PRQA S 2814 # JV-01 */ FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_TRUE; } #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ /* Call the API below to start read status reg command by * user configuration */ LddProcessStatus = Fls_SfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Fill read data to pData pointer */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_TWO); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { /* ---------------Waiting for data transfer has ended --------------------*/ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Enable transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_TWO); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } /* End of if (FLS_TRUE == blEnableConfig) */ if (E_OK == LddProcessStatus) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) */ break; case FLS_STATUS_PROTECT: default: if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) */ } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (ERASE_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) */ break; case FLS_STATUS_PROTECT: default: if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) && ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition)) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_SERIAL_HYPER_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'PROGRAM_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ERASE_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DDR_CALIB_FEATURE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'enStatusType', 'Value': 'FLS_STATUS_WRITE'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'Timeout', 'Value': '6'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'blEnableConfig', 'Value': 'FLS_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucProgramErrorBitPositionMask', 'Value': '0x40'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucEraseErrorBitPositionMask', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucWriteEnableBitPosition', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucBusyBitPositionMask', 'Value': '0x01'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pSfReadStatusRegConfig', 'Value': '&map_pSfReadStatusRegConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_019': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '0x00000001']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '[1 to 2] = 6'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': 'pDest'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '(uint32 *)FLS_RPC_SMRDR0_ADDR'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': 'FLS_TWO'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x55555554'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_STT_BUSY'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_SfCheckStatusRegister /* PRQA S 1532 # JV-01 */ (const Fls_FlashReadStatusType enStatusType, const uint32 Timeout, const boolean blEnableConfig) { Fls_StatusRegType LenReturnValue; Std_ReturnType LddProcessStatus; uint32 LulStatusRegValue; #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) uint8 LucStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint8 LucStatusRegValue001; uint8 LucStatusRegValue002; #endif /* This variable used to set the manual configuration */ Fls_SfSetConfigManualModeType LddSetManualConfig; /* ----------------Only configure at the first time------------------------ */ if (FLS_TRUE == blEnableConfig) { /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfReadStatusRegConfig; /* PRQA S 2814 # JV-01 */ /* The data not used */ LddSetManualConfig.pData = NULL_PTR; /* The option data not used */ LddSetManualConfig.ulOptionalData = FLS_ZERO_LONG_WORD; /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif /* The address not used */ LddSetManualConfig.ulAddress = FLS_ZERO_LONG_WORD; /* write command operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; LddSetManualConfig.ulTimeout = Timeout; #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER == (LddSetManualConfig.pUserConfig->ulSMDRENRValue & /* PRQA S 2814 # JV-01 */ FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_TRUE; } #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ /* Call the API below to start read status reg command by * user configuration */ LddProcessStatus = Fls_SfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Fill read data to pData pointer */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_TWO); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { /* ---------------Waiting for data transfer has ended --------------------*/ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Enable transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_TWO); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } /* End of if (FLS_TRUE == blEnableConfig) */ if (E_OK == LddProcessStatus) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) */ break; case FLS_STATUS_PROTECT: default: if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) */ } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (ERASE_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) */ break; case FLS_STATUS_PROTECT: default: if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) && ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition)) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_SERIAL_HYPER_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'PROGRAM_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ERASE_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DDR_CALIB_FEATURE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'enStatusType', 'Value': 'FLS_STATUS_WRITE'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'Timeout', 'Value': '6'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'blEnableConfig', 'Value': 'FLS_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucProgramErrorBitPositionMask', 'Value': '0xFF'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucEraseErrorBitPositionMask', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucWriteEnableBitPosition', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucBusyBitPositionMask', 'Value': '0x7F'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pSfReadStatusRegConfig', 'Value': '&map_pSfReadStatusRegConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_019': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '0x0000007F']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '[1 to 2] = 6'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': 'pDest'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '(uint32 *)FLS_RPC_SMRDR0_ADDR'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': 'FLS_ONE'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x55555554'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_STT_BUSY'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_SfCheckStatusRegister /* PRQA S 1532 # JV-01 */ (const Fls_FlashReadStatusType enStatusType, const uint32 Timeout, const boolean blEnableConfig) { Fls_StatusRegType LenReturnValue; Std_ReturnType LddProcessStatus; uint32 LulStatusRegValue; #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) uint8 LucStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint8 LucStatusRegValue001; uint8 LucStatusRegValue002; #endif /* This variable used to set the manual configuration */ Fls_SfSetConfigManualModeType LddSetManualConfig; /* ----------------Only configure at the first time------------------------ */ if (FLS_TRUE == blEnableConfig) { /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfReadStatusRegConfig; /* PRQA S 2814 # JV-01 */ /* The data not used */ LddSetManualConfig.pData = NULL_PTR; /* The option data not used */ LddSetManualConfig.ulOptionalData = FLS_ZERO_LONG_WORD; /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif /* The address not used */ LddSetManualConfig.ulAddress = FLS_ZERO_LONG_WORD; /* write command operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; LddSetManualConfig.ulTimeout = Timeout; #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER == (LddSetManualConfig.pUserConfig->ulSMDRENRValue & /* PRQA S 2814 # JV-01 */ FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_TRUE; } #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ /* Call the API below to start read status reg command by * user configuration */ LddProcessStatus = Fls_SfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Fill read data to pData pointer */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_TWO); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { /* ---------------Waiting for data transfer has ended --------------------*/ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Enable transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_TWO); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } /* End of if (FLS_TRUE == blEnableConfig) */ if (E_OK == LddProcessStatus) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) */ break; case FLS_STATUS_PROTECT: default: if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) */ } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (ERASE_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) */ break; case FLS_STATUS_PROTECT: default: if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) && ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition)) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_SERIAL_HYPER_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'PROGRAM_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ERASE_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DDR_CALIB_FEATURE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'enStatusType', 'Value': 'FLS_STATUS_PROTECT'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'Timeout', 'Value': '6'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'blEnableConfig', 'Value': 'FLS_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucProgramErrorBitPositionMask', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucEraseErrorBitPositionMask', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucWriteEnableBitPosition', 'Value': '0x7F'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucBusyBitPositionMask', 'Value': '0x01'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pSfReadStatusRegConfig', 'Value': '&map_pSfReadStatusRegConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_019': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '0x000000FF']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '[1 to 2] = 6'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': 'pDest'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '(uint32 *)FLS_RPC_SMRDR0_ADDR'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': 'FLS_ONE'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x55555554'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_STT_FREE'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_SfCheckStatusRegister /* PRQA S 1532 # JV-01 */ (const Fls_FlashReadStatusType enStatusType, const uint32 Timeout, const boolean blEnableConfig) { Fls_StatusRegType LenReturnValue; Std_ReturnType LddProcessStatus; uint32 LulStatusRegValue; #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) uint8 LucStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint8 LucStatusRegValue001; uint8 LucStatusRegValue002; #endif /* This variable used to set the manual configuration */ Fls_SfSetConfigManualModeType LddSetManualConfig; /* ----------------Only configure at the first time------------------------ */ if (FLS_TRUE == blEnableConfig) { /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfReadStatusRegConfig; /* PRQA S 2814 # JV-01 */ /* The data not used */ LddSetManualConfig.pData = NULL_PTR; /* The option data not used */ LddSetManualConfig.ulOptionalData = FLS_ZERO_LONG_WORD; /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif /* The address not used */ LddSetManualConfig.ulAddress = FLS_ZERO_LONG_WORD; /* write command operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; LddSetManualConfig.ulTimeout = Timeout; #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER == (LddSetManualConfig.pUserConfig->ulSMDRENRValue & /* PRQA S 2814 # JV-01 */ FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_TRUE; } #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ /* Call the API below to start read status reg command by * user configuration */ LddProcessStatus = Fls_SfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Fill read data to pData pointer */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_TWO); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { /* ---------------Waiting for data transfer has ended --------------------*/ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Enable transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_TWO); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } /* End of if (FLS_TRUE == blEnableConfig) */ if (E_OK == LddProcessStatus) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) */ break; case FLS_STATUS_PROTECT: default: if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) */ } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (ERASE_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) */ break; case FLS_STATUS_PROTECT: default: if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) && ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition)) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_SERIAL_HYPER_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'PROGRAM_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ERASE_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DDR_CALIB_FEATURE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'enStatusType', 'Value': 'FLS_STATUS_WRITE'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'Timeout', 'Value': '6'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'blEnableConfig', 'Value': 'FLS_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucProgramErrorBitPositionMask', 'Value': '0x00'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucEraseErrorBitPositionMask', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucWriteEnableBitPosition', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucBusyBitPositionMask', 'Value': '0x01'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pSfReadStatusRegConfig', 'Value': '&map_pSfReadStatusRegConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_019': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '0x000000FF']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '[1 to 2] = 6'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': 'pDest'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '(uint32 *)FLS_RPC_SMRDR0_ADDR'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': 'FLS_TWO'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x55555554'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_STT_ERROR'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_SfCheckStatusRegister /* PRQA S 1532 # JV-01 */ (const Fls_FlashReadStatusType enStatusType, const uint32 Timeout, const boolean blEnableConfig) { Fls_StatusRegType LenReturnValue; Std_ReturnType LddProcessStatus; uint32 LulStatusRegValue; #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) uint8 LucStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint8 LucStatusRegValue001; uint8 LucStatusRegValue002; #endif /* This variable used to set the manual configuration */ Fls_SfSetConfigManualModeType LddSetManualConfig; /* ----------------Only configure at the first time------------------------ */ if (FLS_TRUE == blEnableConfig) { /* Apply the user configuration */ LddSetManualConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfReadStatusRegConfig; /* PRQA S 2814 # JV-01 */ /* The data not used */ LddSetManualConfig.pData = NULL_PTR; /* The option data not used */ LddSetManualConfig.ulOptionalData = FLS_ZERO_LONG_WORD; /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif /* The address not used */ LddSetManualConfig.ulAddress = FLS_ZERO_LONG_WORD; /* write command operation */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; LddSetManualConfig.ulTimeout = Timeout; #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER == (LddSetManualConfig.pUserConfig->ulSMDRENRValue & /* PRQA S 2814 # JV-01 */ FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_TRUE; } #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ /* Call the API below to start read status reg command by * user configuration */ LddProcessStatus = Fls_SfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Fill read data to pData pointer */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_TWO); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { /* ---------------Waiting for data transfer has ended --------------------*/ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Enable transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ LddProcessStatus = Fls_WaitRpcTransferEnd(Timeout); if (E_OK == LddProcessStatus) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* ---Read direct SMRDR0 register --*/ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_ONE); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue = (uint8)LulStatusRegValue; #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop((uint32 *)&LulStatusRegValue, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_TWO); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LucStatusRegValue001 = (uint8)LulStatusRegValue; LucStatusRegValue002 = (uint8)(LulStatusRegValue >> FLS_EIGHT_LONG_WORD); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenReturnValue = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } /* End of if (FLS_TRUE == blEnableConfig) */ if (E_OK == LddProcessStatus) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) { LenReturnValue = FLS_STT_ERROR; } else #endif { if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) */ break; case FLS_STATUS_PROTECT: default: if ((LucStatusRegValue & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) switch (enStatusType) { case FLS_STATUS_WRITE: #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) /* PRQA S 2814 # JV-01 */ == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (PROGRAM_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) */ } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucProgramErrorBitPositionMask)) */ break; case FLS_STATUS_ERASE: #if (ERASE_ERROR_BIT_CHECK == STD_ON) if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) { LenReturnValue = FLS_STT_ERROR; } else #endif /* End of #if (ERASE_ERROR_BIT_CHECK == STD_ON) */ { if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucBusyBitPositionMask)) { LenReturnValue = FLS_STT_BUSY; } else { LenReturnValue = FLS_STT_FREE; } } /* End of if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) || ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask) == Fls_GpConfigPtr->pSfConfig->ucEraseErrorBitPositionMask)) */ break; case FLS_STATUS_PROTECT: default: if (((LucStatusRegValue001 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) && ((LucStatusRegValue002 & Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition) == Fls_GpConfigPtr->pSfConfig->ucWriteEnableBitPosition)) { LenReturnValue = FLS_STT_FREE; } else { LenReturnValue = FLS_STT_BUSY; } break; } /* End of switch (enStatusType) */ #endif } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_SERIAL_HYPER_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'PROGRAM_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ERASE_ERROR_BIT_CHECK', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DDR_CALIB_FEATURE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'enStatusType', 'Value': 'FLS_STATUS_ERASE'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'Timeout', 'Value': '6'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'blEnableConfig', 'Value': 'FLS_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucProgramErrorBitPositionMask', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucEraseErrorBitPositionMask', 'Value': '0x00'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucWriteEnableBitPosition', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucBusyBitPositionMask', 'Value': '0x01'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pSfReadStatusRegConfig', 'Value': '&map_pSfReadStatusRegConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_019': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '0x00007F00']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '[1 to 2] = 6'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': 'pDest'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '(uint32 *)FLS_RPC_SMRDR0_ADDR'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': 'FLS_TWO'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x55555554'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenReturnValue', 'Value': 'FLS_STT_ERROR'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_CompareStatusType, FLS_CODE_SLOW) Fls_SfDDRVerifyPattern (CONSTP2CONST(Fls_SfReadType, AUTOMATIC, FLS_APPL_CONST) UserConfigPtr) { /* Declare internal variables */ Fls_CompareStatusType LenProcessStatus; Std_ReturnType LddProcessStatus; #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_SetExtSpaceReadType LddSetReadConfig; uint32 LulVirtualAddress; uint32 LulPatternValue; uint32 LulInteralAddressMask; #else Fls_SfSetConfigManualModeType LddSetManualConfig; #endif / External Space Read Mode / #if (FLS_EXTERNAL_SPACE_READ == STD_ON) if (FLS_ONE != UserConfigPtr->ucDREAR_EACValue) /* PRQA S 2814 # JV-01 */ { /* External address bits [24:0] enabled: EAC =0b000 */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* Only 24 bits are mapped to internal address space */ LulInteralAddressMask = FLS_24BITS_MASK; #elif (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) /* All 25 bits are mapped to internal address space */ LulInteralAddressMask = FLS_25BITS_MASK; #endif } else { /* External address bits [25:0] enabled: EAC =0b001 */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* Only 25 bits are mapped to internal address space */ LulInteralAddressMask = FLS_25BITS_MASK; #elif (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) /* All 26 bits are mapped to internal address space */ LulInteralAddressMask = FLS_26BITS_MASK; #endif } /* End of if (FLS_ONE != UserConfigPtr->ucDREAR_EACValue) */ /* Get virtual address */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* External address is mapped from position 1 in internal address */ LulVirtualAddress = FLS_RPC_INTERNAL_ADDR_MAP + (((FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress)/* PRQA S 2814, 3383, 2986 # JV-01, JV-01, JV-01 */ & LulInteralAddressMask) << FLS_BIT_INDEX_1); #elif (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) /* External address is mapped from position 0 in internal address */ LulVirtualAddress = FLS_RPC_INTERNAL_ADDR_MAP + ((FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress) /* PRQA S 2814, 3383, 2986 # JV-01, JV-01, JV-01 */ & LulInteralAddressMask); #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ /* Apply the user configuration */ LddSetReadConfig.pUserConfig = UserConfigPtr; /* Get the optional data */ LddSetReadConfig.ulOptionalData = Fls_GpConfigPtr->pSfConfig->ulDdrVerifyOptDataValue; /* Get pattern address */ LddSetReadConfig.ulAddress = FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress; /* PRQA S 3383, 2986 # JV-01, JV-01 */ if (FLS_DRDRENR_SF_SDR_TRANSFER == (LddSetReadConfig.pUserConfig->ulDRDRENRValue & FLS_DRDRENR_ADDRE_OPDRE_DRDRE_MASK)) /* PRQA S 2814 # JV-01 */ { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetReadConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetReadConfig.blStrobeTimeAdjust = FLS_TRUE; } /* Call the API below to start read by user configuration */ LddProcessStatus = Fls_SfSetExtSpaceReadConfig(LddSetReadConfig); if (E_OK == LddProcessStatus) { /* Get pattern value */ LulPatternValue = Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternValue; /* PRQA S 2814 # JV-01 */ /* Compare pattern value */ LenProcessStatus = Fls_MemCompare((void *)LulVirtualAddress, (uint32 *)&LulPatternValue, /* PRQA S 0326, 0315 # JV-01, JV-01 */ Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulNumberOfPattern * FLS_SIZE_OF_A_LONG_WORD, FLS_TRUE); /* PRQA S 3383 # JV-01 */ } else { LenProcessStatus = FLS_COMPARE_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ / Manual Mode / #else /* Apply the user configuration */ LddSetManualConfig.pUserConfig = UserConfigPtr; LddSetManualConfig.ulOptionalData = Fls_GpConfigPtr->pSfConfig->ulDdrVerifyOptDataValue; /* PRQA S 2814 # JV-01 */ LddSetManualConfig.ulAddress = FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress; /* PRQA S 2814, 2986, 3383 # JV-01, JV-01, JV-01 */ LddSetManualConfig.enOperation = FLS_READ_OPERATION; LddSetManualConfig.pData = (uint32 *)&Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternValue; /* PRQA S 0311 # JV-01 */ LddSetManualConfig.ulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* The length not used */ #if (FLS_WRITE_BUFFER == STD_ON) LddSetManualConfig.Length = FLS_ZERO_LONG_WORD; #else LddSetManualConfig.Length = FLS_ZERO; #endif if (FLS_SMDRENR_SF_SDR_TRANSFER == (LddSetManualConfig.pUserConfig->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) /* PRQA S 2814 # JV-01 */ { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetManualConfig.blStrobeTimeAdjust = FLS_TRUE; } /* Call the API below to start compare by user configuration */ LddProcessStatus = Fls_SfSetConfigManualMode(LddSetManualConfig); if (E_OK == LddProcessStatus) { /* Compare to the data begin at address SetManualConfig.ulAddress with * the data of pointer SetManualConfig.pData */ LenProcessStatus = Fls_SfCompareDataManualMode(LddSetManualConfig.ulAddress, (uint32 *)LddSetManualConfig.pData, Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulNumberOfPattern * FLS_SIZE_OF_A_LONG_WORD, FLS_TRUE); /* PRQA S 2814, 3383 # JV-01, JV-01 */ } else { LenProcessStatus = FLS_COMPARE_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ #endif /* End of #if (FLS_EXTERNAL_SPACE_READ == STD_ON) */ return (LenProcessStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXTERNAL_SPACE_READ', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_QSPI0_QSPI1_PIN_GROUP,\\nFLS_QSPI0_PIN_GROUP (CFG01)', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'UserConfigPtr', 'Value': '&map_UserConfigPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulDRDRENRValue', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '!FLS_ONE: FLS_25BITS_MASK\\nFLS_ONE: FLS_26BITS_MASK', 'Name': 'ucDREAR_EACValue', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': 'FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pSfDdrPatternConfig', 'Value': '&map_pSfDdrPatternConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulDdrVerifyOptDataValue', 'Value': '0x00000000'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulPatternAddress', 'Value': '0x00000000'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulPatternValue', 'Value': '0x00000000'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulNumberOfPattern', 'Value': '0x00000001'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'FLS_BASE_ADDRESS = 0x00000000\\n!FLS_ONE: FLS_25BITS_MASK\\nFLS_ONE: FLS_26BITS_MASK', 'Name': 'map_FLS_RPC_INTERNAL_ADDR_MAP[0]', 'Value': '-'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetExtSpaceReadConfig', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'blSrcIsAConstNumber', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ReadAddress', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDistData', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'DataSize', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'blSrcIsAConstNumber', 'Value': '-'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return_Value', 'Value': 'FLS_COMPARE_TIMEOUT'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_SfGetDataManualMode (CONSTP2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) pDistData, const uint32 DataSize, const Fls_AddressType ReadAddress) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LddReturnValue; Fls_AddressType LddReadAddress; uint32 LulDataSize; P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) LpData; /* PRQA S 3432 # JV-01 */ uint32 LulTotalRegSize; #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) uint32 LulRegRealValue; uint32 LulOrMaskValRegister; #endif #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulTotalRegSize = FLS_SIZE_OF_TWO_LONG_WORD; #else LulTotalRegSize = FLS_SIZE_OF_A_LONG_WORD; #endif LulDataSize = DataSize; LddReturnValue = E_OK; LpData = pDistData; LddReadAddress = ReadAddress; /* --------------Check data size--------------------*/ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) if (LulTotalRegSize >= DataSize) { /* ---Read direct SMRDR1 register when data size less than 4-------------*/ if (FLS_SIZE_OF_A_LONG_WORD >= LulDataSize) { Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR1_ADDR, LulDataSize); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LulDataSize = FLS_ZERO_LONG_WORD; } else { Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LulDataSize -= FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 0315, 0306, 3383 # JV-01, JV-01, JV-01 */ } if (FLS_ZERO_LONG_WORD != LulDataSize) { LpData++; /* PRQA S 2824 # JV-01 */ /* ---Read direct SMRDR0 register when data size less than 4------------*/ Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR0_ADDR, LulDataSize); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LulDataSize = FLS_ZERO_LONG_WORD; } else { /* No action required */ } /* End of if (FLS_ZERO_LONG_WORD != LulDataSize) */ } else { LddReturnValue = Fls_WaitRpcTransferEnd((uint32)FLS_READ_TIME); /* PRQA S 2905 # JV-01 */ } /* End of if (LulTotalRegSize >= DataSize) */ #else if (LulTotalRegSize >= DataSize) { /* ---Read direct SMRDR0 register when data size less than 4-------------*/ Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR0_ADDR, LulDataSize); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LulDataSize = FLS_ZERO_LONG_WORD; } else { LddReturnValue = Fls_WaitRpcTransferEnd((uint32)FLS_READ_TIME); /* PRQA S 2905 # JV-01 */ } /* End of if (LulTotalRegSize >= DataSize) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ /* When data size > 4 (SPIx1) or 8 (SPIx2) */ /* Update the address to read to the next address-*/ while ((E_OK == LddReturnValue) && (LulTotalRegSize <= LulDataSize)) { #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LpData++; /* PRQA S 2824 # JV-01 */ #endif Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR0_ADDR, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 0306 # JV-01, JV-01 */ LpData++; /* PRQA S 2824 # JV-01 */ LddReadAddress += FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 3383 # JV-01 */ /* Assigned new address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, LddReadAddress); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LddReadAddress, LulOrMaskValRegister); #endif /* -----------Configure SMCR register--------------- */ /* Clear bits */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); /* Enable transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIE_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, (FLS_SMCR_SPIRE_MASK), LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd((uint32)FLS_READ_TIME); /* PRQA S 2905 # JV-01 */ if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ LulDataSize -= LulTotalRegSize; } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ } /* End of while ((E_OK == LddReturnValue) && * (LulTotalRegSize <= LulDataSize)) */ /* Fill the remaining bytes */ if ((FLS_ZERO_LONG_WORD != LulDataSize) && (E_OK == LddReturnValue)) { /* Assigned new address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, LddReadAddress); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LddReadAddress, LulOrMaskValRegister); #endif /* -----------Configure SMCR register--------------- */ /* Clear bits */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 3469, 0303 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); /* Enable transfer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIE_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 3469, 0303 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, (FLS_SMCR_SPIRE_MASK), LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd((uint32)FLS_READ_TIME); /* PRQA S 2905 # JV-01 */ if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) /* Read the remaining bytes */ Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR0_ADDR, LulDataSize); /* PRQA S 0306, 0315 # JV-01, JV-01 */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* ---Read direct SMRDR1 register when data size less than 4-------------*/ if (FLS_SIZE_OF_A_LONG_WORD >= LulDataSize) { Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR1_ADDR, LulDataSize); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LulDataSize = FLS_ZERO_LONG_WORD; } else { Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR1_ADDR, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LulDataSize -= FLS_SIZE_OF_A_LONG_WORD; /* PRQA S 3383 # JV-01 */ } if (FLS_ZERO_LONG_WORD != LulDataSize) { LpData++; /* PRQA S 2824 # JV-01 */ /* ---Read direct SMRDR0 register when data size less than 4------------*/ Fls_MemCopyUseLoop(LpData, (uint32 *)FLS_RPC_SMRDR0_ADDR, LulDataSize); /* PRQA S 0306, 0315 # JV-01, JV-01 */ } else { /* No action required */ } #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO_LONG_WORD != LulDataSize) && * (E_OK == LddReturnValue)) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_WRITE_VERIFY_ENABLE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_EXTERNAL_SPACE_READ', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'pDistData', 'Value': '&map_pDistData[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'DataSize', 'Value': '0'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'ReadAddress', 'Value': '0'], 'Input_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMADR_ADDR[0]', 'Value': '0x00000000'], 'Input_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x00000000'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '&map_pDistData[0]'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '(uint32 *)FLS_RPC_SMRDR0_ADDR'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '-'], 'Output_Param_046': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_048': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_049': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_051': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_052': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '-'], 'Output_Param_053': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_054': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_055': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_056': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_057': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_058': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_059': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMADR_ADDR[0]', 'Value': '0x00000000'], 'Output_Param_060': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x00000000'], 'Output_Param_061': ['Type': 'Return_Value', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'LddProcessStatus', 'Value': 'E_OK'], 'Output_Param_062': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Fls_StatusRegType, FLS_CODE_SLOW) Fls_SfProcessPPWithBuffer (const Fls_AddressType TargetAddress, CONSTP2CONST(uint32, AUTOMATIC, FLS_APPL_CONST) pWriteData, const uint16 Length) { Std_ReturnType LddProcessStatus; Fls_StatusRegType LenStatus; TickType LddWriteTime; /* This variable used to save the user configuration for page program * operation */ Fls_SfSetConfigManualModeType LddPPConfig; /* -------------------------------------------Write Enable Latch: Write Enable--------------------------------------*/ LddProcessStatus = Fls_SfWriteEnable(); if (E_OK == LddProcessStatus) { /* Waiting for flash device enable */ LenStatus = Fls_SfWaitStatusReg((uint32)FLS_READ_TIME, FLS_STATUS_PROTECT); /* PRQA S 2905 # JV-01 */ if (FLS_STT_FREE != LenStatus) { LddProcessStatus = E_NOT_OK; } else { /* No action required */ } } else { LenStatus = FLS_STT_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ /* ---------------------------------------------Send Page program configuration-------------------------------------*/ /* Until now, If no timeout */ if (E_OK == LddProcessStatus) { /* Apply the user configuration */ LddPPConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfProgramConfig; /* PRQA S 2814 # JV-01 */ /* The option data not used */ LddPPConfig.ulOptionalData = FLS_ZERO_LONG_WORD; /* Set the erase start address */ LddPPConfig.ulAddress = TargetAddress; LddPPConfig.pData = (uint32 *)pWriteData; /* PRQA S 0311 # JV-01 */ LddPPConfig.Length = Length; LddPPConfig.enOperation = FLS_WRITE_BUFF_OPERATION; LddPPConfig.ulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ #if (FLS_DDR_CALIB_FEATURE == STD_ON) LddPPConfig.blStrobeTimeAdjust = FLS_FALSE; #endif /* Call the API below to start page program by user configuration */ LddProcessStatus = Fls_SfSetConfigManualMode(LddPPConfig); if (E_OK == LddProcessStatus) { /* Clear buffer */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_DRCR_ADDR, FLS_DRCR_RCF_MASK); /* PRQA S 3469, 0303 # JV-01, JV-01 */ } else { LenStatus = FLS_STT_TIMEOUT; } } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ /* -------------------------------------------Waiting for status----------------------------------------------------*/ /* Until now, If no timeout */ if (E_OK == LddProcessStatus) { LddWriteTime = Fls_GetMaxWriteTime(TargetAddress, (uint32)Length); LenStatus = Fls_SfWaitStatusReg(LddWriteTime, FLS_STATUS_WRITE); } else { /* No action required */ } return (LenStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'TargetAddress', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'pWriteData', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0x0..0xFFFF', 'Name': 'Length', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pSfProgramConfig', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': 'FLS_STT_ERROR\\nFLS_STT_BUSY\\nFLS_STT_FREE\\nFLS_ERR_NG', 'Name': 'return', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'return', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'enStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetManualConfig', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulFlsAddress', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSize', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'enStatus', 'Value': '-'], 'Output_Param_008': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenStatus', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_SfSetSpecificConfig /* PRQA S 1532 # JV-01 */ (CONSTP2CONST(Fls_SfSpecificConfigType, AUTOMATIC, FLS_APPL_CONST) SpecificConfigPtr, CONSTP2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) DataAddressPtr, /* PRQA S 3432 # JV-01 */ const uint8 Length) { /* Local variable to hold the return value */ Std_ReturnType LddReturnValue; uint8 LucOperation; uint16 LusOptDataEnable; uint32 LulTimeout; uint32 LulSMWDR0Value; uint32 LulSMRDR0Value; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint32 LulSMWDR1Value; uint32 LulSMRDR1Value; #endif #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) uint32 LulRegRealValue; uint32 LulOrMaskValRegister; #endif uint32 LulRegData; /* Get the SPIRE bit value, if it configured as 1, read operation enabled. * Else, write operation enabled */ LucOperation = (uint8)(SpecificConfigPtr->ulSMCRRegValue & FLS_SMCR_SPIRE_MASK); /* PRQA S 2814 # JV-01 */ LusOptDataEnable = (uint16)(SpecificConfigPtr->ulSMENRRegValue & FLS_SMENR_OPDE_MASK); /* Timeout monitor */ LulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* ---------------Waiting for data transfer has ended --------------------*/ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); #if (FLS_CPG_CLOCK_SETTING == STD_ON) if (E_OK == LddReturnValue) { /* clock setting with waiting for data transfer has ended */ LddReturnValue = Fls_ClockSetting( (uint32)(SpecificConfigPtr->ucRPCCKCRRegValue)); } else { /* No action required */ } #endif /* End of #if (FLS_CPG_CLOCK_SETTING == STD_ON) */ /* If transfer has been finished */ if (E_OK == LddReturnValue) { /* --------------------------Initialize manual mode---------------------- */ /* Configure PHYOFFSET1 register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, FLS_PHYOFFSET1_DDRTMG_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, SpecificConfigPtr->ulPHYOFFSET1RegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYOFFSET1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulPHYOFFSET1RegValue, FLS_PHYOFFSET1_DDRTMG_MASK); #endif /* Configure PHYCNT register */ /* Set PHYCNT user configuration */ LulRegData = SpecificConfigPtr->ulPHYCNTRegValue; /* Set PHYCNT.CAL = 0 */ LulRegData &= ~(FLS_PHYCNT_CAL_MASK); /* Clear PHYCNT.STRTIM before set*/ LulRegData &= ~(FLS_PHYCNT_STRTIM_MASK); #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER != (SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* DDR transfer */ /* Set PHYCNT.DDRCAL to 1 */ LulRegData |= FLS_PHYCNT_DDRCAL_MASK; /* Set PHYCNT.STRTIM value for DDR calibration */ LulRegData |= (((uint32)(Fls_GstVarProperties.ucDDRStrobeTimingAdjust) & FLS_PHYCNT_STRTIM_15_TO_17_MASK_BIT) << FLS_PHYCNT_STRTIM_15_TO_17_INDEX); LulRegData |= ((Fls_GstVarProperties.ucDDRStrobeTimingAdjust & FLS_PHYCNT_STRTIM_27_MASK_BIT) << FLS_PHYCNT_STRTIM_27_INDEX); FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } else #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ { /* Execute PHY calibration */ /* Set PHYCNT.DDRCAL to 0 */ LulRegData &= ~(FLS_PHYCNT_DDRCAL_MASK); /* When set PHYCNT.CAL = 1'b1, PHYCNT.STRTIM must be set to smallest */ LulRegData |= (uint32)FLS_PHYCNT_STRTIM_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Set PHYCNT.CAL = 1'b1 */ LulRegData |= FLS_PHYCNT_CAL_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } /* End of if ((SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK) != FLS_SMDRENR_SF_SDR_TRANSFER) */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYCNT_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Configure CMNCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_CMNCR_ADDR, FLS_CMNCR_MD_MASK /* PRQA S 0303, 3469 # JV-01, JV-01 */ | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_CMNCR_ADDR, SpecificConfigPtr->ulCMNCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_CMNCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulCMNCRRegValue, LulOrMaskValRegister); #endif /* Configure SSLDR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SSLDR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SSLDR_ADDR, SpecificConfigPtr->ulSSLDRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SSLDR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSSLDRRegValue, LulOrMaskValRegister); #endif /* Configure SMDRENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDRENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDRENR_ADDR, SpecificConfigPtr->ulSMDRENRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDRENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDRENRValue, LulOrMaskValRegister); #endif /* Set dummy cycles */ /* Configure SMDMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDMCR_ADDR, FLS_SMDMCR_DMCYC_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDMCR_ADDR, SpecificConfigPtr->ulSMDMCRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_SMDMCR_DMCYC_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDMCRValue, LulOrMaskValRegister); #endif /* Configure SMENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMENR_ADDR, SpecificConfigPtr->ulSMENRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMENRRegValue, LulOrMaskValRegister); #endif /* Set command/optional command */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCMR_ADDR, FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCMR_ADDR, SpecificConfigPtr->ulSMCMRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCMR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCMRRegValue, LulOrMaskValRegister); #endif /* Set the target address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, SpecificConfigPtr->ulSMADRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMADRRegValue, LulOrMaskValRegister); #endif /* End of #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) */ if (FLS_ZERO_WORD != LusOptDataEnable) { /* Set optional data */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMOPR_ADDR, FLS_A_LONG_WORD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMOPR_ADDR, SpecificConfigPtr->ulSMOPRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMOPR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMOPRRegValue, LulOrMaskValRegister); #endif } else { /* No action required */ } /* End of if (FLS_ZERO_WORD != LusOptDataEnable) */ /* Write operation and having data */ if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, (uint32)Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop ((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0315, 0306 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* If 64 bits transferred, copies to SMWDR1 and SMWDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, copies data[31:0] to SMWDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR1Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR1Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR1_ADDR, LulSMWDR1Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR1Value, LulOrMaskValRegister); #endif FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, FLS_ERASED_VALUE); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_ERASED_VALUE, LulOrMaskValRegister); #endif } else { /* Otherwise, copies to data[63:32] to SMWDR0, data[31:0] to SMWDR1 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR1_ADDR, (uint32 *)DataAddressPtr, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 3305, 0310, 0306 # JV-01, JV-01, JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, (*(uint32 *)DataAddressPtr), LulOrMaskValRegister); /* PRQA S 2814, 3305, 0310 # JV-01, JV-01, JV-01 */ #endif LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMWDR0Value, /* PRQA S 0315 # JV-01 */ (uint32 *)(DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD), /* PRQA S 3305, 0315, 0310, 2824, 0488 # JV-01, JV-01, JV-01, JV-01, JV-01 */ (uint32)Length - FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 3383 # JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, LulSMWDR0Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR0Value, LulOrMaskValRegister); #endif } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, copies to SMWDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, SpecificConfigPtr->ucDataLength);/* PRQA S 0306, 0315 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength) */ /* -----Enable Read/Write Operation and Start transfer----- */ /* Configure SMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, SpecificConfigPtr->ulSMCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCRRegValue, LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* If read operation and having data */ if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register */ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, /* PRQA S 0306, 0315 # JV-01, JV-01 */ (uint32)SpecificConfigPtr->ucDataLength); Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #else /* If 64 bits transferred, read from SMRDR1 and SMRDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, read data[31:0] from SMRDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR1 register*/ LulSMRDR1Value = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR1Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* Else read data[63:32] from SMRDR0, data[31:0] from SMRDR1 */ Fls_MemCopyUseLoop (DataAddressPtr, (uint32 *)FLS_RPC_SMRDR1_ADDR, (uint32)FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LulSMRDR0Value= FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop (DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD, /* PRQA S 0488, 0315 # JV-01, JV-01 */ (uint32 *)&LulSMRDR0Value, /* PRQA S 0315 # JV-01 */ (uint32)(Length - FLS_SIZE_OF_A_LONG_WORD)); /* PRQA S 4391, 3383 # JV-01, JV-01 */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, read directly from SMRDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register*/ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0306, 0315 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) */ } else { /* No action required */ } /* if (E_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEND_SPEC_CONFIG_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': '&map_SpecificConfigPtr[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'DataAddressPtr', 'Value': '&map_DataAddressPtr[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '0x05'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '0x07060504'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0] ', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '0x03020100'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucDDRStrobeTimingAdjust', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYCNTRegValue', 'Value': '0x88038000UL'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulCMNCRRegValue', 'Value': '0x80FF0300UL'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCMRRegValue', 'Value': '0x00650000UL'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMADRRegValue', 'Value': '0x00800002UL'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMENRRegValue', 'Value': '0x0000C70FUL'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulSSLDRRegValue', 'Value': '0x00000400UL'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDMCRValue', 'Value': '0x00000007UL'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '0x00000000UL'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMOPRRegValue', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCRRegValue', 'Value': '0x00000005UL'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYOFFSET1RegValue', 'Value': '0x30000000UL'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ucRPCCKCRRegValue', 'Value': '0x13U'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ucDataLength', 'Value': 'FOUR_UNITS_DATA'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Input_Param_035': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '[0 to 1] = *((uint32 *)pSrc)'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_037': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '0x03020100'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '0x07060504'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0x30000000'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYCNT_ADDR[0]', 'Value': '0x88038000'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0x80FF0300'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0x00000400'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0]', 'Value': '0x00000000'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0x00000007'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0x0000C70F'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0x00650000'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x00000004'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMADR_ADDR[0]', 'Value': '0x00800002'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '0x07060504'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '0x03020100'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRPCCKCRRegValue', 'Value': '0x13U'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_PHYOFFSET1_ADDR[0]\\n[1] = map_FLS_RPC_PHYCNT_ADDR[0]\\n[2] = map_FLS_RPC_CMNCR_ADDR[0]\\n[3] = map_FLS_RPC_SSLDR_ADDR[0]\\n[4] = map_FLS_RPC_SMDRENR_ADDR[0]\\n[5] = map_FLS_RPC_SMDMCR_ADDR[0]\\n[6] = map_FLS_RPC_SMENR_ADDR[0]\\n[7] = map_FLS_RPC_SMCMR_ADDR[0]\\n[8] = map_FLS_RPC_SMADR_ADDR[0]'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_SpecificConfigPtr[0].ulPHYOFFSET1RegValue\\n[1] = ((map_SpecificConfigPtr[0].ulPHYCNTRegValue & (~FLS_PHYCNT_DDRCAL_MASK)) | (FLS_PHYCNT_CAL_MASK | FLS_PHYCNT_STRTIM_MASK))\\n[2] = map_SpecificConfigPtr[0].ulCMNCRRegValue\\n[3] = map_SpecificConfigPtr[0].ulSSLDRRegValue\\n[4] = map_SpecificConfigPtr[0].ulSMDRENRValue\\n[5] = map_SpecificConfigPtr[0].ulSMDMCRValue\\n[6] = map_SpecificConfigPtr[0].ulSMENRRegValue\\n[7] = map_SpecificConfigPtr[0].ulSMCMRRegValue\\n[8] = map_SpecificConfigPtr[0].ulSMADRRegValue'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_PHYOFFSET1_DDRTMG_MASK\\n[1] = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK)\\n[2] = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK)\\n[3] = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK)\\n[4] = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)\\n[5] = FLS_SMDMCR_DMCYC_MASK\\n[6] = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK)\\n[7] = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK)\\n[8] = FLS_A_LONG_WORD_MASK'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': 'map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': 'map_SpecificConfigPtr[0].ulSMCRRegValue'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '(FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '[0] = &map_DataAddressPtr[0]\\n[1] = &map_DataAddressPtr[1]'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '[0] = (uint32 *)FLS_RPC_SMRDR1_ADDR\\n[1] = pSrc'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '[0] = FLS_SIZE_OF_A_LONG_WORD\\n[1] = 1'], 'Output_Param_044': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_045': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_SfSetSpecificConfig /* PRQA S 1532 # JV-01 */ (CONSTP2CONST(Fls_SfSpecificConfigType, AUTOMATIC, FLS_APPL_CONST) SpecificConfigPtr, CONSTP2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) DataAddressPtr, /* PRQA S 3432 # JV-01 */ const uint8 Length) { /* Local variable to hold the return value */ Std_ReturnType LddReturnValue; uint8 LucOperation; uint16 LusOptDataEnable; uint32 LulTimeout; uint32 LulSMWDR0Value; uint32 LulSMRDR0Value; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint32 LulSMWDR1Value; uint32 LulSMRDR1Value; #endif #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) uint32 LulRegRealValue; uint32 LulOrMaskValRegister; #endif uint32 LulRegData; /* Get the SPIRE bit value, if it configured as 1, read operation enabled. * Else, write operation enabled */ LucOperation = (uint8)(SpecificConfigPtr->ulSMCRRegValue & FLS_SMCR_SPIRE_MASK); /* PRQA S 2814 # JV-01 */ LusOptDataEnable = (uint16)(SpecificConfigPtr->ulSMENRRegValue & FLS_SMENR_OPDE_MASK); /* Timeout monitor */ LulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* ---------------Waiting for data transfer has ended --------------------*/ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); #if (FLS_CPG_CLOCK_SETTING == STD_ON) if (E_OK == LddReturnValue) { /* clock setting with waiting for data transfer has ended */ LddReturnValue = Fls_ClockSetting( (uint32)(SpecificConfigPtr->ucRPCCKCRRegValue)); } else { /* No action required */ } #endif /* End of #if (FLS_CPG_CLOCK_SETTING == STD_ON) */ /* If transfer has been finished */ if (E_OK == LddReturnValue) { /* --------------------------Initialize manual mode---------------------- */ /* Configure PHYOFFSET1 register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, FLS_PHYOFFSET1_DDRTMG_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, SpecificConfigPtr->ulPHYOFFSET1RegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYOFFSET1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulPHYOFFSET1RegValue, FLS_PHYOFFSET1_DDRTMG_MASK); #endif /* Configure PHYCNT register */ /* Set PHYCNT user configuration */ LulRegData = SpecificConfigPtr->ulPHYCNTRegValue; /* Set PHYCNT.CAL = 0 */ LulRegData &= ~(FLS_PHYCNT_CAL_MASK); /* Clear PHYCNT.STRTIM before set*/ LulRegData &= ~(FLS_PHYCNT_STRTIM_MASK); #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER != (SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* DDR transfer */ /* Set PHYCNT.DDRCAL to 1 */ LulRegData |= FLS_PHYCNT_DDRCAL_MASK; /* Set PHYCNT.STRTIM value for DDR calibration */ LulRegData |= (((uint32)(Fls_GstVarProperties.ucDDRStrobeTimingAdjust) & FLS_PHYCNT_STRTIM_15_TO_17_MASK_BIT) << FLS_PHYCNT_STRTIM_15_TO_17_INDEX); LulRegData |= ((Fls_GstVarProperties.ucDDRStrobeTimingAdjust & FLS_PHYCNT_STRTIM_27_MASK_BIT) << FLS_PHYCNT_STRTIM_27_INDEX); FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } else #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ { /* Execute PHY calibration */ /* Set PHYCNT.DDRCAL to 0 */ LulRegData &= ~(FLS_PHYCNT_DDRCAL_MASK); /* When set PHYCNT.CAL = 1'b1, PHYCNT.STRTIM must be set to smallest */ LulRegData |= (uint32)FLS_PHYCNT_STRTIM_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Set PHYCNT.CAL = 1'b1 */ LulRegData |= FLS_PHYCNT_CAL_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } /* End of if ((SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK) != FLS_SMDRENR_SF_SDR_TRANSFER) */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYCNT_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Configure CMNCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_CMNCR_ADDR, FLS_CMNCR_MD_MASK /* PRQA S 0303, 3469 # JV-01, JV-01 */ | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_CMNCR_ADDR, SpecificConfigPtr->ulCMNCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_CMNCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulCMNCRRegValue, LulOrMaskValRegister); #endif /* Configure SSLDR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SSLDR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SSLDR_ADDR, SpecificConfigPtr->ulSSLDRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SSLDR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSSLDRRegValue, LulOrMaskValRegister); #endif /* Configure SMDRENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDRENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDRENR_ADDR, SpecificConfigPtr->ulSMDRENRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDRENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDRENRValue, LulOrMaskValRegister); #endif /* Set dummy cycles */ /* Configure SMDMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDMCR_ADDR, FLS_SMDMCR_DMCYC_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDMCR_ADDR, SpecificConfigPtr->ulSMDMCRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_SMDMCR_DMCYC_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDMCRValue, LulOrMaskValRegister); #endif /* Configure SMENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMENR_ADDR, SpecificConfigPtr->ulSMENRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMENRRegValue, LulOrMaskValRegister); #endif /* Set command/optional command */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCMR_ADDR, FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCMR_ADDR, SpecificConfigPtr->ulSMCMRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCMR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCMRRegValue, LulOrMaskValRegister); #endif /* Set the target address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, SpecificConfigPtr->ulSMADRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMADRRegValue, LulOrMaskValRegister); #endif /* End of #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) */ if (FLS_ZERO_WORD != LusOptDataEnable) { /* Set optional data */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMOPR_ADDR, FLS_A_LONG_WORD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMOPR_ADDR, SpecificConfigPtr->ulSMOPRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMOPR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMOPRRegValue, LulOrMaskValRegister); #endif } else { /* No action required */ } /* End of if (FLS_ZERO_WORD != LusOptDataEnable) */ /* Write operation and having data */ if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, (uint32)Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop ((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0315, 0306 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* If 64 bits transferred, copies to SMWDR1 and SMWDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, copies data[31:0] to SMWDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR1Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR1Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR1_ADDR, LulSMWDR1Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR1Value, LulOrMaskValRegister); #endif FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, FLS_ERASED_VALUE); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_ERASED_VALUE, LulOrMaskValRegister); #endif } else { /* Otherwise, copies to data[63:32] to SMWDR0, data[31:0] to SMWDR1 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR1_ADDR, (uint32 *)DataAddressPtr, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 3305, 0310, 0306 # JV-01, JV-01, JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, (*(uint32 *)DataAddressPtr), LulOrMaskValRegister); /* PRQA S 2814, 3305, 0310 # JV-01, JV-01, JV-01 */ #endif LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMWDR0Value, /* PRQA S 0315 # JV-01 */ (uint32 *)(DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD), /* PRQA S 3305, 0315, 0310, 2824, 0488 # JV-01, JV-01, JV-01, JV-01, JV-01 */ (uint32)Length - FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 3383 # JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, LulSMWDR0Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR0Value, LulOrMaskValRegister); #endif } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, copies to SMWDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, SpecificConfigPtr->ucDataLength);/* PRQA S 0306, 0315 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength) */ /* -----Enable Read/Write Operation and Start transfer----- */ /* Configure SMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, SpecificConfigPtr->ulSMCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCRRegValue, LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* If read operation and having data */ if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register */ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, /* PRQA S 0306, 0315 # JV-01, JV-01 */ (uint32)SpecificConfigPtr->ucDataLength); Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #else /* If 64 bits transferred, read from SMRDR1 and SMRDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, read data[31:0] from SMRDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR1 register*/ LulSMRDR1Value = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR1Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* Else read data[63:32] from SMRDR0, data[31:0] from SMRDR1 */ Fls_MemCopyUseLoop (DataAddressPtr, (uint32 *)FLS_RPC_SMRDR1_ADDR, (uint32)FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LulSMRDR0Value= FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop (DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD, /* PRQA S 0488, 0315 # JV-01, JV-01 */ (uint32 *)&LulSMRDR0Value, /* PRQA S 0315 # JV-01 */ (uint32)(Length - FLS_SIZE_OF_A_LONG_WORD)); /* PRQA S 4391, 3383 # JV-01, JV-01 */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, read directly from SMRDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register*/ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0306, 0315 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) */ } else { /* No action required */ } /* if (E_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEND_SPEC_CONFIG_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': '&map_SpecificConfigPtr[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'DataAddressPtr', 'Value': '&map_DataAddressPtr[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '0xFF'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '0x07060504'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0] ', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '0x03020100'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucDDRStrobeTimingAdjust', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYCNTRegValue', 'Value': '0x88038000UL'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulCMNCRRegValue', 'Value': '0x80FF0300UL'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCMRRegValue', 'Value': '0x00650000UL'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMADRRegValue', 'Value': '0x00800002UL'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMENRRegValue', 'Value': '0x0000C70FUL'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulSSLDRRegValue', 'Value': '0x00000400UL'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDMCRValue', 'Value': '0x00000007UL'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '0x00000000UL'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMOPRRegValue', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCRRegValue', 'Value': '0x00000005UL'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYOFFSET1RegValue', 'Value': '0x30000000UL'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ucRPCCKCRRegValue', 'Value': '0x13U'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ucDataLength', 'Value': 'FOUR_UNITS_DATA'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Input_Param_035': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '[0 to 1] = *((uint32 *)pSrc)'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_037': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '0x03020100'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '0x07060504'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0x30000000'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYCNT_ADDR[0]', 'Value': '0x88038000'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0x80FF0300'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0x00000400'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0]', 'Value': '0x00000000'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0x00000007'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0x0000C70F'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0x00650000'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x00000004'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMADR_ADDR[0]', 'Value': '0x00800002'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '0x07060504'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '0x03020100'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRPCCKCRRegValue', 'Value': '0x13U'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_PHYOFFSET1_ADDR[0]\\n[1] = map_FLS_RPC_PHYCNT_ADDR[0]\\n[2] = map_FLS_RPC_CMNCR_ADDR[0]\\n[3] = map_FLS_RPC_SSLDR_ADDR[0]\\n[4] = map_FLS_RPC_SMDRENR_ADDR[0]\\n[5] = map_FLS_RPC_SMDMCR_ADDR[0]\\n[6] = map_FLS_RPC_SMENR_ADDR[0]\\n[7] = map_FLS_RPC_SMCMR_ADDR[0]\\n[8] = map_FLS_RPC_SMADR_ADDR[0]'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_SpecificConfigPtr[0].ulPHYOFFSET1RegValue\\n[1] = ((map_SpecificConfigPtr[0].ulPHYCNTRegValue & (~FLS_PHYCNT_DDRCAL_MASK)) | (FLS_PHYCNT_CAL_MASK | FLS_PHYCNT_STRTIM_MASK))\\n[2] = map_SpecificConfigPtr[0].ulCMNCRRegValue\\n[3] = map_SpecificConfigPtr[0].ulSSLDRRegValue\\n[4] = map_SpecificConfigPtr[0].ulSMDRENRValue\\n[5] = map_SpecificConfigPtr[0].ulSMDMCRValue\\n[6] = map_SpecificConfigPtr[0].ulSMENRRegValue\\n[7] = map_SpecificConfigPtr[0].ulSMCMRRegValue\\n[8] = map_SpecificConfigPtr[0].ulSMADRRegValue'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_PHYOFFSET1_DDRTMG_MASK\\n[1] = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK)\\n[2] = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK)\\n[3] = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK)\\n[4] = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)\\n[5] = FLS_SMDMCR_DMCYC_MASK\\n[6] = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK)\\n[7] = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK)\\n[8] = FLS_A_LONG_WORD_MASK'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': 'map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': 'map_SpecificConfigPtr[0].ulSMCRRegValue'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '(FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '[0] = &map_DataAddressPtr[0]\\n[1] = &map_DataAddressPtr[1]'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '[0] = (uint32 *)FLS_RPC_SMRDR1_ADDR\\n[1] = pSrc'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '[0] = FLS_SIZE_OF_A_LONG_WORD\\n[1] = (0xFF - FLS_SIZE_OF_A_LONG_WORD)'], 'Output_Param_044': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_045': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_SfSetSpecificConfig /* PRQA S 1532 # JV-01 */ (CONSTP2CONST(Fls_SfSpecificConfigType, AUTOMATIC, FLS_APPL_CONST) SpecificConfigPtr, CONSTP2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) DataAddressPtr, /* PRQA S 3432 # JV-01 */ const uint8 Length) { /* Local variable to hold the return value */ Std_ReturnType LddReturnValue; uint8 LucOperation; uint16 LusOptDataEnable; uint32 LulTimeout; uint32 LulSMWDR0Value; uint32 LulSMRDR0Value; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint32 LulSMWDR1Value; uint32 LulSMRDR1Value; #endif #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) uint32 LulRegRealValue; uint32 LulOrMaskValRegister; #endif uint32 LulRegData; /* Get the SPIRE bit value, if it configured as 1, read operation enabled. * Else, write operation enabled */ LucOperation = (uint8)(SpecificConfigPtr->ulSMCRRegValue & FLS_SMCR_SPIRE_MASK); /* PRQA S 2814 # JV-01 */ LusOptDataEnable = (uint16)(SpecificConfigPtr->ulSMENRRegValue & FLS_SMENR_OPDE_MASK); /* Timeout monitor */ LulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* ---------------Waiting for data transfer has ended --------------------*/ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); #if (FLS_CPG_CLOCK_SETTING == STD_ON) if (E_OK == LddReturnValue) { /* clock setting with waiting for data transfer has ended */ LddReturnValue = Fls_ClockSetting( (uint32)(SpecificConfigPtr->ucRPCCKCRRegValue)); } else { /* No action required */ } #endif /* End of #if (FLS_CPG_CLOCK_SETTING == STD_ON) */ /* If transfer has been finished */ if (E_OK == LddReturnValue) { /* --------------------------Initialize manual mode---------------------- */ /* Configure PHYOFFSET1 register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, FLS_PHYOFFSET1_DDRTMG_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, SpecificConfigPtr->ulPHYOFFSET1RegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYOFFSET1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulPHYOFFSET1RegValue, FLS_PHYOFFSET1_DDRTMG_MASK); #endif /* Configure PHYCNT register */ /* Set PHYCNT user configuration */ LulRegData = SpecificConfigPtr->ulPHYCNTRegValue; /* Set PHYCNT.CAL = 0 */ LulRegData &= ~(FLS_PHYCNT_CAL_MASK); /* Clear PHYCNT.STRTIM before set*/ LulRegData &= ~(FLS_PHYCNT_STRTIM_MASK); #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER != (SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* DDR transfer */ /* Set PHYCNT.DDRCAL to 1 */ LulRegData |= FLS_PHYCNT_DDRCAL_MASK; /* Set PHYCNT.STRTIM value for DDR calibration */ LulRegData |= (((uint32)(Fls_GstVarProperties.ucDDRStrobeTimingAdjust) & FLS_PHYCNT_STRTIM_15_TO_17_MASK_BIT) << FLS_PHYCNT_STRTIM_15_TO_17_INDEX); LulRegData |= ((Fls_GstVarProperties.ucDDRStrobeTimingAdjust & FLS_PHYCNT_STRTIM_27_MASK_BIT) << FLS_PHYCNT_STRTIM_27_INDEX); FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } else #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ { /* Execute PHY calibration */ /* Set PHYCNT.DDRCAL to 0 */ LulRegData &= ~(FLS_PHYCNT_DDRCAL_MASK); /* When set PHYCNT.CAL = 1'b1, PHYCNT.STRTIM must be set to smallest */ LulRegData |= (uint32)FLS_PHYCNT_STRTIM_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Set PHYCNT.CAL = 1'b1 */ LulRegData |= FLS_PHYCNT_CAL_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } /* End of if ((SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK) != FLS_SMDRENR_SF_SDR_TRANSFER) */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYCNT_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Configure CMNCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_CMNCR_ADDR, FLS_CMNCR_MD_MASK /* PRQA S 0303, 3469 # JV-01, JV-01 */ | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_CMNCR_ADDR, SpecificConfigPtr->ulCMNCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_CMNCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulCMNCRRegValue, LulOrMaskValRegister); #endif /* Configure SSLDR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SSLDR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SSLDR_ADDR, SpecificConfigPtr->ulSSLDRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SSLDR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSSLDRRegValue, LulOrMaskValRegister); #endif /* Configure SMDRENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDRENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDRENR_ADDR, SpecificConfigPtr->ulSMDRENRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDRENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDRENRValue, LulOrMaskValRegister); #endif /* Set dummy cycles */ /* Configure SMDMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDMCR_ADDR, FLS_SMDMCR_DMCYC_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDMCR_ADDR, SpecificConfigPtr->ulSMDMCRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_SMDMCR_DMCYC_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDMCRValue, LulOrMaskValRegister); #endif /* Configure SMENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMENR_ADDR, SpecificConfigPtr->ulSMENRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMENRRegValue, LulOrMaskValRegister); #endif /* Set command/optional command */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCMR_ADDR, FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCMR_ADDR, SpecificConfigPtr->ulSMCMRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCMR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCMRRegValue, LulOrMaskValRegister); #endif /* Set the target address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, SpecificConfigPtr->ulSMADRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMADRRegValue, LulOrMaskValRegister); #endif /* End of #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) */ if (FLS_ZERO_WORD != LusOptDataEnable) { /* Set optional data */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMOPR_ADDR, FLS_A_LONG_WORD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMOPR_ADDR, SpecificConfigPtr->ulSMOPRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMOPR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMOPRRegValue, LulOrMaskValRegister); #endif } else { /* No action required */ } /* End of if (FLS_ZERO_WORD != LusOptDataEnable) */ /* Write operation and having data */ if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, (uint32)Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop ((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0315, 0306 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* If 64 bits transferred, copies to SMWDR1 and SMWDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, copies data[31:0] to SMWDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR1Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR1Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR1_ADDR, LulSMWDR1Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR1Value, LulOrMaskValRegister); #endif FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, FLS_ERASED_VALUE); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_ERASED_VALUE, LulOrMaskValRegister); #endif } else { /* Otherwise, copies to data[63:32] to SMWDR0, data[31:0] to SMWDR1 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR1_ADDR, (uint32 *)DataAddressPtr, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 3305, 0310, 0306 # JV-01, JV-01, JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, (*(uint32 *)DataAddressPtr), LulOrMaskValRegister); /* PRQA S 2814, 3305, 0310 # JV-01, JV-01, JV-01 */ #endif LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMWDR0Value, /* PRQA S 0315 # JV-01 */ (uint32 *)(DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD), /* PRQA S 3305, 0315, 0310, 2824, 0488 # JV-01, JV-01, JV-01, JV-01, JV-01 */ (uint32)Length - FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 3383 # JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, LulSMWDR0Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR0Value, LulOrMaskValRegister); #endif } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, copies to SMWDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, SpecificConfigPtr->ucDataLength);/* PRQA S 0306, 0315 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength) */ /* -----Enable Read/Write Operation and Start transfer----- */ /* Configure SMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, SpecificConfigPtr->ulSMCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCRRegValue, LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* If read operation and having data */ if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register */ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, /* PRQA S 0306, 0315 # JV-01, JV-01 */ (uint32)SpecificConfigPtr->ucDataLength); Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #else /* If 64 bits transferred, read from SMRDR1 and SMRDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, read data[31:0] from SMRDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR1 register*/ LulSMRDR1Value = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR1Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* Else read data[63:32] from SMRDR0, data[31:0] from SMRDR1 */ Fls_MemCopyUseLoop (DataAddressPtr, (uint32 *)FLS_RPC_SMRDR1_ADDR, (uint32)FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LulSMRDR0Value= FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop (DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD, /* PRQA S 0488, 0315 # JV-01, JV-01 */ (uint32 *)&LulSMRDR0Value, /* PRQA S 0315 # JV-01 */ (uint32)(Length - FLS_SIZE_OF_A_LONG_WORD)); /* PRQA S 4391, 3383 # JV-01, JV-01 */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, read directly from SMRDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register*/ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0306, 0315 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) */ } else { /* No action required */ } /* if (E_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEND_SPEC_CONFIG_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': '&map_SpecificConfigPtr[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'DataAddressPtr', 'Value': '&map_DataAddressPtr[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '0x04'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '0x03020100'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0] ', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucDDRStrobeTimingAdjust', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYCNTRegValue', 'Value': '0x88038000UL'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulCMNCRRegValue', 'Value': '0x80FF0300UL'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCMRRegValue', 'Value': '0x00650000UL'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMADRRegValue', 'Value': '0x00800002UL'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMENRRegValue', 'Value': '0x0000C708UL'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulSSLDRRegValue', 'Value': '0x00000400UL'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDMCRValue', 'Value': '0x00000007UL'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '0x00000000UL'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMOPRRegValue', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCRRegValue', 'Value': '0x00000005UL'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYOFFSET1RegValue', 'Value': '0x30000000UL'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ucRPCCKCRRegValue', 'Value': '0x13U'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ucDataLength', 'Value': 'FOUR_UNITS_DATA'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Input_Param_035': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '[0 to 1] = *((uint32 *)pSrc)'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_037': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '0x03020100'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0x30000000'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYCNT_ADDR[0]', 'Value': '0x88038000'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0x80FF0300'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0x00000400'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0]', 'Value': '0x00000000'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0x00000007'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0x0000C708'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0x00650000'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x00000004'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMADR_ADDR[0]', 'Value': '0x00800002'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '0x03020100'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRPCCKCRRegValue', 'Value': '0x13U'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_PHYOFFSET1_ADDR[0]\\n[1] = map_FLS_RPC_PHYCNT_ADDR[0]\\n[2] = map_FLS_RPC_CMNCR_ADDR[0]\\n[3] = map_FLS_RPC_SSLDR_ADDR[0]\\n[4] = map_FLS_RPC_SMDRENR_ADDR[0]\\n[5] = map_FLS_RPC_SMDMCR_ADDR[0]\\n[6] = map_FLS_RPC_SMENR_ADDR[0]\\n[7] = map_FLS_RPC_SMCMR_ADDR[0]\\n[8] = map_FLS_RPC_SMADR_ADDR[0]'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_SpecificConfigPtr[0].ulPHYOFFSET1RegValue\\n[1] = ((map_SpecificConfigPtr[0].ulPHYCNTRegValue & (~FLS_PHYCNT_DDRCAL_MASK)) | (FLS_PHYCNT_CAL_MASK | FLS_PHYCNT_STRTIM_MASK))\\n[2] = map_SpecificConfigPtr[0].ulCMNCRRegValue\\n[3] = map_SpecificConfigPtr[0].ulSSLDRRegValue\\n[4] = map_SpecificConfigPtr[0].ulSMDRENRValue\\n[5] = map_SpecificConfigPtr[0].ulSMDMCRValue\\n[6] = map_SpecificConfigPtr[0].ulSMENRRegValue\\n[7] = map_SpecificConfigPtr[0].ulSMCMRRegValue\\n[8] = map_SpecificConfigPtr[0].ulSMADRRegValue'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_PHYOFFSET1_DDRTMG_MASK\\n[1] = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK)\\n[2] = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK)\\n[3] = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK)\\n[4] = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)\\n[5] = FLS_SMDMCR_DMCYC_MASK\\n[6] = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK)\\n[7] = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK)\\n[8] = FLS_A_LONG_WORD_MASK'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': 'map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': 'map_SpecificConfigPtr[0].ulSMCRRegValue'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '(FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '[0] = pDest\\n[1] = &map_DataAddressPtr[0]'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '[0] = (uint32 *)FLS_RPC_SMRDR0_ADDR\\n[1] = pSrc'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '[0] = map_SpecificConfigPtr[0].ucDataLength\\n[1] = 4'], 'Output_Param_044': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_045': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_SfSetSpecificConfig /* PRQA S 1532 # JV-01 */ (CONSTP2CONST(Fls_SfSpecificConfigType, AUTOMATIC, FLS_APPL_CONST) SpecificConfigPtr, CONSTP2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) DataAddressPtr, /* PRQA S 3432 # JV-01 */ const uint8 Length) { /* Local variable to hold the return value */ Std_ReturnType LddReturnValue; uint8 LucOperation; uint16 LusOptDataEnable; uint32 LulTimeout; uint32 LulSMWDR0Value; uint32 LulSMRDR0Value; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint32 LulSMWDR1Value; uint32 LulSMRDR1Value; #endif #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) uint32 LulRegRealValue; uint32 LulOrMaskValRegister; #endif uint32 LulRegData; /* Get the SPIRE bit value, if it configured as 1, read operation enabled. * Else, write operation enabled */ LucOperation = (uint8)(SpecificConfigPtr->ulSMCRRegValue & FLS_SMCR_SPIRE_MASK); /* PRQA S 2814 # JV-01 */ LusOptDataEnable = (uint16)(SpecificConfigPtr->ulSMENRRegValue & FLS_SMENR_OPDE_MASK); /* Timeout monitor */ LulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* ---------------Waiting for data transfer has ended --------------------*/ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); #if (FLS_CPG_CLOCK_SETTING == STD_ON) if (E_OK == LddReturnValue) { /* clock setting with waiting for data transfer has ended */ LddReturnValue = Fls_ClockSetting( (uint32)(SpecificConfigPtr->ucRPCCKCRRegValue)); } else { /* No action required */ } #endif /* End of #if (FLS_CPG_CLOCK_SETTING == STD_ON) */ /* If transfer has been finished */ if (E_OK == LddReturnValue) { /* --------------------------Initialize manual mode---------------------- */ /* Configure PHYOFFSET1 register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, FLS_PHYOFFSET1_DDRTMG_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, SpecificConfigPtr->ulPHYOFFSET1RegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYOFFSET1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulPHYOFFSET1RegValue, FLS_PHYOFFSET1_DDRTMG_MASK); #endif /* Configure PHYCNT register */ /* Set PHYCNT user configuration */ LulRegData = SpecificConfigPtr->ulPHYCNTRegValue; /* Set PHYCNT.CAL = 0 */ LulRegData &= ~(FLS_PHYCNT_CAL_MASK); /* Clear PHYCNT.STRTIM before set*/ LulRegData &= ~(FLS_PHYCNT_STRTIM_MASK); #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER != (SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* DDR transfer */ /* Set PHYCNT.DDRCAL to 1 */ LulRegData |= FLS_PHYCNT_DDRCAL_MASK; /* Set PHYCNT.STRTIM value for DDR calibration */ LulRegData |= (((uint32)(Fls_GstVarProperties.ucDDRStrobeTimingAdjust) & FLS_PHYCNT_STRTIM_15_TO_17_MASK_BIT) << FLS_PHYCNT_STRTIM_15_TO_17_INDEX); LulRegData |= ((Fls_GstVarProperties.ucDDRStrobeTimingAdjust & FLS_PHYCNT_STRTIM_27_MASK_BIT) << FLS_PHYCNT_STRTIM_27_INDEX); FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } else #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ { /* Execute PHY calibration */ /* Set PHYCNT.DDRCAL to 0 */ LulRegData &= ~(FLS_PHYCNT_DDRCAL_MASK); /* When set PHYCNT.CAL = 1'b1, PHYCNT.STRTIM must be set to smallest */ LulRegData |= (uint32)FLS_PHYCNT_STRTIM_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Set PHYCNT.CAL = 1'b1 */ LulRegData |= FLS_PHYCNT_CAL_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } /* End of if ((SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK) != FLS_SMDRENR_SF_SDR_TRANSFER) */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYCNT_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Configure CMNCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_CMNCR_ADDR, FLS_CMNCR_MD_MASK /* PRQA S 0303, 3469 # JV-01, JV-01 */ | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_CMNCR_ADDR, SpecificConfigPtr->ulCMNCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_CMNCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulCMNCRRegValue, LulOrMaskValRegister); #endif /* Configure SSLDR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SSLDR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SSLDR_ADDR, SpecificConfigPtr->ulSSLDRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SSLDR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSSLDRRegValue, LulOrMaskValRegister); #endif /* Configure SMDRENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDRENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDRENR_ADDR, SpecificConfigPtr->ulSMDRENRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDRENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDRENRValue, LulOrMaskValRegister); #endif /* Set dummy cycles */ /* Configure SMDMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDMCR_ADDR, FLS_SMDMCR_DMCYC_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDMCR_ADDR, SpecificConfigPtr->ulSMDMCRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_SMDMCR_DMCYC_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDMCRValue, LulOrMaskValRegister); #endif /* Configure SMENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMENR_ADDR, SpecificConfigPtr->ulSMENRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMENRRegValue, LulOrMaskValRegister); #endif /* Set command/optional command */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCMR_ADDR, FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCMR_ADDR, SpecificConfigPtr->ulSMCMRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCMR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCMRRegValue, LulOrMaskValRegister); #endif /* Set the target address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, SpecificConfigPtr->ulSMADRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMADRRegValue, LulOrMaskValRegister); #endif /* End of #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) */ if (FLS_ZERO_WORD != LusOptDataEnable) { /* Set optional data */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMOPR_ADDR, FLS_A_LONG_WORD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMOPR_ADDR, SpecificConfigPtr->ulSMOPRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMOPR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMOPRRegValue, LulOrMaskValRegister); #endif } else { /* No action required */ } /* End of if (FLS_ZERO_WORD != LusOptDataEnable) */ /* Write operation and having data */ if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, (uint32)Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop ((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0315, 0306 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* If 64 bits transferred, copies to SMWDR1 and SMWDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, copies data[31:0] to SMWDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR1Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR1Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR1_ADDR, LulSMWDR1Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR1Value, LulOrMaskValRegister); #endif FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, FLS_ERASED_VALUE); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_ERASED_VALUE, LulOrMaskValRegister); #endif } else { /* Otherwise, copies to data[63:32] to SMWDR0, data[31:0] to SMWDR1 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR1_ADDR, (uint32 *)DataAddressPtr, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 3305, 0310, 0306 # JV-01, JV-01, JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, (*(uint32 *)DataAddressPtr), LulOrMaskValRegister); /* PRQA S 2814, 3305, 0310 # JV-01, JV-01, JV-01 */ #endif LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMWDR0Value, /* PRQA S 0315 # JV-01 */ (uint32 *)(DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD), /* PRQA S 3305, 0315, 0310, 2824, 0488 # JV-01, JV-01, JV-01, JV-01, JV-01 */ (uint32)Length - FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 3383 # JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, LulSMWDR0Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR0Value, LulOrMaskValRegister); #endif } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, copies to SMWDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, SpecificConfigPtr->ucDataLength);/* PRQA S 0306, 0315 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength) */ /* -----Enable Read/Write Operation and Start transfer----- */ /* Configure SMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, SpecificConfigPtr->ulSMCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCRRegValue, LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* If read operation and having data */ if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register */ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, /* PRQA S 0306, 0315 # JV-01, JV-01 */ (uint32)SpecificConfigPtr->ucDataLength); Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #else /* If 64 bits transferred, read from SMRDR1 and SMRDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, read data[31:0] from SMRDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR1 register*/ LulSMRDR1Value = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR1Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* Else read data[63:32] from SMRDR0, data[31:0] from SMRDR1 */ Fls_MemCopyUseLoop (DataAddressPtr, (uint32 *)FLS_RPC_SMRDR1_ADDR, (uint32)FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LulSMRDR0Value= FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop (DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD, /* PRQA S 0488, 0315 # JV-01, JV-01 */ (uint32 *)&LulSMRDR0Value, /* PRQA S 0315 # JV-01 */ (uint32)(Length - FLS_SIZE_OF_A_LONG_WORD)); /* PRQA S 4391, 3383 # JV-01, JV-01 */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, read directly from SMRDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register*/ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0306, 0315 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) */ } else { /* No action required */ } /* if (E_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEND_SPEC_CONFIG_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': '&map_SpecificConfigPtr[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'DataAddressPtr', 'Value': '&map_DataAddressPtr[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '0x05'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0] ', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucDDRStrobeTimingAdjust', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYCNTRegValue', 'Value': '0x88038000UL'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulCMNCRRegValue', 'Value': '0x80FF0300UL'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCMRRegValue', 'Value': '0x00650000UL'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMADRRegValue', 'Value': '0x00800002UL'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMENRRegValue', 'Value': '0x0000C708UL'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulSSLDRRegValue', 'Value': '0x00000400UL'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDMCRValue', 'Value': '0x00000007UL'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '0x00000000UL'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMOPRRegValue', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCRRegValue', 'Value': '0x00000005UL'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYOFFSET1RegValue', 'Value': '0x30000000UL'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ucRPCCKCRRegValue', 'Value': '0x13U'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ucDataLength', 'Value': 'FOUR_UNITS_DATA'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Input_Param_035': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '-'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_037': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0x30000000'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYCNT_ADDR[0]', 'Value': '0x88038000'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0x80FF0300'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0x00000400'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0]', 'Value': '0x00000000'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0x00000007'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0x0000C708'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0x00650000'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x00000004'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMADR_ADDR[0]', 'Value': '0x00800002'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '-'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRPCCKCRRegValue', 'Value': '0x13U'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_PHYOFFSET1_ADDR[0]\\n[1] = map_FLS_RPC_PHYCNT_ADDR[0]\\n[2] = map_FLS_RPC_CMNCR_ADDR[0]\\n[3] = map_FLS_RPC_SSLDR_ADDR[0]\\n[4] = map_FLS_RPC_SMDRENR_ADDR[0]\\n[5] = map_FLS_RPC_SMDMCR_ADDR[0]\\n[6] = map_FLS_RPC_SMENR_ADDR[0]\\n[7] = map_FLS_RPC_SMCMR_ADDR[0]\\n[8] = map_FLS_RPC_SMADR_ADDR[0]'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_SpecificConfigPtr[0].ulPHYOFFSET1RegValue\\n[1] = ((map_SpecificConfigPtr[0].ulPHYCNTRegValue & (~FLS_PHYCNT_DDRCAL_MASK)) | (FLS_PHYCNT_CAL_MASK | FLS_PHYCNT_STRTIM_MASK))\\n[2] = map_SpecificConfigPtr[0].ulCMNCRRegValue\\n[3] = map_SpecificConfigPtr[0].ulSSLDRRegValue\\n[4] = map_SpecificConfigPtr[0].ulSMDRENRValue\\n[5] = map_SpecificConfigPtr[0].ulSMDMCRValue\\n[6] = map_SpecificConfigPtr[0].ulSMENRRegValue\\n[7] = map_SpecificConfigPtr[0].ulSMCMRRegValue\\n[8] = map_SpecificConfigPtr[0].ulSMADRRegValue'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_PHYOFFSET1_DDRTMG_MASK\\n[1] = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK)\\n[2] = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK)\\n[3] = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK)\\n[4] = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)\\n[5] = FLS_SMDMCR_DMCYC_MASK\\n[6] = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK)\\n[7] = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK)\\n[8] = FLS_A_LONG_WORD_MASK'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': 'map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': 'map_SpecificConfigPtr[0].ulSMCRRegValue'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '(FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_044': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_045': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_SfSetSpecificConfig /* PRQA S 1532 # JV-01 */ (CONSTP2CONST(Fls_SfSpecificConfigType, AUTOMATIC, FLS_APPL_CONST) SpecificConfigPtr, CONSTP2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) DataAddressPtr, /* PRQA S 3432 # JV-01 */ const uint8 Length) { /* Local variable to hold the return value */ Std_ReturnType LddReturnValue; uint8 LucOperation; uint16 LusOptDataEnable; uint32 LulTimeout; uint32 LulSMWDR0Value; uint32 LulSMRDR0Value; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) uint32 LulSMWDR1Value; uint32 LulSMRDR1Value; #endif #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) uint32 LulRegRealValue; uint32 LulOrMaskValRegister; #endif uint32 LulRegData; /* Get the SPIRE bit value, if it configured as 1, read operation enabled. * Else, write operation enabled */ LucOperation = (uint8)(SpecificConfigPtr->ulSMCRRegValue & FLS_SMCR_SPIRE_MASK); /* PRQA S 2814 # JV-01 */ LusOptDataEnable = (uint16)(SpecificConfigPtr->ulSMENRRegValue & FLS_SMENR_OPDE_MASK); /* Timeout monitor */ LulTimeout = (uint32)FLS_READ_TIME; /* PRQA S 2905 # JV-01 */ /* ---------------Waiting for data transfer has ended --------------------*/ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); #if (FLS_CPG_CLOCK_SETTING == STD_ON) if (E_OK == LddReturnValue) { /* clock setting with waiting for data transfer has ended */ LddReturnValue = Fls_ClockSetting( (uint32)(SpecificConfigPtr->ucRPCCKCRRegValue)); } else { /* No action required */ } #endif /* End of #if (FLS_CPG_CLOCK_SETTING == STD_ON) */ /* If transfer has been finished */ if (E_OK == LddReturnValue) { /* --------------------------Initialize manual mode---------------------- */ /* Configure PHYOFFSET1 register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, FLS_PHYOFFSET1_DDRTMG_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_PHYOFFSET1_ADDR, SpecificConfigPtr->ulPHYOFFSET1RegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYOFFSET1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulPHYOFFSET1RegValue, FLS_PHYOFFSET1_DDRTMG_MASK); #endif /* Configure PHYCNT register */ /* Set PHYCNT user configuration */ LulRegData = SpecificConfigPtr->ulPHYCNTRegValue; /* Set PHYCNT.CAL = 0 */ LulRegData &= ~(FLS_PHYCNT_CAL_MASK); /* Clear PHYCNT.STRTIM before set*/ LulRegData &= ~(FLS_PHYCNT_STRTIM_MASK); #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_SMDRENR_SF_SDR_TRANSFER != (SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)) { /* DDR transfer */ /* Set PHYCNT.DDRCAL to 1 */ LulRegData |= FLS_PHYCNT_DDRCAL_MASK; /* Set PHYCNT.STRTIM value for DDR calibration */ LulRegData |= (((uint32)(Fls_GstVarProperties.ucDDRStrobeTimingAdjust) & FLS_PHYCNT_STRTIM_15_TO_17_MASK_BIT) << FLS_PHYCNT_STRTIM_15_TO_17_INDEX); LulRegData |= ((Fls_GstVarProperties.ucDDRStrobeTimingAdjust & FLS_PHYCNT_STRTIM_27_MASK_BIT) << FLS_PHYCNT_STRTIM_27_INDEX); FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } else #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ { /* Execute PHY calibration */ /* Set PHYCNT.DDRCAL to 0 */ LulRegData &= ~(FLS_PHYCNT_DDRCAL_MASK); /* When set PHYCNT.CAL = 1'b1, PHYCNT.STRTIM must be set to smallest */ LulRegData |= (uint32)FLS_PHYCNT_STRTIM_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Set PHYCNT.CAL = 1'b1 */ LulRegData |= FLS_PHYCNT_CAL_MASK; FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_PHYCNT_ADDR, LulRegData); /* PRQA S 0303, 3469 # JV-01, JV-01 */ } /* End of if ((SpecificConfigPtr->ulSMDRENRValue & FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK) != FLS_SMDRENR_SF_SDR_TRANSFER) */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_PHYCNT_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulRegData, LulOrMaskValRegister); #endif /* Configure CMNCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_CMNCR_ADDR, FLS_CMNCR_MD_MASK /* PRQA S 0303, 3469 # JV-01, JV-01 */ | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_CMNCR_ADDR, SpecificConfigPtr->ulCMNCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_CMNCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulCMNCRRegValue, LulOrMaskValRegister); #endif /* Configure SSLDR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SSLDR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SSLDR_ADDR, SpecificConfigPtr->ulSSLDRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SSLDR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSSLDRRegValue, LulOrMaskValRegister); #endif /* Configure SMDRENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDRENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDRENR_ADDR, SpecificConfigPtr->ulSMDRENRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDRENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDRENRValue, LulOrMaskValRegister); #endif /* Set dummy cycles */ /* Configure SMDMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMDMCR_ADDR, FLS_SMDMCR_DMCYC_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMDMCR_ADDR, SpecificConfigPtr->ulSMDMCRValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_SMDMCR_DMCYC_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMDMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMDMCRValue, LulOrMaskValRegister); #endif /* Configure SMENR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMENR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMENR_ADDR, SpecificConfigPtr->ulSMENRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMENR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMENRRegValue, LulOrMaskValRegister); #endif /* Set command/optional command */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCMR_ADDR, FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCMR_ADDR, SpecificConfigPtr->ulSMCMRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCMR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCMRRegValue, LulOrMaskValRegister); #endif /* Set the target address */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMADR_ADDR, SpecificConfigPtr->ulSMADRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMADR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMADRRegValue, LulOrMaskValRegister); #endif /* End of #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) */ if (FLS_ZERO_WORD != LusOptDataEnable) { /* Set optional data */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMOPR_ADDR, FLS_A_LONG_WORD_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMOPR_ADDR, SpecificConfigPtr->ulSMOPRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMOPR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMOPRRegValue, LulOrMaskValRegister); #endif } else { /* No action required */ } /* End of if (FLS_ZERO_WORD != LusOptDataEnable) */ /* Write operation and having data */ if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, (uint32)Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop ((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0315, 0306 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #elif (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* If 64 bits transferred, copies to SMWDR1 and SMWDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, copies data[31:0] to SMWDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR1Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR1Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR1_ADDR, LulSMWDR1Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR1Value, LulOrMaskValRegister); #endif FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, FLS_ERASED_VALUE); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, FLS_ERASED_VALUE, LulOrMaskValRegister); #endif } else { /* Otherwise, copies to data[63:32] to SMWDR0, data[31:0] to SMWDR1 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR1_ADDR, (uint32 *)DataAddressPtr, FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0315, 3305, 0310, 0306 # JV-01, JV-01, JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, (*(uint32 *)DataAddressPtr), LulOrMaskValRegister); /* PRQA S 2814, 3305, 0310 # JV-01, JV-01, JV-01 */ #endif LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMWDR0Value, /* PRQA S 0315 # JV-01 */ (uint32 *)(DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD), /* PRQA S 3305, 0315, 0310, 2824, 0488 # JV-01, JV-01, JV-01, JV-01, JV-01 */ (uint32)Length - FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 3383 # JV-01 */ FLS_WRITE_4BYTES_TO_ADDR(FLS_RPC_SMWDR0_ADDR, LulSMWDR0Value); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* Invoke safety write verify feature */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = FLS_A_LONG_WORD_MASK; LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMWDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, LulSMWDR0Value, LulOrMaskValRegister); #endif } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, copies to SMWDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { LulSMWDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop((uint32 *)&LulSMWDR0Value, (uint32 *)DataAddressPtr, Length); /* PRQA S 0315, 3305, 0310 # JV-01, JV-01, JV-01 */ Fls_MemCopyUseLoop((uint32 *)FLS_RPC_SMWDR0_ADDR, (uint32 *)&LulSMWDR0Value, SpecificConfigPtr->ucDataLength);/* PRQA S 0306, 0315 # JV-01, JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO == LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength) */ /* -----Enable Read/Write Operation and Start transfer----- */ /* Configure SMCR register */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, /* PRQA S 0303, 3469 # JV-01, JV-01 */ FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK | FLS_SMCR_SPIE_MASK); FLS_SET_BITS_TO_ADDR_32(FLS_RPC_SMCR_ADDR, SpecificConfigPtr->ulSMCRRegValue); /* PRQA S 0303, 3469 # JV-01, JV-01 */ #if (FLS_WRITE_VERIFY_ENABLE == STD_ON) LulOrMaskValRegister = (FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK); LulRegRealValue = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMCR_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_WriteVerifyCheck(LulRegRealValue, SpecificConfigPtr->ulSMCRRegValue, LulOrMaskValRegister); #endif /* Waiting for data transfer has ended */ LddReturnValue = Fls_WaitRpcTransferEnd(LulTimeout); if (E_OK == LddReturnValue) { /* Disable transfer */ FLS_CLEAR_BITS_FROM_ADDR_32(FLS_RPC_SMCR_ADDR, FLS_SMCR_SPIE_MASK); /* PRQA S 0303, 3469 # JV-01, JV-01 */ /* If read operation and having data */ if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) { #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register */ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, /* PRQA S 0306, 0315 # JV-01, JV-01 */ (uint32)SpecificConfigPtr->ucDataLength); Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ #else /* If 64 bits transferred, read from SMRDR1 and SMRDR0 */ if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) { /* If data length less than 4 bytes, read data[31:0] from SMRDR1 */ if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR1 register*/ LulSMRDR1Value = FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR1_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR1Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* Else read data[63:32] from SMRDR0, data[31:0] from SMRDR1 */ Fls_MemCopyUseLoop (DataAddressPtr, (uint32 *)FLS_RPC_SMRDR1_ADDR, (uint32)FLS_SIZE_OF_A_LONG_WORD); /* PRQA S 0306, 0315 # JV-01, JV-01 */ LulSMRDR0Value= FLS_READ_4BYTES_FROM_ADDR(FLS_RPC_SMRDR0_ADDR); /* PRQA S 0303, 3469 # JV-01, JV-01 */ Fls_MemCopyUseLoop (DataAddressPtr + FLS_SIZE_OF_A_LONG_WORD, /* PRQA S 0488, 0315 # JV-01, JV-01 */ (uint32 *)&LulSMRDR0Value, /* PRQA S 0315 # JV-01 */ (uint32)(Length - FLS_SIZE_OF_A_LONG_WORD)); /* PRQA S 4391, 3383 # JV-01, JV-01 */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } else /* Otherwise, read directly from SMRDR0 only */ { if (FLS_SIZE_OF_A_LONG_WORD >= Length) { /* Read direct SMRDR0 register*/ LulSMRDR0Value = FLS_ERASED_VALUE; Fls_MemCopyUseLoop ((uint32 *)&LulSMRDR0Value, (uint32 *)FLS_RPC_SMRDR0_ADDR, (uint32)SpecificConfigPtr->ucDataLength); /* PRQA S 0306, 0315 # JV-01, JV-01 */ Fls_MemCopyUseLoop(DataAddressPtr, (uint32 *)&LulSMRDR0Value, (uint32)Length); /* PRQA S 0315 # JV-01 */ } else { /* No action required */ } /* End of if (FLS_SIZE_OF_A_LONG_WORD >= Length) */ } /* End of if (FLS_SMENR_SPIDE_64_BIT == ((SpecificConfigPtr->ulSMENRRegValue) & FLS_SMENR_SPIDE_MASK)) */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ } else { /* No action required */ } /* End of if ((FLS_ZERO != LucOperation) && (NOT_USED != SpecificConfigPtr->ucDataLength)) */ } else { /* No action required */ } /* if (E_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEND_SPEC_CONFIG_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': '&map_SpecificConfigPtr[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'DataAddressPtr', 'Value': '&map_DataAddressPtr[0]'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '0xFF'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0] ', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucDDRStrobeTimingAdjust', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYCNTRegValue', 'Value': '0x88038000UL'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulCMNCRRegValue', 'Value': '0x80FF0300UL'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCMRRegValue', 'Value': '0x00650000UL'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMADRRegValue', 'Value': '0x00800002UL'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMENRRegValue', 'Value': '0x0000C708UL'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulSSLDRRegValue', 'Value': '0x00000400UL'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDMCRValue', 'Value': '0x00000007UL'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMDRENRValue', 'Value': '0x00000000UL'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMOPRRegValue', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulSMCRRegValue', 'Value': '0x00000005UL'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulPHYOFFSET1RegValue', 'Value': '0x30000000UL'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ucRPCCKCRRegValue', 'Value': '0x13U'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ucDataLength', 'Value': 'FOUR_UNITS_DATA'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Input_Param_035': ['Type': 'Output_Argument', 'Range': '', 'Name': '*((uint32 *)pDest)', 'Value': '-'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK'], 'Input_Param_037': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataAddressPtr[1]', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYOFFSET1_ADDR[0]', 'Value': '0x30000000'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_PHYCNT_ADDR[0]', 'Value': '0x88038000'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_CMNCR_ADDR[0]', 'Value': '0x80FF0300'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SSLDR_ADDR[0]', 'Value': '0x00000400'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDRENR_ADDR[0]', 'Value': '0x00000000'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMDMCR_ADDR[0]', 'Value': '0x00000007'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMENR_ADDR[0]', 'Value': '0x0000C708'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCMR_ADDR[0]', 'Value': '0x00650000'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMCR_ADDR[0]', 'Value': '0x00000004'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR0_ADDR[0]', 'Value': '-'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMWDR1_ADDR[0]', 'Value': '-'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMADR_ADDR[0]', 'Value': '0x00800002'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMOPR_ADDR[0]', 'Value': '-'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR0_ADDR[0]', 'Value': '-'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'map_FLS_RPC_SMRDR1_ADDR[0]', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRPCCKCRRegValue', 'Value': '0x13U'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '[0] = map_FLS_RPC_PHYOFFSET1_ADDR[0]\\n[1] = map_FLS_RPC_PHYCNT_ADDR[0]\\n[2] = map_FLS_RPC_CMNCR_ADDR[0]\\n[3] = map_FLS_RPC_SSLDR_ADDR[0]\\n[4] = map_FLS_RPC_SMDRENR_ADDR[0]\\n[5] = map_FLS_RPC_SMDMCR_ADDR[0]\\n[6] = map_FLS_RPC_SMENR_ADDR[0]\\n[7] = map_FLS_RPC_SMCMR_ADDR[0]\\n[8] = map_FLS_RPC_SMADR_ADDR[0]'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '[0] = map_SpecificConfigPtr[0].ulPHYOFFSET1RegValue\\n[1] = ((map_SpecificConfigPtr[0].ulPHYCNTRegValue & (~FLS_PHYCNT_DDRCAL_MASK)) | (FLS_PHYCNT_CAL_MASK | FLS_PHYCNT_STRTIM_MASK))\\n[2] = map_SpecificConfigPtr[0].ulCMNCRRegValue\\n[3] = map_SpecificConfigPtr[0].ulSSLDRRegValue\\n[4] = map_SpecificConfigPtr[0].ulSMDRENRValue\\n[5] = map_SpecificConfigPtr[0].ulSMDMCRValue\\n[6] = map_SpecificConfigPtr[0].ulSMENRRegValue\\n[7] = map_SpecificConfigPtr[0].ulSMCMRRegValue\\n[8] = map_SpecificConfigPtr[0].ulSMADRRegValue'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '[0] = FLS_PHYOFFSET1_DDRTMG_MASK\\n[1] = (FLS_PHYCNT_OCTA_OCT_MASK | FLS_PHYCNT_EXDS_MASK | FLS_PHYCNT_DDRCAL_MASK | FLS_PHYCNT_HS_MASK | FLS_PHYCNT_STRTIM_MASK | FLS_PHYCNT_WBUF2_WBUF_MASK | FLS_PHYCNT_PHYMEM_MASK)\\n[2] = (FLS_CMNCR_MD_MASK | FLS_CMNCR_MOIIO_MASK | FLS_CMNCR_IONFV_MASK | FLS_CMNCR_BSZ_MASK)\\n[3] = (FLS_SSLDR_SPNDL_MASK | FLS_SSLDR_SCKDL_MASK | FLS_SSLDR_SLNDL_MASK)\\n[4] = (FLS_SMDRENR_HYPE_SPI_MODE_MASK | FLS_SMDRENR_ADDRE_OPDRE_SPIDRE_MASK)\\n[5] = FLS_SMDMCR_DMCYC_MASK\\n[6] = (FLS_SMENR_CDB_MASK | FLS_SMENR_OCDB_MASK | FLS_SMENR_ADB_MASK | FLS_SMENR_OPDB_MASK | FLS_SMENR_SPIDB_MASK | FLS_SMENR_DME_MASK | FLS_SMENR_OCDE_MASK | FLS_SMENR_ADE_MASK | FLS_SMENR_OPDE_MASK | FLS_SMENR_SPIDE_MASK)\\n[7] = (FLS_SMCMR_OCMD_MASK | FLS_SMCMR_CMD_MASK)\\n[8] = FLS_A_LONG_WORD_MASK'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': '-'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '-'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulRegValue', 'Value': 'map_FLS_RPC_SMCR_ADDR[0]'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCompareData', 'Value': 'map_SpecificConfigPtr[0].ulSMCRRegValue'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulOrMaskValRegister', 'Value': '(FLS_SMCR_SSLKP_MASK | FLS_SMCR_SPIRE_MASK | FLS_SMCR_SPIWE_MASK)'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_042': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'Size', 'Value': '-'], 'Output_Param_044': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_045': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Fls_CompareStatusType, FLS_CODE_SLOW) Fls_SfSwitchCompareMode /* PRQA S 1532 # JV-01 */ (CONSTP2VAR(volatile void, AUTOMATIC, FLS_APPL_DATA) pDest, /* PRQA S 3673 # JV-01 */ CONSTP2VAR(const void, AUTOMATIC, FLS_APPL_DATA) pSrc, const uint32 Length, const boolean blSrcIsAConstNumber) { Fls_CompareStatusType LenCompareStatus; P2VAR(volatile uint32, AUTOMATIC, FLS_APPL_DATA) LpDest; /* PRQA S 3678, 3432 # JV-01, JV-01 */ P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA) LpSrc; /* PRQA S 3432 # JV-01 */ uint32 LulFlashAddress; #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_SetExtSpaceReadType LddSetReadConfig; Std_ReturnType LddProcessStatus; Fls_AddressType LulVirtualAddress; uint32 LulInteralAddressMask; LpDest = (P2VAR(volatile uint32, AUTOMATIC, FLS_APPL_DATA)) pDest; /* PRQA S 3432, 0316 # JV-01, JV-01 */ LpSrc = (P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA)) pSrc; /* PRQA S 3432, 0316, 0311 # JV-01, JV-01, JV-01 */ LddProcessStatus = E_OK; /* PRQA S 2982 # JV-01 */ LulFlashAddress = FLS_READ_4BYTES_FROM_ADDR(LpDest); /* PRQA S 3469, 2814 # JV-01, JV-01 */ #if (FLS_DDR_CALIB_FEATURE == STD_ON) if ((E_NOT_OK == Fls_GstVarProperties.ddDDRWritePatternStatus) && (FLS_TRUE == Fls_GpConfigPtr->pSfConfig->blReadDdrEnable)) /* PRQA S 2814 # JV-01 */ { /* Apply the user configuration */ LddSetReadConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfDdrVerifyConfig; LddSetReadConfig.ulOptionalData = Fls_GpConfigPtr->pSfConfig->ulDdrVerifyOptDataValue; LddSetReadConfig.blStrobeTimeAdjust = FLS_FALSE; } else #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ { /* Apply the user configuration */ LddSetReadConfig.pUserConfig = Fls_GpConfigPtr->pSfConfig->pSfReadConfig; /* PRQA S 2814 # JV-01 */ LddSetReadConfig.ulOptionalData = Fls_GpConfigPtr->pSfConfig->ulOptionalDataValue; #if (FLS_DDR_CALIB_FEATURE == STD_ON) if (FLS_DRDRENR_SF_SDR_TRANSFER == (LddSetReadConfig.pUserConfig->ulDRDRENRValue & /* PRQA S 2814 # JV-01 */ FLS_DRDRENR_ADDRE_OPDRE_DRDRE_MASK)) { /* SDR transfer, do not use Strobe Timing Adjustment */ LddSetReadConfig.blStrobeTimeAdjust = FLS_FALSE; } else { /* DDR transfer, use Strobe Timing Adjustment */ LddSetReadConfig.blStrobeTimeAdjust = FLS_TRUE; } #endif /* End of #if (FLS_DDR_CALIB_FEATURE == STD_ON) */ } /* End of if ((E_NOT_OK == Fls_GstVarProperties.ddDDRWritePatternStatus) && (FLS_TRUE == Fls_GpConfigPtr->pSfConfig->blReadDdrEnable)) */ if (FLS_ONE != LddSetReadConfig.pUserConfig->ucDREAR_EACValue) /* PRQA S 2814 # JV-01 */ { /* External address bits [24:0] enabled: EAC =0b000 */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* Only 24 bits are mapped to internal address space */ LulInteralAddressMask = FLS_24BITS_MASK; #elif (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) /* All 25 bits are mapped to internal address space */ LulInteralAddressMask = FLS_25BITS_MASK; #endif } else { /* External address bits [25:0] enabled: EAC =0b001 */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* Only 25 bits are mapped to internal address space */ LulInteralAddressMask = FLS_25BITS_MASK; #elif (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) /* All 26 bits are mapped to internal address space */ LulInteralAddressMask = FLS_26BITS_MASK; #endif } /* End of if (FLS_ONE != LddSetReadConfig.pUserConfig->ucDREAR_EACValue) */ /* Get virtual address */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) /* External address is mapped from position 1 in internal address */ LulVirtualAddress = FLS_RPC_INTERNAL_ADDR_MAP + ((LulFlashAddress & LulInteralAddressMask) << FLS_BIT_INDEX_1); /* PRQA S 3383 # JV-01 */ #elif (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) /* External address is mapped from position 0 in internal address */ LulVirtualAddress = FLS_RPC_INTERNAL_ADDR_MAP + (LulFlashAddress & LulInteralAddressMask); /* PRQA S 3383 # JV-01 */ #endif /* End of #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) */ if (FLS_TRUE == Fls_GstVarProperties.blExtSpaceRead) { LddSetReadConfig.ulAddress = LulFlashAddress; /* Call the API below to start read by user configuration */ LddProcessStatus = Fls_SfSetExtSpaceReadConfig(LddSetReadConfig); if (E_OK == LddProcessStatus) { LenCompareStatus = Fls_MemCompare ((void *)LulVirtualAddress, /* PRQA S 0326 # JV-01 */ LpSrc, Length, blSrcIsAConstNumber); /* PRQA S 0315 # JV-01 */ } else { LenCompareStatus = FLS_COMPARE_TIMEOUT; } /* End of if (E_OK == LddProcessStatus) */ } else { LenCompareStatus = Fls_MemCompare ((void *)LulVirtualAddress, /* PRQA S 0326 # JV-01 */ LpSrc, Length, blSrcIsAConstNumber); /* PRQA S 0315 # JV-01 */ } /* End of if (FLS_TRUE == Fls_GstVarProperties.blExtSpaceRead) */ #else LpDest = (P2VAR(volatile uint32, AUTOMATIC, FLS_APPL_DATA)) pDest; /* PRQA S 3432, 0316 # JV-01, JV-01 */ LpSrc = (P2VAR(uint32, AUTOMATIC, FLS_APPL_DATA)) pSrc; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ LulFlashAddress = FLS_READ_4BYTES_FROM_ADDR(LpDest); /* PRQA S 3469, 2814 # JV-01, JV-01 */ /* Call Fls_SfManualModeCompare API to compare data */ LenCompareStatus = Fls_SfManualModeCompare (LulFlashAddress , LpSrc, Length, blSrcIsAConstNumber); #endif /* End of #if (FLS_EXTERNAL_SPACE_READ == STD_ON) */ return (LenCompareStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_ERASE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BLANKCHECK_API', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXTERNAL_SPACE_READ', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'pDest', 'Value': '(uint32 *)&map_pDest[0]'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'pSrc', 'Value': ''], 'Input_Param_009': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '0'], 'Input_Param_010': ['Type': 'Argument', 'Range': '', 'Name': 'blSrcIsAConstNumber', 'Value': 'FLS_FALSE'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pSfDdrVerifyConfig', 'Value': '&map_pSfDdrVerifyConfig[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulDdrVerifyOptDataValue', 'Value': '0x00000000'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulOptionalDataValue', 'Value': '0x00000000'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pSfReadConfig', 'Value': '&map_pSfReadConfig[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'blReadDdrEnable', 'Value': 'FLS_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ddDDRWritePatternStatus', 'Value': 'E_NOT_OK'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulDRDRENRValue', 'Value': 'FLS_DRDRENR_ADDRE_OPDRE_DRDRE_MASK'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ucDREAR_EACValue', 'Value': '0x17'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'blExtSpaceRead', 'Value': 'FLS_FALSE'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDest[0]', 'Value': '0x00001234'], 'Input_Param_023': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-'], 'Input_Param_024': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': 'FLS_CONSISTENT'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return ', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'SetExtSpaceReadConfig', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': ''], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '0'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'blSrcIsAConstNumber', 'Value': 'FLS_FALSE'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'ReadAddress', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'pReadData', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'blSrcIsAConstNumber', 'Value': '-'], 'Output_Param_009': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenCompareStatus', 'Value': 'FLS_CONSISTENT'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Fls_CompareStatusType, FLS_CODE_SLOW) Fls_SfVerifyEraseArea (const uint32 MaxWriteLength) { /* Declare internal variables */ Fls_CompareStatusType LenProcessStatus; uint32 LulEraseValue; P2VAR(volatile uint32, AUTOMATIC, FLS_APPL_DATA) LpFlashAddress; /* PRQA S 3432 # JV-01 */ /* If Job is not finished */ if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) { LulEraseValue = FLS_ERASED_VALUE; LpFlashAddress = (volatile uint32 *)&Fls_GstVarProperties.ulFlashAddress; #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_GstVarProperties.blExtSpaceRead = FLS_TRUE; #endif LenProcessStatus = Fls_SfSwitchCompareMode(LpFlashAddress, (uint32 *)&LulEraseValue, MaxWriteLength, FLS_TRUE); /* PRQA S 0315 # JV-01 */ } else { LenProcessStatus = FLS_CONSISTENT; } /* End of if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) */ return (LenProcessStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_ERASE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BLANKCHECK_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXTERNAL_SPACE_READ', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'MaxWriteLength', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '&map_ulFlashAddress[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_ulFlashAddress[0]', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FLS_CONSISTENT'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'blSrcIsAConstNumber', 'Value': 'FLS_TRUE'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDest', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'pSrc', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'blSrcIsAConstNumber', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'blExtSpaceRead', 'Value': 'FLS_TRUE'], 'Output_Param_009': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenProcessStatus', 'Value': 'FLS_CONSISTENT'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_SpecificConfigHandler /* PRQA S 1532 # JV-01 */ (CONSTP2CONST(Fls_SpecificConfigType, AUTOMATIC, FLS_APPL_CONST) SpecificConfigPtr, CONSTP2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) DataAddressPtr, /* PRQA S 3432 # JV-01 */ const uint8 Length) { Std_ReturnType LddProcessStatus; LddProcessStatus = Fls_WaitRpcTransferEnd((uint32)FLS_READ_TIME); /* PRQA S 2905 # JV-01 */ /* Waiting for data transfer has ended */ if (E_OK == LddProcessStatus) { #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) /* Send Specific Configuration to Serial Flash */ LddProcessStatus = Fls_SfSetSpecificConfig (SpecificConfigPtr, DataAddressPtr, Length); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) /* Send Specific Configuration to Hyper Flash */ LddProcessStatus = Fls_HfSetSpecificConfig (SpecificConfigPtr, DataAddressPtr, Length); #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ /* Check the Send Specific Configuration was successful */ #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) \\ && (FLS_TIMEOUT_MONITORING == STD_ON)) if (E_NOT_OK == LddProcessStatus) { /* Report error to DET if timeout */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_SEND_SPEC_CONFIG_SID, FLS_E_TIMEOUT); } else { /* No action required */ } /* End of if (E_NOT_OK == LddProcessStatus) */ #endif /* End of #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && * (FLS_TIMEOUT_MONITORING == STD_ON)) */ return (LddProcessStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_TIMEOUT_MONITORING', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEND_SPEC_CONFIG_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': ''], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'DataAddressPtr', 'Value': ''], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '85'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '0'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'DataAddressPtr', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'DataAddressPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_011': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': '85'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_SpecificConfigHandler /* PRQA S 1532 # JV-01 */ (CONSTP2CONST(Fls_SpecificConfigType, AUTOMATIC, FLS_APPL_CONST) SpecificConfigPtr, CONSTP2VAR(uint8, AUTOMATIC, FLS_APPL_DATA) DataAddressPtr, /* PRQA S 3432 # JV-01 */ const uint8 Length) { Std_ReturnType LddProcessStatus; LddProcessStatus = Fls_WaitRpcTransferEnd((uint32)FLS_READ_TIME); /* PRQA S 2905 # JV-01 */ /* Waiting for data transfer has ended */ if (E_OK == LddProcessStatus) { #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) /* Send Specific Configuration to Serial Flash */ LddProcessStatus = Fls_SfSetSpecificConfig (SpecificConfigPtr, DataAddressPtr, Length); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) /* Send Specific Configuration to Hyper Flash */ LddProcessStatus = Fls_HfSetSpecificConfig (SpecificConfigPtr, DataAddressPtr, Length); #endif /* #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ } else { /* No action required */ } /* End of if (E_OK == LddProcessStatus) */ /* Check the Send Specific Configuration was successful */ #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) \\ && (FLS_TIMEOUT_MONITORING == STD_ON)) if (E_NOT_OK == LddProcessStatus) { /* Report error to DET if timeout */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_SEND_SPEC_CONFIG_SID, FLS_E_TIMEOUT); } else { /* No action required */ } /* End of if (E_NOT_OK == LddProcessStatus) */ #endif /* End of #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && * (FLS_TIMEOUT_MONITORING == STD_ON)) */ return (LddProcessStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_TIMEOUT_MONITORING', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEND_SPEC_CONFIG_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': ''], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'DataAddressPtr', 'Value': ''], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '85'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '0'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'TimeOutValue', 'Value': '(uint32)FLS_READ_TIME'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'DataAddressPtr', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'SpecificConfigPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'DataAddressPtr', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_011': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': '85'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FLS_CODE_SLOW) Fls_Suspend(void) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Check if the module is initialized */ #if (FLS_DEV_ERROR_DETECT == STD_ON) if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_SUSPEND_SID, FLS_E_UNINIT); } else #endif /* FLS_DEV_ERROR_DETECT == STD_ON */ { /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif /* Check if the driver state is not Idle */ if (FLS_COMMAND_NONE != Fls_GstVarProperties.enCommand) { if (FLS_SUSPENDED != Fls_GstVarProperties.enBackUpJobStatus) { /* Set backup job status as suspended */ Fls_GstVarProperties.enBackUpJobStatus = FLS_SUSPENDED; /* Set job status as ok */ Fls_GstVarProperties.enJobStatus = FLS_OK; /* Set the back up command with previous command */ Fls_GstVarProperties.enBackUpCmd = Fls_GstVarProperties.enCommand; Fls_GstVarProperties.pBackUpVarAddress = Fls_GstVarProperties.pVarAddress; Fls_GstVarProperties.pBackUpContAddress = Fls_GstVarProperties.pContAddress; Fls_GstVarProperties.ulBackUpLength = Fls_GstVarProperties.ulLength; Fls_GstVarProperties.ulBackUpFlashAddress = Fls_GstVarProperties.ulFlashAddress; /* Set the command to none */ Fls_GstVarProperties.enCommand = FLS_COMMAND_NONE; /* Set the driver state to idle */ Fls_GenState = MEMIF_IDLE; /* Set the job Result to OK */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_OK; /* External space read mode is OFF */ #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_GstVarProperties.blExtSpaceRead = FLS_TRUE; #endif Fls_GstVarProperties.ddMainJobFlag = E_NOT_OK; } else { /* No action required */ } /* End of if (FLS_SUSPENDED != * Fls_GstVarProperties.enBackUpJobStatus) */ } else { /* No action required */ } /* End of Check if the driver state is not Idle */ /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif /* Release the semaphore/exclusive control */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) /* Check if the driver suspended */ if (FLS_SUSPENDED == Fls_GstVarProperties.enBackUpJobStatus) { (void)Fls_ReleaseControl(); } else { /* No action required */ } #endif } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SUSPEND_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_JOB_NOTIF_CONFIG', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpJobStatus', 'Value': 'FLS_OK'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': ''], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': ''], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'FLS_COMMAND_NONE/FLS_COMMAND_ERASE/FLS_COMMAND_WRITE/FLS_COMMAND_READ/FLS_COMMAND_BLANKCHECK', 'Name': 'enCommand', 'Value': 'FLS_COMMAND_ERASE'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'MEMIF_JOB_OK/MEMIF_JOB_FAILED/MEMIF_JOB_PENDING/MEMIF_JOB_CANCELED/MEMIF_BLOCK_INCONSISTENT/MEMIF_BLOCK_INVALID', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_PENDING'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GenState', 'Value': 'MEMIF_IDLE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': ''], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': ''], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '0'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '0'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': 'FLS_COMMAND_NONE'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '1'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'blExtSpaceRead', 'Value': '1'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_OK'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpJobStatus', 'Value': 'FLS_SUSPENDED'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pBackUpVarAddress', 'Value': ''], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pBackUpContAddress', 'Value': ''], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulBackUpLength', 'Value': '0'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulBackUpFlashAddress', 'Value': '0'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpCmd', 'Value': 'FLS_COMMAND_ERASE'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': 'FLS_OK'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_022': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_023': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_024': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FLS_CODE_SLOW) Fls_Suspend(void) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Check if the module is initialized */ #if (FLS_DEV_ERROR_DETECT == STD_ON) if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_SUSPEND_SID, FLS_E_UNINIT); } else #endif /* FLS_DEV_ERROR_DETECT == STD_ON */ { /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif /* Check if the driver state is not Idle */ if (FLS_COMMAND_NONE != Fls_GstVarProperties.enCommand) { if (FLS_SUSPENDED != Fls_GstVarProperties.enBackUpJobStatus) { /* Set backup job status as suspended */ Fls_GstVarProperties.enBackUpJobStatus = FLS_SUSPENDED; /* Set job status as ok */ Fls_GstVarProperties.enJobStatus = FLS_OK; /* Set the back up command with previous command */ Fls_GstVarProperties.enBackUpCmd = Fls_GstVarProperties.enCommand; Fls_GstVarProperties.pBackUpVarAddress = Fls_GstVarProperties.pVarAddress; Fls_GstVarProperties.pBackUpContAddress = Fls_GstVarProperties.pContAddress; Fls_GstVarProperties.ulBackUpLength = Fls_GstVarProperties.ulLength; Fls_GstVarProperties.ulBackUpFlashAddress = Fls_GstVarProperties.ulFlashAddress; /* Set the command to none */ Fls_GstVarProperties.enCommand = FLS_COMMAND_NONE; /* Set the driver state to idle */ Fls_GenState = MEMIF_IDLE; /* Set the job Result to OK */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_OK; /* External space read mode is OFF */ #if (FLS_EXTERNAL_SPACE_READ == STD_ON) Fls_GstVarProperties.blExtSpaceRead = FLS_TRUE; #endif Fls_GstVarProperties.ddMainJobFlag = E_NOT_OK; } else { /* No action required */ } /* End of if (FLS_SUSPENDED != * Fls_GstVarProperties.enBackUpJobStatus) */ } else { /* No action required */ } /* End of Check if the driver state is not Idle */ /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif /* Release the semaphore/exclusive control */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) /* Check if the driver suspended */ if (FLS_SUSPENDED == Fls_GstVarProperties.enBackUpJobStatus) { (void)Fls_ReleaseControl(); } else { /* No action required */ } #endif } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SUSPEND_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_JOB_NOTIF_CONFIG', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpJobStatus', 'Value': 'FLS_ERR_VERIFY_ERASE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': ''], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': ''], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'FLS_COMMAND_NONE/FLS_COMMAND_ERASE/FLS_COMMAND_WRITE/FLS_COMMAND_READ/FLS_COMMAND_BLANKCHECK', 'Name': 'enCommand', 'Value': 'FLS_COMMAND_COMPARE'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'MEMIF_JOB_OK/MEMIF_JOB_FAILED/MEMIF_JOB_PENDING/MEMIF_JOB_CANCELED/MEMIF_BLOCK_INCONSISTENT/MEMIF_BLOCK_INVALID', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_PENDING'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': 'E_OK/E_NOT_OK', 'Name': 'return', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GenState', 'Value': 'MEMIF_IDLE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pVarAddress', 'Value': ''], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': ''], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '0'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '0'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': 'FLS_COMMAND_NONE'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '1'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'blExtSpaceRead', 'Value': '1'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_OK'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpJobStatus', 'Value': 'FLS_SUSPENDED'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pBackUpVarAddress', 'Value': ''], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pBackUpContAddress', 'Value': ''], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulBackUpLength', 'Value': '0'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulBackUpFlashAddress', 'Value': '0'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'enBackUpCmd', 'Value': 'FLS_COMMAND_COMPARE'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': 'FLS_OK'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_022': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_023': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_024': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_VerifyEraseAddressAndLength /* PRQA S 1532 # JV-01 */ (const Fls_AddressType TargetAddress, const Fls_LengthType Length) { /* Local variable to hold the DET return value */ Std_ReturnType LddReturnValue; #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Declare the Start/End address of Erase sector */ uint32 LulEraseStartAddr; uint32 LulEraseEndAddr; /* Declare the Start/End address of DDR pattern */ uint32 LulDDRPatternStartAddr; uint32 LulDDRPatternEndAddr; #endif /* Declare the variable hold the sector start address of Flash device */ uint32 LulFlsEraseStartSector; /* Declare the variable to store index sector map */ uint32 LulIndexSectorMap; /* Declare the target address offset with start sector address */ uint32 LulOffsetAddress; /* Declare the minimal erase length */ uint32 LulUnitEraseLength; /* Declare the limit erase length */ uint32 LulFlsExpectedLength; /* Set default index sector map to zero */ LulIndexSectorMap = FLS_ZERO_LONG_WORD; /* Set default address of sector to zero */ LulFlsEraseStartSector = FLS_ZERO_LONG_WORD; /* Get index sector map based on target address */ LddReturnValue = Fls_GetIndexSectorMap(TargetAddress, &LulIndexSectorMap); if (E_NOT_OK == LddReturnValue) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_ERASE_SID, FLS_E_PARAM_ADDRESS); } else { /* Get address of the start sector */ LulFlsEraseStartSector = Fls_SectorMap[LulIndexSectorMap].ulSectorStartAddress; /* PRQA S 2844 # JV-01 */ /* Get size of the inspect sector */ Fls_GstVarProperties.ulSectorSize = Fls_SectorMap[LulIndexSectorMap].ulSectorSize; } /* End of if (E_NOT_OK == LddReturnValue) */ /*-------------------------------------------- SERIAL FLASH --------------------------------------------------------*/ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LulOffsetAddress = (uint32)TargetAddress - LulFlsEraseStartSector; /* PRQA S 3383 # JV-01 */ #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulUnitEraseLength = Fls_GstVarProperties.ulSectorSize * FLS_TWO_LONG_WORD; /* PRQA S 3384 # JV-01 */ LulFlsExpectedLength = ((uint32)FLS_TOTAL_SIZE + FLS_BASE_ADDRESS - TargetAddress) * FLS_TWO_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ #else LulUnitEraseLength = Fls_GstVarProperties.ulSectorSize; /* PRQA S 3383 # JV-01 */ LulFlsExpectedLength = (uint32)FLS_TOTAL_SIZE + FLS_BASE_ADDRESS - TargetAddress; /* PRQA S 3383 # JV-01 */ #endif /*----------------------------------------------- HYPER FLASH ------------------------------------------------------*/ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulOffsetAddress = ((uint32)TargetAddress - LulFlsEraseStartSector) * FLS_TWO_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ LulUnitEraseLength = Fls_GstVarProperties.ulSectorSize; LulFlsExpectedLength = ((uint32)FLS_TOTAL_SIZE - ((TargetAddress - FLS_BASE_ADDRESS) * FLS_TWO_LONG_WORD)); /* PRQA S 3383, 3384, 2985 # JV-01, JV-01, JV-01 */ #endif if (E_OK == LddReturnValue) { if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulSectorSize) { if (FLS_ZERO_LONG_WORD != (LulOffsetAddress % Fls_GstVarProperties.ulSectorSize)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_ERASE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { /* No action required */ } /* End of if (FLS_ZERO_LONG_WORD != (LulOffsetAddress * * Fls_GstVarProperties.ulSectorSize)) */ if ((FLS_ZERO_LONG_WORD != (Length % LulUnitEraseLength)) && (E_OK == LddReturnValue)) /* PRQA S 2834 # JV-01 */ { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_ERASE_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { /* No action required */ } /* End of checking the input length is consistency with sector size */ } else { /* No action required */ } /* End of if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulSectorSize) */ } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ if (((FLS_ZERO_LONG_WORD == Fls_GstVarProperties.ulSectorSize) || (FLS_ZERO_LONG_WORD == Length) || (Length > LulFlsExpectedLength)) && (E_OK == LddReturnValue)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_ERASE_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { /* No action required */ } /* End of if (((FLS_ZERO_LONG_WORD == Fls_GstVarProperties.ulSectorSize) || (FLS_ZERO_LONG_WORD == Length) || (Length > LulFlsExpectedLength)) && (E_OK == LddReturnValue)) */ #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* If Address and Length have no error */ if (E_OK == LddReturnValue) { /* Get the Start/End address of Erase sector */ LulEraseStartAddr = TargetAddress; LulEraseEndAddr = (TargetAddress + Length) - FLS_ONE_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ /* Get the Start/End address of DDR pattern */ LulDDRPatternStartAddr = FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress; /* PRQA S 2814, 2986, 3383, 3384 # JV-01, JV-01, JV-01, JV-01 */ LulDDRPatternEndAddr = (LulDDRPatternStartAddr + Fls_GstVarProperties.ulSectorSize) - FLS_ONE_LONG_WORD; /* PRQA S 2814, 2986, 3383, 3384 # JV-01, JV-01, JV-01, JV-01 */ /* Check if the Erase address not lies on DDR Pattern address */ if ((LulEraseEndAddr < LulDDRPatternStartAddr) || (LulEraseStartAddr > LulDDRPatternEndAddr)) { /* No action required */ } else { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_ERASE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } } else { /* No action required */ } /* End of if (E_OK == LddReturnValue) */ #endif /* #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'TargetAddress', 'Value': '0xFFFFFFFF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'Length', 'Value': '0x00000001'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Fls_SectorMap', 'Value': '&Fls_SectorMap[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0x0..0xFFFFFFFF', 'Name': 'ulSectorSize', 'Value': '0x00000001'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0x0..0xFFFFFFFF', 'Name': 'ulSectorStartAddress', 'Value': '0x00000000'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0x0..0xFFFFFFFF', 'Name': 'ulSectorSize', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pSfDdrPatternConfig', 'Value': '&map_pSfDdrPatternConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulPatternAddress', 'Value': '0'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': 'E_NOT_OK.. E_OK             ', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_013': ['Type': 'Output_Argument', 'Range': '', 'Name': '* ulIndexSectorMap', 'Value': '((uint32)0UL)']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulTargetAddress', 'Value': '0xFFFFFFFF'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulIndexSectorMap', 'Value': 'ulIndexSectorMap'], 'Output_Param_002': ['Type': 'Variable', 'Range': '-', 'Name': 'ulSectorSize', 'Value': '1'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '-', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_VerifyJobStatus(void) /* PRQA S 1532 # JV-01 */ { Std_ReturnType LddReturnValue; #if (FLS_JOB_NOTIF_CONFIG == STD_ON) Fls_JobStatusType LenJobStatus; LenJobStatus = Fls_GstVarProperties.enJobStatus; /* Call notification */ Fls_JobNotifications(LenJobStatus) /* PRQA S 2814 # JV-01 */ #endif /* End of #if (FLS_JOB_NOTIF_CONFIG == STD_ON) */ /* By default no issue found */ LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ if (MEMIF_JOB_PENDING == Fls_GstVarProperties.enJobResult) { /* Default status when a job completed is MEMIF_JOB_OK */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_OK; } else { /* No action required */ } /* Verify job status */ switch (Fls_GstVarProperties.enJobStatus) { /* Operation terminated successfully */ case FLS_OK: Fls_GstVarProperties.enJobResult = MEMIF_JOB_OK; LddReturnValue = E_OK; break; /* The compared data from a flash compare job are not equal. */ case FLS_ERR_INCONSISTENT: Fls_GstVarProperties.enJobResult = MEMIF_BLOCK_INCONSISTENT; LddReturnValue = E_NOT_OK; break; /* Flash write error */ case FLS_ERR_WRITE: /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; #if (FLS_TRANSIENT_FAULT_DETECT == STD_ON) (void)Det_ReportTransientFault(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_WRITE_FAILED); #endif LddReturnValue = E_NOT_OK; break; /* Flash erase error */ case FLS_ERR_ERASE: /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; #if (FLS_TRANSIENT_FAULT_DETECT == STD_ON) (void)Det_ReportTransientFault(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_ERASE_FAILED); #endif LddReturnValue = E_NOT_OK; break; /* Flash blank check error */ case FLS_ERR_BLANKCHECK: /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; LddReturnValue = E_NOT_OK; break; /* Operation is Time out */ case FLS_TIME_OUT: #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) \\ && (FLS_TIMEOUT_SUPERVISION_ENABLED == STD_ON)) /* Report timeout error to Det */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_TIMEOUT); #endif /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; LddReturnValue = E_NOT_OK; break; /* Flash compare erase area failed */ #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) #if (FLS_ERASE_VERIFICATION_ENABLED == STD_ON) case FLS_ERR_VERIFY_ERASE: /* Report error to Det */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_VERIFY_ERASE_FAILED); /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; LddReturnValue = E_NOT_OK; break; #endif /* End of #if (FLS_ERASE_VERIFICATION_ENABLED == STD_ON) */ #if (FLS_WRITE_VERIFICATION_ENABLED == STD_ON) /* Flash compare write area failed */ case FLS_ERR_VERIFY_WRITE: /* Report error to Det */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_VERIFY_WRITE_FAILED); /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; LddReturnValue = E_NOT_OK; break; #endif /* End of #if (FLS_WRITE_VERIFICATION_ENABLED == STD_ON) */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ /* Operation is still ongoing */ case FLS_BUSY: /* Flash operation is cancelled */ case FLS_CANCELLED: /* Flash operation is suspended */ case FLS_SUSPENDED: default: LddReturnValue = E_OK; break; } /* End of Verify job status*/ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_JOB_NOTIF_CONFIG', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_TIMEOUT_SUPERVISION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_ERASE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'FLS_OK/FLS_BUSY/FLS_ERR_WRITE/FLS_ERR_ERASE/FLS_ERR_BLANKCHECK/FLS_CANCELLED/FLS_TIME_OUT/FLS_ERR_VERIFY_ERASE/FLS_ERR_VERIFY_WRITE', 'Name': 'enJobStatus', 'Value': 'FLS_ERR_WRITE'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'MEMIF_JOB_OK/MEMIF_JOB_FAILED/MEMIF_JOB_PENDING/MEMIF_JOB_CANCELED/MEMIF_BLOCK_INCONSISTENT/MEMIF_BLOCK_INVALID', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_OK'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pJobEndNotificationPointer', 'Value': '&ISOLATE_void_func_ptr'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pJobErrorNotificationPointer', 'Value': '&ISOLATE_void_func_ptr']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Variable', 'Range': '-', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FLS_MODULE_ID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FLS_INSTANCE_ID'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FLS_MAINFUNCTION_SID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'FaultId', 'Value': 'FLS_E_WRITE_FAILED'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_VerifyJobStatus(void) /* PRQA S 1532 # JV-01 */ { Std_ReturnType LddReturnValue; #if (FLS_JOB_NOTIF_CONFIG == STD_ON) Fls_JobStatusType LenJobStatus; LenJobStatus = Fls_GstVarProperties.enJobStatus; /* Call notification */ Fls_JobNotifications(LenJobStatus) /* PRQA S 2814 # JV-01 */ #endif /* End of #if (FLS_JOB_NOTIF_CONFIG == STD_ON) */ /* By default no issue found */ LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ if (MEMIF_JOB_PENDING == Fls_GstVarProperties.enJobResult) { /* Default status when a job completed is MEMIF_JOB_OK */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_OK; } else { /* No action required */ } /* Verify job status */ switch (Fls_GstVarProperties.enJobStatus) { /* Operation terminated successfully */ case FLS_OK: Fls_GstVarProperties.enJobResult = MEMIF_JOB_OK; LddReturnValue = E_OK; break; /* The compared data from a flash compare job are not equal. */ case FLS_ERR_INCONSISTENT: Fls_GstVarProperties.enJobResult = MEMIF_BLOCK_INCONSISTENT; LddReturnValue = E_NOT_OK; break; /* Flash write error */ case FLS_ERR_WRITE: /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; #if (FLS_TRANSIENT_FAULT_DETECT == STD_ON) (void)Det_ReportTransientFault(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_WRITE_FAILED); #endif LddReturnValue = E_NOT_OK; break; /* Flash erase error */ case FLS_ERR_ERASE: /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; #if (FLS_TRANSIENT_FAULT_DETECT == STD_ON) (void)Det_ReportTransientFault(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_ERASE_FAILED); #endif LddReturnValue = E_NOT_OK; break; /* Flash blank check error */ case FLS_ERR_BLANKCHECK: /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; LddReturnValue = E_NOT_OK; break; /* Operation is Time out */ case FLS_TIME_OUT: #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) \\ && (FLS_TIMEOUT_SUPERVISION_ENABLED == STD_ON)) /* Report timeout error to Det */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_TIMEOUT); #endif /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; LddReturnValue = E_NOT_OK; break; /* Flash compare erase area failed */ #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) #if (FLS_ERASE_VERIFICATION_ENABLED == STD_ON) case FLS_ERR_VERIFY_ERASE: /* Report error to Det */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_VERIFY_ERASE_FAILED); /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; LddReturnValue = E_NOT_OK; break; #endif /* End of #if (FLS_ERASE_VERIFICATION_ENABLED == STD_ON) */ #if (FLS_WRITE_VERIFICATION_ENABLED == STD_ON) /* Flash compare write area failed */ case FLS_ERR_VERIFY_WRITE: /* Report error to Det */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_VERIFY_WRITE_FAILED); /* Set the job result to Job failed */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_FAILED; LddReturnValue = E_NOT_OK; break; #endif /* End of #if (FLS_WRITE_VERIFICATION_ENABLED == STD_ON) */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ /* Operation is still ongoing */ case FLS_BUSY: /* Flash operation is cancelled */ case FLS_CANCELLED: /* Flash operation is suspended */ case FLS_SUSPENDED: default: LddReturnValue = E_OK; break; } /* End of Verify job status*/ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_JOB_NOTIF_CONFIG', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_TIMEOUT_SUPERVISION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_ERASE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'FLS_OK/FLS_BUSY/FLS_ERR_WRITE/FLS_ERR_ERASE/FLS_ERR_BLANKCHECK/FLS_CANCELLED/FLS_TIME_OUT/FLS_ERR_VERIFY_ERASE/FLS_ERR_VERIFY_WRITE', 'Name': 'enJobStatus', 'Value': 'FLS_ERR_VERIFY_WRITE'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'MEMIF_JOB_OK/MEMIF_JOB_FAILED/MEMIF_JOB_PENDING/MEMIF_JOB_CANCELED/MEMIF_BLOCK_INCONSISTENT/MEMIF_BLOCK_INVALID', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_OK'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pJobEndNotificationPointer', 'Value': '&ISOLATE_void_func_ptr'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pJobErrorNotificationPointer', 'Value': '&ISOLATE_void_func_ptr']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Variable', 'Range': '-', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FLS_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FLS_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FLS_MAINFUNCTION_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FLS_E_VERIFY_WRITE_FAILED'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'FaultId', 'Value': '-'], 'Output_Param_010': ['Type': 'Return_Value', 'Range': 'E_OK\\nE_NOT_OK', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_Write /* PRQA S 1503, 1532 # JV-01, JV-01 */ (Fls_AddressType TargetAddress, P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) SourceAddressPtr, Fls_LengthType Length) /* PRQA S 3432 # JV-01 */ { #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the compare value */ uint32 LulFlsMaxLength; uint32 LulFlsLimitAddress; #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Declare Start/End address of Write sector*/ uint32 LulWriteStartAddr; uint32 LulWriteEndAddr; /* Declare Start/End address of DDR pattern*/ uint32 LulDDRPatternStartAddr; uint32 LulDDRPatternEndAddr; #endif /* End of #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GetControlResultType LddGetControlResult; #endif /* Local variable to hold the DET return value */ Std_ReturnType LddReturnValue; Fls_AddressType LddTargetAddress; /* Set default value for return variable */ LddReturnValue = E_OK; /* Get the write start address */ LddTargetAddress = TargetAddress + FLS_BASE_ADDRESS; /* PRQA S 2985, 3383 # JV-01, JV-01 */ #if (FLS_DEV_ERROR_DETECT == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LulFlsLimitAddress = (FLS_BASE_ADDRESS + FLS_TOTAL_SIZE) - FLS_ONE_LONG_WORD; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulFlsMaxLength = (uint32)(FLS_TOTAL_SIZE - TargetAddress) * FLS_TWO_LONG_WORD; /* PRQA S 3384, 3383 # JV-01, JV-01 */ #else LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - TargetAddress; /* PRQA S 3383 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulFlsLimitAddress = FLS_BASE_ADDRESS + (FLS_TOTAL_SIZE / FLS_TWO_LONG_WORD) - FLS_ONE_LONG_WORD; LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - (TargetAddress * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_UNINIT); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) /* Check if the driver is busy by servicing another request */ else if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET if the driver is currently busy */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) */ /* Check whether the application buffer is a null pointer */ else if (NULL_PTR == SourceAddressPtr) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_DATA); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Check if the write start address is aligned to a flash page boundary * and lies within the specified lower and upper flash address * boundaries. */ else if (LulFlsLimitAddress < LddTargetAddress) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else if ((FLS_ZERO_LONG_WORD == Length) || (LulFlsMaxLength < Length)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Get the Start/End address of Write function */ LulWriteStartAddr = LddTargetAddress; LulWriteEndAddr = (LddTargetAddress + Length) - FLS_ONE_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ /* Get the Start/End address of DDR partern */ LulDDRPatternStartAddr = FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress; /* PRQA S 2814, 3383, 3384, 2986 # JV-01, JV-01, JV-01, JV-01 */ LulDDRPatternEndAddr = (LulDDRPatternStartAddr + Fls_GstVarProperties.ulSectorSize) - FLS_ONE_LONG_WORD; /* PRQA S 2814, 3383, 3384, 2986 # JV-01, JV-01, JV-01, JV-01 */ /* Check if the Write address not lies on DDR Pattern address */ if ((LulWriteEndAddr < LulDDRPatternStartAddr) || (LulWriteStartAddr > LulDDRPatternEndAddr)) { /* No action required */ } else { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) /* Check if the driver is busy by servicing another request */ if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET Runtime if the driver is currently busy */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) */ /* Check whether any error is reported to DET */ if (E_OK == LddReturnValue) { /* Check status of get exclusive control/get semaphore * with critical section */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) LddGetControlResult = Fls_GetControl(); /* If get exclusive or get semaphore are successfully */ if (FLS_GOT_NOTHING != LddGetControlResult) { #endif /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif Fls_GstVarProperties.ulFlashAddress = LddTargetAddress; /* Set the global variables with length */ Fls_GstVarProperties.ulLength = Length; /* Set the global variable with application buffer pointer */ Fls_GstVarProperties.pContAddress = SourceAddressPtr; Fls_GstVarProperties.enJobStatus = FLS_BUSY; /* Set the job result to Job pending */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_PENDING; /* Set the command as write command */ Fls_GstVarProperties.enCommand = FLS_COMMAND_WRITE; /* Set the driver state as Busy */ Fls_GenState = MEMIF_BUSY; Fls_GstVarProperties.ddMainJobFlag = E_OK; /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) } else { LddReturnValue = E_NOT_OK; } /* End of if (FLS_GOT_NOTHING != LddGetControlResult) */ #endif } /* else No action required */ /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BASE_ADDRESS_ZERO', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'Length', 'Value': '7'], 'Input_Param_008': ['Type': 'Argument', 'Range': 'NULL_PTR \u2026 Address', 'Name': 'SourceAddressPtr', 'Value': '&map_SourceAddressPtr[0]'], 'Input_Param_009': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'TargetAddress', 'Value': '0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0x0..0xFFFFFFFF', 'Name': 'map_SourceAddressPtr[0]', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'pSfDdrPatternConfig', 'Value': '&map_pSfDdrPatternConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulPatternAddress', 'Value': '0x00000005'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'ulNumberOfPattern', 'Value': '0x00000001'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorSize', 'Value': '-'], 'Input_Param_019': ['Type': 'Return_Value_of', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FLS_MODULE_ID'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FLS_INSTANCE_ID'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FLS_WRITE_SID'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FLS_E_PARAM_ADDRESS'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_021': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_Write /* PRQA S 1503, 1532 # JV-01, JV-01 */ (Fls_AddressType TargetAddress, P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) SourceAddressPtr, Fls_LengthType Length) /* PRQA S 3432 # JV-01 */ { #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the compare value */ uint32 LulFlsMaxLength; uint32 LulFlsLimitAddress; #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Declare Start/End address of Write sector*/ uint32 LulWriteStartAddr; uint32 LulWriteEndAddr; /* Declare Start/End address of DDR pattern*/ uint32 LulDDRPatternStartAddr; uint32 LulDDRPatternEndAddr; #endif /* End of #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GetControlResultType LddGetControlResult; #endif /* Local variable to hold the DET return value */ Std_ReturnType LddReturnValue; Fls_AddressType LddTargetAddress; /* Set default value for return variable */ LddReturnValue = E_OK; /* Get the write start address */ LddTargetAddress = TargetAddress + FLS_BASE_ADDRESS; /* PRQA S 2985, 3383 # JV-01, JV-01 */ #if (FLS_DEV_ERROR_DETECT == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LulFlsLimitAddress = (FLS_BASE_ADDRESS + FLS_TOTAL_SIZE) - FLS_ONE_LONG_WORD; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulFlsMaxLength = (uint32)(FLS_TOTAL_SIZE - TargetAddress) * FLS_TWO_LONG_WORD; /* PRQA S 3384, 3383 # JV-01, JV-01 */ #else LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - TargetAddress; /* PRQA S 3383 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulFlsLimitAddress = FLS_BASE_ADDRESS + (FLS_TOTAL_SIZE / FLS_TWO_LONG_WORD) - FLS_ONE_LONG_WORD; LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - (TargetAddress * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_UNINIT); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) /* Check if the driver is busy by servicing another request */ else if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET if the driver is currently busy */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) */ /* Check whether the application buffer is a null pointer */ else if (NULL_PTR == SourceAddressPtr) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_DATA); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Check if the write start address is aligned to a flash page boundary * and lies within the specified lower and upper flash address * boundaries. */ else if (LulFlsLimitAddress < LddTargetAddress) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else if ((FLS_ZERO_LONG_WORD == Length) || (LulFlsMaxLength < Length)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Get the Start/End address of Write function */ LulWriteStartAddr = LddTargetAddress; LulWriteEndAddr = (LddTargetAddress + Length) - FLS_ONE_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ /* Get the Start/End address of DDR partern */ LulDDRPatternStartAddr = FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress; /* PRQA S 2814, 3383, 3384, 2986 # JV-01, JV-01, JV-01, JV-01 */ LulDDRPatternEndAddr = (LulDDRPatternStartAddr + Fls_GstVarProperties.ulSectorSize) - FLS_ONE_LONG_WORD; /* PRQA S 2814, 3383, 3384, 2986 # JV-01, JV-01, JV-01, JV-01 */ /* Check if the Write address not lies on DDR Pattern address */ if ((LulWriteEndAddr < LulDDRPatternStartAddr) || (LulWriteStartAddr > LulDDRPatternEndAddr)) { /* No action required */ } else { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) /* Check if the driver is busy by servicing another request */ if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET Runtime if the driver is currently busy */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) */ /* Check whether any error is reported to DET */ if (E_OK == LddReturnValue) { /* Check status of get exclusive control/get semaphore * with critical section */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) LddGetControlResult = Fls_GetControl(); /* If get exclusive or get semaphore are successfully */ if (FLS_GOT_NOTHING != LddGetControlResult) { #endif /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif Fls_GstVarProperties.ulFlashAddress = LddTargetAddress; /* Set the global variables with length */ Fls_GstVarProperties.ulLength = Length; /* Set the global variable with application buffer pointer */ Fls_GstVarProperties.pContAddress = SourceAddressPtr; Fls_GstVarProperties.enJobStatus = FLS_BUSY; /* Set the job result to Job pending */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_PENDING; /* Set the command as write command */ Fls_GstVarProperties.enCommand = FLS_COMMAND_WRITE; /* Set the driver state as Busy */ Fls_GenState = MEMIF_BUSY; Fls_GstVarProperties.ddMainJobFlag = E_OK; /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) } else { LddReturnValue = E_NOT_OK; } /* End of if (FLS_GOT_NOTHING != LddGetControlResult) */ #endif } /* else No action required */ /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BASE_ADDRESS_ZERO', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'Length', 'Value': '1'], 'Input_Param_008': ['Type': 'Argument', 'Range': 'NULL_PTR \u2026 Address', 'Name': 'SourceAddressPtr', 'Value': '&map_SourceAddressPtr[0]'], 'Input_Param_009': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'TargetAddress', 'Value': '0x00000004'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0x0..0xFFFFFFFF', 'Name': 'map_SourceAddressPtr[0]', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'pSfDdrPatternConfig', 'Value': '&map_pSfDdrPatternConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulPatternAddress', 'Value': '0x00000000'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'ulNumberOfPattern', 'Value': '0x00000001'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorSize', 'Value': '0x00000004'], 'Input_Param_019': ['Type': 'Return_Value_of', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'return', 'Value': 'FLS_GOT_SEMAPHORE']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_BUSY'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '0x00000004'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '1'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '&map_SourceAddressPtr[0]'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': 'FLS_BUSY'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': 'MEMIF_JOB_PENDING'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': 'FLS_COMMAND_WRITE'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': 'E_OK'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_021': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_Write /* PRQA S 1503, 1532 # JV-01, JV-01 */ (Fls_AddressType TargetAddress, P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) SourceAddressPtr, Fls_LengthType Length) /* PRQA S 3432 # JV-01 */ { #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the compare value */ uint32 LulFlsMaxLength; uint32 LulFlsLimitAddress; #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Declare Start/End address of Write sector*/ uint32 LulWriteStartAddr; uint32 LulWriteEndAddr; /* Declare Start/End address of DDR pattern*/ uint32 LulDDRPatternStartAddr; uint32 LulDDRPatternEndAddr; #endif /* End of #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GetControlResultType LddGetControlResult; #endif /* Local variable to hold the DET return value */ Std_ReturnType LddReturnValue; Fls_AddressType LddTargetAddress; /* Set default value for return variable */ LddReturnValue = E_OK; /* Get the write start address */ LddTargetAddress = TargetAddress + FLS_BASE_ADDRESS; /* PRQA S 2985, 3383 # JV-01, JV-01 */ #if (FLS_DEV_ERROR_DETECT == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LulFlsLimitAddress = (FLS_BASE_ADDRESS + FLS_TOTAL_SIZE) - FLS_ONE_LONG_WORD; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulFlsMaxLength = (uint32)(FLS_TOTAL_SIZE - TargetAddress) * FLS_TWO_LONG_WORD; /* PRQA S 3384, 3383 # JV-01, JV-01 */ #else LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - TargetAddress; /* PRQA S 3383 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulFlsLimitAddress = FLS_BASE_ADDRESS + (FLS_TOTAL_SIZE / FLS_TWO_LONG_WORD) - FLS_ONE_LONG_WORD; LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - (TargetAddress * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_UNINIT); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) /* Check if the driver is busy by servicing another request */ else if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET if the driver is currently busy */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) */ /* Check whether the application buffer is a null pointer */ else if (NULL_PTR == SourceAddressPtr) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_DATA); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Check if the write start address is aligned to a flash page boundary * and lies within the specified lower and upper flash address * boundaries. */ else if (LulFlsLimitAddress < LddTargetAddress) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else if ((FLS_ZERO_LONG_WORD == Length) || (LulFlsMaxLength < Length)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Get the Start/End address of Write function */ LulWriteStartAddr = LddTargetAddress; LulWriteEndAddr = (LddTargetAddress + Length) - FLS_ONE_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ /* Get the Start/End address of DDR partern */ LulDDRPatternStartAddr = FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress; /* PRQA S 2814, 3383, 3384, 2986 # JV-01, JV-01, JV-01, JV-01 */ LulDDRPatternEndAddr = (LulDDRPatternStartAddr + Fls_GstVarProperties.ulSectorSize) - FLS_ONE_LONG_WORD; /* PRQA S 2814, 3383, 3384, 2986 # JV-01, JV-01, JV-01, JV-01 */ /* Check if the Write address not lies on DDR Pattern address */ if ((LulWriteEndAddr < LulDDRPatternStartAddr) || (LulWriteStartAddr > LulDDRPatternEndAddr)) { /* No action required */ } else { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) /* Check if the driver is busy by servicing another request */ if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET Runtime if the driver is currently busy */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) */ /* Check whether any error is reported to DET */ if (E_OK == LddReturnValue) { /* Check status of get exclusive control/get semaphore * with critical section */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) LddGetControlResult = Fls_GetControl(); /* If get exclusive or get semaphore are successfully */ if (FLS_GOT_NOTHING != LddGetControlResult) { #endif /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif Fls_GstVarProperties.ulFlashAddress = LddTargetAddress; /* Set the global variables with length */ Fls_GstVarProperties.ulLength = Length; /* Set the global variable with application buffer pointer */ Fls_GstVarProperties.pContAddress = SourceAddressPtr; Fls_GstVarProperties.enJobStatus = FLS_BUSY; /* Set the job result to Job pending */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_PENDING; /* Set the command as write command */ Fls_GstVarProperties.enCommand = FLS_COMMAND_WRITE; /* Set the driver state as Busy */ Fls_GenState = MEMIF_BUSY; Fls_GstVarProperties.ddMainJobFlag = E_OK; /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) } else { LddReturnValue = E_NOT_OK; } /* End of if (FLS_GOT_NOTHING != LddGetControlResult) */ #endif } /* else No action required */ /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BASE_ADDRESS_ZERO', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'Length', 'Value': '0xFFFFFFFF'], 'Input_Param_008': ['Type': 'Argument', 'Range': 'NULL_PTR \u2026 Address', 'Name': 'SourceAddressPtr', 'Value': '&map_SourceAddressPtr[0]'], 'Input_Param_009': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'TargetAddress', 'Value': '67108863'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0x0..0xFFFFFFFF', 'Name': 'map_SourceAddressPtr[0]', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'pSfDdrPatternConfig', 'Value': '&map_pSfDdrPatternConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulPatternAddress', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'ulNumberOfPattern', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorSize', 'Value': '-'], 'Input_Param_019': ['Type': 'Return_Value_of', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FLS_MODULE_ID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FLS_INSTANCE_ID'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FLS_WRITE_SID'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FLS_E_PARAM_LENGTH'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_021': ['Type': '', 'Range': '', 'Name': '', 'Value': 'V4H Added']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_Write /* PRQA S 1503, 1532 # JV-01, JV-01 */ (Fls_AddressType TargetAddress, P2CONST(uint8, AUTOMATIC, FLS_APPL_CONST) SourceAddressPtr, Fls_LengthType Length) /* PRQA S 3432 # JV-01 */ { #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Local variable to hold the compare value */ uint32 LulFlsMaxLength; uint32 LulFlsLimitAddress; #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Declare Start/End address of Write sector*/ uint32 LulWriteStartAddr; uint32 LulWriteEndAddr; /* Declare Start/End address of DDR pattern*/ uint32 LulDDRPatternStartAddr; uint32 LulDDRPatternEndAddr; #endif /* End of #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) Fls_GetControlResultType LddGetControlResult; #endif /* Local variable to hold the DET return value */ Std_ReturnType LddReturnValue; Fls_AddressType LddTargetAddress; /* Set default value for return variable */ LddReturnValue = E_OK; /* Get the write start address */ LddTargetAddress = TargetAddress + FLS_BASE_ADDRESS; /* PRQA S 2985, 3383 # JV-01, JV-01 */ #if (FLS_DEV_ERROR_DETECT == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LulFlsLimitAddress = (FLS_BASE_ADDRESS + FLS_TOTAL_SIZE) - FLS_ONE_LONG_WORD; #if (FLS_PIN_GROUP == FLS_QSPI0_QSPI1_PIN_GROUP) LulFlsMaxLength = (uint32)(FLS_TOTAL_SIZE - TargetAddress) * FLS_TWO_LONG_WORD; /* PRQA S 3384, 3383 # JV-01, JV-01 */ #else LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - TargetAddress; /* PRQA S 3383 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulFlsLimitAddress = FLS_BASE_ADDRESS + (FLS_TOTAL_SIZE / FLS_TWO_LONG_WORD) - FLS_ONE_LONG_WORD; LulFlsMaxLength = (uint32)FLS_TOTAL_SIZE - (TargetAddress * FLS_TWO_LONG_WORD); /* PRQA S 3383 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FLS_UNINITIALIZED == Fls_GenInitStatus) { /* Report error to DET that module is not initialized */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_UNINIT); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) /* Check if the driver is busy by servicing another request */ else if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET if the driver is currently busy */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R19_11_VERSION) */ /* Check whether the application buffer is a null pointer */ else if (NULL_PTR == SourceAddressPtr) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_DATA); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Check if the write start address is aligned to a flash page boundary * and lies within the specified lower and upper flash address * boundaries. */ else if (LulFlsLimitAddress < LddTargetAddress) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else if ((FLS_ZERO_LONG_WORD == Length) || (LulFlsMaxLength < Length)) { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_LENGTH); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } else { #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) /* Get the Start/End address of Write function */ LulWriteStartAddr = LddTargetAddress; LulWriteEndAddr = (LddTargetAddress + Length) - FLS_ONE_LONG_WORD; /* PRQA S 3383, 3384 # JV-01, JV-01 */ /* Get the Start/End address of DDR partern */ LulDDRPatternStartAddr = FLS_BASE_ADDRESS + Fls_GpConfigPtr->pSfConfig->pSfDdrPatternConfig->ulPatternAddress; /* PRQA S 2814, 3383, 3384, 2986 # JV-01, JV-01, JV-01, JV-01 */ LulDDRPatternEndAddr = (LulDDRPatternStartAddr + Fls_GstVarProperties.ulSectorSize) - FLS_ONE_LONG_WORD; /* PRQA S 2814, 3383, 3384, 2986 # JV-01, JV-01, JV-01, JV-01 */ /* Check if the Write address not lies on DDR Pattern address */ if ((LulWriteEndAddr < LulDDRPatternStartAddr) || (LulWriteStartAddr > LulDDRPatternEndAddr)) { /* No action required */ } else { /* Report error to DET */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_PARAM_ADDRESS); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } #endif /* End of #if ((FLS_DDR_CALIB_FEATURE == STD_ON) \\ && (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE)) */ } /* End of if (FLS_UNINITIALIZED == Fls_GenInitStatus) */ #endif /* End of #if (FLS_DEV_ERROR_DETECT == STD_ON) */ #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) /* Check if the driver is busy by servicing another request */ if ((MEMIF_BUSY == Fls_GenState) || (MEMIF_BUSY_INTERNAL == Fls_GenState)) { /* Report to DET Runtime if the driver is currently busy */ (void)Det_ReportRuntimeError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_WRITE_SID, FLS_E_BUSY); /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) */ #endif /* End of #if (FLS_AR_VERSION == FLS_AR_R22_11_VERSION) */ /* Check whether any error is reported to DET */ if (E_OK == LddReturnValue) { /* Check status of get exclusive control/get semaphore * with critical section */ #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) LddGetControlResult = Fls_GetControl(); /* If get exclusive or get semaphore are successfully */ if (FLS_GOT_NOTHING != LddGetControlResult) { #endif /* Enter critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_ENTER_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif Fls_GstVarProperties.ulFlashAddress = LddTargetAddress; /* Set the global variables with length */ Fls_GstVarProperties.ulLength = Length; /* Set the global variable with application buffer pointer */ Fls_GstVarProperties.pContAddress = SourceAddressPtr; Fls_GstVarProperties.enJobStatus = FLS_BUSY; /* Set the job result to Job pending */ Fls_GstVarProperties.enJobResult = MEMIF_JOB_PENDING; /* Set the command as write command */ Fls_GstVarProperties.enCommand = FLS_COMMAND_WRITE; /* Set the driver state as Busy */ Fls_GenState = MEMIF_BUSY; Fls_GstVarProperties.ddMainJobFlag = E_OK; /* Exit critical section */ #if (FLS_CRITICAL_SECTION_PROTECTION == STD_ON) FLS_EXIT_CRITICAL_SECTION(FLS_RAM_DATA_PROTECTION); #endif #if ((FLS_EXCLUSIVE_CONTROL == STD_ON) || (FLS_SEMAPHORE == STD_ON)) } else { LddReturnValue = E_NOT_OK; } /* End of if (FLS_GOT_NOTHING != LddGetControlResult) */ #endif } /* else No action required */ /* End of if (E_OK == LddReturnValue) */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_SEMAPHORE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_BASE_ADDRESS_ZERO', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_PIN_GROUP'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'Length', 'Value': '7'], 'Input_Param_008': ['Type': 'Argument', 'Range': 'NULL_PTR \u2026 Address', 'Name': 'SourceAddressPtr', 'Value': '&map_SourceAddressPtr[0]'], 'Input_Param_009': ['Type': 'Argument', 'Range': '0x0..0xFFFFFFFF', 'Name': 'TargetAddress', 'Value': '0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0x0..0xFFFFFFFF', 'Name': 'map_SourceAddressPtr[0]', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FLS_UNINITIALIZED\\nFLS_INITIALIZED', 'Name': 'Fls_GenInitStatus', 'Value': 'FLS_INITIALIZED'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': 'MEMIF_UNINIT'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'pSfConfig', 'Value': '&map_pSfConfig[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'pSfDdrPatternConfig', 'Value': '&map_pSfDdrPatternConfig[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulPatternAddress', 'Value': '0x00000005'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'ulNumberOfPattern', 'Value': '0x00000001'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulSectorSize', 'Value': '-'], 'Input_Param_019': ['Type': 'Return_Value_of', 'Range': 'FLS_GOT_NOTHING\\nFLS_GOT_SEMAPHORE\\nFLS_GOT_EXCLUSIVE\\nFLS_GOT_SEMAPHORE_EXCLUSIVE', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'MEMIF_UNINIT\\nMEMIF_IDLE\\nMEMIF_BUSY\\nMEMIF_BUSY_INTERNAL', 'Name': 'Fls_GenState', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'enJobResult', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enCommand', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ddMainJobFlag', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FLS_MODULE_ID'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FLS_INSTANCE_ID'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FLS_WRITE_SID'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FLS_E_PARAM_ADDRESS'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_021': ['Type': '', 'Range': '', 'Name': '', 'Value': 'V4H Added']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_WriteJobHandler(void) { uint32 LulMaxWriteLength; Fls_StatusRegType LenWriteStatus; #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ ((FLS_WRITE_VERIFICATION_ENABLED == STD_ON) || \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON))) Fls_CompareStatusType LenProcessStatus; #endif uint32 LulFlashAddress; uint32 LulOffsetPageBufferLength; Fls_LengthType LddMaxBytesToWrite; Fls_LengthType LddLength; P2CONST(uint32, AUTOMATIC, FLS_APPL_CONST) LpContAddress; /* PRQA S 3432 # JV-01 */ Std_ReturnType LddReturnValue; /* Default state of Writing Job: is not finished */ LddReturnValue = E_NOT_OK; /* If length still valid */ if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) { LddMaxBytesToWrite = Fls_GpConfigPtr->ulFlsMaxWriteBytes; /* PRQA S 2814 # JV-01 */ LddLength = Fls_GstVarProperties.ulLength; /* Collect maximum length of flash used to write */ LulMaxWriteLength = FLS_GET_MIN_NUMBER(LddMaxBytesToWrite, LddLength); /* PRQA S 3469 # JV-01 */ #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) /* Before writing a flash block, the function Fls_MainFunction shall compare * the contents of the addressed memory area against the value of an erased * flash cell to check that the block has been completely erased. */ /*-------------------------- SERIAL FLASH ------------------------------------------------------------------------*/ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenProcessStatus = Fls_SfVerifyEraseArea(LulMaxWriteLength); /*-------------------------- HYPER FLASH -------------------------------------------------------------------------*/ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenProcessStatus = Fls_HfVerifyEraseArea(LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ switch (LenProcessStatus) { /* Flash cell is not erased */ case FLS_INCONSISTENT: Fls_GstVarProperties.enJobStatus = FLS_ERR_VERIFY_ERASE; /* End this job */ LddReturnValue = E_OK; break; /* Flash cell has been erased */ case FLS_CONSISTENT: break; /* Blank check timeout */ case FLS_COMPARE_TIMEOUT: /* End this job */ LddReturnValue = E_OK; Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; default: /* No action required */ break; } /* End of switch (LenProcessStatus) */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ * (FLS_ERASE_VERIFICATION_ENABLED == STD_ON) */ /* If job still on-going */ if (E_NOT_OK == LddReturnValue) /* PRQA S 2995, 2991 # JV-01, JV-01 */ { /*------------------------ WRITE BUFFER ------------------------------------------------------------------------*/ LulFlashAddress = Fls_GstVarProperties.ulFlashAddress; LpContAddress = (P2CONST(uint32, AUTOMATIC, FLS_APPL_CONST)) Fls_GstVarProperties.pContAddress; /* PRQA S 3432, 3305, 0310 # JV-01, JV-01, JV-01 */ /* Check if next block overlaps page boundary */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) LulOffsetPageBufferLength = (uint32)(FLS_PAGE_BUFFER_WRAP_VALUE - (LulFlashAddress % FLS_PAGE_BUFFER_WRAP_VALUE));/* PRQA S 3383 # JV-01 */ if ((FLS_ZERO != ((LulFlashAddress + LulMaxWriteLength) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * ((LulFlashAddress + LulMaxWriteLength) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #else /* In case Dual Flash */ LulOffsetPageBufferLength = (uint32)(FLS_TWO * (FLS_PAGE_BUFFER_WRAP_VALUE /* PRQA S 3384 # JV-01 */ - (LulFlashAddress % FLS_PAGE_BUFFER_WRAP_VALUE))); /* PRQA S 3383, 3384 # JV-01, JV-01 */ if ((FLS_ZERO != ((LulFlashAddress + (LulMaxWriteLength / FLS_TWO)) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * ((LulFlashAddress + (LulMaxWriteLength / FLS_TWO)) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #endif /* End of (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulOffsetPageBufferLength = (uint32)(FLS_PAGE_BUFFER_WRAP_VALUE - ((LulFlashAddress * FLS_TWO) % FLS_PAGE_BUFFER_WRAP_VALUE)); /* PRQA S 3383 # JV-01 */ if ((FLS_ZERO != (((LulFlashAddress * FLS_TWO) + LulMaxWriteLength) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * (((LulFlashAddress * FLS_TWO) + LulMaxWriteLength) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #if (FLS_WRITE_BUFFER == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenWriteStatus = Fls_SfPPWithBuffer(LulFlashAddress, LpContAddress, LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenWriteStatus = Fls_HfPPWithBuffer(LulFlashAddress, LpContAddress, LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ /*------------------------ WRITE NORMAL --------------------------------*/ #else #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenWriteStatus = Fls_SfPPNormal (LulFlashAddress, LpContAddress, LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenWriteStatus = Fls_HfPPNormal (LulFlashAddress, LpContAddress, LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_WRITE_BUFFER == STD_ON) */ /*----------------------- Check, If job has any errors -----------------*/ if (FLS_STT_FREE != LenWriteStatus) { /* End this job */ LddReturnValue = E_OK; /* Verify errors and report */ switch (LenWriteStatus) { /* Verify is timeout */ case FLS_STT_TIMEOUT: Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; /* Hardware error */ case FLS_STT_ERROR: Fls_GstVarProperties.enJobStatus = FLS_ERR_WRITE; break; case FLS_ERR_NG: #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Report error to Det */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_PARAM_DATA); #endif break; default: /* NOT REACHED */ break; } /* End of switch (LenWriteStatus) */ } else { #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_WRITE_VERIFICATION_ENABLED == STD_ON)) /* After writing a flash block, the function Fls_MainFunction shall * compare the contents of the reprogrammed memory area against the * contents of the provided application buffer to check that the block * has been completely reprogrammed. */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenProcessStatus = Fls_SfVerifyWriteValue(LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenProcessStatus = Fls_HfVerifyWriteValue(LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ switch (LenProcessStatus) { /* Flash cell is not written */ case FLS_INCONSISTENT: Fls_GstVarProperties.enJobStatus = FLS_ERR_VERIFY_WRITE; /* End this job */ LddReturnValue = E_OK; break; /* Verify is timeout */ case FLS_COMPARE_TIMEOUT: Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; /* End this job */ LddReturnValue = E_OK; break; /* Flash cell has been written */ case FLS_CONSISTENT: default: /* Report status */ Fls_GstVarProperties.enJobStatus = FLS_OK; break; } /* End of switch (LenProcessStatus) */ #else /* Report status */ Fls_GstVarProperties.enJobStatus = FLS_OK; #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ * (FLS_WRITE_VERIFICATION_ENABLED == STD_ON)) */ } /* End of if (FLS_STT_FREE != LenWriteStatus) */ } else { /* No action required */ } /* End of if (E_NOT_OK == LddReturnValue) */ /* If job still on-going */ if (E_NOT_OK == LddReturnValue) { Fls_GstVarProperties.ulLength -= LulMaxWriteLength; /* PRQA S 3384 # JV-01 */ Fls_GstVarProperties.pContAddress += LulMaxWriteLength; /* PRQA S 0488 # JV-01 */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_GstVarProperties.ulFlashAddress += LulMaxWriteLength; /* PRQA S 3384 # JV-01 */ #else Fls_GstVarProperties.ulFlashAddress += (uint32)(LulMaxWriteLength / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) Fls_GstVarProperties.ulFlashAddress += (uint32)(LulMaxWriteLength / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ } else { /* No action required */ } /* End of if (E_NOT_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) */ /* If length not valid */ if (FLS_ZERO_LONG_WORD == Fls_GstVarProperties.ulLength) { /* Job has been finished */ LddReturnValue = E_OK; } else { /* No action required */ } /* End of If job not completed */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulLength', 'Value': '496'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlashAddress', 'Value': '8'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlsMaxWriteBytes', 'Value': '1024'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FLS_CONSISTENT'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': '-'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': 'FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': 'FLS_STT_FREE'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': 'FLS_CONSISTENT']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': '496'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': 'FLS_OK'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '0'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '0x01F0'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '0x100'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': '0x08'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': '0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '496'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': '496'], 'Output_Param_024': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_WriteJobHandler(void) { uint32 LulMaxWriteLength; Fls_StatusRegType LenWriteStatus; #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ ((FLS_WRITE_VERIFICATION_ENABLED == STD_ON) || \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON))) Fls_CompareStatusType LenProcessStatus; #endif uint32 LulFlashAddress; uint32 LulOffsetPageBufferLength; Fls_LengthType LddMaxBytesToWrite; Fls_LengthType LddLength; P2CONST(uint32, AUTOMATIC, FLS_APPL_CONST) LpContAddress; /* PRQA S 3432 # JV-01 */ Std_ReturnType LddReturnValue; /* Default state of Writing Job: is not finished */ LddReturnValue = E_NOT_OK; /* If length still valid */ if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) { LddMaxBytesToWrite = Fls_GpConfigPtr->ulFlsMaxWriteBytes; /* PRQA S 2814 # JV-01 */ LddLength = Fls_GstVarProperties.ulLength; /* Collect maximum length of flash used to write */ LulMaxWriteLength = FLS_GET_MIN_NUMBER(LddMaxBytesToWrite, LddLength); /* PRQA S 3469 # JV-01 */ #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) /* Before writing a flash block, the function Fls_MainFunction shall compare * the contents of the addressed memory area against the value of an erased * flash cell to check that the block has been completely erased. */ /*-------------------------- SERIAL FLASH ------------------------------------------------------------------------*/ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenProcessStatus = Fls_SfVerifyEraseArea(LulMaxWriteLength); /*-------------------------- HYPER FLASH -------------------------------------------------------------------------*/ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenProcessStatus = Fls_HfVerifyEraseArea(LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ switch (LenProcessStatus) { /* Flash cell is not erased */ case FLS_INCONSISTENT: Fls_GstVarProperties.enJobStatus = FLS_ERR_VERIFY_ERASE; /* End this job */ LddReturnValue = E_OK; break; /* Flash cell has been erased */ case FLS_CONSISTENT: break; /* Blank check timeout */ case FLS_COMPARE_TIMEOUT: /* End this job */ LddReturnValue = E_OK; Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; default: /* No action required */ break; } /* End of switch (LenProcessStatus) */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ * (FLS_ERASE_VERIFICATION_ENABLED == STD_ON) */ /* If job still on-going */ if (E_NOT_OK == LddReturnValue) /* PRQA S 2995, 2991 # JV-01, JV-01 */ { /*------------------------ WRITE BUFFER ------------------------------------------------------------------------*/ LulFlashAddress = Fls_GstVarProperties.ulFlashAddress; LpContAddress = (P2CONST(uint32, AUTOMATIC, FLS_APPL_CONST)) Fls_GstVarProperties.pContAddress; /* PRQA S 3432, 3305, 0310 # JV-01, JV-01, JV-01 */ /* Check if next block overlaps page boundary */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) LulOffsetPageBufferLength = (uint32)(FLS_PAGE_BUFFER_WRAP_VALUE - (LulFlashAddress % FLS_PAGE_BUFFER_WRAP_VALUE));/* PRQA S 3383 # JV-01 */ if ((FLS_ZERO != ((LulFlashAddress + LulMaxWriteLength) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * ((LulFlashAddress + LulMaxWriteLength) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #else /* In case Dual Flash */ LulOffsetPageBufferLength = (uint32)(FLS_TWO * (FLS_PAGE_BUFFER_WRAP_VALUE /* PRQA S 3384 # JV-01 */ - (LulFlashAddress % FLS_PAGE_BUFFER_WRAP_VALUE))); /* PRQA S 3383, 3384 # JV-01, JV-01 */ if ((FLS_ZERO != ((LulFlashAddress + (LulMaxWriteLength / FLS_TWO)) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * ((LulFlashAddress + (LulMaxWriteLength / FLS_TWO)) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #endif /* End of (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulOffsetPageBufferLength = (uint32)(FLS_PAGE_BUFFER_WRAP_VALUE - ((LulFlashAddress * FLS_TWO) % FLS_PAGE_BUFFER_WRAP_VALUE)); /* PRQA S 3383 # JV-01 */ if ((FLS_ZERO != (((LulFlashAddress * FLS_TWO) + LulMaxWriteLength) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * (((LulFlashAddress * FLS_TWO) + LulMaxWriteLength) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #if (FLS_WRITE_BUFFER == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenWriteStatus = Fls_SfPPWithBuffer(LulFlashAddress, LpContAddress, LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenWriteStatus = Fls_HfPPWithBuffer(LulFlashAddress, LpContAddress, LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ /*------------------------ WRITE NORMAL --------------------------------*/ #else #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenWriteStatus = Fls_SfPPNormal (LulFlashAddress, LpContAddress, LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenWriteStatus = Fls_HfPPNormal (LulFlashAddress, LpContAddress, LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_WRITE_BUFFER == STD_ON) */ /*----------------------- Check, If job has any errors -----------------*/ if (FLS_STT_FREE != LenWriteStatus) { /* End this job */ LddReturnValue = E_OK; /* Verify errors and report */ switch (LenWriteStatus) { /* Verify is timeout */ case FLS_STT_TIMEOUT: Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; /* Hardware error */ case FLS_STT_ERROR: Fls_GstVarProperties.enJobStatus = FLS_ERR_WRITE; break; case FLS_ERR_NG: #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Report error to Det */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_PARAM_DATA); #endif break; default: /* NOT REACHED */ break; } /* End of switch (LenWriteStatus) */ } else { #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_WRITE_VERIFICATION_ENABLED == STD_ON)) /* After writing a flash block, the function Fls_MainFunction shall * compare the contents of the reprogrammed memory area against the * contents of the provided application buffer to check that the block * has been completely reprogrammed. */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenProcessStatus = Fls_SfVerifyWriteValue(LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenProcessStatus = Fls_HfVerifyWriteValue(LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ switch (LenProcessStatus) { /* Flash cell is not written */ case FLS_INCONSISTENT: Fls_GstVarProperties.enJobStatus = FLS_ERR_VERIFY_WRITE; /* End this job */ LddReturnValue = E_OK; break; /* Verify is timeout */ case FLS_COMPARE_TIMEOUT: Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; /* End this job */ LddReturnValue = E_OK; break; /* Flash cell has been written */ case FLS_CONSISTENT: default: /* Report status */ Fls_GstVarProperties.enJobStatus = FLS_OK; break; } /* End of switch (LenProcessStatus) */ #else /* Report status */ Fls_GstVarProperties.enJobStatus = FLS_OK; #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ * (FLS_WRITE_VERIFICATION_ENABLED == STD_ON)) */ } /* End of if (FLS_STT_FREE != LenWriteStatus) */ } else { /* No action required */ } /* End of if (E_NOT_OK == LddReturnValue) */ /* If job still on-going */ if (E_NOT_OK == LddReturnValue) { Fls_GstVarProperties.ulLength -= LulMaxWriteLength; /* PRQA S 3384 # JV-01 */ Fls_GstVarProperties.pContAddress += LulMaxWriteLength; /* PRQA S 0488 # JV-01 */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_GstVarProperties.ulFlashAddress += LulMaxWriteLength; /* PRQA S 3384 # JV-01 */ #else Fls_GstVarProperties.ulFlashAddress += (uint32)(LulMaxWriteLength / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) Fls_GstVarProperties.ulFlashAddress += (uint32)(LulMaxWriteLength / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ } else { /* No action required */ } /* End of if (E_NOT_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) */ /* If length not valid */ if (FLS_ZERO_LONG_WORD == Fls_GstVarProperties.ulLength) { /* Job has been finished */ LddReturnValue = E_OK; } else { /* No action required */ } /* End of If job not completed */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_SERIAL_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulLength', 'Value': '4294967295'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlashAddress', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlsMaxWriteBytes', 'Value': '511'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FLS_CONSISTENT'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': '-'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': 'FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': '-'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FLS_STT_ERROR'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': '511'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': 'FLS_ERR_WRITE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '511'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_024': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(Std_ReturnType, FLS_CODE_SLOW) Fls_WriteJobHandler(void) { uint32 LulMaxWriteLength; Fls_StatusRegType LenWriteStatus; #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ ((FLS_WRITE_VERIFICATION_ENABLED == STD_ON) || \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON))) Fls_CompareStatusType LenProcessStatus; #endif uint32 LulFlashAddress; uint32 LulOffsetPageBufferLength; Fls_LengthType LddMaxBytesToWrite; Fls_LengthType LddLength; P2CONST(uint32, AUTOMATIC, FLS_APPL_CONST) LpContAddress; /* PRQA S 3432 # JV-01 */ Std_ReturnType LddReturnValue; /* Default state of Writing Job: is not finished */ LddReturnValue = E_NOT_OK; /* If length still valid */ if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) { LddMaxBytesToWrite = Fls_GpConfigPtr->ulFlsMaxWriteBytes; /* PRQA S 2814 # JV-01 */ LddLength = Fls_GstVarProperties.ulLength; /* Collect maximum length of flash used to write */ LulMaxWriteLength = FLS_GET_MIN_NUMBER(LddMaxBytesToWrite, LddLength); /* PRQA S 3469 # JV-01 */ #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_ERASE_VERIFICATION_ENABLED == STD_ON)) /* Before writing a flash block, the function Fls_MainFunction shall compare * the contents of the addressed memory area against the value of an erased * flash cell to check that the block has been completely erased. */ /*-------------------------- SERIAL FLASH ------------------------------------------------------------------------*/ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenProcessStatus = Fls_SfVerifyEraseArea(LulMaxWriteLength); /*-------------------------- HYPER FLASH -------------------------------------------------------------------------*/ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenProcessStatus = Fls_HfVerifyEraseArea(LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ switch (LenProcessStatus) { /* Flash cell is not erased */ case FLS_INCONSISTENT: Fls_GstVarProperties.enJobStatus = FLS_ERR_VERIFY_ERASE; /* End this job */ LddReturnValue = E_OK; break; /* Flash cell has been erased */ case FLS_CONSISTENT: break; /* Blank check timeout */ case FLS_COMPARE_TIMEOUT: /* End this job */ LddReturnValue = E_OK; Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; default: /* No action required */ break; } /* End of switch (LenProcessStatus) */ #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ * (FLS_ERASE_VERIFICATION_ENABLED == STD_ON) */ /* If job still on-going */ if (E_NOT_OK == LddReturnValue) /* PRQA S 2995, 2991 # JV-01, JV-01 */ { /*------------------------ WRITE BUFFER ------------------------------------------------------------------------*/ LulFlashAddress = Fls_GstVarProperties.ulFlashAddress; LpContAddress = (P2CONST(uint32, AUTOMATIC, FLS_APPL_CONST)) Fls_GstVarProperties.pContAddress; /* PRQA S 3432, 3305, 0310 # JV-01, JV-01, JV-01 */ /* Check if next block overlaps page boundary */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) LulOffsetPageBufferLength = (uint32)(FLS_PAGE_BUFFER_WRAP_VALUE - (LulFlashAddress % FLS_PAGE_BUFFER_WRAP_VALUE));/* PRQA S 3383 # JV-01 */ if ((FLS_ZERO != ((LulFlashAddress + LulMaxWriteLength) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * ((LulFlashAddress + LulMaxWriteLength) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #else /* In case Dual Flash */ LulOffsetPageBufferLength = (uint32)(FLS_TWO * (FLS_PAGE_BUFFER_WRAP_VALUE /* PRQA S 3384 # JV-01 */ - (LulFlashAddress % FLS_PAGE_BUFFER_WRAP_VALUE))); /* PRQA S 3383, 3384 # JV-01, JV-01 */ if ((FLS_ZERO != ((LulFlashAddress + (LulMaxWriteLength / FLS_TWO)) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * ((LulFlashAddress + (LulMaxWriteLength / FLS_TWO)) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #endif /* End of (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) */ #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LulOffsetPageBufferLength = (uint32)(FLS_PAGE_BUFFER_WRAP_VALUE - ((LulFlashAddress * FLS_TWO) % FLS_PAGE_BUFFER_WRAP_VALUE)); /* PRQA S 3383 # JV-01 */ if ((FLS_ZERO != (((LulFlashAddress * FLS_TWO) + LulMaxWriteLength) % /* PRQA S 3383 # JV-01 */ FLS_PAGE_BUFFER_WRAP_VALUE)) && (LulMaxWriteLength > LulOffsetPageBufferLength)) { LulMaxWriteLength = LulOffsetPageBufferLength; } else { /* No action required */ } /* End of if ((FLS_ZERO != * (((LulFlashAddress * FLS_TWO) + LulMaxWriteLength) % * FLS_PAGE_BUFFER_WRAP_VALUE)) && * (LulMaxWriteLength > LulOffsetPageBufferLength)) */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #if (FLS_WRITE_BUFFER == STD_ON) #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenWriteStatus = Fls_SfPPWithBuffer(LulFlashAddress, LpContAddress, LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenWriteStatus = Fls_HfPPWithBuffer(LulFlashAddress, LpContAddress, LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ /*------------------------ WRITE NORMAL --------------------------------*/ #else #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenWriteStatus = Fls_SfPPNormal (LulFlashAddress, LpContAddress, LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenWriteStatus = Fls_HfPPNormal (LulFlashAddress, LpContAddress, LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ #endif /* End of #if (FLS_WRITE_BUFFER == STD_ON) */ /*----------------------- Check, If job has any errors -----------------*/ if (FLS_STT_FREE != LenWriteStatus) { /* End this job */ LddReturnValue = E_OK; /* Verify errors and report */ switch (LenWriteStatus) { /* Verify is timeout */ case FLS_STT_TIMEOUT: Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; break; /* Hardware error */ case FLS_STT_ERROR: Fls_GstVarProperties.enJobStatus = FLS_ERR_WRITE; break; case FLS_ERR_NG: #if (FLS_DEV_ERROR_DETECT == STD_ON) /* Report error to Det */ (void)Det_ReportError(FLS_MODULE_ID, FLS_INSTANCE_ID, FLS_MAINFUNCTION_SID, FLS_E_PARAM_DATA); #endif break; default: /* NOT REACHED */ break; } /* End of switch (LenWriteStatus) */ } else { #if ((FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ (FLS_WRITE_VERIFICATION_ENABLED == STD_ON)) /* After writing a flash block, the function Fls_MainFunction shall * compare the contents of the reprogrammed memory area against the * contents of the provided application buffer to check that the block * has been completely reprogrammed. */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) LenProcessStatus = Fls_SfVerifyWriteValue(LulMaxWriteLength); #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) LenProcessStatus = Fls_HfVerifyWriteValue(LulMaxWriteLength); #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ switch (LenProcessStatus) { /* Flash cell is not written */ case FLS_INCONSISTENT: Fls_GstVarProperties.enJobStatus = FLS_ERR_VERIFY_WRITE; /* End this job */ LddReturnValue = E_OK; break; /* Verify is timeout */ case FLS_COMPARE_TIMEOUT: Fls_GstVarProperties.enJobStatus = FLS_TIME_OUT; /* End this job */ LddReturnValue = E_OK; break; /* Flash cell has been written */ case FLS_CONSISTENT: default: /* Report status */ Fls_GstVarProperties.enJobStatus = FLS_OK; break; } /* End of switch (LenProcessStatus) */ #else /* Report status */ Fls_GstVarProperties.enJobStatus = FLS_OK; #endif /* End of #if (FLS_RUNTIME_ERROR_DETECT == STD_ON) && \\ * (FLS_WRITE_VERIFICATION_ENABLED == STD_ON)) */ } /* End of if (FLS_STT_FREE != LenWriteStatus) */ } else { /* No action required */ } /* End of if (E_NOT_OK == LddReturnValue) */ /* If job still on-going */ if (E_NOT_OK == LddReturnValue) { Fls_GstVarProperties.ulLength -= LulMaxWriteLength; /* PRQA S 3384 # JV-01 */ Fls_GstVarProperties.pContAddress += LulMaxWriteLength; /* PRQA S 0488 # JV-01 */ #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) #if (FLS_PIN_GROUP == FLS_QSPI0_PIN_GROUP) Fls_GstVarProperties.ulFlashAddress += LulMaxWriteLength; /* PRQA S 3384 # JV-01 */ #else Fls_GstVarProperties.ulFlashAddress += (uint32)(LulMaxWriteLength / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ #endif #elif (FLS_FLASH_ACCESS == FLS_HYPER_FLASH_DEVICE) Fls_GstVarProperties.ulFlashAddress += (uint32)(LulMaxWriteLength / FLS_TWO_LONG_WORD); /* PRQA S 3384 # JV-01 */ #endif /* End of #if (FLS_FLASH_ACCESS == FLS_SERIAL_FLASH_DEVICE) */ } else { /* No action required */ } /* End of if (E_NOT_OK == LddReturnValue) */ } else { /* No action required */ } /* End of if (FLS_ZERO_LONG_WORD != Fls_GstVarProperties.ulLength) */ /* If length not valid */ if (FLS_ZERO_LONG_WORD == Fls_GstVarProperties.ulLength) { /* Job has been finished */ LddReturnValue = E_OK; } else { /* No action required */ } /* End of If job not completed */ return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'FLS_SERIAL_FLASH_DEVICE/FLS_HYPER_FLASH_DEVICE', 'Name': 'FLS_FLASH_ACCESS', 'Value': 'FLS_HYPER_FLASH_DEVICE'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_RUNTIME_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_VERIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_WRITE_BUFFER', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'FLS_QSPI0_PIN_GROUP/FLS_QSPI0_QSPI1_PIN_GROUP', 'Name': 'FLS_PIN_GROUP', 'Value': 'FLS_QSPI0_QSPI1_PIN_GROUP'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FLS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulLength', 'Value': '4294967295'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlashAddress', 'Value': '0x7FFFFFFF'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fls_GpConfigPtr', 'Value': '&map_Fls_GpConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..4294967295', 'Name': 'ulFlsMaxWriteBytes', 'Value': '256'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FLS_CONSISTENT'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': 'FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': '-'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': 'FLS_STT_ERROR/\\n  FLS_STT_TIMEOUT/\\n  FLS_STT_FREE/\\n  FLS_STT_BUSY/\\n  FLS_ERR_NG', 'Name': 'return', 'Value': 'FLS_STT_ERROR'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': 'FLS_INCONSISTENT/\\n  FLS_CONSISTENT/\\n  FLS_COMPARE_TIMEOUT', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': '256'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enJobStatus', 'Value': 'FLS_ERR_WRITE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulLength', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pContAddress', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFlashAddress', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': '2'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'TargetAddress', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'pWriteData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Length', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'MaxWriteLength', 'Value': '-'], 'Output_Param_024': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_OK'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': ''], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FLS_START_SEC_CODE_SLOW #include \"Fls_MemMap.h\" /* PRQA S 5087 # JV-01 */ static FUNC(void, FLS_CODE_SLOW) Fls_WriteVerifyCheck (const uint32 ulRegValue, const uint32 ulCompareData, const uint32 ulOrMaskValRegister) { /* Check data from register with compare data */ if ((ulOrMaskValRegister & ulRegValue) != (ulOrMaskValRegister & ulCompareData)) { /* Report DEM */ Dem_SetEventStatus(FLS_E_WRITE_VERIFY_FAILURE, DEM_EVENT_STATUS_FAILED); /* PRQA S 3200 # JV-01 */ } else { /* No action required */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'FLS_WRITE_VERIFY_ENABLE', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'ulRegValue', 'Value': '0xAAAAAAAA'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'ulCompareData', 'Value': '0x00000002'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..4294967295', 'Name': 'ulOrMaskValRegister', 'Value': '0x00000002']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_CfgBuffer(CONST(uint8, AUTOMATIC) Fr_CtrlIdx) /* PRQA S 1532 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_MessageBufferControlRegType, AUTOMATIC, REGSPACE) LpMBCtrlReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ P2VAR(volatile Fr_59_Renesas_InputBufferRegType, AUTOMATIC, REGSPACE) LpInputBuffReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpBufferHeader; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; uint32 LulData; uint16 LusFrameCount; uint16 LusNoOfFrames; uint16 LusDataPointer; uint16 LusDataPtrInc; uint16 LusFirstFIFOBuffer; uint8 LucFIFOdepth; uint8 LucPayloadLength; Std_ReturnType LucReturnValue; volatile uint16 LusLoopCount; /* Initialize the return value */ LucReturnValue = E_OK; /* Initialize the payload value */ LucPayloadLength = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpMBCtrlReg = LpCtrlRegSet->pMBCtrlReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LpInputBuffReg = (P2VAR(volatile Fr_59_Renesas_InputBufferRegType, AUTOMATIC, REGSPACE))LpCtrlRegSet->pInputBuffReg; /* PRQA S 3432 # JV-01 */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Get the total number of frames configured */ LusNoOfFrames = LpCtrlTable->usMaxFrames; /* PRQA S 2814 # JV-02 */ LpFrameConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig; /* Initialize the number of frames processed */ LusFrameCount = FR_59_RENESAS_ZERO; /* Initialize the 1st FIFO Buffer */ LusFirstFIFOBuffer = FR_59_RENESAS_ZERO; /* Loop through all the frames for loading the message buffer header */ do { /* Get the pointer to frame configuration of the corresponding LusFrameCount */ LpBufferHeader = &LpFrameConfig[LusFrameCount]; /* PRQA S 2824 # JV-02 */ /* * Note: Frames allocated dedicated buffers shall be only be configured from Fr_59_Renesas_ControllerInit(). * All other frames which are reconfigurable shall be performed only by Fr_PrepareLPdu() */ if ((FR_59_RENESAS_FALSE == LpBufferHeader->blBufferReConfig) || /* PRQA S 2814 # JV-02 */ (FR_59_RENESAS_FALSE == LpBufferHeader->blFrIfReconfigurable)) { /* Invoke the internal function to calculate header value of the frames and load the values in the register */ LucReturnValue = Fr_59_Renesas_CfgBufferHeader(Fr_CtrlIdx, LusFrameCount, LpBufferHeader->ucPayloadLength); /* Check if the return value */ if (E_NOT_OK == LucReturnValue) { /* Update the frame count to the maximum number of frames configured */ LusFrameCount = LusNoOfFrames; } /* else No Action required */ } /* else No Action required */ /* If FIFO is configured, get the message Buffer Id and data pointer */ if ((FR_59_RENESAS_TRUE == LpBufferHeader->blIsFIFOConfig) && (FR_59_RENESAS_ZERO == LusFirstFIFOBuffer)) { /* Data Pointer of the FIFO */ LusDataPointer = LpBufferHeader->usDataPointer; /* Message Buffer Id for FIFO */ LusFirstFIFOBuffer = LpBufferHeader->ucMsgBuffer; /* Get the static payload length */ LucPayloadLength = LpBufferHeader->ucPayloadLength; } /* else No Action required */ /* Increment the number of frames processed */ LusFrameCount++; /* PRQA S 3383 # JV-01 */ } while (LusFrameCount < LusNoOfFrames); /* * The header section of each FIFO buffer is configured as below * 1. Wait until IBCR.IBSYH is reset * 2. All bits of WRHS1 shall be configured to \"0\" * 3. In WRHS2, the payload length configured of the FIFO buffer has to be * configured (WRHS2.PLC[6:0]). * 4. The configuration of WRHS2.CRC[10:0] is not necessary. * 5. In WRHS3, the data pointer according to the FIFO buffer has to be * configured. * 6. Write header section to WRHS1..3 * 7. Write Command Mask: Write IBCM.LDSH * 8. Demand data transfer to target message buffer: Write IBCR.IBRH[6:0] */ if (LusFirstFIFOBuffer > FR_59_RENESAS_ZERO) { /* Get the FIFO depth from register */ LucFIFOdepth = (uint8)LpMBCtrlReg->ulFLXAnFRFCL; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LusFrameCount = FR_59_RENESAS_ZERO; LusDataPtrInc = ((uint16)LucPayloadLength / (uint16)FR_59_RENESAS_TWO); /* Check if Fr_PayloadLength is a even number */ if (FR_59_RENESAS_ZERO == (LucPayloadLength % FR_59_RENESAS_TWO)) { /* No action required */ } else { /* In case of Odd number, round it of to higher value */ LusDataPtrInc = LusDataPtrInc + FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ } do { /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; while ((FR_59_RENESAS_FLX0IBCR_FLX0IBSYH_MASK == (LpInputBuffReg->ulFLXAnFRIBCR /* PRQA S 3415, 3416, 2814, 2844 # JV-01, JV-01, JV-02, JV-01 */ & FR_59_RENESAS_FLX0IBCR_FLX0IBSYH_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set return value */ LucReturnValue = E_NOT_OK; /* Exit the loop */ LusFrameCount = LucFIFOdepth; } else { LulData = FR_59_RENESAS_ZERO; /* Write the value of the header into FlexRay Write Header Section Register 1 and mirror address */ LpInputBuffReg->ulFLXAnFRWRHS1 = LulData; /* Get the value of the Payload length configured */ LulData = ((uint32)((LucPayloadLength)&FR_59_RENESAS_PLC_MASK) << FR_59_RENESAS_PLC_SHIFT); /* Write the value of the header into FlexRay Write Header Section Register 2 and mirror address */ LpInputBuffReg->ulFLXAnFRWRHS2 = LulData; /* Get the value of the Data pointer */ LulData = (LusDataPointer & FR_59_RENESAS_DP_MASK); /* Write the value of the Data Pointer header in the FlexRay Write Header Section Register 3 */ LpInputBuffReg->ulFLXAnFRWRHS3 = LulData; /* Get the value of the Data pointer */ LulData = FR_59_RENESAS_FLX0IBCM_FLX0LHSH_MASK; /* Write the value of the header into FlexRay Input Buffer Command Mask Register and mirror address */ LpInputBuffReg->ulFLXAnFRIBCM = LulData; /* Get the value of the message buffer configured and load the value in the FRIBCR register */ LulData = (LusFirstFIFOBuffer & FR_59_RENESAS_FLX0IBCR_FLX0IBRH_MASK); /* Write the value of the header into FlexRay Input Buffer Command Request Register and mirror address */ LpInputBuffReg->ulFLXAnFRIBCR = LulData; /* Next Data Pointer Value */ LusDataPointer = LusDataPointer + LusDataPtrInc; /* PRQA S 3383 # JV-01 */ /* Get the next Message Buffer */ LusFirstFIFOBuffer = LusFirstFIFOBuffer + FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ } LusFrameCount++; /* PRQA S 3383 # JV-01 */ } while (LusFrameCount < LucFIFOdepth); } /* else No Action required */ return (LucReturnValue); /* End of function Fr_59_Renesas_CfgBuffer */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[1]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '8'], 'Input_Param_004': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blBufferReConfig', 'Value': '[0 to 7] = FR_59_RENESAS_TRUE'], 'Input_Param_006': ['Type': 'Array', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blFrIfReconfigurable', 'Value': '[0 to 7] = FR_59_RENESAS_TRUE'], 'Input_Param_007': ['Type': 'Array', 'Range': '0..127', 'Name': 'ucPayloadLength', 'Value': '[7] = 2'], 'Input_Param_008': ['Type': 'Array', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blIsFIFOConfig', 'Value': '[7] = FR_59_RENESAS_TRUE'], 'Input_Param_009': ['Type': 'Array', 'Range': '0..8192\\n(Data section in the Message RAM)', 'Name': 'usDataPointer', 'Value': '[7] = 268'], 'Input_Param_010': ['Type': 'Array', 'Range': '-', 'Name': 'ucMsgBuffer', 'Value': '[7] = 127'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pMBCtrlReg', 'Value': '&map_MBCtrlReg[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRFCL', 'Value': '0x0001'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRMHDC', 'Value': '0x0002'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pInputBuffReg', 'Value': '&map_InputBuffReg[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRIBCR', 'Value': '0x0001'], 'Input_Param_019': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'usFlagClearMaxWait', 'Value': '1'], 'Input_Param_020': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pDemEventId', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'usReadTimeoutFailure', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'usFrameHandle', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'ucPayLoadLength', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRWRHS1', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRWRHS2', 'Value': '0x00020000'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRWRHS3', 'Value': '268'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRIBCM', 'Value': 'FR_59_RENESAS_FLX0IBCM_FLX0LHSH_MASK'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRIBCR', 'Value': '127'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_CheckCCConfig(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2CONST(Fr_59_Renesas_LowLevelConfSetType, AUTOMATIC, FR_APPL_CONST) pLowLevelCfgPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint32 LulConfiguredData; uint32 LulOffSet; uint16 LusFrCtrlTestCount; uint8 LucRegCnt; /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ LucRegCnt = FR_59_RENESAS_ZERO; LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* NULL pointer checking for input parameter */ if (NULL_PTR == pLowLevelCfgPtr) { LucReturnValue = E_NOT_OK; } else { /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ do { LusFrCtrlTestCount = FR_59_RENESAS_ZERO; do { /* Read Data from the CC */ switch (LucRegCnt) { case FR_59_RENESAS_ZERO: LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LulConfiguredData = pLowLevelCfgPtr->ulFrSUCC1Config; break; case FR_59_RENESAS_ONE: LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2; LulConfiguredData = pLowLevelCfgPtr->ulFrSUCC2Config; break; case FR_59_RENESAS_TWO: LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3; LulConfiguredData = pLowLevelCfgPtr->ulFrSUCC3Config; break; case FR_59_RENESAS_THREE: LulOffSet = LpCCCtrlReg->ulFLXAnFRNEMC; LulConfiguredData = pLowLevelCfgPtr->ulFrNEMConfig; break; case FR_59_RENESAS_FOUR: LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1; LulConfiguredData = pLowLevelCfgPtr->ulFrPRTC1Config; break; case FR_59_RENESAS_FIVE: LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2; LulConfiguredData = pLowLevelCfgPtr->ulFrPRTC2Config; break; case FR_59_RENESAS_SIX: LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC; LulConfiguredData = pLowLevelCfgPtr->ulFrMHDCConfig; break; case FR_59_RENESAS_SEVEN: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC1; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC1Config; break; case FR_59_RENESAS_EIGHT: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC2Config; break; case FR_59_RENESAS_NINE: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC3Config; break; case FR_59_RENESAS_TEN: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC4; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC4Config; break; case FR_59_RENESAS_ELEVEN: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC5Config; break; case FR_59_RENESAS_TWELVE: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC6; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC6Config; break; case FR_59_RENESAS_THIRTEEN: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC7Config; break; case FR_59_RENESAS_FOURTEEN: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC8Config; break; case FR_59_RENESAS_FIFTEEN: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC9Config; break; case FR_59_RENESAS_SIXTEEN: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC10Config; break; case FR_59_RENESAS_SEVENTEEN: LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC11; LulConfiguredData = pLowLevelCfgPtr->ulFrGTUC11Config; break; default: /* No action required */ break; } if (FR_59_RENESAS_ZERO == LucRegCnt) { /* Mask the CMD Command Bits and PBSY bits in FLXnSUCC1 */ LulOffSet = LulOffSet & FR_59_RENESAS_FLX0SUCC1_FLX0_PBSY_CMD_MASK; } /* else No Action required */ if (FR_59_RENESAS_FOUR == LucRegCnt) { /* FLXnCASM06 is fixed to 1 */ LulConfiguredData = LulConfiguredData | FR_59_RENESAS_FLX0PRTC1_FLX0CASM_MASK; } /* else No Action required */ if (LulOffSet == LulConfiguredData) { LucReturnValue = E_OK; /* Break the loop */ LusFrCtrlTestCount = (uint16)FR_59_RENESAS_CTRL_TEST_COUNT + (uint16)FR_59_RENESAS_ONE; } else { LucReturnValue = E_NOT_OK; LusFrCtrlTestCount++; /* PRQA S 3383 # JV-01 */ } } while ((uint16)FR_59_RENESAS_CTRL_TEST_COUNT >= LusFrCtrlTestCount); if (E_NOT_OK == LucReturnValue) { /* Break the while loop */ LucRegCnt = FR_59_RENESAS_EIGHTTEEN; } else { LucRegCnt++; /* PRQA S 3383 # JV-01 */ } } while (FR_59_RENESAS_SEVENTEEN >= LucRegCnt); } if (E_OK == LucReturnValue) { /* Raise DEM Error PASSED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_PASSED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); /* End of function Fr_59_Renesas_CheckCCConfig */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': '!NULL_PTR', 'Name': 'pLowLevelCfgPtr', 'Value': '&map_pLowLevelCfgPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0x00001000..0x0CFFFB00', 'Name': 'ulFrSUCC1Config', 'Value': '0x00001000'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0x01000504..0x0F139706', 'Name': 'ulFrSUCC2Config', 'Value': '0x01000504'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0x00000011..0x000000FF', 'Name': 'ulFrSUCC3Config', 'Value': '0x00000011'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0x00000000..0x0000000C', 'Name': 'ulFrNEMConfig', 'Value': '0x00000000'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0x084C0433..0xF92DF63F', 'Name': 'ulFrPRTC1Config', 'Value': '0x084C0433'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0x0F2D0A0E..0x3CB4373B', 'Name': 'ulFrPRTC2Config', 'Value': '0x0F2D0A0E'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0x00000000..0x0F2D007F', 'Name': 'ulFrMHDCConfig', 'Value': '0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0x00000280..0x0009C400', 'Name': 'ulFrGTUC1Config', 'Value': '0x00000280'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0x0002000A..0x000F0E80', 'Name': 'ulFrGTUC2Config', 'Value': '0x0002000A'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0x02020000..0x73724040', 'Name': 'ulFrGTUC3Config', 'Value': '0x02020000'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0x00080007..0x3E7E3E7D', 'Name': 'ulFrGTUC4Config', 'Value': '0x00080007'], 'Input_Param_014': ['Type': 'Variable', 'Range': '0x0E000000..0x8F14C8C8', 'Name': 'ulFrGTUC5Config', 'Value': '0x0E000000'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0x00020000..0x07830753', 'Name': 'ulFrGTUC6Config', 'Value': '0x00020000'], 'Input_Param_016': ['Type': 'Variable', 'Range': '0x00020004..0x03FF0293', 'Name': 'ulFrGTUC7Config', 'Value': '0x00020004'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0x00000002..0x1F32003F', 'Name': 'ulFrGTUC8Config', 'Value': '0x00000002'], 'Input_Param_018': ['Type': 'Variable', 'Range': '0x00000101..0x00021F3F', 'Name': 'ulFrGTUC9Config', 'Value': '0x00000101'], 'Input_Param_019': ['Type': 'Variable', 'Range': '0x00020005..0x07833BA2', 'Name': 'ulFrGTUC10Config', 'Value': '0x00020005'], 'Input_Param_020': ['Type': 'Variable', 'Range': '0x00000000..0x07070000', 'Name': 'ulFrGTUC11Config', 'Value': '0x00000000'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC1', 'Value': '0x00001000'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC2', 'Value': '0x01000504'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC3', 'Value': '0x00000011'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNEMC', 'Value': '0x00000000'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC1', 'Value': '0x084C0433'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC2', 'Value': '0x0F2D0A0E'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRMHDC', 'Value': '0x00000000'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC1', 'Value': '0x00000280'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC2', 'Value': '0x0002000A'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC3', 'Value': '0x02020000'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC4', 'Value': '0x00080007'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC5', 'Value': '0x0E000000'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC6', 'Value': '0x00020000'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC7', 'Value': '0x00020004'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC8', 'Value': '0x00000002'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC9', 'Value': '0x00000101'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC10', 'Value': '0x00020005'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC11', 'Value': '0x00000000'], 'Input_Param_041': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pDemEventId', 'Value': '[0] = &map_Fr_59_Renesas_DemEventId[0]\\n[1] = &map_Fr_59_Renesas_DemEventId[1]'], 'Input_Param_042': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'usHardwareTestFailure', 'Value': 'FR_59_RENESAS_DEM_NOT_CONFIGURED']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_CheckTxLPduStatus(VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ VAR(uint16, AUTOMATIC) Fr_LPduIdx, P2VAR(Fr_TxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_TxLPduStatusPtr /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) , P2VAR(Fr_SlotAssignmentType, AUTOMATIC, FR_APPL_DATA)Fr_SlotAssignmentPtr /* PRQA S 3432 # JV-01 */ #endif ) { P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_APPL_CONST) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) P2VAR(volatile uint16, AUTOMATIC, FR_VAR_NO_INIT) LpBufReconfigStatusPtr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; uint8 LucMessageBuffer; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value to E_OK */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_CHECKTXLPDU_STATUS_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_CHECKTXLPDU_STATUS_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) { /* Check if the value of LPduIdx is greater than the number of frames configured */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); if (Fr_LPduIdx >= LpCtrlTable->usMaxFrames) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_CHECKTXLPDU_STATUS_SID, FR_59_RENESAS_E_INV_LPDU_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* else No Action required */ /* Check if the output parameter Fr_TxLPduStatusPtr is NULL pointer */ if (NULL_PTR == Fr_TxLPduStatusPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_CHECKTXLPDU_STATUS_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Initialize local pointer */ LpFrameConfig = (P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig); LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ /* Read the Message Buffer configured to the frame */ LucMessageBuffer = LpFrameConfigPtr->ucMsgBuffer; /* PRQA S 2814 # JV-02 */ /* Initialize the *Fr_TxLPduStatusPtr as FR_NOT_TRANSMITTED. */ *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; /* PRQA S 2814 # JV-03 */ #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Initialize local pointer of Buffer Reconfig Status */ LpBufReconfigStatusPtr = Fr_59_Renesas_GpBufReconfigStatusPtr[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ if (((LpFrameConfigPtr->blBufferReConfig != LpFrameConfigPtr->blFrIfReconfigurable) && (LpBufReconfigStatusPtr[LucMessageBuffer] == Fr_LPduIdx)) || /* PRQA S 2844, 2824 # JV-01, JV-02 */ ((FR_59_RENESAS_FALSE == LpFrameConfigPtr->blBufferReConfig) && (FR_59_RENESAS_FALSE == LpFrameConfigPtr->blFrIfReconfigurable))) #endif { #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) if (NULL_PTR != Fr_SlotAssignmentPtr) { LucReturnValue = Fr_59_Renesas_GetSlotAssignment(Fr_CtrlIdx, Fr_LPduIdx, Fr_SlotAssignmentPtr); /* PRQA S 2982 # JV-01 */ } /* else No Action required */ #endif /* (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) */ /* Check if Frame is not receive frame and Frame id is not equal * to zero */ if ((FR_59_RENESAS_CFG_TRANSMIT == LpFrameConfigPtr->ucFrameConfig) && (FR_59_RENESAS_ZERO != LpFrameConfigPtr->usFrameId)) { /* Update the status of LPdu */ LucReturnValue = Fr_59_Renesas_UpdateLPduTxSts(Fr_CtrlIdx, Fr_LPduIdx, LucMessageBuffer, Fr_TxLPduStatusPtr); } else /* Receive frame or Startup frame */ { /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* DEM report for slot status information is enable and TransmissionMode is Single Shot */ if (((FR_59_RENESAS_TRUE == LpFrameConfigPtr->blIsFrIfDemFTSlotStatusConfig) && (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode)) && (LucReturnValue == E_OK)) { #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) LucReturnValue = Fr_59_Renesas_WriteOutputBufferCommand(Fr_CtrlIdx, Fr_LPduIdx); if (E_OK == LucReturnValue) { #endif LucReturnValue = Fr_59_Renesas_MessageBufferStatus(Fr_CtrlIdx, Fr_LPduIdx); #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) } /* else No Action required */ #endif } /* else No Action required */ } #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_RECONFIG_LPDU', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_PREPARE_LPDU', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DISABLE_LPDU', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_EXTENDED_LPDU_REPORTING', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '2'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_TxLPduStatusPtr', 'Value': '&map_Fr_TxLPduStatusPtr'], 'Input_Param_008': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '&map_Fr_SlotAssignmentPtr'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '&map_Fr_59_Renesas_CtrlTable[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '3'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'ucMsgBuffer', 'Value': '2'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blBufferReConfig', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_016': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blFrIfReconfigurable', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucFrameConfig', 'Value': 'FR_59_RENESAS_CFG_TRANSMIT'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1..2047', 'Name': 'usFrameId', 'Value': 'FR_59_RENESAS_ZERO'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blIsFrIfDemFTSlotStatusConfig', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_020': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucTransmissionMode', 'Value': '0'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpBufReconfigStatusPtr[CURRENT_TEST.Fr_CtrlIdx]', 'Value': ' &map_Fr_59_Renesas_GpBufferReConfigStatus[0]'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus[0 to 2]', 'Value': '[2] = 2'], 'Input_Param_023': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_024': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_TxLPduStatusPtr', 'Value': '-'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_027': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_TxLPduStatusPtr', 'Value': 'FR_NOT_TRANSMITTED'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '2'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '&map_Fr_SlotAssignmentPtr'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_TxLPduStatusPtr', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_ClearTimerInterrupt(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) Fr_AbsTimerIdx) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_AbsTimerConfigType, AUTOMATIC, FR_CONFIG_DATA)LpAbsTimerConfig; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Fr_59_Renesas_AbsTimerConfigType, AUTOMATIC, FR_CONFIG_DATA)LpAbsTimer; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OperationRegType, AUTOMATIC, REGSPACE) LpFROReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; uint32 LulFrosValue; uint32 LulFrosMask; /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; volatile uint16 LusLoopCount; /* Initialize return value */ LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpAbsTimerConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pAbsTimerConfig; LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpFROReg = LpCtrlRegSet->pFROReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LusLoopCount = FR_59_RENESAS_ZERO; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Get the pointer to Absolute Timer configuration of the corresponding Fr_AbsTimerIdx */ LpAbsTimer = &LpAbsTimerConfig[Fr_AbsTimerIdx]; /* PRQA S 2824 # JV-02 */ do { /* Timer 0 */ if (FR_59_RENESAS_TIMER0 == LpAbsTimer->enTimerSelection) /* PRQA S 2814 # JV-02 */ { /* Check if critical section protection is required */ #if (FR_59_RENESAS_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter the Critical Section Area */ FR_59_RENESAS_ENTER_CRITICAL_SECTION(FR_INTERRUPT_CONTROL_PROTECTION); #endif /* Reset the flag T0IS of the register FROS */ /* Writing in to FlexRay Operation Status Register and mirror address */ LpFROReg->ulFLXAnFROS = FR_59_RENESAS_FLX0FROS_T0IS_CLR; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Read the status interrupt register */ LulFrosValue = LpFROReg->ulFLXAnFROS; LulFrosMask = FR_59_RENESAS_FLX0FROS_T0IS_CLR; /* Check if critical section protection is required */ #if (FR_59_RENESAS_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit the Critical Section Area */ FR_59_RENESAS_EXIT_CRITICAL_SECTION(FR_INTERRUPT_CONTROL_PROTECTION); #endif } /* Timer 2 */ else { /* Check if critical section protection is required */ #if (FR_59_RENESAS_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter the Critical Section Area */ FR_59_RENESAS_ENTER_CRITICAL_SECTION(FR_INTERRUPT_CONTROL_PROTECTION); #endif /* Reset the flag T2IS of the register FROS */ /* Writing in to FlexRay Operation Status Register and mirror address */ LpFROReg->ulFLXAnFROS = FR_59_RENESAS_FLX0FROS_T2IS_CLR; /* Read the status interrupt register */ LulFrosValue = LpFROReg->ulFLXAnFROS; LulFrosMask = FR_59_RENESAS_FLX0FROS_T2IS_CLR; /* Check if critical section protection is required */ #if (FR_59_RENESAS_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit the Critical Section Area */ FR_59_RENESAS_EXIT_CRITICAL_SECTION(FR_INTERRUPT_CONTROL_PROTECTION); #endif } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416, 2814 # JV-01, JV-02 */ { LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; } /* else No Action required */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } while ((LulFrosMask == (LulFrosValue & LulFrosMask)) && (E_OK == LucReturnValue)); return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_AbsTimerIdx', 'Value': '0'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pFROReg', 'Value': '&map_OperationReg[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pAbsTimerConfig', 'Value': '&map_pAbsTimerConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAbsTimerConfig[CURRENT_TEST.Fr_AbsTimerIdx].enTimerSelection', 'Value': 'FR_59_RENESAS_TIMER2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'SchM_Enter_Fr_59_Renesas_FR_INTERRUPT_CONTROL_PROTECTION#1'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'SchM_Exit_Fr_59_Renesas_FR_INTERRUPT_CONTROL_PROTECTION#1'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'SchM_Enter_Fr_59_Renesas_FR_INTERRUPT_CONTROL_PROTECTION#1'], 'Output_Param_004': ['Type': 'Critical_Section', 'Range': '', 'Name': '-', 'Value': 'SchM_Exit_Fr_59_Renesas_FR_INTERRUPT_CONTROL_PROTECTION#1'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'map_OperationReg[0].ulFLXAnFROS', 'Value': '0x00040000'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_GetAbsoluteTimerIRQStatus(VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_AbsTimerIdx, P2VAR(boolean, AUTOMATIC, FR_APPL_DATA) Fr_IRQStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value to E_OK */ LucReturnValue = E_OK; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETABSOLUTETIMERIRQSTATUS_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETABSOLUTETIMERIRQSTATUS_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) { /* Store the global pointer to FlexRay Control Table */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* * Check if the absolute timer configured is greater than the number * of absolute timers configured for this controller */ if ((LpCtrlTable->ucAbsTimerCount) <= Fr_AbsTimerIdx) /* PRQA S 2814 # JV-02 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETABSOLUTETIMERIRQSTATUS_SID, FR_59_RENESAS_E_INV_TIMER_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* else No Action required */ /* Check if the output parameter Fr_IRQStatusPtr is NULL pointer */ if (NULL_PTR == Fr_IRQStatusPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETABSOLUTETIMERIRQSTATUS_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { Fr_59_Renesas_GetIrqSts(Fr_CtrlIdx, Fr_AbsTimerIdx, Fr_IRQStatusPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED -1'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0,1', 'Name': 'Fr_AbsTimerIdx', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_IRQStatusPtr', 'Value': '&map_Fr_IRQStatus'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1..4', 'Name': 'ucAbsTimerCount', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_IRQStatusPtr', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FR_59_RENESAS_E_INIT_FAILED'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FR_59_RENESAS_MODULE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FR_59_RENESAS_INSTANCE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FR_59_RENESAS_GETABSOLUTETIMERIRQSTATUS_SID'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_AbsTimerIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_IRQStatusPtr', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_IRQStatus', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_GetChannelStatus(VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ P2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelAStatusPtr, /* PRQA S 3432 # JV-01 */ P2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelBStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETCHANNELSTATUS_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETCHANNELSTATUS_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_ChannelAStatusPtr is NULL pointer */ if (NULL_PTR == Fr_ChannelAStatusPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETCHANNELSTATUS_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_ChannelBStatusPtr is NULL pointer */ if (NULL_PTR == Fr_ChannelBStatusPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETCHANNELSTATUS_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Update Channel status pointer */ LucReturnValue = Fr_59_Renesas_ReadAggregatedStatus(Fr_CtrlIdx, Fr_ChannelAStatusPtr, Fr_ChannelBStatusPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelAStatusPtr', 'Value': '&map_Fr_ChannelAStatusPtr'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelAStatusPtr', 'Value': '-'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelBStatusPtr', 'Value': '&map_Fr_ChannelBStatusPtr'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelBStatusPtr', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_ChannelAStatusPtr', 'Value': '&map_Fr_ChannelAStatusPtr'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_ChannelBStatusPtr', 'Value': '&map_Fr_ChannelBStatusPtr'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_GetClockCorrection(VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ P2VAR(sint16, AUTOMATIC, FR_APPL_DATA) Fr_RateCorrectionPtr, /* PRQA S 3432 # JV-01 */ P2VAR(sint32, AUTOMATIC, FR_APPL_DATA) Fr_OffsetCorrectionPtr) /* PRQA S 3432 # JV-01 */ { /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETCLOCKCORRECTION_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETCLOCKCORRECTION_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_RateCorrectionPtr is NULL pointer */ if (NULL_PTR == Fr_RateCorrectionPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETCLOCKCORRECTION_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_OffsetCorrectionPtr is NULL pointer */ if (NULL_PTR == Fr_OffsetCorrectionPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETCLOCKCORRECTION_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Update Rate correction and Offset correction value to input pointer */ LucReturnValue = Fr_59_Renesas_GetCorrectionValue(Fr_CtrlIdx, Fr_RateCorrectionPtr, Fr_OffsetCorrectionPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_RateCorrectionPtr', 'Value': '&map_Fr_RateCorrectionPtr'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_OffsetCorrectionPtr', 'Value': '&map_Fr_OffsetCorrectionPtr'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_NOT_OK'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_RateCorrectionPtr', 'Value': '1'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_OffsetCorrectionPtr', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_RateCorrectionPtr', 'Value': '&map_Fr_RateCorrectionPtr'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_OffsetCorrectionPtr', 'Value': '&map_Fr_OffsetCorrectionPtr'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_RateCorrectionPtr', 'Value': '1'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_OffsetCorrectionPtr', 'Value': '1'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_GetCycleCounter(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_CyclePtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_MacroTickPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store return value */ Std_ReturnType LucReturnValue; uint32 LulRegData; /* Initialize the return value */ LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Read the POC State by getting FLX0CCSV register value */ LulRegData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if the CC is in normal active state */ if ((FR_59_RENESAS_NORMAL_ACTIVE_STATE == LulRegData) || (FR_59_RENESAS_NORMAL_PASSIVE_STATE == LulRegData)) { /* Read the value of the MTCCV register */ LulRegData = LpCCStatusReg->ulFLXAnFRMTCCV; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Update the output parameter Fr_CyclePtr with the current cycle count of CC */ *Fr_CyclePtr = /* PRQA S 2814 # JV-03 */ (uint8)((LulRegData & FR_59_RENESAS_FLX0MTCCV_FLX0CCV_MASK) >> FR_59_RENESAS_FLX0MTCCV_FLX0CCV_SHIFT); /* Update the Output parameter Fr_MacroTickPtr with the current macrotick value of CC */ *Fr_MacroTickPtr = (uint16)(LulRegData & FR_59_RENESAS_FLX0MTCCV_FLX0MTV_MASK); /* PRQA S 2814 # JV-03 */ } else { /* Raise DEM Error FAILED */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_CyclePtr', 'Value': '&map_Fr_CyclePtr[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_MacroTickPtr', 'Value': '&map_Fr_MacroTickPtr[0]'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FR_59_RENESAS_NORMAL_PASSIVE_STATE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx]', 'Value': '&map_Fr_59_Renesas_GpCtrlRegSet[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[0].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_CCStatusReg[0].ulFLXAnFRMTCCV', 'Value': '0xF0FFF'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_CyclePtr[0]', 'Value': '15'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_MacroTickPtr[0]', 'Value': '4095'], 'Output_Param_002': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_GetGlobalTime(VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ P2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_CyclePtr, P2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_MacroTickPtr) /* PRQA S 3432 # JV-01 */ { /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETGLOBALTIME_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETGLOBALTIME_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_CyclePtr is NULL pointer */ if (NULL_PTR == Fr_CyclePtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETGLOBALTIME_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_MacroTickPtr is NULL pointer */ if (NULL_PTR == Fr_MacroTickPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETGLOBALTIME_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Read the POC State by getting FLX0CCSV register value */ LucReturnValue = Fr_59_Renesas_GetCycleCounter(Fr_CtrlIdx, Fr_CyclePtr, Fr_MacroTickPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_CyclePtr', 'Value': '&map_Fr_CyclePtr'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_MacroTickPtr', 'Value': '&map_Fr_MacroTickPtr'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_NOT_OK'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_CyclePtr', 'Value': '1'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_MacroTickPtr', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CyclePtr', 'Value': '&map_Fr_CyclePtr'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_MacroTickPtr', 'Value': '&map_Fr_MacroTickPtr'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_CyclePtr', 'Value': '1'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_MacroTickPtr', 'Value': '1'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_GetPOCStatus(VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ P2VAR(Fr_POCStatusType, AUTOMATIC, FR_APPL_DATA) Fr_POCStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETPOCSTATUS_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETPOCSTATUS_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_POCStatusPtr is NULL pointer */ if (NULL_PTR == Fr_POCStatusPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_GETPOCSTATUS_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Update the POC status to output pointer */ LucReturnValue = Fr_59_Renesas_UpdatePOCSts(Fr_CtrlIdx, Fr_POCStatusPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 2'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_POCStatusPtr', 'Value': '&map_Fr_POCStatusPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'CHIHaltRequest', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 2'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_POCStatusPtr', 'Value': '&map_Fr_POCStatusPtr[0]'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_HaltInputQueueProcess(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2CONST(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_CONST) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, TYPEDEF, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint32 LulData; uint32 LulGetIndex; uint32 LulPutIndex; uint32 LulQueueMax; volatile uint16 LusLoopCount; uint8 LucMsgBuffer1; uint8 LucMsgBuffer2; uint8 LucMsgBufferMask; uint8 LucFRDAindex; boolean LblQueueHalted; P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpInputPointerTablePtr; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* Initialize queue status as running */ LblQueueHalted = FR_59_RENESAS_FALSE; /* Read current value of FLX0FRITS register */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Input Transfer enable */ if (FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Halt input transfer queue */ LulData = LulData | FR_59_RENESAS_FLX0FRITC_FLX0_IQHR_MASK; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; /* Wait input queue is halted */ while ((FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != /* PRQA S 3415, 3416 # JV-01, JV-01 */ (LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Set queue status as halted */ LblQueueHalted = FR_59_RENESAS_TRUE; /* Get the Message buffer from control register */ LucMsgBuffer1 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-03 */ /* Get the position of DA flag to be checked */ LucMsgBufferMask = LucMsgBuffer1 & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMsgBuffer1 >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; /* Check whether the frame is already transferred by polling the corresponding DA flag */ if (FR_59_RENESAS_FLX0FRDA_INDEX_ZERO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA0; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_ONE == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA1; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_TWO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA2; } else { LulData = LpDataTransferStatusReg->ulFLXAnFRDA3; } /* Check if the corresponding DA flag is set */ if ((uint32)FR_59_RENESAS_ONE == ((LulData >> LucMsgBufferMask) & (uint32)FR_59_RENESAS_ONE)) { /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } if (E_OK == LucReturnValue) { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; /* Get the put index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IPIDX_MASK; LulPutIndex = LulData >> FR_59_RENESAS_SIXTEEN; /* Get the get index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IGIDX_MASK; LulGetIndex = LulData >> FR_59_RENESAS_TWENTYFOUR; /* Get the Input queue table max value */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; LulQueueMax = LulData >> FR_59_RENESAS_SIXTEEN; do { /* Read current value of FLX0FRIBA register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* Get the address to write the control reg and data pointer */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (LulGetIndex * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383 # JV-01 */ /* Get the Message buffer at get index */ LucMsgBuffer1 = (uint8)((LpInputPointerTablePtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-01 */ /* Get the Message buffer from control register */ LucMsgBuffer2 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* Check whether the message buffer is same */ if (LucMsgBuffer1 == LucMsgBuffer2) { if ((uint32)FR_59_RENESAS_ZERO < ((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK)) { /* Write the control reg in input pointer */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = ((LpInputPointerTablePtr->ulFLX0FRWRHS4) | FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK); /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else { LulGetIndex = ((LulGetIndex + (uint32)FR_59_RENESAS_ONE) % (LulQueueMax + (uint32)FR_59_RENESAS_ONE)); /* PRQA S 3383 # JV-01 */ } } while ((LulPutIndex != LulGetIndex) && (E_OK != LucReturnValue)); } /* else No Action required */ /* Check whether queue was halted */ if (FR_59_RENESAS_TRUE == LblQueueHalted) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* Input queue run request */ LulData = LulData & FR_59_RENESAS_FLX0FRITC_IQHR_RESET; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] =  &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] =  &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS\\n', 'Value': '0x10003'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '1'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_011': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr[0].ulFLX0FRWRHS4\\n', 'Value': '0x20'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '&map_InputData[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '[0] = 0x00'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '0x01'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x10000']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x10000'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_HaltInputQueueProcess(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2CONST(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_CONST) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, TYPEDEF, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint32 LulData; uint32 LulGetIndex; uint32 LulPutIndex; uint32 LulQueueMax; volatile uint16 LusLoopCount; uint8 LucMsgBuffer1; uint8 LucMsgBuffer2; uint8 LucMsgBufferMask; uint8 LucFRDAindex; boolean LblQueueHalted; P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpInputPointerTablePtr; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* Initialize queue status as running */ LblQueueHalted = FR_59_RENESAS_FALSE; /* Read current value of FLX0FRITS register */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Input Transfer enable */ if (FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Halt input transfer queue */ LulData = LulData | FR_59_RENESAS_FLX0FRITC_FLX0_IQHR_MASK; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; /* Wait input queue is halted */ while ((FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != /* PRQA S 3415, 3416 # JV-01, JV-01 */ (LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Set queue status as halted */ LblQueueHalted = FR_59_RENESAS_TRUE; /* Get the Message buffer from control register */ LucMsgBuffer1 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-03 */ /* Get the position of DA flag to be checked */ LucMsgBufferMask = LucMsgBuffer1 & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMsgBuffer1 >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; /* Check whether the frame is already transferred by polling the corresponding DA flag */ if (FR_59_RENESAS_FLX0FRDA_INDEX_ZERO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA0; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_ONE == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA1; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_TWO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA2; } else { LulData = LpDataTransferStatusReg->ulFLXAnFRDA3; } /* Check if the corresponding DA flag is set */ if ((uint32)FR_59_RENESAS_ONE == ((LulData >> LucMsgBufferMask) & (uint32)FR_59_RENESAS_ONE)) { /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } if (E_OK == LucReturnValue) { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; /* Get the put index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IPIDX_MASK; LulPutIndex = LulData >> FR_59_RENESAS_SIXTEEN; /* Get the get index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IGIDX_MASK; LulGetIndex = LulData >> FR_59_RENESAS_TWENTYFOUR; /* Get the Input queue table max value */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; LulQueueMax = LulData >> FR_59_RENESAS_SIXTEEN; do { /* Read current value of FLX0FRIBA register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* Get the address to write the control reg and data pointer */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (LulGetIndex * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383 # JV-01 */ /* Get the Message buffer at get index */ LucMsgBuffer1 = (uint8)((LpInputPointerTablePtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-01 */ /* Get the Message buffer from control register */ LucMsgBuffer2 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* Check whether the message buffer is same */ if (LucMsgBuffer1 == LucMsgBuffer2) { if ((uint32)FR_59_RENESAS_ZERO < ((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK)) { /* Write the control reg in input pointer */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = ((LpInputPointerTablePtr->ulFLX0FRWRHS4) | FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK); /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else { LulGetIndex = ((LulGetIndex + (uint32)FR_59_RENESAS_ONE) % (LulQueueMax + (uint32)FR_59_RENESAS_ONE)); /* PRQA S 3383 # JV-01 */ } } while ((LulPutIndex != LulGetIndex) && (E_OK != LucReturnValue)); } /* else No Action required */ /* Check whether queue was halted */ if (FR_59_RENESAS_TRUE == LblQueueHalted) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* Input queue run request */ LulData = LulData & FR_59_RENESAS_FLX0FRITC_IQHR_RESET; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] =  &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] =  &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS\\n', 'Value': '0x20003'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_011': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr[0].ulFLX0FRWRHS4\\n', 'Value': '0x840'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '&map_InputData[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '[0] = 0x01\\n[1] = 0x40'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '0x01'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x20000']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x20000'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '[1] = 0x840'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_HaltInputQueueProcess(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2CONST(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_CONST) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, TYPEDEF, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint32 LulData; uint32 LulGetIndex; uint32 LulPutIndex; uint32 LulQueueMax; volatile uint16 LusLoopCount; uint8 LucMsgBuffer1; uint8 LucMsgBuffer2; uint8 LucMsgBufferMask; uint8 LucFRDAindex; boolean LblQueueHalted; P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpInputPointerTablePtr; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* Initialize queue status as running */ LblQueueHalted = FR_59_RENESAS_FALSE; /* Read current value of FLX0FRITS register */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Input Transfer enable */ if (FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Halt input transfer queue */ LulData = LulData | FR_59_RENESAS_FLX0FRITC_FLX0_IQHR_MASK; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; /* Wait input queue is halted */ while ((FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != /* PRQA S 3415, 3416 # JV-01, JV-01 */ (LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Set queue status as halted */ LblQueueHalted = FR_59_RENESAS_TRUE; /* Get the Message buffer from control register */ LucMsgBuffer1 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-03 */ /* Get the position of DA flag to be checked */ LucMsgBufferMask = LucMsgBuffer1 & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMsgBuffer1 >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; /* Check whether the frame is already transferred by polling the corresponding DA flag */ if (FR_59_RENESAS_FLX0FRDA_INDEX_ZERO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA0; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_ONE == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA1; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_TWO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA2; } else { LulData = LpDataTransferStatusReg->ulFLXAnFRDA3; } /* Check if the corresponding DA flag is set */ if ((uint32)FR_59_RENESAS_ONE == ((LulData >> LucMsgBufferMask) & (uint32)FR_59_RENESAS_ONE)) { /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } if (E_OK == LucReturnValue) { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; /* Get the put index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IPIDX_MASK; LulPutIndex = LulData >> FR_59_RENESAS_SIXTEEN; /* Get the get index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IGIDX_MASK; LulGetIndex = LulData >> FR_59_RENESAS_TWENTYFOUR; /* Get the Input queue table max value */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; LulQueueMax = LulData >> FR_59_RENESAS_SIXTEEN; do { /* Read current value of FLX0FRIBA register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* Get the address to write the control reg and data pointer */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (LulGetIndex * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383 # JV-01 */ /* Get the Message buffer at get index */ LucMsgBuffer1 = (uint8)((LpInputPointerTablePtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-01 */ /* Get the Message buffer from control register */ LucMsgBuffer2 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* Check whether the message buffer is same */ if (LucMsgBuffer1 == LucMsgBuffer2) { if ((uint32)FR_59_RENESAS_ZERO < ((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK)) { /* Write the control reg in input pointer */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = ((LpInputPointerTablePtr->ulFLX0FRWRHS4) | FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK); /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else { LulGetIndex = ((LulGetIndex + (uint32)FR_59_RENESAS_ONE) % (LulQueueMax + (uint32)FR_59_RENESAS_ONE)); /* PRQA S 3383 # JV-01 */ } } while ((LulPutIndex != LulGetIndex) && (E_OK != LucReturnValue)); } /* else No Action required */ /* Check whether queue was halted */ if (FR_59_RENESAS_TRUE == LblQueueHalted) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* Input queue run request */ LulData = LulData & FR_59_RENESAS_FLX0FRITC_IQHR_RESET; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] =  &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] =  &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS\\n', 'Value': '0x7F7F0003'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_011': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr[0].ulFLX0FRWRHS4\\n', 'Value': '0x40'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '&map_InputData[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '[127] = 40'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '0x01'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x7F0000']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x7F0000'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_HaltInputQueueProcess(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2CONST(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_CONST) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, TYPEDEF, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint32 LulData; uint32 LulGetIndex; uint32 LulPutIndex; uint32 LulQueueMax; volatile uint16 LusLoopCount; uint8 LucMsgBuffer1; uint8 LucMsgBuffer2; uint8 LucMsgBufferMask; uint8 LucFRDAindex; boolean LblQueueHalted; P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpInputPointerTablePtr; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* Initialize queue status as running */ LblQueueHalted = FR_59_RENESAS_FALSE; /* Read current value of FLX0FRITS register */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Input Transfer enable */ if (FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Halt input transfer queue */ LulData = LulData | FR_59_RENESAS_FLX0FRITC_FLX0_IQHR_MASK; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; /* Wait input queue is halted */ while ((FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != /* PRQA S 3415, 3416 # JV-01, JV-01 */ (LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Set queue status as halted */ LblQueueHalted = FR_59_RENESAS_TRUE; /* Get the Message buffer from control register */ LucMsgBuffer1 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-03 */ /* Get the position of DA flag to be checked */ LucMsgBufferMask = LucMsgBuffer1 & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMsgBuffer1 >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; /* Check whether the frame is already transferred by polling the corresponding DA flag */ if (FR_59_RENESAS_FLX0FRDA_INDEX_ZERO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA0; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_ONE == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA1; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_TWO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA2; } else { LulData = LpDataTransferStatusReg->ulFLXAnFRDA3; } /* Check if the corresponding DA flag is set */ if ((uint32)FR_59_RENESAS_ONE == ((LulData >> LucMsgBufferMask) & (uint32)FR_59_RENESAS_ONE)) { /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } if (E_OK == LucReturnValue) { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; /* Get the put index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IPIDX_MASK; LulPutIndex = LulData >> FR_59_RENESAS_SIXTEEN; /* Get the get index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IGIDX_MASK; LulGetIndex = LulData >> FR_59_RENESAS_TWENTYFOUR; /* Get the Input queue table max value */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; LulQueueMax = LulData >> FR_59_RENESAS_SIXTEEN; do { /* Read current value of FLX0FRIBA register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* Get the address to write the control reg and data pointer */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (LulGetIndex * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383 # JV-01 */ /* Get the Message buffer at get index */ LucMsgBuffer1 = (uint8)((LpInputPointerTablePtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-01 */ /* Get the Message buffer from control register */ LucMsgBuffer2 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* Check whether the message buffer is same */ if (LucMsgBuffer1 == LucMsgBuffer2) { if ((uint32)FR_59_RENESAS_ZERO < ((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK)) { /* Write the control reg in input pointer */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = ((LpInputPointerTablePtr->ulFLX0FRWRHS4) | FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK); /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else { LulGetIndex = ((LulGetIndex + (uint32)FR_59_RENESAS_ONE) % (LulQueueMax + (uint32)FR_59_RENESAS_ONE)); /* PRQA S 3383 # JV-01 */ } } while ((LulPutIndex != LulGetIndex) && (E_OK != LucReturnValue)); } /* else No Action required */ /* Check whether queue was halted */ if (FR_59_RENESAS_TRUE == LblQueueHalted) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* Input queue run request */ LulData = LulData & FR_59_RENESAS_FLX0FRITC_IQHR_RESET; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] =  &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] =  &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS\\n', 'Value': '0x03'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '1'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_011': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr[0].ulFLX0FRWRHS4\\n', 'Value': '0x5F'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '&map_InputData[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '[0] = 0x00'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '0x80000000'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x00']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x00'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_HaltInputQueueProcess(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2CONST(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_CONST) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, TYPEDEF, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint32 LulData; uint32 LulGetIndex; uint32 LulPutIndex; uint32 LulQueueMax; volatile uint16 LusLoopCount; uint8 LucMsgBuffer1; uint8 LucMsgBuffer2; uint8 LucMsgBufferMask; uint8 LucFRDAindex; boolean LblQueueHalted; P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpInputPointerTablePtr; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* Initialize queue status as running */ LblQueueHalted = FR_59_RENESAS_FALSE; /* Read current value of FLX0FRITS register */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Input Transfer enable */ if (FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Halt input transfer queue */ LulData = LulData | FR_59_RENESAS_FLX0FRITC_FLX0_IQHR_MASK; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; /* Wait input queue is halted */ while ((FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != /* PRQA S 3415, 3416 # JV-01, JV-01 */ (LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Set queue status as halted */ LblQueueHalted = FR_59_RENESAS_TRUE; /* Get the Message buffer from control register */ LucMsgBuffer1 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-03 */ /* Get the position of DA flag to be checked */ LucMsgBufferMask = LucMsgBuffer1 & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMsgBuffer1 >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; /* Check whether the frame is already transferred by polling the corresponding DA flag */ if (FR_59_RENESAS_FLX0FRDA_INDEX_ZERO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA0; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_ONE == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA1; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_TWO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA2; } else { LulData = LpDataTransferStatusReg->ulFLXAnFRDA3; } /* Check if the corresponding DA flag is set */ if ((uint32)FR_59_RENESAS_ONE == ((LulData >> LucMsgBufferMask) & (uint32)FR_59_RENESAS_ONE)) { /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } if (E_OK == LucReturnValue) { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; /* Get the put index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IPIDX_MASK; LulPutIndex = LulData >> FR_59_RENESAS_SIXTEEN; /* Get the get index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IGIDX_MASK; LulGetIndex = LulData >> FR_59_RENESAS_TWENTYFOUR; /* Get the Input queue table max value */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; LulQueueMax = LulData >> FR_59_RENESAS_SIXTEEN; do { /* Read current value of FLX0FRIBA register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* Get the address to write the control reg and data pointer */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (LulGetIndex * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383 # JV-01 */ /* Get the Message buffer at get index */ LucMsgBuffer1 = (uint8)((LpInputPointerTablePtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-01 */ /* Get the Message buffer from control register */ LucMsgBuffer2 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* Check whether the message buffer is same */ if (LucMsgBuffer1 == LucMsgBuffer2) { if ((uint32)FR_59_RENESAS_ZERO < ((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK)) { /* Write the control reg in input pointer */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = ((LpInputPointerTablePtr->ulFLX0FRWRHS4) | FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK); /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else { LulGetIndex = ((LulGetIndex + (uint32)FR_59_RENESAS_ONE) % (LulQueueMax + (uint32)FR_59_RENESAS_ONE)); /* PRQA S 3383 # JV-01 */ } } while ((LulPutIndex != LulGetIndex) && (E_OK != LucReturnValue)); } /* else No Action required */ /* Check whether queue was halted */ if (FR_59_RENESAS_TRUE == LblQueueHalted) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* Input queue run request */ LulData = LulData & FR_59_RENESAS_FLX0FRITC_IQHR_RESET; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] =  &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] =  &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS\\n', 'Value': '0x7F7F0003'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_011': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr[0].ulFLX0FRWRHS4\\n', 'Value': '0x85F'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '&map_InputData[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '[127] = 00\\n[1] = 0x5F'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '0x80000000'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x7F0000']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x7F0000'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '[127] = 0x00\\n[1] = 0x85F'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_HaltInputQueueProcess(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2CONST(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_CONST) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, TYPEDEF, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint32 LulData; uint32 LulGetIndex; uint32 LulPutIndex; uint32 LulQueueMax; volatile uint16 LusLoopCount; uint8 LucMsgBuffer1; uint8 LucMsgBuffer2; uint8 LucMsgBufferMask; uint8 LucFRDAindex; boolean LblQueueHalted; P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpInputPointerTablePtr; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* Initialize queue status as running */ LblQueueHalted = FR_59_RENESAS_FALSE; /* Read current value of FLX0FRITS register */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Input Transfer enable */ if (FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Halt input transfer queue */ LulData = LulData | FR_59_RENESAS_FLX0FRITC_FLX0_IQHR_MASK; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; /* Wait input queue is halted */ while ((FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != /* PRQA S 3415, 3416 # JV-01, JV-01 */ (LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Set queue status as halted */ LblQueueHalted = FR_59_RENESAS_TRUE; /* Get the Message buffer from control register */ LucMsgBuffer1 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-03 */ /* Get the position of DA flag to be checked */ LucMsgBufferMask = LucMsgBuffer1 & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMsgBuffer1 >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; /* Check whether the frame is already transferred by polling the corresponding DA flag */ if (FR_59_RENESAS_FLX0FRDA_INDEX_ZERO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA0; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_ONE == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA1; } else if (FR_59_RENESAS_FLX0FRDA_INDEX_TWO == LucFRDAindex) { LulData = LpDataTransferStatusReg->ulFLXAnFRDA2; } else { LulData = LpDataTransferStatusReg->ulFLXAnFRDA3; } /* Check if the corresponding DA flag is set */ if ((uint32)FR_59_RENESAS_ONE == ((LulData >> LucMsgBufferMask) & (uint32)FR_59_RENESAS_ONE)) { /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } if (E_OK == LucReturnValue) { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; /* Get the put index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IPIDX_MASK; LulPutIndex = LulData >> FR_59_RENESAS_SIXTEEN; /* Get the get index */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_IGIDX_MASK; LulGetIndex = LulData >> FR_59_RENESAS_TWENTYFOUR; /* Get the Input queue table max value */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; LulQueueMax = LulData >> FR_59_RENESAS_SIXTEEN; do { /* Read current value of FLX0FRIBA register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* Get the address to write the control reg and data pointer */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (LulGetIndex * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383 # JV-01 */ /* Get the Message buffer at get index */ LucMsgBuffer1 = (uint8)((LpInputPointerTablePtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* PRQA S 2814 # JV-01 */ /* Get the Message buffer from control register */ LucMsgBuffer2 = (uint8)((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* Check whether the message buffer is same */ if (LucMsgBuffer1 == LucMsgBuffer2) { if ((uint32)FR_59_RENESAS_ZERO < ((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK)) { /* Write the control reg in input pointer */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = ((LpInputPointerTablePtr->ulFLX0FRWRHS4) | FR_59_RENESAS_FLX0FRWRHS4_FLX0_INV_MASK); /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else { LulGetIndex = ((LulGetIndex + (uint32)FR_59_RENESAS_ONE) % (LulQueueMax + (uint32)FR_59_RENESAS_ONE)); /* PRQA S 3383 # JV-01 */ } } while ((LulPutIndex != LulGetIndex) && (E_OK != LucReturnValue)); } /* else No Action required */ /* Check whether queue was halted */ if (FR_59_RENESAS_TRUE == LblQueueHalted) { /* Read the input transfer control register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* Input queue run request */ LulData = LulData & FR_59_RENESAS_FLX0FRITC_IQHR_RESET; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] =  &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] =  &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS\\n', 'Value': '0x1000003'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '1'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_011': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr[0].ulFLX0FRWRHS4\\n', 'Value': '0x60'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '&map_InputData[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '[1] = 0x00'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '0x01'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x10000']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x10000'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_InputData[0 to 128].ulFLX0FRWRHS4', 'Value': '-'], 'Output_Param_006': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" FUNC(void, FR_PUBLIC_CODE) Fr_59_Renesas_Init(P2CONST(Fr_59_Renesas_ConfigType, AUTOMATIC, FR_APPL_CONST) Fr_ConfigPtr) /* PRQA S 1503, 3432 # JV-01, JV-01 */ { #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Declare pointer to control table configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare variable to store the index of reconfigurable frame */ uint16 LusFrameCnt; #endif /* Declare the variable to store the index of Fr controller */ uint8 LucCtrlIdx; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check whether the input pointer is null */ if (NULL_PTR == Fr_ConfigPtr) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_INIT_SID, FR_59_RENESAS_E_PARAM_POINTER); } /* Check whether the existing database is correct */ else if (FR_59_RENESAS_DBTOC_VALUE != Fr_ConfigPtr->ulStartOfDbToc) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_INIT_SID, FR_59_RENESAS_E_INVALID_DATABASE); } else #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Assign the config pointer value to global pointer */ { /* Store the global pointer to the controller structure */ Fr_59_Renesas_GpControllerConfigPtr = Fr_ConfigPtr->pControllerConfig; /* PRQA S 2814 # JV-03 */ for (LucCtrlIdx = FR_59_RENESAS_ZERO; LucCtrlIdx < FR_59_RENESAS_NUM_CTRL_SUPPORTED; LucCtrlIdx++) /* PRQA S 2877 # JV-01 */ { /* Initialize global pointer to the Hardware register structure */ Fr_59_Renesas_GpCtrlRegSet[LucCtrlIdx] = Fr_59_Renesas_GpControllerConfigPtr[LucCtrlIdx].pCtrlReg; #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Initialize global pointer of Buffer Reconfig Status */ Fr_59_Renesas_GpBufReconfigStatusPtr[LucCtrlIdx] = (Fr_59_Renesas_GpControllerConfigPtr[LucCtrlIdx].pBufferReConfigStatus); /* Store the global pointer to FlexRay Control Table */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[LucCtrlIdx].pCtrlTable); /* Initialize the value invalid LPdu index for all reconfigured frame */ for (LusFrameCnt = FR_59_RENESAS_ZERO; LusFrameCnt < LpCtrlTable->usMaxFrames; LusFrameCnt++) /* PRQA S 2814 # JV-02 */ { Fr_59_Renesas_GpBufReconfigStatusPtr[LucCtrlIdx][LusFrameCnt] = FR_59_RENESAS_INVALID_LPDUID; } #endif } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) Fr_59_Renesas_InitDone(); #endif } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_RECONFIG_LPDU', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_PREPARE_LPDU', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DISABLE_LPDU', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ConfigPtr', 'Value': '&map_Fr_ConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'ulStartOfDbToc', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pControllerConfig', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pCtrlReg', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pBufferReConfigStatus', 'Value': '-'], 'Input_Param_009': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FR_59_RENESAS_E_INVALID_DATABASE'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FR_59_RENESAS_MODULE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FR_59_RENESAS_INSTANCE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FR_59_RENESAS_INIT_SID'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpBufReconfigStatusPtr[0 to 1]', 'Value': '-'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '-'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus0[0 to 0]', 'Value': '-'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus1[0 to 0]', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" FUNC(void, FR_PUBLIC_CODE) Fr_59_Renesas_Init(P2CONST(Fr_59_Renesas_ConfigType, AUTOMATIC, FR_APPL_CONST) Fr_ConfigPtr) /* PRQA S 1503, 3432 # JV-01, JV-01 */ { #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Declare pointer to control table configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare variable to store the index of reconfigurable frame */ uint16 LusFrameCnt; #endif /* Declare the variable to store the index of Fr controller */ uint8 LucCtrlIdx; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check whether the input pointer is null */ if (NULL_PTR == Fr_ConfigPtr) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_INIT_SID, FR_59_RENESAS_E_PARAM_POINTER); } /* Check whether the existing database is correct */ else if (FR_59_RENESAS_DBTOC_VALUE != Fr_ConfigPtr->ulStartOfDbToc) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_INIT_SID, FR_59_RENESAS_E_INVALID_DATABASE); } else #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Assign the config pointer value to global pointer */ { /* Store the global pointer to the controller structure */ Fr_59_Renesas_GpControllerConfigPtr = Fr_ConfigPtr->pControllerConfig; /* PRQA S 2814 # JV-03 */ for (LucCtrlIdx = FR_59_RENESAS_ZERO; LucCtrlIdx < FR_59_RENESAS_NUM_CTRL_SUPPORTED; LucCtrlIdx++) /* PRQA S 2877 # JV-01 */ { /* Initialize global pointer to the Hardware register structure */ Fr_59_Renesas_GpCtrlRegSet[LucCtrlIdx] = Fr_59_Renesas_GpControllerConfigPtr[LucCtrlIdx].pCtrlReg; #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Initialize global pointer of Buffer Reconfig Status */ Fr_59_Renesas_GpBufReconfigStatusPtr[LucCtrlIdx] = (Fr_59_Renesas_GpControllerConfigPtr[LucCtrlIdx].pBufferReConfigStatus); /* Store the global pointer to FlexRay Control Table */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[LucCtrlIdx].pCtrlTable); /* Initialize the value invalid LPdu index for all reconfigured frame */ for (LusFrameCnt = FR_59_RENESAS_ZERO; LusFrameCnt < LpCtrlTable->usMaxFrames; LusFrameCnt++) /* PRQA S 2814 # JV-02 */ { Fr_59_Renesas_GpBufReconfigStatusPtr[LucCtrlIdx][LusFrameCnt] = FR_59_RENESAS_INVALID_LPDUID; } #endif } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) Fr_59_Renesas_InitDone(); #endif } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_RECONFIG_LPDU', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_PREPARE_LPDU', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DISABLE_LPDU', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ConfigPtr', 'Value': '&map_Fr_ConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'ulStartOfDbToc', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pControllerConfig', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pCtrlReg', 'Value': '[0] = Fr_59_Renesas_GpCtrlRegSet'], 'Input_Param_008': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pBufferReConfigStatus', 'Value': '[0] = &map_Fr_59_Renesas_GpBufferReConfigStatus0[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '[0] = &map_Fr_59_Renesas_CtrlTable[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '[0] = 1 '], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpBufReconfigStatusPtr[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpBufferReConfigStatus0[0]'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = Fr_59_Renesas_GpCtrlRegSet'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus0[0 to 0]', 'Value': '[0] = FR_59_RENESAS_INVALID_LPDUID'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus1[0 to 0]', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_InputTransferRequest(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpInputPointerTablePtr; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; uint32 LulData; uint32 LulData_Size; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; /* Check for Input Transfer enabled, input queue is not halted and no pending user input transfer requested */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2814, 2844 # JV-02, JV-01 */ if ((FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) && (FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK)) && (FR_59_RENESAS_FLX0FRITS_FLX0_UIRP_MASK != (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_UIRP_MASK))) { /* Get the input pointer table base address */ LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Get the size of the input pointer table */ /* Read the first msg buffer of FIFO from FRMRC register */ LulData_Size = LpDataTransferCtrlReg->ulFLXAnFRITC; LulData_Size = LulData_Size & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; /* User input transfer address */ /* Calculate user input transfer address */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (((LulData_Size >> FR_59_RENESAS_SIXTEEN) + (uint32)FR_59_RENESAS_ONE) * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383, 3384 # JV-01, JV-01 */ /* Write the control register in user input pointer table */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = (Fr_InputTableContentPtr->ulFLX0FRWRHS4); /* PRQA S 2814 # JV-01 */ /* Write the Data pointer in user input pointer table */ LpInputPointerTablePtr->Fr_59_Renesas_pInputDataPtr = (Fr_InputTableContentPtr->Fr_59_Renesas_pInputDataPtr); /* Get the size to calculate UIDX */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; LulData = LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; /* User requested pointer index */ LulData = (LulData >> FR_59_RENESAS_SIXTEEN) + (uint32)FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ /* Update the Input pointer table index requested for input transfer */ /* Writing in to FlexRay User Input transfer Request Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRUIR = LulData; LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL, !NULL', 'Name': 'Fr_59_Renesas_pInputDataPtr', 'Value': '&map_pInputDataPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLX0FRWRHS4', 'Value': '1'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS', 'Value': '0x1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '&map_Fr_InputTableContentPtr_1[0].ulFLX0FRWRHS4'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr_1[0 to 9].ulFLX0FRWRHS4', 'Value': '[0 to 9] = 0x0'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '0x0']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr_1[0 to 9].ulFLX0FRWRHS4', 'Value': '[1] = 1'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr_1[0 to 9].Fr_59_Renesas_pInputDataPtr', 'Value': '[1] = &map_pInputDataPtr[0]'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRUIR', 'Value': '0x1'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_InputTransferRequest(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpInputPointerTablePtr; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; uint32 LulData; uint32 LulData_Size; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; /* Check for Input Transfer enabled, input queue is not halted and no pending user input transfer requested */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2814, 2844 # JV-02, JV-01 */ if ((FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) && (FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK)) && (FR_59_RENESAS_FLX0FRITS_FLX0_UIRP_MASK != (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_UIRP_MASK))) { /* Get the input pointer table base address */ LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Get the size of the input pointer table */ /* Read the first msg buffer of FIFO from FRMRC register */ LulData_Size = LpDataTransferCtrlReg->ulFLXAnFRITC; LulData_Size = LulData_Size & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; /* User input transfer address */ /* Calculate user input transfer address */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (((LulData_Size >> FR_59_RENESAS_SIXTEEN) + (uint32)FR_59_RENESAS_ONE) * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383, 3384 # JV-01, JV-01 */ /* Write the control register in user input pointer table */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = (Fr_InputTableContentPtr->ulFLX0FRWRHS4); /* PRQA S 2814 # JV-01 */ /* Write the Data pointer in user input pointer table */ LpInputPointerTablePtr->Fr_59_Renesas_pInputDataPtr = (Fr_InputTableContentPtr->Fr_59_Renesas_pInputDataPtr); /* Get the size to calculate UIDX */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; LulData = LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITM_MASK; /* User requested pointer index */ LulData = (LulData >> FR_59_RENESAS_SIXTEEN) + (uint32)FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ /* Update the Input pointer table index requested for input transfer */ /* Writing in to FlexRay User Input transfer Request Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRUIR = LulData; LucReturnValue = E_OK; } else { /* Raise DEM Error FAILED */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL, !NULL', 'Name': 'Fr_59_Renesas_pInputDataPtr', 'Value': '&map_pInputDataPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLX0FRWRHS4', 'Value': '0'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS', 'Value': '0x3'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '1'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '-'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr_1[0 to 9].ulFLX0FRWRHS4', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr_1[0 to 9].ulFLX0FRWRHS4', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr_1[0 to 9].Fr_59_Renesas_pInputDataPtr', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRUIR', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_LoadCfgLowLevelParameters(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2CONST(Fr_59_Renesas_LowLevelConfSetType, AUTOMATIC, FR_APPL_CONST) pLowLevelCfgPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_InterruptRegType, AUTOMATIC, REGSPACE) LpIntReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_TimerRegType, AUTOMATIC, REGSPACE) LpTimerReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_MessageBufferControlRegType, AUTOMATIC, REGSPACE) LpMBCtrlReg; /* PRQA S 3432 # JV-01 */ #if ((FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) || (FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) || \\ (FR_59_RENESAS_ENABLE_OUTPUT_RX_FIFO_HANDLER == STD_ON)) P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ #endif /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; /* Initialize the default return value */ LucReturnValue = E_OK; /* NULL pointer checking for input parameter */ if (NULL_PTR == pLowLevelCfgPtr) { LucReturnValue = E_NOT_OK; } else { /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpIntReg = LpCtrlRegSet->pIntReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LpTimerReg = LpCtrlRegSet->pTimerReg; LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; LpMBCtrlReg = LpCtrlRegSet->pMBCtrlReg; #if ((FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) || (FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) || \\ (FR_59_RENESAS_ENABLE_OUTPUT_RX_FIFO_HANDLER == STD_ON)) LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; #endif /* Writing into FlexRay Error Interrupt Line Select Register and mirror address */ LpIntReg->ulFLXAnFREILS = pLowLevelCfgPtr->ulFrErrorIntpLineSelect; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Writing into FlexRay Status Interrupt Line Select Register and mirror address */ LpIntReg->ulFLXAnFRSILS = pLowLevelCfgPtr->ulFrStatusIntpLineSelect; /* Writing into FlexRay Error Interrupt Enable Set Register and mirror address */ LpIntReg->ulFLXAnFREIES = pLowLevelCfgPtr->ulFrErrorIntpEnable; /* Writing into FlexRay Status Interrupt Enable Set Register and mirror address */ LpIntReg->ulFLXAnFRSIES = pLowLevelCfgPtr->ulFrStatusIntpEnable; /* Writing into FlexRay Interrupt Line Enable Register and mirror address */ LpIntReg->ulFLXAnFRILE = pLowLevelCfgPtr->ulFrIntpLineEnable; /* Writing into FlexRay Stop Watch Register 1 and mirror address */ LpTimerReg->ulFLXAnFRSTPW1 = pLowLevelCfgPtr->ulFrStopWatchConfig; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Writing into FlexRay SUC Configuration Register 1 and mirror address */ LpCCCtrlReg->ulFLXAnFRSUCC1 = pLowLevelCfgPtr->ulFrSUCC1Config; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Writing into FlexRay SUC Configuration Register 2 and mirror address */ LpCCCtrlReg->ulFLXAnFRSUCC2 = pLowLevelCfgPtr->ulFrSUCC2Config; /* Writing into FlexRay SUC Configuration Register 3 and mirror address */ LpCCCtrlReg->ulFLXAnFRSUCC3 = pLowLevelCfgPtr->ulFrSUCC3Config; /* Writing into FlexRay NEM Configuration Register and mirror address */ LpCCCtrlReg->ulFLXAnFRNEMC = pLowLevelCfgPtr->ulFrNEMConfig; /* Writing into FlexRay PRT Configuration Register 1 and mirror address */ LpCCCtrlReg->ulFLXAnFRPRTC1 = pLowLevelCfgPtr->ulFrPRTC1Config; /* Writing into FlexRay PRT Configuration Register 2 and mirror address */ LpCCCtrlReg->ulFLXAnFRPRTC2 = pLowLevelCfgPtr->ulFrPRTC2Config; /* Writing into FlexRay MHD Configuration Register and mirror address */ LpCCCtrlReg->ulFLXAnFRMHDC = pLowLevelCfgPtr->ulFrMHDCConfig; /* Writing into FlexRay GTU Configuration Register 1 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC1 = pLowLevelCfgPtr->ulFrGTUC1Config; /* Writing into FlexRay GTU Configuration Register 2 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC2 = pLowLevelCfgPtr->ulFrGTUC2Config; /* Writing into FlexRay GTU Configuration Register 3 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC3 = pLowLevelCfgPtr->ulFrGTUC3Config; /* Writing into FlexRay GTU Configuration Register 4 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC4 = pLowLevelCfgPtr->ulFrGTUC4Config; /* Writing into FlexRay GTU Configuration Register 5 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC5 = pLowLevelCfgPtr->ulFrGTUC5Config; /* Writing into FlexRay GTU Configuration Register 6 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC6 = pLowLevelCfgPtr->ulFrGTUC6Config; /* Writing into FlexRay GTU Configuration Register 7 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC7 = pLowLevelCfgPtr->ulFrGTUC7Config; /* Writing into FlexRay GTU Configuration Register 8 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC8 = pLowLevelCfgPtr->ulFrGTUC8Config; /* Writing into FlexRay GTU Configuration Register 9 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC9 = pLowLevelCfgPtr->ulFrGTUC9Config; /* Writing into FlexRay GTU Configuration Register 10 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC10 = pLowLevelCfgPtr->ulFrGTUC10Config; /* Writing into FlexRay GTU Configuration Register 11 and mirror address */ LpCCCtrlReg->ulFLXAnFRGTUC11 = pLowLevelCfgPtr->ulFrGTUC11Config; /* Writing into FlexRay Message RAM Configuration Register and mirror address */ LpMBCtrlReg->ulFLXAnFRMRC = pLowLevelCfgPtr->ulFrMRCConfig; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Writing into FlexRay FIFO Rejection Filter Register and mirror address */ LpMBCtrlReg->ulFLXAnFRFRF = pLowLevelCfgPtr->ulFrFRFConfig; /* Writing into FlexRay FIFO Rejection Filter Mask Register and mirror address */ LpMBCtrlReg->ulFLXAnFRFRFM = pLowLevelCfgPtr->ulFrFRFMConfig; /* Writing into FlexRay FIFO Critical Level Register and mirror address */ LpMBCtrlReg->ulFLXAnFRFCL = pLowLevelCfgPtr->ulFrFCLConfig; #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) /* Writing into FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = pLowLevelCfgPtr->ulFrInputTxConfReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Writing into FlexRay Input pointer table Base Address Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRIBA = pLowLevelCfgPtr->ulFrInpPtrTblBaseAddReg; #endif #if (FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) /* Writing into FlexRay Output pointer table Base Address Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFROBA = pLowLevelCfgPtr->ulFrOptPtrTblBaseAddReg; #endif #if (FR_59_RENESAS_ENABLE_OUTPUT_RX_FIFO_HANDLER == STD_ON) /* Writing into FlexRay Output Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFROTC = pLowLevelCfgPtr->ulFrOutputTxConfReg; /* Writing into FlexRay FIFO pointer table Base Address Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRFBA = pLowLevelCfgPtr->ulFrFIFOPtrTblBaseAddReg; #endif } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_ENABLE_OUTPUT_RX_FIFO_HANDLER', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_004': ['Type': 'Argument', 'Range': '!NULL_PTR', 'Name': 'pLowLevelCfgPtr', 'Value': '&map_pLowLevelCfgPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0x00000000..0x07070FFF', 'Name': 'ulFrErrorIntpLineSelect', 'Value': '0x00000001'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0x00000000..0x0303FFFF', 'Name': 'ulFrStatusIntpLineSelect', 'Value': '0x00000002'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0x00000000..0x07070FFF', 'Name': 'ulFrErrorIntpEnable', 'Value': '0x00000003'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0x00000000..0x0303FFFF', 'Name': 'ulFrStatusIntpEnable', 'Value': '0x00000004'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0x00000000..0x00000003', 'Name': 'ulFrIntpLineEnable', 'Value': '0x00000005'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0x00000000..0x0000007F', 'Name': 'ulFrStopWatchConfig', 'Value': '0x00000008'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0x00001000..0x0CFFFB00', 'Name': 'ulFrSUCC1Config', 'Value': '0x00001000'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0x01000504..0x0F139706', 'Name': 'ulFrSUCC2Config', 'Value': '0x01000504'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0x00000011..0x000000FF', 'Name': 'ulFrSUCC3Config', 'Value': '0x00000011'], 'Input_Param_014': ['Type': 'Variable', 'Range': '0x00000000..0x0000000C', 'Name': 'ulFrNEMConfig', 'Value': '0x00000012'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0x084C0433..0xF92DF63F', 'Name': 'ulFrPRTC1Config', 'Value': '0x084C0433'], 'Input_Param_016': ['Type': 'Variable', 'Range': '0x0F2D0A0E..0x3CB4373B', 'Name': 'ulFrPRTC2Config', 'Value': '0x0F2D0A0E'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0x00000000..0x0F2D007F', 'Name': 'ulFrMHDCConfig', 'Value': '0x00000015'], 'Input_Param_018': ['Type': 'Variable', 'Range': '0x00000280..0x0009C400', 'Name': 'ulFrGTUC1Config', 'Value': '0x00000280'], 'Input_Param_019': ['Type': 'Variable', 'Range': '0x0002000A..0x000F0E80', 'Name': 'ulFrGTUC2Config', 'Value': '0x0002000A'], 'Input_Param_020': ['Type': 'Variable', 'Range': '0x02020000..0x73724040', 'Name': 'ulFrGTUC3Config', 'Value': '0x02020000'], 'Input_Param_021': ['Type': 'Variable', 'Range': '0x00080007..0x3E7E3E7D', 'Name': 'ulFrGTUC4Config', 'Value': '0x00080007'], 'Input_Param_022': ['Type': 'Variable', 'Range': '0x0E000000..0x8F14C8C8', 'Name': 'ulFrGTUC5Config', 'Value': '0x0E000000'], 'Input_Param_023': ['Type': 'Variable', 'Range': '0x00020000..0x07830753', 'Name': 'ulFrGTUC6Config', 'Value': '0x00020000'], 'Input_Param_024': ['Type': 'Variable', 'Range': '0x00020004..0x03FF0293', 'Name': 'ulFrGTUC7Config', 'Value': '0x00020004'], 'Input_Param_025': ['Type': 'Variable', 'Range': '0x00000002..0x1F32003F', 'Name': 'ulFrGTUC8Config', 'Value': '0x00000002'], 'Input_Param_026': ['Type': 'Variable', 'Range': '0x00000101..0x00021F3F', 'Name': 'ulFrGTUC9Config', 'Value': '0x00000101'], 'Input_Param_027': ['Type': 'Variable', 'Range': '0x00020005..0x07833BA2', 'Name': 'ulFrGTUC10Config', 'Value': '0x00020005'], 'Input_Param_028': ['Type': 'Variable', 'Range': '0x00000000..0x07070000', 'Name': 'ulFrGTUC11Config', 'Value': '0x00000026'], 'Input_Param_029': ['Type': 'Variable', 'Range': '0x00000000..0x07808080', 'Name': 'ulFrMRCConfig', 'Value': '0x00000027'], 'Input_Param_030': ['Type': 'Variable', 'Range': '0x00000000..0x01871FFF', 'Name': 'ulFrFRFConfig', 'Value': '0x00000028'], 'Input_Param_031': ['Type': 'Variable', 'Range': '0x00000000..0x000007FF', 'Name': 'ulFrFRFMConfig', 'Value': '0x00000029'], 'Input_Param_032': ['Type': 'Variable', 'Range': 'see Generation Rule', 'Name': 'ulFrFCLConfig', 'Value': '0x00000030'], 'Input_Param_033': ['Type': 'Variable', 'Range': '0x00000000..0x007F0000', 'Name': 'ulFrInputTxConfReg', 'Value': '0x00000031'], 'Input_Param_034': ['Type': 'Variable', 'Range': '0xFE000000..0xFE0AFFFC', 'Name': 'ulFrInpPtrTblBaseAddReg', 'Value': '0x00000032'], 'Input_Param_035': ['Type': 'Variable', 'Range': '0xFE000000..0xFE0AFFFC', 'Name': 'ulFrOptPtrTblBaseAddReg', 'Value': '0x00000033'], 'Input_Param_036': ['Type': 'Variable', 'Range': '0x00000000..0x001F0000', 'Name': 'ulFrOutputTxConfReg', 'Value': '0x00000034'], 'Input_Param_037': ['Type': 'Variable', 'Range': '0xFE000000..0xFE0AFFFC', 'Name': 'ulFrFIFOPtrTblBaseAddReg', 'Value': '0x00000035'], 'Input_Param_038': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_039': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pIntReg', 'Value': '&map_IntReg[0]'], 'Input_Param_040': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pTimerReg', 'Value': '&map_TimerReg[0]'], 'Input_Param_041': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_042': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pMBCtrlReg', 'Value': '&map_MBCtrlReg[0]'], 'Input_Param_043': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFREILS', 'Value': '0x00000001'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRSILS', 'Value': '0x00000002'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFREIES', 'Value': '0x00000003'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRSIES', 'Value': '0x00000004'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRILE', 'Value': '0x00000005'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRSTPW1', 'Value': '0x00000008'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRSUCC1', 'Value': '0x00001000'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRSUCC2', 'Value': '0x01000504'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRSUCC3', 'Value': '0x00000011'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRNEMC', 'Value': '0x00000012'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRPRTC1', 'Value': '0x084C0433'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRPRTC2', 'Value': '0x0F2D0A0E'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRMHDC', 'Value': '0x00000015'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC1', 'Value': '0x00000280'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC2', 'Value': '0x0002000A'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC3', 'Value': '0x02020000'], 'Output_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC4', 'Value': '0x00080007'], 'Output_Param_018': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC5', 'Value': '0x0E000000'], 'Output_Param_019': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC6', 'Value': '0x00020000'], 'Output_Param_020': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC7', 'Value': '0x00020004'], 'Output_Param_021': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC8', 'Value': '0x00000002'], 'Output_Param_022': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC9', 'Value': '0x00000101'], 'Output_Param_023': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC10', 'Value': '0x00020005'], 'Output_Param_024': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRGTUC11', 'Value': '0x00000026'], 'Output_Param_025': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRMRC', 'Value': '0x00000027'], 'Output_Param_026': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRFRF', 'Value': '0x00000028'], 'Output_Param_027': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRFRFM', 'Value': '0x00000029'], 'Output_Param_028': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRFCL', 'Value': '0x00000030'], 'Output_Param_029': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRITC', 'Value': '0x00000031'], 'Output_Param_030': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRIBA', 'Value': '0x00000032'], 'Output_Param_031': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFROBA', 'Value': '0x00000033'], 'Output_Param_032': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFROTC', 'Value': '0x00000034'], 'Output_Param_033': ['Type': 'Register', 'Range': '', 'Name': 'ulFLXAnFRFBA', 'Value': '0x00000035'], 'Output_Param_034': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_MessageBufferStatus(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint16, AUTOMATIC) Fr_LPduIdx) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; /* Declare the variable to store the slot status error flag */ boolean LblSlotStatus; /* Declare the variable to store the Controller Channel */ uint8 LucLPduChannel; /* Declare the variable to store the Slot Status Error value */ uint32 LulSlotStatusError; LpFrameConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig; LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ LblSlotStatus = FR_59_RENESAS_FALSE; LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Read Controller Channel from Configuration */ LucLPduChannel = LpFrameConfigPtr->ucChannelFilter; /* PRQA S 2814 # JV-02 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Read Slot Status Error Information from Register FLX0MBS */ LulSlotStatusError = LpOutputBuffReg->ulFLXAnFRMBS; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* * Check SEOA, SEOB, CEOA, CEOB, SVOA, SVOB bits in register FLXnMBS for * slots status error */ if ((uint8)FR_59_RENESAS_CHANNEL_AB == LucLPduChannel) { LulSlotStatusError = LulSlotStatusError & FR_59_RENESAS_FLX0MBS_SLOT_ERROR_MASK; if ((uint32)FR_59_RENESAS_ZERO != LulSlotStatusError) { LblSlotStatus = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* * Check SEOA, CEOA, SVOA bits in register FLXnMBS for slots status error */ else if ((uint8)FR_59_RENESAS_CHANNEL_A == LucLPduChannel) { LulSlotStatusError = LulSlotStatusError & FR_59_RENESAS_FLX0MBS_SEOA_CEOA_SVOA_MASK; if ((uint32)FR_59_RENESAS_ZERO != LulSlotStatusError) { LblSlotStatus = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* * Check SEOB, CEOB, SVOB bits in register FLXnMBS for slots status error */ else /* FR_CHANNEL_B */ { LulSlotStatusError = LulSlotStatusError & FR_59_RENESAS_FLX0MBS_SEOB_CEOB_SVOB_MASK; if ((uint32)FR_59_RENESAS_ZERO != LulSlotStatusError) { LblSlotStatus = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* No Slot Status Error */ if (FR_59_RENESAS_FALSE == LblSlotStatus) { if (FR_59_RENESAS_TRUE == LpFrameConfigPtr->blIsFrIfDemFTSlotStatusConfig) { /* Report Error to DEM */ FR_59_RENESAS_DEM_REPORT_ERROR(LpFrameConfigPtr->usFrIfDemFTSlotStatus, DEM_EVENT_STATUS_PASSED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_OK */ LucReturnValue = E_OK; } else { if (FR_59_RENESAS_TRUE == LpFrameConfigPtr->blIsFrIfDemFTSlotStatusConfig) { /* Report Error to DEM */ FR_59_RENESAS_DEM_REPORT_ERROR(LpFrameConfigPtr->usFrIfDemFTSlotStatus, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_CHANNEL_A, FR_59_RENESAS_CHANNEL_AB, FR_59_RENESAS_CHANNEL_B', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucChannelFilter', 'Value': 'FR_59_RENESAS_CHANNEL_AB'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].blIsFrIfDemFTSlotStatusConfig', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'FRIF_E_LPDU_SLOTSTATUS', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].usFrIfDemFTSlotStatus', 'Value': '1'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRMBS', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '1'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_PASSED'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_NewData(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) LucMessageBuffer, CONSTP2VAR(Fr_RxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_LPduStatusPtr,/* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduLengthPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_MessageBufferStatusRegType, AUTOMATIC, REGSPACE) LpMBStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store return value */ Std_ReturnType LucReturnValue; uint32 LulNDData; /* New Data register offset */ uint8 LucNDRegNumber; uint32 LulNDBitMask; /* Initialize the return value */ LucReturnValue = E_OK; /* Initialize the register value */ LulNDData = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpMBStatusReg = LpCtrlRegSet->pMBStatusReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Get address of Transmission Requestregister corresponding with MessageBuffer */ LucNDRegNumber = FR_59_RENESAS_REGNUMBER_OFFSET(LucMessageBuffer); LulNDBitMask = FR_59_RENESAS_BITNUMBER_MASK(LucMessageBuffer); /* PRQA S 3469 # JV-01 */ switch (LucNDRegNumber) { /*Using FLXAnFRNDAT1 */ case FR_59_RENESAS_ZERO: LulNDData = LpMBStatusReg->ulFLXAnFRNDAT1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; /*Using FLXAnFRNDAT2 */ case FR_59_RENESAS_ONE: LulNDData = LpMBStatusReg->ulFLXAnFRNDAT2; break; /*Using FLXAnFRNDAT3 */ case FR_59_RENESAS_TWO: LulNDData = LpMBStatusReg->ulFLXAnFRNDAT3; break; /*Using FLXAnFRNDAT4 */ case FR_59_RENESAS_THREE: LulNDData = LpMBStatusReg->ulFLXAnFRNDAT4; break; default: /* No action required */ break; } if (LulNDBitMask == (LulNDData & LulNDBitMask)) { /* Update the status Ptr */ *Fr_LPduStatusPtr = FR_RECEIVED; /* PRQA S 2814 # JV-03 */ } else /* No new data received */ { /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; /* Update the status Ptr and Sdu Length Ptr */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '96'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '&map_Fr_LPduStatusPtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '&map_Fr_LSduLengthPtr[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Array', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[0 to 1].pMBStatusReg', 'Value': '[0] = &map_MBStatusReg[0]\\n[1] = &map_MBStatusReg[1]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNDAT1', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNDAT2', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNDAT3', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNDAT4', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNDAT1', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNDAT2', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNDAT3', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNDAT4', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr[0]', 'Value': 'FR_NOT_RECEIVED'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LSduLengthPtr[0]', 'Value': '0'], 'Output_Param_002': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_OutputTransferRequest(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_OutputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpOutputPointerTable; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ uint32 LulData; uint8 LucMessageBuffer; Std_ReturnType LucReturnValue; uint8 LucMsgBufferMask; volatile uint16 LusLoopCount; uint8 LucFRDAindex; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LucMessageBuffer = Fr_OutputTableContentPtr->ucMsgBuffer; /* PRQA S 2814 # JV-03 */ LulData = LpDataTransferStatusReg->ulFLXAnFROTS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Output Transfer enabled, no pending user output transfer request pending */ if ((FR_59_RENESAS_FLX0FROTS_FLX0_OTS_MASK == (LulData & FR_59_RENESAS_FLX0FROTS_FLX0_OTS_MASK)) && (FR_59_RENESAS_FLX0FROTS_FLX0_UORP_MASK != (LulData & FR_59_RENESAS_FLX0FROTS_FLX0_UORP_MASK))) { LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Get the output table base address */ LulData = LpDataTransferCtrlReg->ulFLXAnFROBA; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Get the address of output pointer table */ LpOutputPointerTable = (P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA))(LulData + /* PRQA S 3432, 0303, 3383 # JV-01, JV-01, JV-01 */ ((uint32)LucMessageBuffer * (uint32)FR_59_RENESAS_FOUR)); /* PRQA S 3383 # JV-01 */ /* Write the output data structure address to output pointer table */ LpOutputPointerTable->Fr_59_Renesas_pOutputDataPtr = Fr_OutputTableContentPtr->Fr_59_Renesas_pOutputDataPtr; /* PRQA S 2814 # JV-01 */ /* Update the Message buffer in User Output Transfer Request Register */ /* Writing in to FlexRay User Output transfer Request Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRUOR = (LucMessageBuffer | FR_59_RENESAS_FLX0FRUOR_URDS_SET); /* Message buffer number is masked in range of 0-31 */ LucMsgBufferMask = LucMessageBuffer & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMessageBuffer >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; switch (LucFRDAindex) { case FR_59_RENESAS_FLX0FRDA_INDEX_ZERO: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA0 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA0 & LulData) != LulData) /* PRQA S 3415, 3416 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; case FR_59_RENESAS_FLX0FRDA_INDEX_ONE: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA1 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA1) != LulData) /* PRQA S 3416, 3415 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; case FR_59_RENESAS_FLX0FRDA_INDEX_TWO: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA2 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA2) != LulData) /* PRQA S 3416, 3415 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; default: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA3 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA3) != LulData) /* PRQA S 3415, 3416 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_OutputTableContentPtr', 'Value': '&map_Fr_OutputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '-', 'Name': 'map_Fr_OutputTableContentPtr[0].ucMsgBuffer', 'Value': '32'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_OutputTableContentPtr[0].Fr_59_Renesas_pOutputDataPtr', 'Value': '&map_temp_OuputData[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFROTS', 'Value': '0x1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFROBA', 'Value': '&map_FLXAnFROBA[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '65535']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRUOR', 'Value': '0x220'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'map_FLXAnFROBA[0 to 127]', 'Value': '[32] = &map_temp_OuputData[0]'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA0', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA1', 'Value': '1'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA2', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA3', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_OutputTransferRequest(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_OutputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpOutputPointerTable; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ uint32 LulData; uint8 LucMessageBuffer; Std_ReturnType LucReturnValue; uint8 LucMsgBufferMask; volatile uint16 LusLoopCount; uint8 LucFRDAindex; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LucMessageBuffer = Fr_OutputTableContentPtr->ucMsgBuffer; /* PRQA S 2814 # JV-03 */ LulData = LpDataTransferStatusReg->ulFLXAnFROTS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Output Transfer enabled, no pending user output transfer request pending */ if ((FR_59_RENESAS_FLX0FROTS_FLX0_OTS_MASK == (LulData & FR_59_RENESAS_FLX0FROTS_FLX0_OTS_MASK)) && (FR_59_RENESAS_FLX0FROTS_FLX0_UORP_MASK != (LulData & FR_59_RENESAS_FLX0FROTS_FLX0_UORP_MASK))) { LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Get the output table base address */ LulData = LpDataTransferCtrlReg->ulFLXAnFROBA; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Get the address of output pointer table */ LpOutputPointerTable = (P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA))(LulData + /* PRQA S 3432, 0303, 3383 # JV-01, JV-01, JV-01 */ ((uint32)LucMessageBuffer * (uint32)FR_59_RENESAS_FOUR)); /* PRQA S 3383 # JV-01 */ /* Write the output data structure address to output pointer table */ LpOutputPointerTable->Fr_59_Renesas_pOutputDataPtr = Fr_OutputTableContentPtr->Fr_59_Renesas_pOutputDataPtr; /* PRQA S 2814 # JV-01 */ /* Update the Message buffer in User Output Transfer Request Register */ /* Writing in to FlexRay User Output transfer Request Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRUOR = (LucMessageBuffer | FR_59_RENESAS_FLX0FRUOR_URDS_SET); /* Message buffer number is masked in range of 0-31 */ LucMsgBufferMask = LucMessageBuffer & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMessageBuffer >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; switch (LucFRDAindex) { case FR_59_RENESAS_FLX0FRDA_INDEX_ZERO: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA0 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA0 & LulData) != LulData) /* PRQA S 3415, 3416 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; case FR_59_RENESAS_FLX0FRDA_INDEX_ONE: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA1 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA1) != LulData) /* PRQA S 3416, 3415 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; case FR_59_RENESAS_FLX0FRDA_INDEX_TWO: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA2 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA2) != LulData) /* PRQA S 3416, 3415 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; default: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA3 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA3) != LulData) /* PRQA S 3415, 3416 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_OutputTableContentPtr', 'Value': '&map_Fr_OutputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '-', 'Name': 'map_Fr_OutputTableContentPtr[0].ucMsgBuffer', 'Value': '127'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_OutputTableContentPtr[0].Fr_59_Renesas_pOutputDataPtr', 'Value': '&map_temp_OuputData[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFROTS', 'Value': '0x1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': 'FR_59_RENESAS_DEM_NOT_CONFIGURED'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '&map_DataTransferCtrlReg[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFROBA', 'Value': '&map_FLXAnFROBA[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '65535']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRUOR', 'Value': '0x27F'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'map_FLXAnFROBA[0 to 127]', 'Value': '[127] = &map_temp_OuputData[0]'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA0', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA1', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA2', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA3', 'Value': '0x80000000'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_OutputTransferRequest(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_OutputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpOutputPointerTable; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ uint32 LulData; uint8 LucMessageBuffer; Std_ReturnType LucReturnValue; uint8 LucMsgBufferMask; volatile uint16 LusLoopCount; uint8 LucFRDAindex; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LucMessageBuffer = Fr_OutputTableContentPtr->ucMsgBuffer; /* PRQA S 2814 # JV-03 */ LulData = LpDataTransferStatusReg->ulFLXAnFROTS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Output Transfer enabled, no pending user output transfer request pending */ if ((FR_59_RENESAS_FLX0FROTS_FLX0_OTS_MASK == (LulData & FR_59_RENESAS_FLX0FROTS_FLX0_OTS_MASK)) && (FR_59_RENESAS_FLX0FROTS_FLX0_UORP_MASK != (LulData & FR_59_RENESAS_FLX0FROTS_FLX0_UORP_MASK))) { LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Get the output table base address */ LulData = LpDataTransferCtrlReg->ulFLXAnFROBA; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Get the address of output pointer table */ LpOutputPointerTable = (P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA))(LulData + /* PRQA S 3432, 0303, 3383 # JV-01, JV-01, JV-01 */ ((uint32)LucMessageBuffer * (uint32)FR_59_RENESAS_FOUR)); /* PRQA S 3383 # JV-01 */ /* Write the output data structure address to output pointer table */ LpOutputPointerTable->Fr_59_Renesas_pOutputDataPtr = Fr_OutputTableContentPtr->Fr_59_Renesas_pOutputDataPtr; /* PRQA S 2814 # JV-01 */ /* Update the Message buffer in User Output Transfer Request Register */ /* Writing in to FlexRay User Output transfer Request Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRUOR = (LucMessageBuffer | FR_59_RENESAS_FLX0FRUOR_URDS_SET); /* Message buffer number is masked in range of 0-31 */ LucMsgBufferMask = LucMessageBuffer & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMessageBuffer >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; switch (LucFRDAindex) { case FR_59_RENESAS_FLX0FRDA_INDEX_ZERO: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA0 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA0 & LulData) != LulData) /* PRQA S 3415, 3416 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; case FR_59_RENESAS_FLX0FRDA_INDEX_ONE: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA1 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA1) != LulData) /* PRQA S 3416, 3415 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; case FR_59_RENESAS_FLX0FRDA_INDEX_TWO: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA2 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA2) != LulData) /* PRQA S 3416, 3415 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; default: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA3 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA3) != LulData) /* PRQA S 3415, 3416 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_OutputTableContentPtr', 'Value': '&map_Fr_OutputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '-', 'Name': 'map_Fr_OutputTableContentPtr[0].ucMsgBuffer', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_OutputTableContentPtr[0].Fr_59_Renesas_pOutputDataPtr', 'Value': '&map_temp_OuputData[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFROTS', 'Value': '0x0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '1'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFROBA', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRUOR', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'map_FLXAnFROBA[0 to 127]', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA0', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA1', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA2', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA3', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_OutputTransferRequest(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_OutputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) LpOutputPointerTable; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ uint32 LulData; uint8 LucMessageBuffer; Std_ReturnType LucReturnValue; uint8 LucMsgBufferMask; volatile uint16 LusLoopCount; uint8 LucFRDAindex; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LucMessageBuffer = Fr_OutputTableContentPtr->ucMsgBuffer; /* PRQA S 2814 # JV-03 */ LulData = LpDataTransferStatusReg->ulFLXAnFROTS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for Output Transfer enabled, no pending user output transfer request pending */ if ((FR_59_RENESAS_FLX0FROTS_FLX0_OTS_MASK == (LulData & FR_59_RENESAS_FLX0FROTS_FLX0_OTS_MASK)) && (FR_59_RENESAS_FLX0FROTS_FLX0_UORP_MASK != (LulData & FR_59_RENESAS_FLX0FROTS_FLX0_UORP_MASK))) { LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Get the output table base address */ LulData = LpDataTransferCtrlReg->ulFLXAnFROBA; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Get the address of output pointer table */ LpOutputPointerTable = (P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA))(LulData + /* PRQA S 3432, 0303, 3383 # JV-01, JV-01, JV-01 */ ((uint32)LucMessageBuffer * (uint32)FR_59_RENESAS_FOUR)); /* PRQA S 3383 # JV-01 */ /* Write the output data structure address to output pointer table */ LpOutputPointerTable->Fr_59_Renesas_pOutputDataPtr = Fr_OutputTableContentPtr->Fr_59_Renesas_pOutputDataPtr; /* PRQA S 2814 # JV-01 */ /* Update the Message buffer in User Output Transfer Request Register */ /* Writing in to FlexRay User Output transfer Request Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRUOR = (LucMessageBuffer | FR_59_RENESAS_FLX0FRUOR_URDS_SET); /* Message buffer number is masked in range of 0-31 */ LucMsgBufferMask = LucMessageBuffer & FR_59_RENESAS_FLXnFRDAi_MASK; /* Get the index of DA register for the given message buffer */ LucFRDAindex = (LucMessageBuffer >> FR_59_RENESAS_FIVE) & FR_59_RENESAS_FLXnFRDA_INDEX_MASK; switch (LucFRDAindex) { case FR_59_RENESAS_FLX0FRDA_INDEX_ZERO: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA0 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA0 & LulData) != LulData) /* PRQA S 3415, 3416 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; case FR_59_RENESAS_FLX0FRDA_INDEX_ONE: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA1 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA1) != LulData) /* PRQA S 3416, 3415 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; case FR_59_RENESAS_FLX0FRDA_INDEX_TWO: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA2 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA2) != LulData) /* PRQA S 3416, 3415 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; default: /* Get the position of DA flag to be cleared */ LulData = ((uint32)FR_59_RENESAS_ONE << LucMsgBufferMask); LpDataTransferStatusReg->ulFLXAnFRDA3 = LulData; while (((LpDataTransferStatusReg->ulFLXAnFRDA3) != LulData) /* PRQA S 3415, 3416 # JV-01, JV-01 */ && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No Action required */ break; } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_OutputTableContentPtr', 'Value': '&map_Fr_OutputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '-', 'Name': 'map_Fr_OutputTableContentPtr[0].ucMsgBuffer', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_OutputTableContentPtr[0].Fr_59_Renesas_pOutputDataPtr', 'Value': '&map_temp_OuputData[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFROTS', 'Value': '0x4'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA0', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA1', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA2', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRDA3', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '1'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFROBA', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pCtrlTable', 'Value': '&map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRUOR', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'map_FLXAnFROBA[0 to 127]', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA0', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA1', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA2', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRDA3', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_ReadAggregatedStatus(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelAStatusPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelBStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the value of register */ uint32 LulRegData; uint32 LulMTSVal; Std_ReturnType LucReturnValue; /* Initialize the value of register */ LulRegData = FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ /* Initialize the return value */ LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Read the POC State by getting FLX0CCSV register value */ LulRegData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if the CC is in normal active state */ if ((FR_59_RENESAS_NORMAL_ACTIVE_STATE == LulRegData) || (FR_59_RENESAS_NORMAL_PASSIVE_STATE == LulRegData)) { /* Read the Aggregated channel status register */ LulRegData = LpCCStatusReg->ulFLXAnFRACS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Copy 1st 4 bits of FLX0ACS to Output pointer VFRA, SEDA, CEDA, CIA, SBVA of Channel A */ *Fr_ChannelAStatusPtr = (uint16)(LulRegData & FR_59_RENESAS_FLX0ACS_CHNL_A_MASK); /* PRQA S 2814 # JV-03 */ /* Copy 1st 4 bits of FLX0ACS to Output pointer VFRB, SEDB, CEDB, CIB, SBVB of Channel B */ LulRegData = LulRegData >> FR_59_RENESAS_EIGHT; *Fr_ChannelBStatusPtr = (uint16)(LulRegData & FR_59_RENESAS_FLX0ACS_CHNL_B_MASK); /* PRQA S 2814 # JV-03 */ /* Write '1' in all bit of the register to reset the aggregated channel status information */ /* Writing in to FlexRay Aggregated Channel Status Register and mirror address */ LpCCStatusReg->ulFLXAnFRACS = FR_59_RENESAS_FLX0ACS_MASK; /* Read the Symbol Window and NIT status register */ LulRegData = LpCCStatusReg->ulFLXAnFRSWNIT; /* Extract MTS A from register FLX0SWNIT */ LulMTSVal = LulRegData & FR_59_RENESAS_FLX0SWNIT_MTSA_MASK; /* Load MTS A in bit 8 of Fr_ChannelAStatusPtr */ *Fr_ChannelAStatusPtr = *Fr_ChannelAStatusPtr | (uint16)(LulMTSVal << FR_59_RENESAS_TWO); /* Extract MTS B from register FLX0SWNIT */ LulMTSVal = LulRegData & FR_59_RENESAS_FLX0SWNIT_MTSB_MASK; /* Load MTS B in bit 8 of Fr_ChannelBStatusPtr */ *Fr_ChannelBStatusPtr = *Fr_ChannelBStatusPtr | (uint16)(LulMTSVal << FR_59_RENESAS_ONE); /* Extract SWNIT.SESA, SWNIT.SBSA, SWNIT.TCSA */ LulMTSVal = LulRegData & FR_59_RENESAS_FLX0SWNIT_SW_A_MASK; /* From bit 0 (SESA) in SWNIT, left shift 9 bit to fill bit 9 in Fr_ChannelAStatusPtr */ LulMTSVal = LulMTSVal << FR_59_RENESAS_NINE; /* Load SWNIT.SESA, SWNIT.SBSA, SWNIT.TCSA in bits 9, 10 and 11 of Fr_ChannelAStatusPtr */ *Fr_ChannelAStatusPtr = *Fr_ChannelAStatusPtr | (uint16)LulMTSVal; /* Extract SWNIT.SESB, SWNIT.SBSB, SWNIT.TCSB */ LulMTSVal = LulRegData & FR_59_RENESAS_FLX0SWNIT_SW_B_MASK; /* From bit 3 (SESA) in SWNIT, left shift 6 bit to fill from bit 9 in Fr_ChannelBStatusPtr */ LulMTSVal = LulMTSVal << FR_59_RENESAS_SIX; /* Load SWNIT.SESB, SWNIT.SBSB, SWNIT.TCSB in bits 9, 10 and 11 of Fr_ChannelBStatusPtr */ *Fr_ChannelBStatusPtr = *Fr_ChannelBStatusPtr | (uint16)LulMTSVal; /* Extract SWNIT.SENA, SWNIT.SBNA */ LulMTSVal = LulRegData & FR_59_RENESAS_FLX0SWNIT_NIT_A_MASK; /* From bit 8 (SENA) in SWNIT, left shift 4 bit to fill from bit 12 in Fr_ChannelBStatusPtr */ LulMTSVal = LulMTSVal << FR_59_RENESAS_FOUR; /* Load SWNIT.SENA, SWNIT.SBNA in bits 12, 13 of Fr_ChannelAStatusPtr */ *Fr_ChannelAStatusPtr = *Fr_ChannelAStatusPtr | (uint16)LulMTSVal; /* Extract SWNIT.SENB, SWNIT.SBNB */ LulMTSVal = LulRegData & FR_59_RENESAS_FLX0SWNIT_NIT_B_MASK; /* From bit 10 (SENB) in SWNIT, left shift 2 bit to fill from bit 12 in Fr_ChannelBStatusPtr */ LulMTSVal = LulMTSVal << FR_59_RENESAS_TWO; /* Load SWNIT.SENB, SWNIT.SBNB in bits 12, 13 of Fr_ChannelBStatusPtr */ *Fr_ChannelBStatusPtr = *Fr_ChannelBStatusPtr | (uint16)LulMTSVal; } else { /* Report Error to DEM */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelAStatusPtr', 'Value': '&map_Fr_ChannelAStatusPtr[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelBStatusPtr', 'Value': '&map_Fr_ChannelBStatusPtr[0]'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FR_59_RENESAS_NORMAL_ACTIVE_STATE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx]', 'Value': '&map_Fr_59_Renesas_GpCtrlRegSet[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[0].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_CCStatusReg[0].ulFLXAnFRACS', 'Value': '0xF0F'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_CCStatusReg[0].ulFLXAnFRSWNIT', 'Value': '0x7F'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelAStatusPtr[0]', 'Value': '0x0F0F'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelBStatusPtr[0]', 'Value': '0x0F0F'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_CCStatusReg[0].ulFLXAnFRACS', 'Value': '0x1F1F'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(uint32, FR_PRIVATE_CODE) Fr_59_Renesas_ReadDataSection(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store the register value */ uint32 LulData; /* Initialize register value */ LulData = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ switch (RegMacro) { case FR_59_RENESAS_FLX0RDDS1: LulData = LpOutputBuffReg->ulFLXAnFRRDDS1; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; case FR_59_RENESAS_FLX0RDDS2: LulData = LpOutputBuffReg->ulFLXAnFRRDDS2; break; case FR_59_RENESAS_FLX0RDDS3: LulData = LpOutputBuffReg->ulFLXAnFRRDDS3; break; case FR_59_RENESAS_FLX0RDDS4: LulData = LpOutputBuffReg->ulFLXAnFRRDDS4; break; case FR_59_RENESAS_FLX0RDDS5: LulData = LpOutputBuffReg->ulFLXAnFRRDDS5; break; case FR_59_RENESAS_FLX0RDDS6: LulData = LpOutputBuffReg->ulFLXAnFRRDDS6; break; case FR_59_RENESAS_FLX0RDDS7: LulData = LpOutputBuffReg->ulFLXAnFRRDDS7; break; case FR_59_RENESAS_FLX0RDDS8: LulData = LpOutputBuffReg->ulFLXAnFRRDDS8; break; case FR_59_RENESAS_FLX0RDDS9: LulData = LpOutputBuffReg->ulFLXAnFRRDDS9; break; case FR_59_RENESAS_FLX0RDDS10: LulData = LpOutputBuffReg->ulFLXAnFRRDDS10; break; case FR_59_RENESAS_FLX0RDDS11: LulData = LpOutputBuffReg->ulFLXAnFRRDDS11; break; case FR_59_RENESAS_FLX0RDDS12: LulData = LpOutputBuffReg->ulFLXAnFRRDDS12; break; case FR_59_RENESAS_FLX0RDDS13: LulData = LpOutputBuffReg->ulFLXAnFRRDDS13; break; case FR_59_RENESAS_FLX0RDDS14: LulData = LpOutputBuffReg->ulFLXAnFRRDDS14; break; case FR_59_RENESAS_FLX0RDDS15: LulData = LpOutputBuffReg->ulFLXAnFRRDDS15; break; case FR_59_RENESAS_FLX0RDDS16: LulData = LpOutputBuffReg->ulFLXAnFRRDDS16; break; case FR_59_RENESAS_FLX0RDDS17: LulData = LpOutputBuffReg->ulFLXAnFRRDDS17; break; case FR_59_RENESAS_FLX0RDDS18: LulData = LpOutputBuffReg->ulFLXAnFRRDDS18; break; case FR_59_RENESAS_FLX0RDDS19: LulData = LpOutputBuffReg->ulFLXAnFRRDDS19; break; case FR_59_RENESAS_FLX0RDDS20: LulData = LpOutputBuffReg->ulFLXAnFRRDDS20; break; case FR_59_RENESAS_FLX0RDDS21: LulData = LpOutputBuffReg->ulFLXAnFRRDDS21; break; case FR_59_RENESAS_FLX0RDDS22: LulData = LpOutputBuffReg->ulFLXAnFRRDDS22; break; case FR_59_RENESAS_FLX0RDDS23: LulData = LpOutputBuffReg->ulFLXAnFRRDDS23; break; case FR_59_RENESAS_FLX0RDDS24: LulData = LpOutputBuffReg->ulFLXAnFRRDDS24; break; case FR_59_RENESAS_FLX0RDDS25: LulData = LpOutputBuffReg->ulFLXAnFRRDDS25; break; case FR_59_RENESAS_FLX0RDDS26: LulData = LpOutputBuffReg->ulFLXAnFRRDDS26; break; case FR_59_RENESAS_FLX0RDDS27: LulData = LpOutputBuffReg->ulFLXAnFRRDDS27; break; case FR_59_RENESAS_FLX0RDDS28: LulData = LpOutputBuffReg->ulFLXAnFRRDDS28; break; case FR_59_RENESAS_FLX0RDDS29: LulData = LpOutputBuffReg->ulFLXAnFRRDDS29; break; case FR_59_RENESAS_FLX0RDDS30: LulData = LpOutputBuffReg->ulFLXAnFRRDDS30; break; case FR_59_RENESAS_FLX0RDDS31: LulData = LpOutputBuffReg->ulFLXAnFRRDDS31; break; case FR_59_RENESAS_FLX0RDDS32: LulData = LpOutputBuffReg->ulFLXAnFRRDDS32; break; case FR_59_RENESAS_FLX0RDDS33: LulData = LpOutputBuffReg->ulFLXAnFRRDDS33; break; case FR_59_RENESAS_FLX0RDDS34: LulData = LpOutputBuffReg->ulFLXAnFRRDDS34; break; case FR_59_RENESAS_FLX0RDDS35: LulData = LpOutputBuffReg->ulFLXAnFRRDDS35; break; case FR_59_RENESAS_FLX0RDDS36: LulData = LpOutputBuffReg->ulFLXAnFRRDDS36; break; case FR_59_RENESAS_FLX0RDDS37: LulData = LpOutputBuffReg->ulFLXAnFRRDDS37; break; case FR_59_RENESAS_FLX0RDDS38: LulData = LpOutputBuffReg->ulFLXAnFRRDDS38; break; case FR_59_RENESAS_FLX0RDDS39: LulData = LpOutputBuffReg->ulFLXAnFRRDDS39; break; case FR_59_RENESAS_FLX0RDDS40: LulData = LpOutputBuffReg->ulFLXAnFRRDDS40; break; case FR_59_RENESAS_FLX0RDDS41: LulData = LpOutputBuffReg->ulFLXAnFRRDDS41; break; case FR_59_RENESAS_FLX0RDDS42: LulData = LpOutputBuffReg->ulFLXAnFRRDDS42; break; case FR_59_RENESAS_FLX0RDDS43: LulData = LpOutputBuffReg->ulFLXAnFRRDDS43; break; case FR_59_RENESAS_FLX0RDDS44: LulData = LpOutputBuffReg->ulFLXAnFRRDDS44; break; case FR_59_RENESAS_FLX0RDDS45: LulData = LpOutputBuffReg->ulFLXAnFRRDDS45; break; case FR_59_RENESAS_FLX0RDDS46: LulData = LpOutputBuffReg->ulFLXAnFRRDDS46; break; case FR_59_RENESAS_FLX0RDDS47: LulData = LpOutputBuffReg->ulFLXAnFRRDDS47; break; case FR_59_RENESAS_FLX0RDDS48: LulData = LpOutputBuffReg->ulFLXAnFRRDDS48; break; case FR_59_RENESAS_FLX0RDDS49: LulData = LpOutputBuffReg->ulFLXAnFRRDDS49; break; case FR_59_RENESAS_FLX0RDDS50: LulData = LpOutputBuffReg->ulFLXAnFRRDDS50; break; case FR_59_RENESAS_FLX0RDDS51: LulData = LpOutputBuffReg->ulFLXAnFRRDDS51; break; case FR_59_RENESAS_FLX0RDDS52: LulData = LpOutputBuffReg->ulFLXAnFRRDDS52; break; case FR_59_RENESAS_FLX0RDDS53: LulData = LpOutputBuffReg->ulFLXAnFRRDDS53; break; case FR_59_RENESAS_FLX0RDDS54: LulData = LpOutputBuffReg->ulFLXAnFRRDDS54; break; case FR_59_RENESAS_FLX0RDDS55: LulData = LpOutputBuffReg->ulFLXAnFRRDDS55; break; case FR_59_RENESAS_FLX0RDDS56: LulData = LpOutputBuffReg->ulFLXAnFRRDDS56; break; case FR_59_RENESAS_FLX0RDDS57: LulData = LpOutputBuffReg->ulFLXAnFRRDDS57; break; case FR_59_RENESAS_FLX0RDDS58: LulData = LpOutputBuffReg->ulFLXAnFRRDDS58; break; case FR_59_RENESAS_FLX0RDDS59: LulData = LpOutputBuffReg->ulFLXAnFRRDDS59; break; case FR_59_RENESAS_FLX0RDDS60: LulData = LpOutputBuffReg->ulFLXAnFRRDDS60; break; case FR_59_RENESAS_FLX0RDDS61: LulData = LpOutputBuffReg->ulFLXAnFRRDDS61; break; case FR_59_RENESAS_FLX0RDDS62: LulData = LpOutputBuffReg->ulFLXAnFRRDDS62; break; case FR_59_RENESAS_FLX0RDDS63: LulData = LpOutputBuffReg->ulFLXAnFRRDDS63; break; case FR_59_RENESAS_FLX0RDDS64: LulData = LpOutputBuffReg->ulFLXAnFRRDDS64; break; default: /* No action required */ break; } return (LulData); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0RDDS27'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS1', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS2', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS3', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS4', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS5', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS6', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS7', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS8', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS9', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS10', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS11', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS12', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS13', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS14', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS15', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS16', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS17', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS18', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS19', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS20', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS21', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS22', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS23', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS24', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS25', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS26', 'Value': '-'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS27', 'Value': '54'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS28', 'Value': '-'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS29', 'Value': '-'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS30', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS31', 'Value': '-'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS32', 'Value': '-'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS33', 'Value': '-'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS34', 'Value': '-'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS35', 'Value': '-'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS36', 'Value': '-'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS37', 'Value': '-'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS38', 'Value': '-'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS39', 'Value': '-'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS40', 'Value': '-'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS41', 'Value': '-'], 'Input_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS42', 'Value': '-'], 'Input_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS43', 'Value': '-'], 'Input_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS44', 'Value': '-'], 'Input_Param_048': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS45', 'Value': '-'], 'Input_Param_049': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS46', 'Value': '-'], 'Input_Param_050': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS47', 'Value': '-'], 'Input_Param_051': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS48', 'Value': '-'], 'Input_Param_052': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS49', 'Value': '-'], 'Input_Param_053': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS50', 'Value': '-'], 'Input_Param_054': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS51', 'Value': '-'], 'Input_Param_055': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS52', 'Value': '-'], 'Input_Param_056': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS53', 'Value': '-'], 'Input_Param_057': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS54', 'Value': '-'], 'Input_Param_058': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS55', 'Value': '-'], 'Input_Param_059': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS56', 'Value': '-'], 'Input_Param_060': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS57', 'Value': '-'], 'Input_Param_061': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS58', 'Value': '-'], 'Input_Param_062': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS59', 'Value': '-'], 'Input_Param_063': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS60', 'Value': '-'], 'Input_Param_064': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS61', 'Value': '-'], 'Input_Param_065': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS62', 'Value': '-'], 'Input_Param_066': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS63', 'Value': '-'], 'Input_Param_067': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS64', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': '54'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(uint32, FR_PRIVATE_CODE) Fr_59_Renesas_ReadDataSection(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store the register value */ uint32 LulData; /* Initialize register value */ LulData = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ switch (RegMacro) { case FR_59_RENESAS_FLX0RDDS1: LulData = LpOutputBuffReg->ulFLXAnFRRDDS1; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; case FR_59_RENESAS_FLX0RDDS2: LulData = LpOutputBuffReg->ulFLXAnFRRDDS2; break; case FR_59_RENESAS_FLX0RDDS3: LulData = LpOutputBuffReg->ulFLXAnFRRDDS3; break; case FR_59_RENESAS_FLX0RDDS4: LulData = LpOutputBuffReg->ulFLXAnFRRDDS4; break; case FR_59_RENESAS_FLX0RDDS5: LulData = LpOutputBuffReg->ulFLXAnFRRDDS5; break; case FR_59_RENESAS_FLX0RDDS6: LulData = LpOutputBuffReg->ulFLXAnFRRDDS6; break; case FR_59_RENESAS_FLX0RDDS7: LulData = LpOutputBuffReg->ulFLXAnFRRDDS7; break; case FR_59_RENESAS_FLX0RDDS8: LulData = LpOutputBuffReg->ulFLXAnFRRDDS8; break; case FR_59_RENESAS_FLX0RDDS9: LulData = LpOutputBuffReg->ulFLXAnFRRDDS9; break; case FR_59_RENESAS_FLX0RDDS10: LulData = LpOutputBuffReg->ulFLXAnFRRDDS10; break; case FR_59_RENESAS_FLX0RDDS11: LulData = LpOutputBuffReg->ulFLXAnFRRDDS11; break; case FR_59_RENESAS_FLX0RDDS12: LulData = LpOutputBuffReg->ulFLXAnFRRDDS12; break; case FR_59_RENESAS_FLX0RDDS13: LulData = LpOutputBuffReg->ulFLXAnFRRDDS13; break; case FR_59_RENESAS_FLX0RDDS14: LulData = LpOutputBuffReg->ulFLXAnFRRDDS14; break; case FR_59_RENESAS_FLX0RDDS15: LulData = LpOutputBuffReg->ulFLXAnFRRDDS15; break; case FR_59_RENESAS_FLX0RDDS16: LulData = LpOutputBuffReg->ulFLXAnFRRDDS16; break; case FR_59_RENESAS_FLX0RDDS17: LulData = LpOutputBuffReg->ulFLXAnFRRDDS17; break; case FR_59_RENESAS_FLX0RDDS18: LulData = LpOutputBuffReg->ulFLXAnFRRDDS18; break; case FR_59_RENESAS_FLX0RDDS19: LulData = LpOutputBuffReg->ulFLXAnFRRDDS19; break; case FR_59_RENESAS_FLX0RDDS20: LulData = LpOutputBuffReg->ulFLXAnFRRDDS20; break; case FR_59_RENESAS_FLX0RDDS21: LulData = LpOutputBuffReg->ulFLXAnFRRDDS21; break; case FR_59_RENESAS_FLX0RDDS22: LulData = LpOutputBuffReg->ulFLXAnFRRDDS22; break; case FR_59_RENESAS_FLX0RDDS23: LulData = LpOutputBuffReg->ulFLXAnFRRDDS23; break; case FR_59_RENESAS_FLX0RDDS24: LulData = LpOutputBuffReg->ulFLXAnFRRDDS24; break; case FR_59_RENESAS_FLX0RDDS25: LulData = LpOutputBuffReg->ulFLXAnFRRDDS25; break; case FR_59_RENESAS_FLX0RDDS26: LulData = LpOutputBuffReg->ulFLXAnFRRDDS26; break; case FR_59_RENESAS_FLX0RDDS27: LulData = LpOutputBuffReg->ulFLXAnFRRDDS27; break; case FR_59_RENESAS_FLX0RDDS28: LulData = LpOutputBuffReg->ulFLXAnFRRDDS28; break; case FR_59_RENESAS_FLX0RDDS29: LulData = LpOutputBuffReg->ulFLXAnFRRDDS29; break; case FR_59_RENESAS_FLX0RDDS30: LulData = LpOutputBuffReg->ulFLXAnFRRDDS30; break; case FR_59_RENESAS_FLX0RDDS31: LulData = LpOutputBuffReg->ulFLXAnFRRDDS31; break; case FR_59_RENESAS_FLX0RDDS32: LulData = LpOutputBuffReg->ulFLXAnFRRDDS32; break; case FR_59_RENESAS_FLX0RDDS33: LulData = LpOutputBuffReg->ulFLXAnFRRDDS33; break; case FR_59_RENESAS_FLX0RDDS34: LulData = LpOutputBuffReg->ulFLXAnFRRDDS34; break; case FR_59_RENESAS_FLX0RDDS35: LulData = LpOutputBuffReg->ulFLXAnFRRDDS35; break; case FR_59_RENESAS_FLX0RDDS36: LulData = LpOutputBuffReg->ulFLXAnFRRDDS36; break; case FR_59_RENESAS_FLX0RDDS37: LulData = LpOutputBuffReg->ulFLXAnFRRDDS37; break; case FR_59_RENESAS_FLX0RDDS38: LulData = LpOutputBuffReg->ulFLXAnFRRDDS38; break; case FR_59_RENESAS_FLX0RDDS39: LulData = LpOutputBuffReg->ulFLXAnFRRDDS39; break; case FR_59_RENESAS_FLX0RDDS40: LulData = LpOutputBuffReg->ulFLXAnFRRDDS40; break; case FR_59_RENESAS_FLX0RDDS41: LulData = LpOutputBuffReg->ulFLXAnFRRDDS41; break; case FR_59_RENESAS_FLX0RDDS42: LulData = LpOutputBuffReg->ulFLXAnFRRDDS42; break; case FR_59_RENESAS_FLX0RDDS43: LulData = LpOutputBuffReg->ulFLXAnFRRDDS43; break; case FR_59_RENESAS_FLX0RDDS44: LulData = LpOutputBuffReg->ulFLXAnFRRDDS44; break; case FR_59_RENESAS_FLX0RDDS45: LulData = LpOutputBuffReg->ulFLXAnFRRDDS45; break; case FR_59_RENESAS_FLX0RDDS46: LulData = LpOutputBuffReg->ulFLXAnFRRDDS46; break; case FR_59_RENESAS_FLX0RDDS47: LulData = LpOutputBuffReg->ulFLXAnFRRDDS47; break; case FR_59_RENESAS_FLX0RDDS48: LulData = LpOutputBuffReg->ulFLXAnFRRDDS48; break; case FR_59_RENESAS_FLX0RDDS49: LulData = LpOutputBuffReg->ulFLXAnFRRDDS49; break; case FR_59_RENESAS_FLX0RDDS50: LulData = LpOutputBuffReg->ulFLXAnFRRDDS50; break; case FR_59_RENESAS_FLX0RDDS51: LulData = LpOutputBuffReg->ulFLXAnFRRDDS51; break; case FR_59_RENESAS_FLX0RDDS52: LulData = LpOutputBuffReg->ulFLXAnFRRDDS52; break; case FR_59_RENESAS_FLX0RDDS53: LulData = LpOutputBuffReg->ulFLXAnFRRDDS53; break; case FR_59_RENESAS_FLX0RDDS54: LulData = LpOutputBuffReg->ulFLXAnFRRDDS54; break; case FR_59_RENESAS_FLX0RDDS55: LulData = LpOutputBuffReg->ulFLXAnFRRDDS55; break; case FR_59_RENESAS_FLX0RDDS56: LulData = LpOutputBuffReg->ulFLXAnFRRDDS56; break; case FR_59_RENESAS_FLX0RDDS57: LulData = LpOutputBuffReg->ulFLXAnFRRDDS57; break; case FR_59_RENESAS_FLX0RDDS58: LulData = LpOutputBuffReg->ulFLXAnFRRDDS58; break; case FR_59_RENESAS_FLX0RDDS59: LulData = LpOutputBuffReg->ulFLXAnFRRDDS59; break; case FR_59_RENESAS_FLX0RDDS60: LulData = LpOutputBuffReg->ulFLXAnFRRDDS60; break; case FR_59_RENESAS_FLX0RDDS61: LulData = LpOutputBuffReg->ulFLXAnFRRDDS61; break; case FR_59_RENESAS_FLX0RDDS62: LulData = LpOutputBuffReg->ulFLXAnFRRDDS62; break; case FR_59_RENESAS_FLX0RDDS63: LulData = LpOutputBuffReg->ulFLXAnFRRDDS63; break; case FR_59_RENESAS_FLX0RDDS64: LulData = LpOutputBuffReg->ulFLXAnFRRDDS64; break; default: /* No action required */ break; } return (LulData); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0RDDS28'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS1', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS2', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS3', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS4', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS5', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS6', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS7', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS8', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS9', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS10', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS11', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS12', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS13', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS14', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS15', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS16', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS17', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS18', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS19', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS20', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS21', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS22', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS23', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS24', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS25', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS26', 'Value': '-'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS27', 'Value': '-'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS28', 'Value': '55'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS29', 'Value': '-'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS30', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS31', 'Value': '-'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS32', 'Value': '-'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS33', 'Value': '-'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS34', 'Value': '-'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS35', 'Value': '-'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS36', 'Value': '-'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS37', 'Value': '-'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS38', 'Value': '-'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS39', 'Value': '-'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS40', 'Value': '-'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS41', 'Value': '-'], 'Input_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS42', 'Value': '-'], 'Input_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS43', 'Value': '-'], 'Input_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS44', 'Value': '-'], 'Input_Param_048': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS45', 'Value': '-'], 'Input_Param_049': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS46', 'Value': '-'], 'Input_Param_050': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS47', 'Value': '-'], 'Input_Param_051': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS48', 'Value': '-'], 'Input_Param_052': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS49', 'Value': '-'], 'Input_Param_053': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS50', 'Value': '-'], 'Input_Param_054': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS51', 'Value': '-'], 'Input_Param_055': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS52', 'Value': '-'], 'Input_Param_056': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS53', 'Value': '-'], 'Input_Param_057': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS54', 'Value': '-'], 'Input_Param_058': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS55', 'Value': '-'], 'Input_Param_059': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS56', 'Value': '-'], 'Input_Param_060': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS57', 'Value': '-'], 'Input_Param_061': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS58', 'Value': '-'], 'Input_Param_062': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS59', 'Value': '-'], 'Input_Param_063': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS60', 'Value': '-'], 'Input_Param_064': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS61', 'Value': '-'], 'Input_Param_065': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS62', 'Value': '-'], 'Input_Param_066': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS63', 'Value': '-'], 'Input_Param_067': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS64', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': '55'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(uint32, FR_PRIVATE_CODE) Fr_59_Renesas_ReadDataSection(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store the register value */ uint32 LulData; /* Initialize register value */ LulData = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ switch (RegMacro) { case FR_59_RENESAS_FLX0RDDS1: LulData = LpOutputBuffReg->ulFLXAnFRRDDS1; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; case FR_59_RENESAS_FLX0RDDS2: LulData = LpOutputBuffReg->ulFLXAnFRRDDS2; break; case FR_59_RENESAS_FLX0RDDS3: LulData = LpOutputBuffReg->ulFLXAnFRRDDS3; break; case FR_59_RENESAS_FLX0RDDS4: LulData = LpOutputBuffReg->ulFLXAnFRRDDS4; break; case FR_59_RENESAS_FLX0RDDS5: LulData = LpOutputBuffReg->ulFLXAnFRRDDS5; break; case FR_59_RENESAS_FLX0RDDS6: LulData = LpOutputBuffReg->ulFLXAnFRRDDS6; break; case FR_59_RENESAS_FLX0RDDS7: LulData = LpOutputBuffReg->ulFLXAnFRRDDS7; break; case FR_59_RENESAS_FLX0RDDS8: LulData = LpOutputBuffReg->ulFLXAnFRRDDS8; break; case FR_59_RENESAS_FLX0RDDS9: LulData = LpOutputBuffReg->ulFLXAnFRRDDS9; break; case FR_59_RENESAS_FLX0RDDS10: LulData = LpOutputBuffReg->ulFLXAnFRRDDS10; break; case FR_59_RENESAS_FLX0RDDS11: LulData = LpOutputBuffReg->ulFLXAnFRRDDS11; break; case FR_59_RENESAS_FLX0RDDS12: LulData = LpOutputBuffReg->ulFLXAnFRRDDS12; break; case FR_59_RENESAS_FLX0RDDS13: LulData = LpOutputBuffReg->ulFLXAnFRRDDS13; break; case FR_59_RENESAS_FLX0RDDS14: LulData = LpOutputBuffReg->ulFLXAnFRRDDS14; break; case FR_59_RENESAS_FLX0RDDS15: LulData = LpOutputBuffReg->ulFLXAnFRRDDS15; break; case FR_59_RENESAS_FLX0RDDS16: LulData = LpOutputBuffReg->ulFLXAnFRRDDS16; break; case FR_59_RENESAS_FLX0RDDS17: LulData = LpOutputBuffReg->ulFLXAnFRRDDS17; break; case FR_59_RENESAS_FLX0RDDS18: LulData = LpOutputBuffReg->ulFLXAnFRRDDS18; break; case FR_59_RENESAS_FLX0RDDS19: LulData = LpOutputBuffReg->ulFLXAnFRRDDS19; break; case FR_59_RENESAS_FLX0RDDS20: LulData = LpOutputBuffReg->ulFLXAnFRRDDS20; break; case FR_59_RENESAS_FLX0RDDS21: LulData = LpOutputBuffReg->ulFLXAnFRRDDS21; break; case FR_59_RENESAS_FLX0RDDS22: LulData = LpOutputBuffReg->ulFLXAnFRRDDS22; break; case FR_59_RENESAS_FLX0RDDS23: LulData = LpOutputBuffReg->ulFLXAnFRRDDS23; break; case FR_59_RENESAS_FLX0RDDS24: LulData = LpOutputBuffReg->ulFLXAnFRRDDS24; break; case FR_59_RENESAS_FLX0RDDS25: LulData = LpOutputBuffReg->ulFLXAnFRRDDS25; break; case FR_59_RENESAS_FLX0RDDS26: LulData = LpOutputBuffReg->ulFLXAnFRRDDS26; break; case FR_59_RENESAS_FLX0RDDS27: LulData = LpOutputBuffReg->ulFLXAnFRRDDS27; break; case FR_59_RENESAS_FLX0RDDS28: LulData = LpOutputBuffReg->ulFLXAnFRRDDS28; break; case FR_59_RENESAS_FLX0RDDS29: LulData = LpOutputBuffReg->ulFLXAnFRRDDS29; break; case FR_59_RENESAS_FLX0RDDS30: LulData = LpOutputBuffReg->ulFLXAnFRRDDS30; break; case FR_59_RENESAS_FLX0RDDS31: LulData = LpOutputBuffReg->ulFLXAnFRRDDS31; break; case FR_59_RENESAS_FLX0RDDS32: LulData = LpOutputBuffReg->ulFLXAnFRRDDS32; break; case FR_59_RENESAS_FLX0RDDS33: LulData = LpOutputBuffReg->ulFLXAnFRRDDS33; break; case FR_59_RENESAS_FLX0RDDS34: LulData = LpOutputBuffReg->ulFLXAnFRRDDS34; break; case FR_59_RENESAS_FLX0RDDS35: LulData = LpOutputBuffReg->ulFLXAnFRRDDS35; break; case FR_59_RENESAS_FLX0RDDS36: LulData = LpOutputBuffReg->ulFLXAnFRRDDS36; break; case FR_59_RENESAS_FLX0RDDS37: LulData = LpOutputBuffReg->ulFLXAnFRRDDS37; break; case FR_59_RENESAS_FLX0RDDS38: LulData = LpOutputBuffReg->ulFLXAnFRRDDS38; break; case FR_59_RENESAS_FLX0RDDS39: LulData = LpOutputBuffReg->ulFLXAnFRRDDS39; break; case FR_59_RENESAS_FLX0RDDS40: LulData = LpOutputBuffReg->ulFLXAnFRRDDS40; break; case FR_59_RENESAS_FLX0RDDS41: LulData = LpOutputBuffReg->ulFLXAnFRRDDS41; break; case FR_59_RENESAS_FLX0RDDS42: LulData = LpOutputBuffReg->ulFLXAnFRRDDS42; break; case FR_59_RENESAS_FLX0RDDS43: LulData = LpOutputBuffReg->ulFLXAnFRRDDS43; break; case FR_59_RENESAS_FLX0RDDS44: LulData = LpOutputBuffReg->ulFLXAnFRRDDS44; break; case FR_59_RENESAS_FLX0RDDS45: LulData = LpOutputBuffReg->ulFLXAnFRRDDS45; break; case FR_59_RENESAS_FLX0RDDS46: LulData = LpOutputBuffReg->ulFLXAnFRRDDS46; break; case FR_59_RENESAS_FLX0RDDS47: LulData = LpOutputBuffReg->ulFLXAnFRRDDS47; break; case FR_59_RENESAS_FLX0RDDS48: LulData = LpOutputBuffReg->ulFLXAnFRRDDS48; break; case FR_59_RENESAS_FLX0RDDS49: LulData = LpOutputBuffReg->ulFLXAnFRRDDS49; break; case FR_59_RENESAS_FLX0RDDS50: LulData = LpOutputBuffReg->ulFLXAnFRRDDS50; break; case FR_59_RENESAS_FLX0RDDS51: LulData = LpOutputBuffReg->ulFLXAnFRRDDS51; break; case FR_59_RENESAS_FLX0RDDS52: LulData = LpOutputBuffReg->ulFLXAnFRRDDS52; break; case FR_59_RENESAS_FLX0RDDS53: LulData = LpOutputBuffReg->ulFLXAnFRRDDS53; break; case FR_59_RENESAS_FLX0RDDS54: LulData = LpOutputBuffReg->ulFLXAnFRRDDS54; break; case FR_59_RENESAS_FLX0RDDS55: LulData = LpOutputBuffReg->ulFLXAnFRRDDS55; break; case FR_59_RENESAS_FLX0RDDS56: LulData = LpOutputBuffReg->ulFLXAnFRRDDS56; break; case FR_59_RENESAS_FLX0RDDS57: LulData = LpOutputBuffReg->ulFLXAnFRRDDS57; break; case FR_59_RENESAS_FLX0RDDS58: LulData = LpOutputBuffReg->ulFLXAnFRRDDS58; break; case FR_59_RENESAS_FLX0RDDS59: LulData = LpOutputBuffReg->ulFLXAnFRRDDS59; break; case FR_59_RENESAS_FLX0RDDS60: LulData = LpOutputBuffReg->ulFLXAnFRRDDS60; break; case FR_59_RENESAS_FLX0RDDS61: LulData = LpOutputBuffReg->ulFLXAnFRRDDS61; break; case FR_59_RENESAS_FLX0RDDS62: LulData = LpOutputBuffReg->ulFLXAnFRRDDS62; break; case FR_59_RENESAS_FLX0RDDS63: LulData = LpOutputBuffReg->ulFLXAnFRRDDS63; break; case FR_59_RENESAS_FLX0RDDS64: LulData = LpOutputBuffReg->ulFLXAnFRRDDS64; break; default: /* No action required */ break; } return (LulData); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0RDDS46'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS1', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS2', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS3', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS4', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS5', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS6', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS7', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS8', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS9', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS10', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS11', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS12', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS13', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS14', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS15', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS16', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS17', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS18', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS19', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS20', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS21', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS22', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS23', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS24', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS25', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS26', 'Value': '-'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS27', 'Value': '-'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS28', 'Value': '-'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS29', 'Value': '-'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS30', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS31', 'Value': '-'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS32', 'Value': '-'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS33', 'Value': '-'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS34', 'Value': '-'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS35', 'Value': '-'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS36', 'Value': '-'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS37', 'Value': '-'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS38', 'Value': '-'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS39', 'Value': '-'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS40', 'Value': '-'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS41', 'Value': '-'], 'Input_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS42', 'Value': '-'], 'Input_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS43', 'Value': '-'], 'Input_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS44', 'Value': '-'], 'Input_Param_048': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS45', 'Value': '-'], 'Input_Param_049': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS46', 'Value': '91'], 'Input_Param_050': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS47', 'Value': '-'], 'Input_Param_051': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS48', 'Value': '-'], 'Input_Param_052': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS49', 'Value': '-'], 'Input_Param_053': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS50', 'Value': '-'], 'Input_Param_054': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS51', 'Value': '-'], 'Input_Param_055': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS52', 'Value': '-'], 'Input_Param_056': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS53', 'Value': '-'], 'Input_Param_057': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS54', 'Value': '-'], 'Input_Param_058': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS55', 'Value': '-'], 'Input_Param_059': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS56', 'Value': '-'], 'Input_Param_060': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS57', 'Value': '-'], 'Input_Param_061': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS58', 'Value': '-'], 'Input_Param_062': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS59', 'Value': '-'], 'Input_Param_063': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS60', 'Value': '-'], 'Input_Param_064': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS61', 'Value': '-'], 'Input_Param_065': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS62', 'Value': '-'], 'Input_Param_066': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS63', 'Value': '-'], 'Input_Param_067': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDDS64', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': '91'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_ReadReceiveData(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint16, AUTOMATIC) Fr_LPduIdx, P2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(Fr_RxLPduStatusType,AUTOMATIC, FR_APPL_DATA) Fr_LPduStatusPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduLengthPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ P2VAR(volatile Fr_59_Renesas_MessageBufferStatusRegType, AUTOMATIC, REGSPACE) LpMBStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ uint32 LulData; volatile uint8 LucLoopCount; volatile uint8 LucIncrement; uint32 LulDataAddress; uint32 LulStatusFlags; uint32 LulValidFrameFlags; Std_ReturnType LucReturnValue; LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LpMBStatusReg = LpCtrlRegSet->pMBStatusReg; /* Read Slot Status Errors from register FLXnMBS */ LulData = LpOutputBuffReg->ulFLXAnFRMBS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpFrameConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig; LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ LulStatusFlags = FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ if (FR_59_RENESAS_TRUE == LpFrameConfigPtr->blIsFrIfDemFTSlotStatusConfig) /* PRQA S 2814 # JV-02 */ { /* Check for slots status error */ LulStatusFlags = (LulData & FR_59_RENESAS_FLX0MBS_SLOT_ERROR_MASK); LulStatusFlags = LulStatusFlags >> FR_59_RENESAS_TWO; if ((uint32)FR_59_RENESAS_ZERO < LulStatusFlags) { FR_59_RENESAS_DEM_REPORT_ERROR(LpFrameConfigPtr->usFrIfDemFTSlotStatus, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } else { FR_59_RENESAS_DEM_REPORT_ERROR(LpFrameConfigPtr->usFrIfDemFTSlotStatus, DEM_EVENT_STATUS_PASSED); /* PRQA S 3469 # JV-01 */ } } /* else No Action required */ /* Check for vSS!ValidFrame */ LulValidFrameFlags = (LulData & FR_59_RENESAS_FLX0MBS_FLX0MBSVFR_MASK); #if (FR_59_RENESAS_RX_STRINGENT_CHECK == STD_ON) /* Check for slots status error */ LulStatusFlags = (LulData & FR_59_RENESAS_FLX0MBS_SLOT_ERROR_MASK); #endif if (((uint32)FR_59_RENESAS_ZERO != LulStatusFlags) || ((uint32)FR_59_RENESAS_ZERO == LulValidFrameFlags)) { *Fr_LPduStatusPtr = FR_NOT_RECEIVED; /* PRQA S 2814 # JV-03 */ *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ } /* else No Action required */ if (FR_RECEIVED == *Fr_LPduStatusPtr) { /* Copy the received data from OBF Host to Fr_LSduPtr */ LulData = ((LpOutputBuffReg->ulFLXAnFRRDHS2) & FR_59_RENESAS_DATA_LENGTH_MASK) >> FR_59_RENESAS_DATA_LENGTH_SHIFT; /* Stringent length check */ #if (FR_59_RENESAS_RX_STRINGENT_LENGTH_CHECK == STD_ON) if (LpFrameConfigPtr->ucPayloadLength != (uint8)LulData) { /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; /* Update the status Ptr and Sdu Length Ptr */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; } else #endif { /* Copy the received data from OBF Host to Fr_LSduPtr */ /* (*Fr_LSduLengthPtr) calculation is corrected by multiply with two */ if (LulData <= LpFrameConfigPtr->ucPayloadLength) { *Fr_LSduLengthPtr = ((uint8)LulData * (uint8)FR_59_RENESAS_TWO); } else { *Fr_LSduLengthPtr = (LpFrameConfigPtr->ucPayloadLength * (uint8)FR_59_RENESAS_TWO); } /* Host Buffer -> *FrLSduPtrPtr */ /* FRRDDS1-64(0x0600-0x06FC) : Host Buffer*/ /* -> Fr_LSduPtr */ /* (Mapping of FlexRayCC Register) */ /* 31 59 15 07 0 */ /* +------+------+------+-------+ */ /*reg01: Data4 Data3 Data2 Data1 */ /* +------+------+------+-------+ */ /*reg02: Data8 Data7 Data6 Data5 */ /* +------+------+------+-------+ */ /* : : */ /* : : */ /* +------+------+------+-------+ */ /*reg63: Data252Data251Data250Data249 */ /* +------+------+------+-------+ */ /*reg64: ----- ----- Data254 Data253 */ /* +------+------+------+-------+ */ /* */ /* (Mapping of LSduPtr) */ /* +0 +1 +2 */ /* +------+------+------+------ */ /*LSduPtr:Data1 Data2 Data3 --- */ /* +------+------+------+------ */ /* */ /* +251 +252 +253 */ /* ---------+--------+-------+ */ /* --- Data252 Data253 Data254 */ /* ---------+--------+-------+ */ /* Get the base address of the register FLX0RDDS1 */ LulDataAddress = (uint32)FR_59_RENESAS_FLX0RDDS1; /* Update the value for loop count to FR_59_RENESAS_ONE */ LucLoopCount = FR_59_RENESAS_ONE; /* Check if the loop count value is less than the value of Fr_LSduLengthPtr */ while (LucLoopCount < (*Fr_LSduLengthPtr)) /* PRQA S 3416 # JV-01 */ { /* Read the value of the data from the address LulDataAddress */ LulData = Fr_59_Renesas_ReadDataSection(Fr_CtrlIdx, LulDataAddress); /* Update the data value in Fr_LSduPtr */ *Fr_LSduPtr = (uint8)(LulData & FR_59_RENESAS_DATA_MASK); /* PRQA S 2814 # JV-03 */ /* Increment the pointer address */ Fr_LSduPtr++; /* PRQA S 1338, 2824 # JV-01, JV-01 */ /* Shift the data value by 8, mask and update the data value in Fr_LSduPtr */ *Fr_LSduPtr = (uint8)((LulData >> FR_59_RENESAS_DATA_BYTE2_SHIFT) & FR_59_RENESAS_DATA_MASK); /* PRQA S 2814 # JV-03 */ Fr_LSduPtr++; /* PRQA S 1338, 2824 # JV-01, JV-01 */ /* Increment the loop count by FR_59_RENESAS_TWO */ LucIncrement = LucLoopCount + (uint8)FR_59_RENESAS_TWO; LucLoopCount = LucIncrement; /* Check the value of loop count */ if (LucLoopCount < (*Fr_LSduLengthPtr)) /* PRQA S 3416 # JV-01 */ { /* Shift the data value by 16, mask and update the data value in Fr_LSduPtr */ *Fr_LSduPtr = (uint8)((LulData >> FR_59_RENESAS_DATA_BYTE3_SHIFT) & FR_59_RENESAS_DATA_MASK); /* PRQA S 2814 # JV-03 */ /* Increment the pointer address */ Fr_LSduPtr++; /* PRQA S 1338, 2824 # JV-01, JV-01 */ /* Shift the data value by 24, mask and update the data value in Fr_LSduPtr */ *Fr_LSduPtr = (uint8)(LulData >> FR_59_RENESAS_DATA_BYTE4_SHIFT); /* PRQA S 2814 # JV-03 */ /* Increment the pointer address */ Fr_LSduPtr++; /* PRQA S 1338, 2824 # JV-01, JV-01 */ /* Increment the loop count by FR_59_RENESAS_TWO */ LucIncrement = LucLoopCount + (uint8)FR_59_RENESAS_TWO; LucLoopCount = LucIncrement; } /* else No Action required */ /* Increment the loop count by FR_59_RENESAS_FOUR */ LulDataAddress = LulDataAddress + (uint32)FR_59_RENESAS_FOUR; /* PRQA S 3383 # JV-01 */ } /* End of while (LucLoopCount < (*Fr_LSduLengthPtr)) */ /* Check if frame is configured to FIFO */ if (FR_59_RENESAS_TRUE == LpFrameConfigPtr->blIsFIFOConfig) { LulData = LpMBStatusReg->ulFLXAnFRFSR; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check if FIFO is empty or not */ if (FR_59_RENESAS_FLX0FSR_FLX0RFNE_MASK == (LulData & FR_59_RENESAS_FLX0FSR_FLX0RFNE_MASK)) { /* Update the status Ptr */ *Fr_LPduStatusPtr = FR_RECEIVED_MORE_DATA_AVAILABLE; } else /* FIFO is empty, no new data is available */ { /* Update the status Ptr and Sdu Length Ptr */ *Fr_LPduStatusPtr = FR_RECEIVED; } } /* else No Action required */ } } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '4095'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_LSduPtr', 'Value': '&map_Fr_LSduPtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '&map_Fr_LPduStatusPtr[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '&map_Fr_LSduLengthPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr[0]', 'Value': 'FR_RECEIVED'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRMBS', 'Value': '0x3'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].blIsFrIfDemFTSlotStatusConfig', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0..127', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucPayloadLength', 'Value': '4'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'FRIF_E_LPDU_SLOTSTATUS', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].usFrIfDemFTSlotStatus', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRRDHS2', 'Value': '0x05000000'], 'Input_Param_015': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = 0x04030201\\n'], 'Input_Param_016': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].blIsFIFOConfig', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pMBStatusReg', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_MBStatusReg[0].ulFLXAnFRFSR', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '[1 to 2] = 0'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDataAddress', 'Value': '[1] = FR_59_RENESAS_FLX0RDDS1\\n[2] = FR_59_RENESAS_FLX0RDDS2'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr[0]', 'Value': 'FR_RECEIVED'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LSduLengthPtr[0]', 'Value': '8'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_LSduPtr[0 to 255]', 'Value': '[0] = 1\\n[1] = 2\\n[2] = 3\\n[3] = 4\\n[4] = 1\\n[5] = 0\\n[6] = 0\\n[7] = 0'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) || (FR_59_RENESAS_ENABLE_OUTPUT_RX_FIFO_HANDLER == STD_ON)) #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_ReceiveQueueTable( VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_OutputTableContentPtr) /* PRQA S 3432, 3673 # JV-01, JV-01 */ { /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module and trasnfer handler are initialized */ if ((FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) || /* PRQA S 3416, 3415 # JV-01, JV-01 */ (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblTransferHandlerInitDone)) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVEQUEUETABLE_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check the validity of the parameter Fr_CtrlIdx */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVEQUEUETABLE_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if Fr_OutputTableContentPtr is a NULL pointer or the input pointer and value is invalid */ if ((NULL_PTR == Fr_OutputTableContentPtr) || ((NULL_PTR == Fr_OutputTableContentPtr ->Fr_59_Renesas_pOutputDataPtr) || (FR_59_RENESAS_MAX_MB_NUMBER < Fr_OutputTableContentPtr->ucMsgBuffer))) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVEQUEUETABLE_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Update the Output table content */ LucReturnValue = Fr_59_Renesas_UpdateOutputPtrTable(Fr_CtrlIdx, Fr_OutputTableContentPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED -1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_OutputTableContentPtr', 'Value': '&map_Fr_OutputTableContentPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'NULL, !NULL', 'Name': 'Fr_59_Renesas_pOutputDataPtr', 'Value': '&map_pOutputDataPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucMsgBuffer', 'Value': '3'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblTransferHandlerInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED -1'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_OutputTableContentPtr', 'Value': '&map_Fr_OutputTableContentPtr[0]'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_ReceiveRxLPdu( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_CtrlIdx, VAR(uint16, AUTOMATIC) Fr_LPduIdx, P2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduPtr, /* PRQA S 3432 # JV-01 */ P2VAR(Fr_RxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_LPduStatusPtr, /* PRQA S 3432 # JV-01 */ P2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduLengthPtr /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) , P2VAR(Fr_SlotAssignmentType, AUTOMATIC, FR_APPL_DATA) Fr_SlotAssignmentPtr /* PRQA S 3432 # JV-01 */ #endif ) { P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) P2VAR(volatile uint16, AUTOMATIC, FR_VAR_NO_INIT) LpBufReconfigStatusPtr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif Std_ReturnType LucReturnValue; uint8 LucMessageBuffer; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if default error is detected */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) { /* Check if the value of LPduIdx is greater than the number of frames configured */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); if (Fr_LPduIdx >= LpCtrlTable->usMaxFrames) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INV_LPDU_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* else No Action required */ /* Check if the output parameter Fr_LSduPtr is NULL pointer */ if (NULL_PTR == Fr_LSduPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_LPduStatusPtr is NULL pointer */ if (NULL_PTR == Fr_LPduStatusPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_LSduLengthPtr is NULL pointer */ if (NULL_PTR == Fr_LSduLengthPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if default error is detected */ if (FR_59_RENESAS_TRUE == LblDevErrDetect) { LucReturnValue = E_NOT_OK; if ((NULL_PTR != Fr_LPduStatusPtr) && (NULL_PTR != Fr_LSduLengthPtr)) { /* Set the status as not received */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; /* Set the received length as zero */ *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; } /* else No Action required */ } else #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Initialize local pointer */ LpFrameConfig = (P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig); LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ /* Read the value of FLXAnFREIR register and check if there is any interrupt */ LucReturnValue = Fr_59_Renesas_CheckErrorInterrupt(Fr_CtrlIdx); if (E_OK == LucReturnValue) { /* Check that frame is not transmit frame and also Frame ID is not equal to ZERO */ if ((FR_59_RENESAS_CFG_RECEIVE == LpFrameConfigPtr->ucFrameConfig) && /* PRQA S 2814 # JV-02 */ (FR_59_RENESAS_ZERO != LpFrameConfigPtr->usFrameId)) { /* Check if frame is configured to FIFO */ if (FR_59_RENESAS_TRUE == LpFrameConfigPtr->blIsFIFOConfig) { /* Update the LPdu status and LSdu length */ Fr_59_Renesas_UpdateStsLength(Fr_CtrlIdx, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } else { /* Read the Message Buffer configured to the frame */ LucMessageBuffer = LpFrameConfigPtr->ucMsgBuffer; #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Initialize local pointer of Buffer Reconfig Status */ LpBufReconfigStatusPtr = Fr_59_Renesas_GpBufReconfigStatusPtr[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ if (((LpFrameConfigPtr->blBufferReConfig != LpFrameConfigPtr->blFrIfReconfigurable) && (LpBufReconfigStatusPtr[LucMessageBuffer] == Fr_LPduIdx)) || /* PRQA S 2824, 2844 # JV-02, JV-01 */ ((FR_59_RENESAS_FALSE == LpFrameConfigPtr->blBufferReConfig) && (FR_59_RENESAS_FALSE == LpFrameConfigPtr->blFrIfReconfigurable))) #endif { LucReturnValue = Fr_59_Renesas_NewData(Fr_CtrlIdx, LucMessageBuffer, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif } if ((FR_RECEIVED == *Fr_LPduStatusPtr) && (E_OK == LucReturnValue)) /* PRQA S 2814 # JV-03 */ { /* Request transfer Header and Data from Message RAM to Output buffer */ LucReturnValue = Fr_59_Renesas_WriteOutputBufferCommand(Fr_CtrlIdx, Fr_LPduIdx); if (E_OK == LucReturnValue) { /* Read Slot Status Errors from register FLXnMBS */ LucReturnValue = Fr_59_Renesas_ReadReceiveData(Fr_CtrlIdx, Fr_LPduIdx, Fr_LSduPtr, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } else { /* Set the status Ptr and Sdu Length Ptr */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ } #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) if (((FR_RECEIVED == *Fr_LPduStatusPtr) || (FR_RECEIVED_MORE_DATA_AVAILABLE == *Fr_LPduStatusPtr)) && \\ (NULL_PTR != Fr_SlotAssignmentPtr)) { LucReturnValue = Fr_59_Renesas_GetSlotAssignment(Fr_CtrlIdx, Fr_LPduIdx, Fr_SlotAssignmentPtr); } /* else No Action required */ #endif /* (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) */ } /* else No Action required */ } else { LucReturnValue = E_NOT_OK; } /* Check if the return value is E_NOT_OK */ if (E_NOT_OK == LucReturnValue) { /* Set the status as not received */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; /* Set the received length as zero */ *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; } /* else No Action required */ } /* else No Action required */ } /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_RECONFIG_LPDU', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_PREPARE_LPDU', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DISABLE_LPDU', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_EXTENDED_LPDU_REPORTING', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '2'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_LSduPtr', 'Value': '&map_Fr_LSduPtr'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '&map_Fr_LPduStatusPtr'], 'Input_Param_009': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '&map_Fr_LSduLengthPtr'], 'Input_Param_010': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '&map_Fr_SlotAssignmentPtr'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '&map_Fr_59_Renesas_CtrlTable[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '3'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucFrameConfig', 'Value': 'FR_59_RENESAS_CFG_RECEIVE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1..2047', 'Name': 'usFrameId', 'Value': 'FR_59_RENESAS_ZERO'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blIsFIFOConfig', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '-', 'Name': 'ucMsgBuffer', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blBufferReConfig', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blFrIfReconfigurable', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpBufReconfigStatusPtr[CURRENT_TEST.Fr_CtrlIdx]', 'Value': '-'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus[0 to 2]', 'Value': '-'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr ', 'Value': '-'], 'Input_Param_027': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_028': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_029': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr', 'Value': '-'], 'Input_Param_030': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_031': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_032': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_033': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduPtr', 'Value': '-'], 'Input_Param_034': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr', 'Value': '-'], 'Input_Param_035': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LSduPtr', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr', 'Value': 'FR_NOT_RECEIVED'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LSduLengthPtr', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduPtr', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '-'], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_ReceiveRxLPdu( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_CtrlIdx, VAR(uint16, AUTOMATIC) Fr_LPduIdx, P2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduPtr, /* PRQA S 3432 # JV-01 */ P2VAR(Fr_RxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_LPduStatusPtr, /* PRQA S 3432 # JV-01 */ P2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduLengthPtr /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) , P2VAR(Fr_SlotAssignmentType, AUTOMATIC, FR_APPL_DATA) Fr_SlotAssignmentPtr /* PRQA S 3432 # JV-01 */ #endif ) { P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) P2VAR(volatile uint16, AUTOMATIC, FR_VAR_NO_INIT) LpBufReconfigStatusPtr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif Std_ReturnType LucReturnValue; uint8 LucMessageBuffer; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if default error is detected */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) { /* Check if the value of LPduIdx is greater than the number of frames configured */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); if (Fr_LPduIdx >= LpCtrlTable->usMaxFrames) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INV_LPDU_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* else No Action required */ /* Check if the output parameter Fr_LSduPtr is NULL pointer */ if (NULL_PTR == Fr_LSduPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_LPduStatusPtr is NULL pointer */ if (NULL_PTR == Fr_LPduStatusPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_LSduLengthPtr is NULL pointer */ if (NULL_PTR == Fr_LSduLengthPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if default error is detected */ if (FR_59_RENESAS_TRUE == LblDevErrDetect) { LucReturnValue = E_NOT_OK; if ((NULL_PTR != Fr_LPduStatusPtr) && (NULL_PTR != Fr_LSduLengthPtr)) { /* Set the status as not received */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; /* Set the received length as zero */ *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; } /* else No Action required */ } else #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Initialize local pointer */ LpFrameConfig = (P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig); LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ /* Read the value of FLXAnFREIR register and check if there is any interrupt */ LucReturnValue = Fr_59_Renesas_CheckErrorInterrupt(Fr_CtrlIdx); if (E_OK == LucReturnValue) { /* Check that frame is not transmit frame and also Frame ID is not equal to ZERO */ if ((FR_59_RENESAS_CFG_RECEIVE == LpFrameConfigPtr->ucFrameConfig) && /* PRQA S 2814 # JV-02 */ (FR_59_RENESAS_ZERO != LpFrameConfigPtr->usFrameId)) { /* Check if frame is configured to FIFO */ if (FR_59_RENESAS_TRUE == LpFrameConfigPtr->blIsFIFOConfig) { /* Update the LPdu status and LSdu length */ Fr_59_Renesas_UpdateStsLength(Fr_CtrlIdx, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } else { /* Read the Message Buffer configured to the frame */ LucMessageBuffer = LpFrameConfigPtr->ucMsgBuffer; #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Initialize local pointer of Buffer Reconfig Status */ LpBufReconfigStatusPtr = Fr_59_Renesas_GpBufReconfigStatusPtr[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ if (((LpFrameConfigPtr->blBufferReConfig != LpFrameConfigPtr->blFrIfReconfigurable) && (LpBufReconfigStatusPtr[LucMessageBuffer] == Fr_LPduIdx)) || /* PRQA S 2824, 2844 # JV-02, JV-01 */ ((FR_59_RENESAS_FALSE == LpFrameConfigPtr->blBufferReConfig) && (FR_59_RENESAS_FALSE == LpFrameConfigPtr->blFrIfReconfigurable))) #endif { LucReturnValue = Fr_59_Renesas_NewData(Fr_CtrlIdx, LucMessageBuffer, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif } if ((FR_RECEIVED == *Fr_LPduStatusPtr) && (E_OK == LucReturnValue)) /* PRQA S 2814 # JV-03 */ { /* Request transfer Header and Data from Message RAM to Output buffer */ LucReturnValue = Fr_59_Renesas_WriteOutputBufferCommand(Fr_CtrlIdx, Fr_LPduIdx); if (E_OK == LucReturnValue) { /* Read Slot Status Errors from register FLXnMBS */ LucReturnValue = Fr_59_Renesas_ReadReceiveData(Fr_CtrlIdx, Fr_LPduIdx, Fr_LSduPtr, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } else { /* Set the status Ptr and Sdu Length Ptr */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ } #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) if (((FR_RECEIVED == *Fr_LPduStatusPtr) || (FR_RECEIVED_MORE_DATA_AVAILABLE == *Fr_LPduStatusPtr)) && \\ (NULL_PTR != Fr_SlotAssignmentPtr)) { LucReturnValue = Fr_59_Renesas_GetSlotAssignment(Fr_CtrlIdx, Fr_LPduIdx, Fr_SlotAssignmentPtr); } /* else No Action required */ #endif /* (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) */ } /* else No Action required */ } else { LucReturnValue = E_NOT_OK; } /* Check if the return value is E_NOT_OK */ if (E_NOT_OK == LucReturnValue) { /* Set the status as not received */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; /* Set the received length as zero */ *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; } /* else No Action required */ } /* else No Action required */ } /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_RECONFIG_LPDU', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_PREPARE_LPDU', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DISABLE_LPDU', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_EXTENDED_LPDU_REPORTING', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '2'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_LSduPtr', 'Value': '&map_Fr_LSduPtr'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '&map_Fr_LPduStatusPtr'], 'Input_Param_009': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '&map_Fr_LSduLengthPtr'], 'Input_Param_010': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '&map_Fr_SlotAssignmentPtr'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '&map_Fr_59_Renesas_CtrlTable[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '3'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucFrameConfig', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1..2047', 'Name': 'usFrameId', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blIsFIFOConfig', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '-', 'Name': 'ucMsgBuffer', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blBufferReConfig', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blFrIfReconfigurable', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpBufReconfigStatusPtr[CURRENT_TEST.Fr_CtrlIdx]', 'Value': '-'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus[0 to 2]', 'Value': '-'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_NOT_OK'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr ', 'Value': '-'], 'Input_Param_027': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_028': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_029': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr', 'Value': '-'], 'Input_Param_030': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_031': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_032': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_033': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduPtr', 'Value': '-'], 'Input_Param_034': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr', 'Value': '-'], 'Input_Param_035': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LSduPtr', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduPtr', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '-'], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_ReceiveRxLPdu( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_CtrlIdx, VAR(uint16, AUTOMATIC) Fr_LPduIdx, P2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduPtr, /* PRQA S 3432 # JV-01 */ P2VAR(Fr_RxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_LPduStatusPtr, /* PRQA S 3432 # JV-01 */ P2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_LSduLengthPtr /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) , P2VAR(Fr_SlotAssignmentType, AUTOMATIC, FR_APPL_DATA) Fr_SlotAssignmentPtr /* PRQA S 3432 # JV-01 */ #endif ) { P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) P2VAR(volatile uint16, AUTOMATIC, FR_VAR_NO_INIT) LpBufReconfigStatusPtr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif Std_ReturnType LucReturnValue; uint8 LucMessageBuffer; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if default error is detected */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) { /* Check if the value of LPduIdx is greater than the number of frames configured */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); if (Fr_LPduIdx >= LpCtrlTable->usMaxFrames) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_INV_LPDU_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* else No Action required */ /* Check if the output parameter Fr_LSduPtr is NULL pointer */ if (NULL_PTR == Fr_LSduPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_LPduStatusPtr is NULL pointer */ if (NULL_PTR == Fr_LPduStatusPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_LSduLengthPtr is NULL pointer */ if (NULL_PTR == Fr_LSduLengthPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECEIVERXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if default error is detected */ if (FR_59_RENESAS_TRUE == LblDevErrDetect) { LucReturnValue = E_NOT_OK; if ((NULL_PTR != Fr_LPduStatusPtr) && (NULL_PTR != Fr_LSduLengthPtr)) { /* Set the status as not received */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; /* Set the received length as zero */ *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; } /* else No Action required */ } else #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Initialize local pointer */ LpFrameConfig = (P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig); LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ /* Read the value of FLXAnFREIR register and check if there is any interrupt */ LucReturnValue = Fr_59_Renesas_CheckErrorInterrupt(Fr_CtrlIdx); if (E_OK == LucReturnValue) { /* Check that frame is not transmit frame and also Frame ID is not equal to ZERO */ if ((FR_59_RENESAS_CFG_RECEIVE == LpFrameConfigPtr->ucFrameConfig) && /* PRQA S 2814 # JV-02 */ (FR_59_RENESAS_ZERO != LpFrameConfigPtr->usFrameId)) { /* Check if frame is configured to FIFO */ if (FR_59_RENESAS_TRUE == LpFrameConfigPtr->blIsFIFOConfig) { /* Update the LPdu status and LSdu length */ Fr_59_Renesas_UpdateStsLength(Fr_CtrlIdx, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } else { /* Read the Message Buffer configured to the frame */ LucMessageBuffer = LpFrameConfigPtr->ucMsgBuffer; #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Initialize local pointer of Buffer Reconfig Status */ LpBufReconfigStatusPtr = Fr_59_Renesas_GpBufReconfigStatusPtr[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ if (((LpFrameConfigPtr->blBufferReConfig != LpFrameConfigPtr->blFrIfReconfigurable) && (LpBufReconfigStatusPtr[LucMessageBuffer] == Fr_LPduIdx)) || /* PRQA S 2824, 2844 # JV-02, JV-01 */ ((FR_59_RENESAS_FALSE == LpFrameConfigPtr->blBufferReConfig) && (FR_59_RENESAS_FALSE == LpFrameConfigPtr->blFrIfReconfigurable))) #endif { LucReturnValue = Fr_59_Renesas_NewData(Fr_CtrlIdx, LucMessageBuffer, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif } if ((FR_RECEIVED == *Fr_LPduStatusPtr) && (E_OK == LucReturnValue)) /* PRQA S 2814 # JV-03 */ { /* Request transfer Header and Data from Message RAM to Output buffer */ LucReturnValue = Fr_59_Renesas_WriteOutputBufferCommand(Fr_CtrlIdx, Fr_LPduIdx); if (E_OK == LucReturnValue) { /* Read Slot Status Errors from register FLXnMBS */ LucReturnValue = Fr_59_Renesas_ReadReceiveData(Fr_CtrlIdx, Fr_LPduIdx, Fr_LSduPtr, Fr_LPduStatusPtr, Fr_LSduLengthPtr); } else { /* Set the status Ptr and Sdu Length Ptr */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ } #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) if (((FR_RECEIVED == *Fr_LPduStatusPtr) || (FR_RECEIVED_MORE_DATA_AVAILABLE == *Fr_LPduStatusPtr)) && \\ (NULL_PTR != Fr_SlotAssignmentPtr)) { LucReturnValue = Fr_59_Renesas_GetSlotAssignment(Fr_CtrlIdx, Fr_LPduIdx, Fr_SlotAssignmentPtr); } /* else No Action required */ #endif /* (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) */ } /* else No Action required */ } else { LucReturnValue = E_NOT_OK; } /* Check if the return value is E_NOT_OK */ if (E_NOT_OK == LucReturnValue) { /* Set the status as not received */ *Fr_LPduStatusPtr = FR_NOT_RECEIVED; /* Set the received length as zero */ *Fr_LSduLengthPtr = FR_59_RENESAS_ZERO; } /* else No Action required */ } /* else No Action required */ } /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_RECONFIG_LPDU', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_PREPARE_LPDU', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DISABLE_LPDU', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_EXTENDED_LPDU_REPORTING', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '2'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_LSduPtr', 'Value': '&map_Fr_LSduPtr'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '&map_Fr_LPduStatusPtr'], 'Input_Param_009': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '&map_Fr_LSduLengthPtr'], 'Input_Param_010': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '&map_Fr_SlotAssignmentPtr'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr', 'Value': 'FR_RECEIVED'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '&map_Fr_59_Renesas_CtrlTable[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '3'], 'Input_Param_017': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucFrameConfig', 'Value': 'FR_59_RENESAS_CFG_RECEIVE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1..2047', 'Name': 'usFrameId', 'Value': 'FR_59_RENESAS_ONE'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blIsFIFOConfig', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_020': ['Type': 'Variable', 'Range': '-', 'Name': 'ucMsgBuffer', 'Value': '1'], 'Input_Param_021': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blBufferReConfig', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_022': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blFrIfReconfigurable', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpBufReconfigStatusPtr[CURRENT_TEST.Fr_CtrlIdx]', 'Value': ' &map_Fr_59_Renesas_GpBufferReConfigStatus[0]'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus[0 to 2]', 'Value': '[1] = 1'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr ', 'Value': '-'], 'Input_Param_027': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_028': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_029': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr', 'Value': '-'], 'Input_Param_030': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_031': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_032': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_033': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduPtr', 'Value': '-'], 'Input_Param_034': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LPduStatusPtr', 'Value': '-'], 'Input_Param_035': ['Type': 'Return_Value_of', 'Range': '', 'Name': '*Fr_LSduLengthPtr', 'Value': '-'], 'Input_Param_036': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LSduPtr', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LPduStatusPtr', 'Value': 'FR_NOT_RECEIVED'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_LSduLengthPtr', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduPtr', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduStatusPtr', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLengthPtr', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '-'], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_ReconfigLPdu( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_CtrlIdx, VAR(uint16, AUTOMATIC) Fr_LPduIdx, VAR(uint16, AUTOMATIC) Fr_FrameId, VAR(Fr_ChannelType, AUTOMATIC) Fr_ChnlIdx, VAR(uint8, AUTOMATIC) Fr_CycleRepetition, VAR(uint8, AUTOMATIC) Fr_CycleOffset, VAR(uint8, AUTOMATIC) Fr_PayloadLength, VAR(uint16, AUTOMATIC) Fr_HeaderCRC) { /* Define fine the variable to store frame configuration */ P2VAR(volatile uint16, AUTOMATIC, FR_VAR_NO_INIT) LpBufReconfigStatusPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpBufferHeader; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the register value */ uint32 LulRegData; /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) { /* * Check if the value of LPduIdx is greater than the number of frames * configured */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); if (Fr_LPduIdx >= LpCtrlTable->usMaxFrames) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INV_LPDU_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the output parameter Fr_ChnlIdx is Valid */ if ((FR_CHANNEL_AB < Fr_ChnlIdx) || ((Fr_ChnlIdx != LpCtrlTable->ddChannels) && (FR_CHANNEL_AB != Fr_ChnlIdx) && (FR_CHANNEL_AB != LpCtrlTable->ddChannels))) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INV_CHNL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ if (FR_59_RENESAS_MAX_FRAMEID < Fr_FrameId) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INV_FRAMEID); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Check if Fr_PayloadLength is a even number */ if (FR_59_RENESAS_ZERO == (Fr_PayloadLength % FR_59_RENESAS_TWO)) { /* Convert the Received Payload length to WORDS */ Fr_PayloadLength = Fr_PayloadLength >> FR_59_RENESAS_ONE; /* PRQA S 1338 # JV-01 */ } else { /* Convert the Received Payload length to WORDS */ Fr_PayloadLength = (Fr_PayloadLength + FR_59_RENESAS_ONE) >> FR_59_RENESAS_ONE; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Recaculate HeaderCRC if Payload length is odd */ Fr_HeaderCRC = Fr_59_Renesas_CalHeaderCRC(Fr_CtrlIdx, Fr_LPduIdx, Fr_PayloadLength, Fr_FrameId); /* PRQA S 1338 # JV-01 */ } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check invalid value of Fr_PayloadLength parameter */ if (Fr_PayloadLength > FR_59_RENESAS_PAYLOADLENGTHMAX) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INV_LENGTH); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* else No Action required */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Check if the input parameter Fr_CycleRepetition values 1, 2, 4, 8, 16, 32 and 64 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) if ((FR_59_RENESAS_ONE == Fr_CycleRepetition) || (FR_59_RENESAS_TWO == Fr_CycleRepetition) || (FR_59_RENESAS_FOUR == Fr_CycleRepetition) || (FR_59_RENESAS_EIGHT == Fr_CycleRepetition) || (FR_59_RENESAS_SIXTEEN == Fr_CycleRepetition) || (FR_59_RENESAS_THIRTYTWO == Fr_CycleRepetition) || (FR_59_RENESAS_SIXTYFOUR == Fr_CycleRepetition)) { /* No action required */ } else { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INV_CYCLE); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* Check if the output parameter Fr_CycleOffset value is in between 0 to (Fr_CycleRepetition minus 1) */ if (Fr_CycleOffset <= (Fr_CycleRepetition - FR_59_RENESAS_ONE)) /* PRQA S 3383 # JV-01 */ { /* No action required */ } else { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INV_CYCLE); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* Check that Fr_HeaderCRC parameter is in the allowed range (0 to 2047) */ if (FR_59_RENESAS_MAX_CRC < Fr_HeaderCRC) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_RECONFIGLPDU_SID, FR_59_RENESAS_E_INV_HEADERCRC); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Initialize local pointer */ LpBufReconfigStatusPtr = Fr_59_Renesas_GpBufReconfigStatusPtr[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpFrameConfig = (P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig); LpBufferHeader = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ /* Read the frame pointer */ /* Check whether the frame is reconfigurable. */ if (FR_59_RENESAS_TRUE == LpBufferHeader->blFrIfReconfigurable) /* PRQA S 2814 # JV-02 */ { /* Get the frame Id */ LulRegData = (Fr_FrameId & FR_59_RENESAS_FID_MASK); /* PRQA S 2985 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Get the configured cycle code */ /* Since the Fr_CycleRepetition and Fr_CycleOffset masking is */ /* considered when FR_59_RENESAS_DEV_ERROR_DETECT is ON */ LulRegData = LulRegData | (((uint32)Fr_CycleRepetition | Fr_CycleOffset) << FR_59_RENESAS_CYC_SHIFT); #else /* Get the configured cycle code */ LulRegData = LulRegData | ((((uint32)Fr_CycleRepetition | Fr_CycleOffset) & FR_59_RENESAS_CYC_MASK) << FR_59_RENESAS_CYC_SHIFT); #endif /* Get the channel configured */ #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION) LulRegData = LulRegData | (((uint32)Fr_ChnlIdx & FR_59_RENESAS_CHNL_MASK) << FR_59_RENESAS_CHNL_SHIFT); #else LulRegData = LulRegData | ((((uint32)Fr_ChnlIdx + (uint32)FR_59_RENESAS_ONE) & FR_59_RENESAS_CHNL_MASK) /* PRQA S 3383 # JV-01 */ << FR_59_RENESAS_CHNL_SHIFT); #endif /* Get the message buffer direction configuration bit */ LulRegData = LulRegData | ((uint32)((LpBufferHeader->ucFrameConfig) & FR_59_RENESAS_CFG_MASK) << FR_59_RENESAS_CFG_SHIFT); /* Get the PPIT bit configured */ LulRegData = LulRegData | ((uint32)((LpBufferHeader->ucPpit) & FR_59_RENESAS_PPIT_MASK) << FR_59_RENESAS_PPIT_SHIFT); /* Get the Transmission mode configured */ LulRegData = LulRegData | ((uint32)((LpBufferHeader->ucTransmissionMode) & FR_59_RENESAS_TXM_MASK) << FR_59_RENESAS_TXM_SHIFT); /* Get the message buffer interrupt configured */ LulRegData = LulRegData | ((uint32)((LpBufferHeader->ucMsgBufferInterrupt) & FR_59_RENESAS_MBI_MASK) << FR_59_RENESAS_MBI_SHIFT); /* Write the value of the header in FlexRay Write Header Section Register 1 and mirror address */ LucReturnValue = Fr_59_Renesas_UpdateWRHReg(Fr_CtrlIdx, LulRegData, Fr_HeaderCRC, Fr_PayloadLength, Fr_LPduIdx); if (E_OK == LucReturnValue) { /* Get the message buffer Id configured for the frame and update the frame Id in the corresponding buffer * reconfiguration status array */ LpBufReconfigStatusPtr[LpBufferHeader->ucMsgBuffer] = Fr_LPduIdx; /* PRQA S 2824, 2844 # JV-02, JV-01 */ } /* else No Action required */ } else { /* Frame is not reconfigurable */ LucReturnValue = E_NOT_OK; } } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_RECONFIG_LPDU', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_PREPARE_LPDU', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '2'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'FR_CHANNEL_A, FR_CHANNEL_B, FR_CHANNEL_AB,', 'Name': 'Fr_ChnlIdx', 'Value': 'FR_CHANNEL_A'], 'Input_Param_006': ['Type': 'Argument', 'Range': '1, 2, 4, 8, 16, 32, 64', 'Name': 'Fr_CycleRepetition', 'Value': 'FR_59_RENESAS_FOUR'], 'Input_Param_007': ['Type': 'Argument', 'Range': '0 to (Fr_CycleRepetition \u2013 1)', 'Name': 'Fr_CycleOffset', 'Value': 'FR_59_RENESAS_ONE'], 'Input_Param_008': ['Type': 'Argument', 'Range': '0..127', 'Name': 'Fr_PayloadLength', 'Value': '126'], 'Input_Param_009': ['Type': 'Argument', 'Range': '0..2047', 'Name': 'Fr_HeaderCRC', 'Value': '1024'], 'Input_Param_010': ['Type': 'Argument', 'Range': '0..2047', 'Name': 'Fr_FrameId', 'Value': '3'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': 'FR_CHANNEL_A, FR_CHANNEL_AB, FR_CHANNEL_B', 'Name': 'ddChannels', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blFrIfReconfigurable', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucFrameConfig', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucPpit', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucTransmissionMode', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucMsgBufferInterrupt', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '-', 'Name': 'ucMsgBuffer', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpBufReconfigStatusPtr[CURRENT_TEST.Fr_CtrlIdx]', 'Value': '-'], 'Input_Param_024': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus[0 to 0]', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_PayloadLength', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_FrameId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegData', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_HeaderCRC', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_PayloadLength', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_019': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_ResetInputTransfer(CONST(uint8, AUTOMATIC) Fr_CtrlIdx) /* PRQA S 1532, 1503 # JV-01, JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint32 LulData; volatile uint16 LusLoopCount; /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* Check for Input Transfer enable */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ if ((FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) && (FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK))) { LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Read current value of FLX0FRITC register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Disable the input transfer handler */ LulData = LulData & FR_59_RENESAS_FLX0FRITC_ITE_RESET; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; /* Wait until input transfer is disabled */ while ((FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == /* PRQA S 3416, 3415 # JV-01, JV-01 */ (LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Set Return Value as E_OK */ LucReturnValue = E_OK; } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS', 'Value': '0x0002'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pDemEventId', 'Value': '[0] = &map_Fr_59_Renesas_DemEventId[0]\\n[1] = &map_Fr_59_Renesas_DemEventId[1]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[CURRENT_TEST.Fr_CtrlIdx].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[CURRENT_TEST.Fr_CtrlIdx].usHardwareTestFailure', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '1'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '-'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_ResetInputTransfer(CONST(uint8, AUTOMATIC) Fr_CtrlIdx) /* PRQA S 1532, 1503 # JV-01, JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint32 LulData; volatile uint16 LusLoopCount; /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); /* Check for Input Transfer enable */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ if ((FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) && (FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK))) { LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Read current value of FLX0FRITC register */ LulData = LpDataTransferCtrlReg->ulFLXAnFRITC; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Disable the input transfer handler */ LulData = LulData & FR_59_RENESAS_FLX0FRITC_ITE_RESET; /* Writing in to FlexRay Input Transfer Configuration Register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRITC = LulData; /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; /* Wait until input transfer is disabled */ while ((FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == /* PRQA S 3416, 3415 # JV-01, JV-01 */ (LpDataTransferStatusReg->ulFLXAnFRITS & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Set Return Value as E_OK */ LucReturnValue = E_OK; } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS', 'Value': '0x0003'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pDemEventId', 'Value': '[0] = &map_Fr_59_Renesas_DemEventId[0]\\n[1] = &map_Fr_59_Renesas_DemEventId[1]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[CURRENT_TEST.Fr_CtrlIdx].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[CURRENT_TEST.Fr_CtrlIdx].usHardwareTestFailure', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '1'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRITC', 'Value': '-'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_SendWUP(VAR(uint8, AUTOMATIC) Fr_CtrlIdx) /* PRQA S 1503 # JV-01 */ { uint32 LulData; /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblErrDetect; /* Initialize development detection flag */ LblErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #if ((FR_59_RENESAS_DEV_ERROR_DETECT != STD_ON) && (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)) P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SENDWUP_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SENDWUP_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Read the POC state by getting the FRCCSV register value */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if POC is not in READY State */ if (FR_59_RENESAS_READY_STATE != LulData) { #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SENDWUP_SID, FR_59_RENESAS_E_INV_POCSTATE); #else /* FR_59_RENESAS_DEV_ERROR_DETECT == STD_OFF */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #endif /* #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)*/ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Report to DET */ (void)Det_ReportRuntimeError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SENDWUP_SID, FR_59_RENESAS_E_INV_POCSTATE); #endif /* Set return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Update the command in Configuration register */ LucReturnValue = Fr_59_Renesas_WriteCHICmd(Fr_CtrlIdx, FR_59_RENESAS_WAKEUP); } } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* End of (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FR_59_RENESAS_DEFAULT_CONFIG_STATE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pDemEventId', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'usHardwareTestFailure', 'Value': '-'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FR_59_RENESAS_E_INV_POCSTATE'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FR_59_RENESAS_MODULE_ID'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FR_59_RENESAS_INSTANCE_ID'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FR_59_RENESAS_SENDWUP_SID'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_015': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'CHICmd', 'Value': '-'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_SendWUP(VAR(uint8, AUTOMATIC) Fr_CtrlIdx) /* PRQA S 1503 # JV-01 */ { uint32 LulData; /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblErrDetect; /* Initialize development detection flag */ LblErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #if ((FR_59_RENESAS_DEV_ERROR_DETECT != STD_ON) && (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)) P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SENDWUP_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SENDWUP_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Read the POC state by getting the FRCCSV register value */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if POC is not in READY State */ if (FR_59_RENESAS_READY_STATE != LulData) { #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SENDWUP_SID, FR_59_RENESAS_E_INV_POCSTATE); #else /* FR_59_RENESAS_DEV_ERROR_DETECT == STD_OFF */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #endif /* #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)*/ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Report to DET */ (void)Det_ReportRuntimeError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SENDWUP_SID, FR_59_RENESAS_E_INV_POCSTATE); #endif /* Set return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Update the command in Configuration register */ LucReturnValue = Fr_59_Renesas_WriteCHICmd(Fr_CtrlIdx, FR_59_RENESAS_WAKEUP); } } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* End of (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FR_59_RENESAS_DEFAULT_CONFIG_STATE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pDemEventId', 'Value': '[0] = &map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure\\n[1] = &map_Fr_59_Renesas_DemEventId[1].usHardwareTestFailure'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'usHardwareTestFailure', 'Value': '[0] = FR_59_RENESAS_DEM_NOT_CONFIGURED\\n[1] = FR_59_RENESAS_DEM_NOT_CONFIGURED'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_015': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'CHICmd', 'Value': '-'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_SetAbsoluteTimer( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_CtrlIdx, VAR(uint8, AUTOMATIC) Fr_AbsTimerIdx, VAR(uint8, AUTOMATIC) Fr_Cycle, /* PRQA S 1503 # JV-01 */ VAR(uint16, AUTOMATIC) Fr_Offset) { /* Declare the variable to store POC state */ uint32 LulData; /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #if ((FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) || (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Declare the variable to store the DET return value */ boolean LblErrDetect; /* Initialize development detection flag */ LblErrDetect = FR_59_RENESAS_FALSE; #endif /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETABSOLUTETIMER_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETABSOLUTETIMER_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the input parameter Fr_Offset is greater than the maximum value of macroticks per cycle */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); if (Fr_Offset > (LpCtrlTable->usMaxMacroPerCycle)) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETABSOLUTETIMER_SID, FR_59_RENESAS_E_INV_OFFSET); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* * Check if the absolute timer configured is greater than the number * of absolute timers configured for this controller */ if ((LpCtrlTable->ucAbsTimerCount) <= Fr_AbsTimerIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETABSOLUTETIMER_SID, FR_59_RENESAS_E_INV_TIMER_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* * Check if the input parameter Fr_Cycle is greater than the maximum * number of cycles in the communication cycle */ if (FR_59_RENESAS_MAX_CYCLE_COUNT < Fr_Cycle) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETABSOLUTETIMER_SID, FR_59_RENESAS_E_INV_CYCLE); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Read the POC state by getting the value of the register FRCCSV */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if the POC is not in NORMAL_ACTIVE or NORMAL_PASSIVE State */ if ((FR_59_RENESAS_NORMAL_ACTIVE_STATE != LulData) && (FR_59_RENESAS_NORMAL_PASSIVE_STATE != LulData)) { #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) && (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON)) /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETABSOLUTETIMER_SID, FR_59_RENESAS_E_INV_POCSTATE); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; #endif /* #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) \\ &&\\ (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON))*/ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Report to DET */ (void)Det_ReportRuntimeError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETABSOLUTETIMER_SID, FR_59_RENESAS_E_INV_POCSTATE); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; #endif } /* else No Action required */ } #if ((FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) || (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblErrDetect) #endif { /* Enable to start the timer */ LucReturnValue = Fr_59_Renesas_StartTimer(Fr_CtrlIdx, Fr_AbsTimerIdx, Fr_Cycle, Fr_Offset); } #if ((FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) || (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) else { LucReturnValue = E_NOT_OK; } #endif /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0,3', 'Name': 'Fr_AbsTimerIdx', 'Value': '3'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..63', 'Name': 'Fr_Cycle', 'Value': '15'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0.. FrIfGMacroPerCycle', 'Name': 'Fr_Offset', 'Value': '8000'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '&map_Fr_59_Renesas_CtrlTable[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '8..16000', 'Name': 'usMaxMacroPerCycle', 'Value': '8000'], 'Input_Param_009': ['Type': 'Variable', 'Range': '1\u20264', 'Name': 'ucAbsTimerCount', 'Value': '1'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '42'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FR_59_RENESAS_E_INV_TIMER_IDX'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FR_59_RENESAS_MODULE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FR_59_RENESAS_INSTANCE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FR_59_RENESAS_SETABSOLUTETIMER_SID'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FR_59_RENESAS_E_INV_POCSTATE'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FR_59_RENESAS_MODULE_ID'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FR_59_RENESAS_INSTANCE_ID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FR_59_RENESAS_SETABSOLUTETIMER_SID'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_AbsTimerIdx', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_Cycle', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_Offset', 'Value': '-'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_SET_CYCLE_COUNTER_FILTERING_API == STD_ON) #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_SetCycleCounterFiltering(VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_AbsTimerIdx, VAR(uint8, AUTOMATIC) Fr_CycleCode, VAR(uint16, AUTOMATIC) Fr_Offset) { /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; uint32 LulData; #if ((FR_59_RENESAS_DEV_ERROR_DETECT != STD_ON) && (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)) /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ #endif #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #if ((FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON ) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Declare the variable to store the DET return value */ boolean LblErrDetect; /* Initialize development detection flag */ LblErrDetect = FR_59_RENESAS_FALSE; #endif /* #if ((FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON ) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETCYCLECOUNTERFILTERING_SID, FR_59_RENESAS_E_INIT_FAILED); LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETCYCLECOUNTERFILTERING_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblErrDetect) { /* Check if the input parameter Fr_Offset is greater than the maximum value of macroticks per cycle */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); if (Fr_Offset > (LpCtrlTable->usMaxMacroPerCycle)) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETCYCLECOUNTERFILTERING_SID, FR_59_RENESAS_E_INV_OFFSET); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* * Check if the absolute timer configured is greater than the number * of absolute timers configured for this controller */ if ((LpCtrlTable->ucAbsTimerCount) <= Fr_AbsTimerIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETCYCLECOUNTERFILTERING_SID, FR_59_RENESAS_E_INV_TIMER_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ } /* else No Action required */ /* * Check if the input parameter Fr_Cycle is greater than the maximum * number of cycles in the communication cycle */ if (FR_59_RENESAS_MAX_CYCLE_CODE < Fr_CycleCode) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETCYCLECOUNTERFILTERING_SID, FR_59_RENESAS_E_INV_CYCLE_CODE); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ if (FR_59_RENESAS_FALSE == LblErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Read the POC state by getting the value of the register FRCCSV */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if the POC is not in READY State */ if ((FR_59_RENESAS_NORMAL_ACTIVE_STATE != LulData) && (FR_59_RENESAS_NORMAL_PASSIVE_STATE != LulData)) { #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) && (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON)) /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETCYCLECOUNTERFILTERING_SID, FR_59_RENESAS_E_INV_POCSTATE); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; #endif /* #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) \\ &&\\ (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON))*/ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Report to DET */ (void)Det_ReportRuntimeError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETCYCLECOUNTERFILTERING_SID, FR_59_RENESAS_E_INV_POCSTATE); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; #endif /* #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION))*/ } /* else No Action required */ } /* else No Action required */ #if ((FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) || (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblErrDetect) #endif /* #if ((FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON ) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) */ { #if ((FR_59_RENESAS_DEV_ERROR_DETECT != STD_ON) && (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)) /* Read the POC State by getting FLX0CCSV register value */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if the CC is in normal active state */ if ((FR_59_RENESAS_NORMAL_ACTIVE_STATE == LulData) || (FR_59_RENESAS_NORMAL_PASSIVE_STATE == LulData)) #endif { /* Set the filter for cycle counter */ LucReturnValue = Fr_59_Renesas_SetCycleOffset(Fr_CtrlIdx, Fr_AbsTimerIdx, Fr_CycleCode, Fr_Offset); } #if ((FR_59_RENESAS_DEV_ERROR_DETECT != STD_ON) && (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)) else { /* Report Error to DEM */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } #endif } #if ((FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) || (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) else { LucReturnValue = E_NOT_OK; } #endif /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0,1', 'Name': 'Fr_AbsTimerIdx', 'Value': '1'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_CycleCode', 'Value': '127'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0.. FrIfGMacroPerCycle', 'Name': 'Fr_Offset', 'Value': '16000'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '&map_Fr_59_Renesas_CtrlTable[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '8..16000', 'Name': 'usMaxMacroPerCycle', 'Value': '16000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '1..4', 'Name': 'ucAbsTimerCount', 'Value': '2'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'usHardwareTestFailure', 'Value': '-'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FR_59_RENESAS_NORMAL_ACTIVE_STATE']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_AbsTimerIdx', 'Value': '1'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CycleCode', 'Value': '127'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_Offset', 'Value': '16000'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_SetCycleOffset(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) Fr_AbsTimerIdx, VAR(uint8, AUTOMATIC) Fr_CycleCode, CONST(uint16, AUTOMATIC) Fr_Offset) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_AbsTimerConfigType, AUTOMATIC, FR_CONFIG_DATA) LpAbsTimerConfig; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Fr_59_Renesas_AbsTimerConfigType, AUTOMATIC, FR_CONFIG_DATA) LpAbsTimer; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_TimerRegType, AUTOMATIC, REGSPACE) LpTimerReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpFLXAnFRT2C; /* PRQA S 3432 # JV-01 */ /* Declare the varible to store return value */ Std_ReturnType LucReturnValue; uint32 LulTimerValue; /* Declare the variable to store the timer mode select */ Fr_59_Renesas_TimerModeSelectType LenTimerModeSelect; /* Initialize the return value */ LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpAbsTimerConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pAbsTimerConfig; LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LulTimerValue = FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ /* Get the pointer to Absolute Timer configuration of the corresponding Fr_AbsTimerIdx */ LpAbsTimer = &LpAbsTimerConfig[Fr_AbsTimerIdx]; /* PRQA S 2824 # JV-02 */ /* Get the Timer mode */ LenTimerModeSelect = LpAbsTimer->enTimerModeSelect; /* PRQA S 2814 # JV-02 */ /* Cycle Code Bit masking */ Fr_CycleCode = Fr_CycleCode & (uint8)FR_59_RENESAS_CYCLE_CODE_MASK; /* PRQA S 1338 # JV-01 */ /* Stop Absolute Timer by setting T0RC, T2RC bit */ if (FR_59_RENESAS_TIMER0 == LpAbsTimer->enTimerSelection) { /* Read the value of the Timer 0 register */ LpTimerReg = LpCtrlRegSet->pTimerReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LulTimerValue = LpTimerReg->ulFLXAnFRT0C; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Stop the Timer 0 */ LpTimerReg->ulFLXAnFRT0C = LulTimerValue & FR_59_RENESAS_FLX0T0C_FLX0T0RC_HALT; /* Read the value of the timer register */ LulTimerValue = LpTimerReg->ulFLXAnFRT0C; /* Clear the value of previous Timer mode, Cycle code and Macrotick value */ LulTimerValue = LulTimerValue & FR_59_RENESAS_FLX0T0C_FLX0T0RC_CLR; /* Set Timer Mode Select, Macrotick Offset and Cycle Code */ LulTimerValue = LulTimerValue | (((uint32)LenTimerModeSelect << FR_59_RENESAS_ONE) | ((uint32)Fr_Offset << FR_59_RENESAS_FLX0TXC_OFFSET_SHIFT) | ((uint32)Fr_CycleCode << FR_59_RENESAS_FLX0TXC_CYC_SHIFT)); /* Load the cycle and offset value in the timer register and start the timer */ LpTimerReg->ulFLXAnFRT0C = LulTimerValue | FR_59_RENESAS_FLX0T0C_FLX0T0RC_SET; } else /* Timer 2 */ { /* Read the value of the Timer 2 register */ LpFLXAnFRT2C = LpCtrlRegSet->plFLXAnFRT2C; LulTimerValue = *LpFLXAnFRT2C; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Stop the Timer 2 */ *LpFLXAnFRT2C = LulTimerValue & FR_59_RENESAS_FLX0T2C_FLX0T2RC_HALT; /* Read the value of the timer register */ LulTimerValue = *LpFLXAnFRT2C; /* Clear the value of previous cycle code and Macrotick value */ LulTimerValue = LulTimerValue & FR_59_RENESAS_FLX0T2C_FLX0T2RC_CLR; /* Set Timer Mode Select, Macrotick Offset and Cycle Code */ LulTimerValue = LulTimerValue | (((uint32)LenTimerModeSelect << FR_59_RENESAS_ONE) | ((uint32)Fr_Offset << FR_59_RENESAS_FLX0TXC_OFFSET_SHIFT) | ((uint32)Fr_CycleCode << FR_59_RENESAS_FLX0TXC_CYC_SHIFT)); /* Load the cycle and offset value in the timer register and start the timer */ *LpFLXAnFRT2C = LulTimerValue | FR_59_RENESAS_FLX0T2C_FLX0T2RC_SET; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0,1', 'Name': 'Fr_AbsTimerIdx', 'Value': '1'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_CycleCode', 'Value': '3'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0.. FrIfGMacroPerCycle', 'Name': 'Fr_Offset', 'Value': '400'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pAbsTimerConfig', 'Value': '&map_pAbsTimerConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAbsTimerConfig[CURRENT_TEST.Fr_AbsTimerIdx].enTimerSelection', 'Value': 'FR_59_RENESAS_TIMER2'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAbsTimerConfig[CURRENT_TEST.Fr_AbsTimerIdx].enTimerModeSelect', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pTimerReg', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_TimerReg[0].ulFLXAnFRT0C', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].plFLXAnFRT2C', 'Value': '&map_tempReg_1'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_tempReg_1', 'Value': '0x02']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_TimerReg[0].ulFLXAnFRT0C', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_tempReg_1', 'Value': '0x1900301'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_SetWakeupChannel( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_CtrlIdx, VAR(Fr_ChannelType, AUTOMATIC) Fr_ChnlIdx) { uint32 LulData; /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblErrDetect; /* Initialize development detection flag */ LblErrDetect = FR_59_RENESAS_FALSE; #endif #if ((FR_59_RENESAS_DEV_ERROR_DETECT != STD_ON) && (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)) P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETWAKEUPCHANNEL_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETWAKEUPCHANNEL_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the channel is invalid */ if (FR_CHANNEL_AB <= Fr_ChnlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETWAKEUPCHANNEL_SID, FR_59_RENESAS_E_INV_CHNL_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Read the POC state by getting the FRCCSV register value */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if POC is not in READY State */ if (FR_59_RENESAS_READY_STATE != LulData) { #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETWAKEUPCHANNEL_SID, FR_59_RENESAS_E_INV_POCSTATE); #else /* FR_59_RENESAS_DEV_ERROR_DETECT == STD_OFF */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #endif /* #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)*/ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Report to DET */ (void)Det_ReportRuntimeError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_SETWAKEUPCHANNEL_SID, FR_59_RENESAS_E_INV_POCSTATE); #endif /* Set return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Wait until CC is busy */ LucReturnValue = Fr_59_Renesas_CheckIfCCBusy(Fr_CtrlIdx); /* Check if the CC has not become idle */ if (E_OK == LucReturnValue) { (void)Fr_59_Renesas_WriteCHICmd(Fr_CtrlIdx, FR_59_RENESAS_CONFIG); LucReturnValue = Fr_59_Renesas_CheckIfCCBusy(Fr_CtrlIdx); /* Check if the CC has not become idle */ if (E_OK == LucReturnValue) { /* Set wakeup channel */ LucReturnValue = Fr_59_Renesas_SetWakeupChannelProcess(Fr_CtrlIdx, Fr_ChnlIdx); } /* else No Action required */ } /* else No Action required */ } } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { /* Set return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'FR_CHANNEL_A, FR_CHANNEL_B, FR_CHANNEL_AB,', 'Name': 'Fr_ChnlIdx', 'Value': 'FR_CHANNEL_B'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '43'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pDemEventId', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'usHardwareTestFailure', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FR_59_RENESAS_E_INV_POCSTATE'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FR_59_RENESAS_MODULE_ID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FR_59_RENESAS_INSTANCE_ID'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FR_59_RENESAS_SETWAKEUPCHANNEL_SID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_015': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'CHICmd', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_ChnlIdx', 'Value': '-'], 'Output_Param_022': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_SetWakeupChannelProcess( CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(Fr_ChannelType, AUTOMATIC) Fr_ChnlIdx) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ uint32 LulData; Std_ReturnType LucReturnValue; volatile uint16 LusLoopCount; /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Initialize internal variable */ LulData = FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Initialize the loop count */ LusLoopCount = FR_59_RENESAS_ZERO; /* Read FRCCSV register value to get the POC state */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check whether POC is in CONFIG State */ if (FR_59_RENESAS_CONFIG_STATE != LulData) { if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Read the value of the register FLX0SUCC1 */ LulData = LpCCCtrlReg->ulFLXAnFRSUCC1; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Check if the channel index is A */ if (FR_CHANNEL_A == Fr_ChnlIdx) { /* Configure the wakeup channel as Channel A */ LulData = (LulData & FR_59_RENESAS_FLX0SUCC1_FLX0WUCS_MASK); } else { /* Configure the wakeup channel as Channel B */ LulData = (LulData | FR_59_RENESAS_FLX0SUCC1_FLX0WUCS_SET); } /* Writing in to FlexRay SUC Configuration Register and mirror address */ LpCCCtrlReg->ulFLXAnFRSUCC1 = LulData; /* Read the value of the register FLX0SUCC1 */ LulData = LpCCCtrlReg->ulFLXAnFRSUCC1; /* Update the READY command */ LulData = ((LulData & FR_59_RENESAS_FLX0SUCC1_FLX0CMD_MASK) | FR_59_RENESAS_READY); /* Check if critical section protection is required */ #if (FR_59_RENESAS_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter the Critical Section Area */ FR_59_RENESAS_ENTER_CRITICAL_SECTION(FR_INTERRUPT_CONTROL_PROTECTION); #endif /* Execute the unlock sequence */ Fr_59_Renesas_UnlockSequence(Fr_CtrlIdx); /* Command CC to enter READY State */ /* Writing in to FlexRay SUC Configuration Register and mirror address */ LpCCCtrlReg->ulFLXAnFRSUCC1 = LulData; /* Check if critical section protection is required */ #if (FR_59_RENESAS_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit the Critical Section Area */ FR_59_RENESAS_EXIT_CRITICAL_SECTION(FR_INTERRUPT_CONTROL_PROTECTION); #endif do { /* Read FRCCSV register value to get the POC state */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } while ((FR_59_RENESAS_READY_STATE != LulData) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))); /* PRQA S 3415, 3416, 2814 # JV-01, JV-01, JV-02 */ /* Check if the CC has not changed to READY State */ if (FR_59_RENESAS_READY_STATE != LulData) { /* Cannot access the communication controller */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; } /* else No Action required */ } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'FR_CHANNEL_A, FR_CHANNEL_B, FR_CHANNEL_AB,', 'Name': 'Fr_ChnlIdx', 'Value': 'FR_CHANNEL_A'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = FR_59_RENESAS_CONFIG_STATE\\n[2] = FR_59_RENESAS_NORMAL_ACTIVE_STATE\\n[3] = FR_59_RENESAS_NORMAL_ACTIVE_STATE'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_CCCtrlReg[0].ulFLXAnFRSUCC1', 'Value': '0x00001000'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[1]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'usFlagClearMaxWait', 'Value': '2'], 'Input_Param_010': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pDemEventId', 'Value': '[0] = &map_Fr_59_Renesas_DemEventId[0]\\n[1] = &map_Fr_59_Renesas_DemEventId[1]'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[CURRENT_TEST.Fr_CtrlIdx].usReadTimeoutFailure', 'Value': '1'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[CURRENT_TEST.Fr_CtrlIdx].usHardwareTestFailure', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '[1] = FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_CCCtrlReg[0].ulFLXAnFRSUCC1', 'Value': '0x00001002'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '#function is called'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '#function is called'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '[2] = FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '[3] = FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '[2] = DEM_EVENT_STATUS_FAILED'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '[2] = 1'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_StartCommunication(VAR(uint8, AUTOMATIC) Fr_CtrlIdx) /* PRQA S 1503 # JV-01 */ { uint32 LulData; /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblErrDetect; /* Initialize development detection flag */ LblErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #if ((FR_59_RENESAS_DEV_ERROR_DETECT != STD_ON) && (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)) P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_STARTCOMMUNICATION_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_STARTCOMMUNICATION_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Read the POC state by getting the FRCCSV register value */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if POC is not in READY State */ if (FR_59_RENESAS_READY_STATE != LulData) { #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION) #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_STARTCOMMUNICATION_SID, FR_59_RENESAS_E_INV_POCSTATE); #else /* FR_59_RENESAS_DEV_ERROR_DETECT == STD_OFF */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-01 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ #endif /* #if (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_422_VERSION)*/ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Report to DET */ (void)Det_ReportRuntimeError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_STARTCOMMUNICATION_SID, FR_59_RENESAS_E_INV_POCSTATE); #endif /* Set return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Update the command in Configuration register */ LucReturnValue = Fr_59_Renesas_WriteCHICmd(Fr_CtrlIdx, FR_59_RENESAS_RUN); } } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* End of (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-'], 'Input_Param_003': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FR_59_RENESAS_READY_STATE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pDemEventId', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'usHardwareTestFailure', 'Value': '-'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'CHICmd', 'Value': 'FR_59_RENESAS_RUN'], 'Output_Param_017': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_StartTimer(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) Fr_AbsTimerIdx, VAR(uint8, AUTOMATIC) Fr_Cycle, CONST(uint16, AUTOMATIC) Fr_Offset) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_AbsTimerConfigType, AUTOMATIC, FR_CONFIG_DATA)LpAbsTimerConfig; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Fr_59_Renesas_AbsTimerConfigType, AUTOMATIC, FR_CONFIG_DATA)LpAbsTimer; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_TimerRegType, AUTOMATIC, REGSPACE) LpTimerReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpFLXAnFRT2C; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpDemEventId; /* Declare the variable to store POC status */ uint32 LulData; /* Declare variable to store register value */ uint32 LulTimerValue; /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; /* Declare the variable to store the timer mode select */ Fr_59_Renesas_TimerModeSelectType LenTimerModeSelect; /* Initialize the return value */ LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpAbsTimerConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pAbsTimerConfig; LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ /* Read the POC State by getting FLX0CCSV register value */ LulData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Get the pointer to Absolute Timer configuration of the corresponding Fr_AbsTimerIdx */ LpAbsTimer = &LpAbsTimerConfig[Fr_AbsTimerIdx]; /* PRQA S 2824 # JV-02 */ /* Get the Timer mode */ LenTimerModeSelect = LpAbsTimer->enTimerModeSelect; /* PRQA S 2814 # JV-02 */ /* Check if the CC is in normal active state */ if ((FR_59_RENESAS_NORMAL_ACTIVE_STATE == LulData) || (FR_59_RENESAS_NORMAL_PASSIVE_STATE == LulData)) { /* Stop Absolute Timer by setting T0RC, T2RC bit */ if (FR_59_RENESAS_TIMER0 == LpAbsTimer->enTimerSelection) { LpTimerReg = LpCtrlRegSet->pTimerReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LulTimerValue = LpTimerReg->ulFLXAnFRT0C; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Stop the Timer 0 */ /* Writing in to FlexRay Timer Configuration Register and mirror address */ LpTimerReg->ulFLXAnFRT0C = LulTimerValue & FR_59_RENESAS_FLX0T0C_FLX0T0RC_HALT; /* Read the value of the timer register */ LulTimerValue = LpTimerReg->ulFLXAnFRT0C; } else /* Timer 2 */ { LpFLXAnFRT2C = LpCtrlRegSet->plFLXAnFRT2C; LulTimerValue = *LpFLXAnFRT2C; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Stop the Timer 2 */ /* Writing in to FlexRay Timer Configuration Register and mirror address */ *LpFLXAnFRT2C = LulTimerValue & FR_59_RENESAS_FLX0T2C_FLX0T2RC_HALT; /* Read the value of the timer register */ LulTimerValue = *LpFLXAnFRT2C; } /* Clear the value of previous cycle code and Macrotick value */ LulTimerValue = LulTimerValue & FR_59_RENESAS_FLX0T0C_FLX0T0RC_CLR; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_OFF) /* If the DET is enabled,the 'FR_59_RENESAS_DEV_ERROR_DETECT' switch is added to avoid QAC warning 5:2985 */ Fr_Cycle = Fr_Cycle & FR_59_RENESAS_MAX_CYCLE_COUNT; /* PRQA S 1338 # JV-01 */ #endif /* Force timer interrupt is generated every sixty-fourth Cycle */ Fr_Cycle = Fr_Cycle | (uint8)FR_59_RENESAS_INT_EVERY_64_CYCLE; /* PRQA S 1338 # JV-01 */ /* Set Timer Mode Select, Macrotick Offset and Cycle Code */ LulTimerValue = LulTimerValue | (((uint32)LenTimerModeSelect << FR_59_RENESAS_ONE) | ((uint32)Fr_Offset << FR_59_RENESAS_FLX0TXC_OFFSET_SHIFT) | ((uint32)Fr_Cycle << FR_59_RENESAS_FLX0TXC_CYC_SHIFT)); /* Load the cycle and offset value in the timer register and start the timer */ /* Writing in to FlexRay Timer Configuration Register and mirror address */ Fr_59_Renesas_TimerRunning(Fr_CtrlIdx, LulTimerValue, Fr_AbsTimerIdx); } else { /* Report Error to DEM */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0,1', 'Name': 'Fr_AbsTimerIdx', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..63', 'Name': 'Fr_Cycle', 'Value': '3'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0.. FrIfGMacroPerCycle', 'Name': 'Fr_Offset', 'Value': '8'], 'Input_Param_004': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'FR_59_RENESAS_NORMAL_PASSIVE_STATE'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pTimerReg', 'Value': '&map_TimerReg[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_TimerReg[0].ulFLXAnFRT0C', 'Value': '3'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].plFLXAnFRT2C', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_tempReg_1', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pAbsTimerConfig', 'Value': '&map_pAbsTimerConfig[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAbsTimerConfig[CURRENT_TEST.Fr_AbsTimerIdx].enTimerModeSelect', 'Value': 'FR_59_RENESAS_SINGLESHOT'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAbsTimerConfig[CURRENT_TEST.Fr_AbsTimerIdx].enTimerSelection', 'Value': 'FR_59_RENESAS_TIMER0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulTimerValue', 'Value': '0x00084302'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_AbsTimerIdx ', 'Value': '0'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_TimerReg[0].ulFLXAnFRT0C', 'Value': '2'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_tempReg_1', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_TransferQueueTable( VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_InputTableContentPtr) /* PRQA S 3432 # JV-01 */ { /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module and transfer handler are initialized */ if ((FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) || /* PRQA S 3415, 3416 # JV-01, JV-01 */ (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblTransferHandlerInitDone)) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_TRANSFERQUEUETABLE_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check the validity of the parameter Fr_CtrlIdx */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_TRANSFERQUEUETABLE_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if Fr_InputTableContentPtr is a NULL pointer or Fr_59_Renesas_pInputDataPtr element is NULL_PTR */ if ((NULL_PTR == Fr_InputTableContentPtr) || (NULL_PTR == Fr_InputTableContentPtr->Fr_59_Renesas_pInputDataPtr)) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_TRANSFERQUEUETABLE_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { LucReturnValue = Fr_59_Renesas_UpdateInputPtrTable(Fr_CtrlIdx, Fr_InputTableContentPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED -1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'NULL, !NULL', 'Name': 'Fr_59_Renesas_pInputDataPtr', 'Value': '&map_pInputDataPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLX0FRWRHS1', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblTransferHandlerInitDone', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FR_59_RENESAS_E_INIT_FAILED'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FR_59_RENESAS_MODULE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FR_59_RENESAS_INSTANCE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FR_59_RENESAS_TRANSFERQUEUETABLE_SID'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_InputTableContentPtr', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_TransmitTxLPdu( /* PRQA S 1503 # JV-01 */ VAR(uint8, AUTOMATIC) Fr_CtrlIdx, VAR(uint16, AUTOMATIC) Fr_LPduIdx, P2CONST(uint8, AUTOMATIC,FR_APPL_CONST) Fr_LSduPtr, VAR(uint8, AUTOMATIC) Fr_LSduLength /* PRQA S 3432 # JV-01 */ #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) , P2VAR(Fr_SlotAssignmentType, AUTOMATIC, FR_APPL_DATA) Fr_SlotAssignmentPtr /* PRQA S 3432 # JV-01 */ #endif ) { P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA)LpHeaderPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpBufferHeaderPtr; #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) P2VAR(volatile uint16, AUTOMATIC, FR_VAR_NO_INIT)LpBufReconfigStatusPtr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif Std_ReturnType LucReturnValue; uint8 LucMessageBuffer; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare local pointer to Control Table */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA)LpCtrlTable; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module is initialized */ if (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_TRANSMITTXLPDU_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if the controller index is greater than the number of controller configured */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_TRANSMITTXLPDU_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) { #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize local pointer */ LpHeaderPtr = (P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig); #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Check if the value of LPduIdx is greater than the number of frames configured */ if (Fr_LPduIdx >= LpCtrlTable->usMaxFrames) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_TRANSMITTXLPDU_SID, FR_59_RENESAS_E_INV_LPDU_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } else { #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize pointer of frame header */ LpBufferHeaderPtr = &LpHeaderPtr[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the length is greater the value of length configured for the Lpdu */ if (Fr_LSduLength > ((uint8)(LpBufferHeaderPtr->ucPayloadLength << FR_59_RENESAS_ONE))) /* PRQA S 2814 # JV-02 */ { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_TRANSMITTXLPDU_SID, FR_59_RENESAS_E_INV_LENGTH); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ } } /* else No Action required */ /* Check if the output parameter Fr_LSduPtr is NULL pointer */ if (NULL_PTR == Fr_LSduPtr) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_TRANSMITTXLPDU_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Read the value of FLXAnFREIR register and check if there is any interrupt */ LucReturnValue = Fr_59_Renesas_CheckErrorInterrupt(Fr_CtrlIdx); if (E_OK == LucReturnValue) { #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) /* Initialize local pointer of Buffer Reconfig Status */ LpBufReconfigStatusPtr = Fr_59_Renesas_GpBufReconfigStatusPtr[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LucMessageBuffer = LpBufferHeaderPtr->ucMsgBuffer; /* PRQA S 2814 # JV-02 */ if (((LpBufferHeaderPtr->blBufferReConfig != LpBufferHeaderPtr->blFrIfReconfigurable) && (LpBufReconfigStatusPtr[LucMessageBuffer] == Fr_LPduIdx)) || /* PRQA S 2844, 2824 # JV-01, JV-02 */ ((FR_59_RENESAS_FALSE == LpBufferHeaderPtr->blBufferReConfig) && (FR_59_RENESAS_FALSE == LpBufferHeaderPtr->blFrIfReconfigurable))) #endif { LucReturnValue = Fr_59_Renesas_GetBufferCommand(Fr_CtrlIdx); /* Check if the return value is E_OK */ if (E_OK == LucReturnValue) { /* Check if Allow dynamic length is supported */ if ((FR_59_RENESAS_TRUE == LpBufferHeaderPtr->blAllowDynLength) && ((Fr_LSduLength <= (uint8)((LpBufferHeaderPtr->ucPayloadLength) << FR_59_RENESAS_ONE)))) { /* * Reconfigure buffer header to match with Fr_LSduLength and * input param Fr_LSduLength is less than configured ucPayloadLength */ LucReturnValue = Fr_59_Renesas_CfgBufferHeader( Fr_CtrlIdx, Fr_LPduIdx, ((Fr_LSduLength + (Fr_LSduLength % FR_59_RENESAS_TWO)) >> FR_59_RENESAS_ONE)); /* PRQA S 3383 # JV-01 */ } /* else No Action required */ if (E_OK == LucReturnValue) { /* Check if Frame Receive or Frame Id is 0, * return E_NOT_OK */ if ((FR_59_RENESAS_CFG_TRANSMIT == LpBufferHeaderPtr->ucFrameConfig) && (FR_59_RENESAS_ZERO != LpBufferHeaderPtr->usFrameId)) { Fr_59_Renesas_UpdateInputBuffer(Fr_CtrlIdx, Fr_LSduLength, Fr_LSduPtr); LucMessageBuffer = LpBufferHeaderPtr->ucMsgBuffer; /* Select Load Data Mode */ LucReturnValue = Fr_59_Renesas_UpdateDataTransferMode(Fr_CtrlIdx, LucMessageBuffer); } else { LucReturnValue = E_NOT_OK; } /* Copy ChannelId, FrameId and CycleId of transmitted frame */ #if (FR_59_RENESAS_EXTENDED_LPDU_REPORTING == STD_ON) if ((E_OK == LucReturnValue) && (NULL_PTR != Fr_SlotAssignmentPtr)) { LucReturnValue = Fr_59_Renesas_GetSlotAssignment(Fr_CtrlIdx, Fr_LPduIdx, Fr_SlotAssignmentPtr); } /* else No Action required */ #endif } /* else No Action required */ } /* else No Action required */ } #if (FR_59_RENESAS_RECONFIG_LPDU == STD_ON) || (FR_59_RENESAS_PREPARE_LPDU == STD_ON) || \\ (FR_59_RENESAS_DISABLE_LPDU == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif } /* else No Action required */ } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_RECONFIG_LPDU', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_PREPARE_LPDU', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DISABLE_LPDU', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_EXTENDED_LPDU_REPORTING', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '2'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_LSduPtr', 'Value': '&map_Fr_LSduPtr'], 'Input_Param_008': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '&map_Fr_SlotAssignmentPtr'], 'Input_Param_009': ['Type': 'Argument', 'Range': '0..254', 'Name': 'Fr_LSduLength', 'Value': '127'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr\\n', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pCtrlTable', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '0..127', 'Name': 'ucPayloadLength', 'Value': '64'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'ucMsgBuffer', 'Value': '2'], 'Input_Param_016': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blBufferReConfig', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_TRUE, FR_59_RENESAS_FALSE', 'Name': 'blFrIfReconfigurable', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'blAllowDynLength', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_019': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'ucFrameConfig', 'Value': 'FR_59_RENESAS_CFG_RECEIVE'], 'Input_Param_020': ['Type': 'Variable', 'Range': '1..2047', 'Name': 'usFrameId', 'Value': 'FR_59_RENESAS_ONE'], 'Input_Param_021': ['Type': 'Variable', 'Range': '0..4095', 'Name': 'usMaxFrames', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpBufReconfigStatusPtr[CURRENT_TEST.Fr_CtrlIdx]', 'Value': ' &map_Fr_59_Renesas_GpBufferReConfigStatus[0]'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpBufferReConfigStatus[0 to 3]', 'Value': '[2] = 2'], 'Input_Param_024': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_025': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_026': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_027': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_028': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLength', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduLength', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LSduPtr', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_SlotAssignmentPtr', 'Value': '-'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateCCConfig(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) Fr_ConfigParamIdx, CONSTP2VAR(uint32, AUTOMATIC, FR_APPL_DATA) Fr_ConfigParamValuePtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ uint32 LulOffSet; uint8 LucBitsTobeMovedRight; boolean LblReturnFlag; Std_ReturnType LucReturnValue; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the return flag */ LblReturnFlag = FR_59_RENESAS_FALSE; /* Initialize the return value */ LucReturnValue = E_OK; /* Initialize the bit to move */ LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; LulOffSet = (uint32)FR_59_RENESAS_ZERO; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Read Data from the communication Controller */ switch (Fr_ConfigParamIdx) { /* pMicroPerCycle FLX0GTUC01(19:0) */ case FR_CIDX_PMICROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC1 & FR_59_RENESAS_CIDX_PMICROPERCYCLE_MASK; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; /* FrIfGMacroPerCycle FLX0GTUC02 FLX0MPC[13:0] */ case FR_CIDX_GMACROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GMACROPERCYCLE_MASK; break; /* FrIfGSyncFrameIDCountMax FLX0GTUC02 FLX0SNM[19:16] */ case FR_CIDX_GSYNCFRAMEIDCOUNTMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GSYNCFRAMEIDCOUNTMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetA FLX0GTUC03 FLX0MIOA[22:16] */ case FR_CIDX_PMACROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETA_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetB FLX0GTUC03 FLX0MIOB[30:24] */ case FR_CIDX_PMACROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPMicroInitialOffsetA FLX0GTUC03 FLX0UIOA[7:0] */ case FR_CIDX_PMICROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETA_MASK; break; /* FrPMicroInitialOffsetB FLX0GTUC03 FLX0UIOB[15:8] */ case FR_CIDX_PMICROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPOffsetCorrectionStart FLX0GTUC04 FLX0OCS[29:16] */ case FR_CIDX_POFFSETCORRECTIONSTART: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC4 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONSTART_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPClusterDriftDamping FLX0GTUC05 FLX0CDD[20:16] */ case FR_CIDX_PCLUSTERDRIFTDAMPING: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PCLUSTERDRIFTDAMPING_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPDecodingCorrection FLX0GTUC05 FLX0DEC[31:24] */ case FR_CIDX_PDECODINGCORRECTION: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDECODINGCORRECTION_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPDelayCompensationA FLX0GTUC05 FLX0DCA[7:0] */ case FR_CIDX_PDELAYCOMPENSATIONA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONA_MASK; break; /* FrPDelayCompensationB FLX0GTUC05 FLX0DCB[15:8] */ case FR_CIDX_PDELAYCOMPENSATIONB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPdAcceptedStartupRange FLX0GTUC06 FLX0ASR[26:16] */ case FR_CIDX_PDACCEPTEDSTARTUPRANGE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC6 & FR_59_RENESAS_CIDX_PDACCEPTEDSTARTUPRANGE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; break; /* FrIfGNumberOfStaticSlots FLX0GTUC07 FLX0NSS[25:16] */ case FR_CIDX_GNUMBEROFSTATICSLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GNUMBEROFSTATICSLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdStaticSlot FLX0GTUC07 FLX0SSL[9:0] */ case FR_CIDX_GDSTATICSLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GDSTATICSLOT_MASK; break; /* FrIfGdMinislot FLX0GTUC08 FLX0MSL[5:0] */ case FR_CIDX_GDMINISLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GDMINISLOT_MASK; break; /* FrIfGNumberOfMinislots FLX0GTUC08 FLX0NMS[28:16] */ case FR_CIDX_GNUMBEROFMINISLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GNUMBEROFMINISLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrIfGdDynamicSlotIdlePhase FLX0GTUC09 FLX0DSI[17:16] */ case FR_CIDX_GDDYNAMICSLOTIDLEPHASE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDDYNAMICSLOTIDLEPHASE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdMiniSlotActionPointOffset FLX0GTUC09 FLX0MAPO[12:8] */ case FR_CIDX_GDMINISLOTACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDMINISLOTACTIONPOINTOFFSET_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdSymbolWindowActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDSYMBOLWINDOWACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrPOffsetCorrectionOut FLX0GTUC10 FLX0MOC[13:0] */ case FR_CIDX_POFFSETCORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONOUT_MASK; break; /* FrPRateCorrectionOut FLX0GTUC10 FLX0MRC[26:16] */ case FR_CIDX_PRATECORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_PRATECORRECTIONOUT_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGPayloadLengthStatic FLX0MHDC FLX0SFDL[6:0] */ case FR_CIDX_GPAYLOADLENGTHSTATIC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_GPAYLOADLENGTHSTATIC_MASK; break; /* FrPLatestTx FLX0MHDC FLX0SLT[28:16] */ case FR_CIDX_PLATESTTX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_PLATESTTX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGNetworkManagementVectorLength FLX0NEMC FLX0NML[3:0] */ case FR_CIDX_GNETWORKMANAGEMENTVECTORLENGTH: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRNEMC & FR_59_RENESAS_CIDX_GNETWORKMANAGEMENTVECTORLENGTH_MASK; break; /* FrPdMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PDMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PDMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrPSamplesPerMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PSAMPLESPERMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PSAMPLESPERMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdTSSTransmitter FLX0PRTC1 FLX0TSST[3:0] */ case FR_CIDX_GDTSSTRANSMITTER: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDTSSTRANSMITTER_MASK; break; /* FrIfGdCasRxLowMax FLX0PRTC1 FLX0CASM[10:4] */ case FR_CIDX_GDCASRXLOWMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDCASRXLOWMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrPWakeupPattern FLX0PRTC1 FLX0RWP[31:26] */ case FR_CIDX_PWAKEUPPATTERN: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PWAKEUPPATTERN_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrIfGdSampleClockPeriod FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_GDSAMPLECLOCKPERIOD: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDSAMPLECLOCKPERIOD_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdWakeupRxWindow FLX0PRTC1 FLX0RXW(24:16) */ case FR_CIDX_GDWAKEUPRXWINDOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDWAKEUPRXWINDOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdWakeupRxIdle FLX0PRTC2 FLX0RXL[13:8] */ case FR_CIDX_GDWAKEUPRXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXIDLE_MASK; break; /* FrIfGdWakeupRxLow FLX0PRTC2 FLX0RXI[5:0] */ case FR_CIDX_GDWAKEUPRXLOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXLOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdWakeupTxActive FLX0PRTC2 FLX0TXL[29:24] */ case FR_CIDX_GDWAKEUPTXACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrIfGdWakeupTxIdle FLX0PRTC2 FLX0TXI[23:16] */ case FR_CIDX_GDWAKEUPTXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXIDLE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGColdStartAttempts FLX0SUCC1 FLX0CSA[15:11] */ case FR_CIDX_GCOLDSTARTATTEMPTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_GCOLDSTARTATTEMPTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ELEVEN; break; /* FrPChannels FLX0SUCC1 FLX0CCHA, FLX0CCHB */ case FR_CIDX_PCHANNELS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PCHANNELS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrPKeySlotUsedForSync FLX0SUCC1 FLX0TXSY */ case FR_CIDX_PKEYSLOTUSEDFORSYNC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSYNC_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_NINE; break; /* FrPKeySlotUsedForStartup FLX0SUCC1 FLX0TXST */ case FR_CIDX_PKEYSLOTUSEDFORSTARTUP: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSTARTUP_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPKeySlotOnlyEnabled FLX0SUCC1 FLX0TSM */ case FR_CIDX_PKEYSLOTONLYENABLED: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTONLYENABLED_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTWO; break; /* FrPAllowHaltDueToClock FLX0SUCC1 FLX0HCSE */ case FR_CIDX_PALLOWHALTDUETOCLOCK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWHALTDUETOCLOCK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTHREE; break; /* FrPWakeupChannel FLX0SUCC1 FLX0WUCS */ case FR_CIDX_PWAKEUPCHANNEL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PWAKEUPCHANNEL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYONE; break; /* FrPAllowPassiveToActive FLX0SUCC1 FLX0PTA[20:16] */ case FR_CIDX_PALLOWPASSIVETOACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWPASSIVETOACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGListenNoise FLX0SUCC2 FLX0LTN[27:24] */ case FR_CIDX_GLISTENNOISE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_GLISTENNOISE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPdListenTimeout FLX0SUCC2 FLX0LT[20:00] */ case FR_CIDX_PDLISTENTIMEOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_PDLISTENTIMEOUT_MASK; break; /* FrIfGMaxWithoutClockCorrectFatal FLX0SUCC3 FLX0WCP[7:4] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrIfGMaxWithoutClockCorrectPassive FLX0SUCC3 FLX0WCF[3:0] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE_MASK; break; /* Set to 63 for FlexRay Protocol 2.1 Rev. A compliance. */ case FR_CIDX_GCYCLECOUNTMAX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_MAX_CYCLE_COUNT; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_PSECONDKEYSLOTID: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_GDIGNOREAFTERTX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPExternalSync : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PEXTERNALSYNC: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPFallBackInternal : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PFALLBACKINTERNAL: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPNmVectorEarlyUpdate : Set to 'false' for FlexRay Protocol 2.1 * Rev. A compliance */ case FR_CIDX_PNMVECTOREARLYUPDATE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPTwoKeySlotMode : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PTWOKEYSLOTMODE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDCYCLE */ case FR_CIDX_GDCYCLE: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDCYCLE * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDMACRO_TICK */ case FR_CIDX_GDMACROTICK: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDMACRO_TICK * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PKEYSLOTID */ case FR_CIDX_PKEYSLOTID: *Fr_ConfigParamValuePtr = LpCtrlTable->usFrPKeySlotId; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDBIT */ case FR_CIDX_GDBIT: *Fr_ConfigParamValuePtr = FR_59_RENESAS_GDBIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDSYMBOL_WINDOW */ case FR_CIDX_GDSYMBOLWINDOW: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDSYMBOL_WINDOW; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PPAYLOADLENGTHDYNMAX */ case FR_CIDX_PPAYLOADLENGTHDYNMAX: *Fr_ConfigParamValuePtr = LpCtrlTable->ucFrPPayloadLengthDynMax; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FrIfGdNit */ case FR_CIDX_GDNIT: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDNIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; default: /* No action required */ break; } if (FR_59_RENESAS_FALSE == LblReturnFlag) { *Fr_ConfigParamValuePtr = LulOffSet >> LucBitsTobeMovedRight; if (FR_CIDX_PSAMPLESPERMICROTICK == Fr_ConfigParamIdx) { /* pSamplepermicrotick */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N2SAMPLES; } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } } else if ((FR_CIDX_GDSAMPLECLOCKPERIOD == Fr_ConfigParamIdx) || (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx)) { /* gdSampleClockPeriod */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { if (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T12_5NS; } } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } } else if (FR_CIDX_PCHANNELS == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } else if ((uint32)FR_59_RENESAS_THREE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_AB; } else { /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else if (FR_CIDX_PWAKEUPCHANNEL == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } } else if ((FR_CIDX_POFFSETCORRECTIONSTART == Fr_ConfigParamIdx) || (FR_CIDX_GLISTENNOISE == Fr_ConfigParamIdx)) /* PRQA S 2004 # JV-01 */ { *Fr_ConfigParamValuePtr = *Fr_ConfigParamValuePtr + (uint32)FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ } /* else No Action required */ } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..62', 'Name': 'Fr_ConfigParamIdx', 'Value': 'FR_CIDX_GDDYNAMICSLOTIDLEPHASE'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ConfigParamValuePtr', 'Value': '&map_Fr_ConfigParamValuePtr[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC1', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC2', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC3', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC4', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC5', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC6', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC7', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC8', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC9', 'Value': '0x12345678'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC10', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRMHDC', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNEMC', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC1', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC2', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC1', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC2', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC3', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '0..1023', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFrPKeySlotId', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '0..127', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].ucFrPPayloadLengthDynMax', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ConfigParamValuePtr[0]', 'Value': '0x0'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateCCConfig(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) Fr_ConfigParamIdx, CONSTP2VAR(uint32, AUTOMATIC, FR_APPL_DATA) Fr_ConfigParamValuePtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ uint32 LulOffSet; uint8 LucBitsTobeMovedRight; boolean LblReturnFlag; Std_ReturnType LucReturnValue; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the return flag */ LblReturnFlag = FR_59_RENESAS_FALSE; /* Initialize the return value */ LucReturnValue = E_OK; /* Initialize the bit to move */ LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; LulOffSet = (uint32)FR_59_RENESAS_ZERO; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Read Data from the communication Controller */ switch (Fr_ConfigParamIdx) { /* pMicroPerCycle FLX0GTUC01(19:0) */ case FR_CIDX_PMICROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC1 & FR_59_RENESAS_CIDX_PMICROPERCYCLE_MASK; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; /* FrIfGMacroPerCycle FLX0GTUC02 FLX0MPC[13:0] */ case FR_CIDX_GMACROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GMACROPERCYCLE_MASK; break; /* FrIfGSyncFrameIDCountMax FLX0GTUC02 FLX0SNM[19:16] */ case FR_CIDX_GSYNCFRAMEIDCOUNTMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GSYNCFRAMEIDCOUNTMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetA FLX0GTUC03 FLX0MIOA[22:16] */ case FR_CIDX_PMACROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETA_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetB FLX0GTUC03 FLX0MIOB[30:24] */ case FR_CIDX_PMACROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPMicroInitialOffsetA FLX0GTUC03 FLX0UIOA[7:0] */ case FR_CIDX_PMICROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETA_MASK; break; /* FrPMicroInitialOffsetB FLX0GTUC03 FLX0UIOB[15:8] */ case FR_CIDX_PMICROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPOffsetCorrectionStart FLX0GTUC04 FLX0OCS[29:16] */ case FR_CIDX_POFFSETCORRECTIONSTART: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC4 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONSTART_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPClusterDriftDamping FLX0GTUC05 FLX0CDD[20:16] */ case FR_CIDX_PCLUSTERDRIFTDAMPING: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PCLUSTERDRIFTDAMPING_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPDecodingCorrection FLX0GTUC05 FLX0DEC[31:24] */ case FR_CIDX_PDECODINGCORRECTION: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDECODINGCORRECTION_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPDelayCompensationA FLX0GTUC05 FLX0DCA[7:0] */ case FR_CIDX_PDELAYCOMPENSATIONA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONA_MASK; break; /* FrPDelayCompensationB FLX0GTUC05 FLX0DCB[15:8] */ case FR_CIDX_PDELAYCOMPENSATIONB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPdAcceptedStartupRange FLX0GTUC06 FLX0ASR[26:16] */ case FR_CIDX_PDACCEPTEDSTARTUPRANGE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC6 & FR_59_RENESAS_CIDX_PDACCEPTEDSTARTUPRANGE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; break; /* FrIfGNumberOfStaticSlots FLX0GTUC07 FLX0NSS[25:16] */ case FR_CIDX_GNUMBEROFSTATICSLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GNUMBEROFSTATICSLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdStaticSlot FLX0GTUC07 FLX0SSL[9:0] */ case FR_CIDX_GDSTATICSLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GDSTATICSLOT_MASK; break; /* FrIfGdMinislot FLX0GTUC08 FLX0MSL[5:0] */ case FR_CIDX_GDMINISLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GDMINISLOT_MASK; break; /* FrIfGNumberOfMinislots FLX0GTUC08 FLX0NMS[28:16] */ case FR_CIDX_GNUMBEROFMINISLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GNUMBEROFMINISLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrIfGdDynamicSlotIdlePhase FLX0GTUC09 FLX0DSI[17:16] */ case FR_CIDX_GDDYNAMICSLOTIDLEPHASE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDDYNAMICSLOTIDLEPHASE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdMiniSlotActionPointOffset FLX0GTUC09 FLX0MAPO[12:8] */ case FR_CIDX_GDMINISLOTACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDMINISLOTACTIONPOINTOFFSET_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdSymbolWindowActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDSYMBOLWINDOWACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrPOffsetCorrectionOut FLX0GTUC10 FLX0MOC[13:0] */ case FR_CIDX_POFFSETCORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONOUT_MASK; break; /* FrPRateCorrectionOut FLX0GTUC10 FLX0MRC[26:16] */ case FR_CIDX_PRATECORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_PRATECORRECTIONOUT_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGPayloadLengthStatic FLX0MHDC FLX0SFDL[6:0] */ case FR_CIDX_GPAYLOADLENGTHSTATIC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_GPAYLOADLENGTHSTATIC_MASK; break; /* FrPLatestTx FLX0MHDC FLX0SLT[28:16] */ case FR_CIDX_PLATESTTX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_PLATESTTX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGNetworkManagementVectorLength FLX0NEMC FLX0NML[3:0] */ case FR_CIDX_GNETWORKMANAGEMENTVECTORLENGTH: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRNEMC & FR_59_RENESAS_CIDX_GNETWORKMANAGEMENTVECTORLENGTH_MASK; break; /* FrPdMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PDMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PDMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrPSamplesPerMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PSAMPLESPERMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PSAMPLESPERMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdTSSTransmitter FLX0PRTC1 FLX0TSST[3:0] */ case FR_CIDX_GDTSSTRANSMITTER: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDTSSTRANSMITTER_MASK; break; /* FrIfGdCasRxLowMax FLX0PRTC1 FLX0CASM[10:4] */ case FR_CIDX_GDCASRXLOWMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDCASRXLOWMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrPWakeupPattern FLX0PRTC1 FLX0RWP[31:26] */ case FR_CIDX_PWAKEUPPATTERN: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PWAKEUPPATTERN_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrIfGdSampleClockPeriod FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_GDSAMPLECLOCKPERIOD: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDSAMPLECLOCKPERIOD_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdWakeupRxWindow FLX0PRTC1 FLX0RXW(24:16) */ case FR_CIDX_GDWAKEUPRXWINDOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDWAKEUPRXWINDOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdWakeupRxIdle FLX0PRTC2 FLX0RXL[13:8] */ case FR_CIDX_GDWAKEUPRXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXIDLE_MASK; break; /* FrIfGdWakeupRxLow FLX0PRTC2 FLX0RXI[5:0] */ case FR_CIDX_GDWAKEUPRXLOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXLOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdWakeupTxActive FLX0PRTC2 FLX0TXL[29:24] */ case FR_CIDX_GDWAKEUPTXACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrIfGdWakeupTxIdle FLX0PRTC2 FLX0TXI[23:16] */ case FR_CIDX_GDWAKEUPTXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXIDLE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGColdStartAttempts FLX0SUCC1 FLX0CSA[15:11] */ case FR_CIDX_GCOLDSTARTATTEMPTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_GCOLDSTARTATTEMPTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ELEVEN; break; /* FrPChannels FLX0SUCC1 FLX0CCHA, FLX0CCHB */ case FR_CIDX_PCHANNELS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PCHANNELS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrPKeySlotUsedForSync FLX0SUCC1 FLX0TXSY */ case FR_CIDX_PKEYSLOTUSEDFORSYNC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSYNC_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_NINE; break; /* FrPKeySlotUsedForStartup FLX0SUCC1 FLX0TXST */ case FR_CIDX_PKEYSLOTUSEDFORSTARTUP: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSTARTUP_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPKeySlotOnlyEnabled FLX0SUCC1 FLX0TSM */ case FR_CIDX_PKEYSLOTONLYENABLED: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTONLYENABLED_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTWO; break; /* FrPAllowHaltDueToClock FLX0SUCC1 FLX0HCSE */ case FR_CIDX_PALLOWHALTDUETOCLOCK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWHALTDUETOCLOCK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTHREE; break; /* FrPWakeupChannel FLX0SUCC1 FLX0WUCS */ case FR_CIDX_PWAKEUPCHANNEL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PWAKEUPCHANNEL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYONE; break; /* FrPAllowPassiveToActive FLX0SUCC1 FLX0PTA[20:16] */ case FR_CIDX_PALLOWPASSIVETOACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWPASSIVETOACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGListenNoise FLX0SUCC2 FLX0LTN[27:24] */ case FR_CIDX_GLISTENNOISE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_GLISTENNOISE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPdListenTimeout FLX0SUCC2 FLX0LT[20:00] */ case FR_CIDX_PDLISTENTIMEOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_PDLISTENTIMEOUT_MASK; break; /* FrIfGMaxWithoutClockCorrectFatal FLX0SUCC3 FLX0WCP[7:4] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrIfGMaxWithoutClockCorrectPassive FLX0SUCC3 FLX0WCF[3:0] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE_MASK; break; /* Set to 63 for FlexRay Protocol 2.1 Rev. A compliance. */ case FR_CIDX_GCYCLECOUNTMAX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_MAX_CYCLE_COUNT; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_PSECONDKEYSLOTID: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_GDIGNOREAFTERTX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPExternalSync : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PEXTERNALSYNC: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPFallBackInternal : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PFALLBACKINTERNAL: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPNmVectorEarlyUpdate : Set to 'false' for FlexRay Protocol 2.1 * Rev. A compliance */ case FR_CIDX_PNMVECTOREARLYUPDATE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPTwoKeySlotMode : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PTWOKEYSLOTMODE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDCYCLE */ case FR_CIDX_GDCYCLE: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDCYCLE * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDMACRO_TICK */ case FR_CIDX_GDMACROTICK: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDMACRO_TICK * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PKEYSLOTID */ case FR_CIDX_PKEYSLOTID: *Fr_ConfigParamValuePtr = LpCtrlTable->usFrPKeySlotId; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDBIT */ case FR_CIDX_GDBIT: *Fr_ConfigParamValuePtr = FR_59_RENESAS_GDBIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDSYMBOL_WINDOW */ case FR_CIDX_GDSYMBOLWINDOW: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDSYMBOL_WINDOW; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PPAYLOADLENGTHDYNMAX */ case FR_CIDX_PPAYLOADLENGTHDYNMAX: *Fr_ConfigParamValuePtr = LpCtrlTable->ucFrPPayloadLengthDynMax; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FrIfGdNit */ case FR_CIDX_GDNIT: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDNIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; default: /* No action required */ break; } if (FR_59_RENESAS_FALSE == LblReturnFlag) { *Fr_ConfigParamValuePtr = LulOffSet >> LucBitsTobeMovedRight; if (FR_CIDX_PSAMPLESPERMICROTICK == Fr_ConfigParamIdx) { /* pSamplepermicrotick */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N2SAMPLES; } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } } else if ((FR_CIDX_GDSAMPLECLOCKPERIOD == Fr_ConfigParamIdx) || (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx)) { /* gdSampleClockPeriod */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { if (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T12_5NS; } } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } } else if (FR_CIDX_PCHANNELS == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } else if ((uint32)FR_59_RENESAS_THREE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_AB; } else { /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else if (FR_CIDX_PWAKEUPCHANNEL == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } } else if ((FR_CIDX_POFFSETCORRECTIONSTART == Fr_ConfigParamIdx) || (FR_CIDX_GLISTENNOISE == Fr_ConfigParamIdx)) /* PRQA S 2004 # JV-01 */ { *Fr_ConfigParamValuePtr = *Fr_ConfigParamValuePtr + (uint32)FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ } /* else No Action required */ } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..62', 'Name': 'Fr_ConfigParamIdx', 'Value': 'FR_CIDX_POFFSETCORRECTIONOUT'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ConfigParamValuePtr', 'Value': '&map_Fr_ConfigParamValuePtr[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC1', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC2', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC3', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC4', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC5', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC6', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC7', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC8', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC9', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC10', 'Value': '0x12345678'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRMHDC', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNEMC', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC1', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC2', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC1', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC2', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC3', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '0..1023', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFrPKeySlotId', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '0..127', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].ucFrPPayloadLengthDynMax', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ConfigParamValuePtr[0]', 'Value': '0x1678'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateCCConfig(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) Fr_ConfigParamIdx, CONSTP2VAR(uint32, AUTOMATIC, FR_APPL_DATA) Fr_ConfigParamValuePtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ uint32 LulOffSet; uint8 LucBitsTobeMovedRight; boolean LblReturnFlag; Std_ReturnType LucReturnValue; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the return flag */ LblReturnFlag = FR_59_RENESAS_FALSE; /* Initialize the return value */ LucReturnValue = E_OK; /* Initialize the bit to move */ LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; LulOffSet = (uint32)FR_59_RENESAS_ZERO; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Read Data from the communication Controller */ switch (Fr_ConfigParamIdx) { /* pMicroPerCycle FLX0GTUC01(19:0) */ case FR_CIDX_PMICROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC1 & FR_59_RENESAS_CIDX_PMICROPERCYCLE_MASK; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; /* FrIfGMacroPerCycle FLX0GTUC02 FLX0MPC[13:0] */ case FR_CIDX_GMACROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GMACROPERCYCLE_MASK; break; /* FrIfGSyncFrameIDCountMax FLX0GTUC02 FLX0SNM[19:16] */ case FR_CIDX_GSYNCFRAMEIDCOUNTMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GSYNCFRAMEIDCOUNTMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetA FLX0GTUC03 FLX0MIOA[22:16] */ case FR_CIDX_PMACROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETA_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetB FLX0GTUC03 FLX0MIOB[30:24] */ case FR_CIDX_PMACROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPMicroInitialOffsetA FLX0GTUC03 FLX0UIOA[7:0] */ case FR_CIDX_PMICROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETA_MASK; break; /* FrPMicroInitialOffsetB FLX0GTUC03 FLX0UIOB[15:8] */ case FR_CIDX_PMICROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPOffsetCorrectionStart FLX0GTUC04 FLX0OCS[29:16] */ case FR_CIDX_POFFSETCORRECTIONSTART: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC4 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONSTART_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPClusterDriftDamping FLX0GTUC05 FLX0CDD[20:16] */ case FR_CIDX_PCLUSTERDRIFTDAMPING: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PCLUSTERDRIFTDAMPING_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPDecodingCorrection FLX0GTUC05 FLX0DEC[31:24] */ case FR_CIDX_PDECODINGCORRECTION: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDECODINGCORRECTION_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPDelayCompensationA FLX0GTUC05 FLX0DCA[7:0] */ case FR_CIDX_PDELAYCOMPENSATIONA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONA_MASK; break; /* FrPDelayCompensationB FLX0GTUC05 FLX0DCB[15:8] */ case FR_CIDX_PDELAYCOMPENSATIONB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPdAcceptedStartupRange FLX0GTUC06 FLX0ASR[26:16] */ case FR_CIDX_PDACCEPTEDSTARTUPRANGE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC6 & FR_59_RENESAS_CIDX_PDACCEPTEDSTARTUPRANGE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; break; /* FrIfGNumberOfStaticSlots FLX0GTUC07 FLX0NSS[25:16] */ case FR_CIDX_GNUMBEROFSTATICSLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GNUMBEROFSTATICSLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdStaticSlot FLX0GTUC07 FLX0SSL[9:0] */ case FR_CIDX_GDSTATICSLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GDSTATICSLOT_MASK; break; /* FrIfGdMinislot FLX0GTUC08 FLX0MSL[5:0] */ case FR_CIDX_GDMINISLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GDMINISLOT_MASK; break; /* FrIfGNumberOfMinislots FLX0GTUC08 FLX0NMS[28:16] */ case FR_CIDX_GNUMBEROFMINISLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GNUMBEROFMINISLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrIfGdDynamicSlotIdlePhase FLX0GTUC09 FLX0DSI[17:16] */ case FR_CIDX_GDDYNAMICSLOTIDLEPHASE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDDYNAMICSLOTIDLEPHASE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdMiniSlotActionPointOffset FLX0GTUC09 FLX0MAPO[12:8] */ case FR_CIDX_GDMINISLOTACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDMINISLOTACTIONPOINTOFFSET_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdSymbolWindowActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDSYMBOLWINDOWACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrPOffsetCorrectionOut FLX0GTUC10 FLX0MOC[13:0] */ case FR_CIDX_POFFSETCORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONOUT_MASK; break; /* FrPRateCorrectionOut FLX0GTUC10 FLX0MRC[26:16] */ case FR_CIDX_PRATECORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_PRATECORRECTIONOUT_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGPayloadLengthStatic FLX0MHDC FLX0SFDL[6:0] */ case FR_CIDX_GPAYLOADLENGTHSTATIC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_GPAYLOADLENGTHSTATIC_MASK; break; /* FrPLatestTx FLX0MHDC FLX0SLT[28:16] */ case FR_CIDX_PLATESTTX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_PLATESTTX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGNetworkManagementVectorLength FLX0NEMC FLX0NML[3:0] */ case FR_CIDX_GNETWORKMANAGEMENTVECTORLENGTH: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRNEMC & FR_59_RENESAS_CIDX_GNETWORKMANAGEMENTVECTORLENGTH_MASK; break; /* FrPdMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PDMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PDMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrPSamplesPerMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PSAMPLESPERMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PSAMPLESPERMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdTSSTransmitter FLX0PRTC1 FLX0TSST[3:0] */ case FR_CIDX_GDTSSTRANSMITTER: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDTSSTRANSMITTER_MASK; break; /* FrIfGdCasRxLowMax FLX0PRTC1 FLX0CASM[10:4] */ case FR_CIDX_GDCASRXLOWMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDCASRXLOWMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrPWakeupPattern FLX0PRTC1 FLX0RWP[31:26] */ case FR_CIDX_PWAKEUPPATTERN: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PWAKEUPPATTERN_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrIfGdSampleClockPeriod FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_GDSAMPLECLOCKPERIOD: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDSAMPLECLOCKPERIOD_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdWakeupRxWindow FLX0PRTC1 FLX0RXW(24:16) */ case FR_CIDX_GDWAKEUPRXWINDOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDWAKEUPRXWINDOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdWakeupRxIdle FLX0PRTC2 FLX0RXL[13:8] */ case FR_CIDX_GDWAKEUPRXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXIDLE_MASK; break; /* FrIfGdWakeupRxLow FLX0PRTC2 FLX0RXI[5:0] */ case FR_CIDX_GDWAKEUPRXLOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXLOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdWakeupTxActive FLX0PRTC2 FLX0TXL[29:24] */ case FR_CIDX_GDWAKEUPTXACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrIfGdWakeupTxIdle FLX0PRTC2 FLX0TXI[23:16] */ case FR_CIDX_GDWAKEUPTXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXIDLE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGColdStartAttempts FLX0SUCC1 FLX0CSA[15:11] */ case FR_CIDX_GCOLDSTARTATTEMPTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_GCOLDSTARTATTEMPTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ELEVEN; break; /* FrPChannels FLX0SUCC1 FLX0CCHA, FLX0CCHB */ case FR_CIDX_PCHANNELS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PCHANNELS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrPKeySlotUsedForSync FLX0SUCC1 FLX0TXSY */ case FR_CIDX_PKEYSLOTUSEDFORSYNC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSYNC_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_NINE; break; /* FrPKeySlotUsedForStartup FLX0SUCC1 FLX0TXST */ case FR_CIDX_PKEYSLOTUSEDFORSTARTUP: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSTARTUP_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPKeySlotOnlyEnabled FLX0SUCC1 FLX0TSM */ case FR_CIDX_PKEYSLOTONLYENABLED: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTONLYENABLED_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTWO; break; /* FrPAllowHaltDueToClock FLX0SUCC1 FLX0HCSE */ case FR_CIDX_PALLOWHALTDUETOCLOCK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWHALTDUETOCLOCK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTHREE; break; /* FrPWakeupChannel FLX0SUCC1 FLX0WUCS */ case FR_CIDX_PWAKEUPCHANNEL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PWAKEUPCHANNEL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYONE; break; /* FrPAllowPassiveToActive FLX0SUCC1 FLX0PTA[20:16] */ case FR_CIDX_PALLOWPASSIVETOACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWPASSIVETOACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGListenNoise FLX0SUCC2 FLX0LTN[27:24] */ case FR_CIDX_GLISTENNOISE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_GLISTENNOISE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPdListenTimeout FLX0SUCC2 FLX0LT[20:00] */ case FR_CIDX_PDLISTENTIMEOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_PDLISTENTIMEOUT_MASK; break; /* FrIfGMaxWithoutClockCorrectFatal FLX0SUCC3 FLX0WCP[7:4] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrIfGMaxWithoutClockCorrectPassive FLX0SUCC3 FLX0WCF[3:0] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE_MASK; break; /* Set to 63 for FlexRay Protocol 2.1 Rev. A compliance. */ case FR_CIDX_GCYCLECOUNTMAX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_MAX_CYCLE_COUNT; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_PSECONDKEYSLOTID: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_GDIGNOREAFTERTX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPExternalSync : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PEXTERNALSYNC: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPFallBackInternal : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PFALLBACKINTERNAL: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPNmVectorEarlyUpdate : Set to 'false' for FlexRay Protocol 2.1 * Rev. A compliance */ case FR_CIDX_PNMVECTOREARLYUPDATE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPTwoKeySlotMode : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PTWOKEYSLOTMODE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDCYCLE */ case FR_CIDX_GDCYCLE: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDCYCLE * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDMACRO_TICK */ case FR_CIDX_GDMACROTICK: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDMACRO_TICK * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PKEYSLOTID */ case FR_CIDX_PKEYSLOTID: *Fr_ConfigParamValuePtr = LpCtrlTable->usFrPKeySlotId; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDBIT */ case FR_CIDX_GDBIT: *Fr_ConfigParamValuePtr = FR_59_RENESAS_GDBIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDSYMBOL_WINDOW */ case FR_CIDX_GDSYMBOLWINDOW: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDSYMBOL_WINDOW; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PPAYLOADLENGTHDYNMAX */ case FR_CIDX_PPAYLOADLENGTHDYNMAX: *Fr_ConfigParamValuePtr = LpCtrlTable->ucFrPPayloadLengthDynMax; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FrIfGdNit */ case FR_CIDX_GDNIT: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDNIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; default: /* No action required */ break; } if (FR_59_RENESAS_FALSE == LblReturnFlag) { *Fr_ConfigParamValuePtr = LulOffSet >> LucBitsTobeMovedRight; if (FR_CIDX_PSAMPLESPERMICROTICK == Fr_ConfigParamIdx) { /* pSamplepermicrotick */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N2SAMPLES; } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } } else if ((FR_CIDX_GDSAMPLECLOCKPERIOD == Fr_ConfigParamIdx) || (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx)) { /* gdSampleClockPeriod */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { if (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T12_5NS; } } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } } else if (FR_CIDX_PCHANNELS == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } else if ((uint32)FR_59_RENESAS_THREE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_AB; } else { /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else if (FR_CIDX_PWAKEUPCHANNEL == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } } else if ((FR_CIDX_POFFSETCORRECTIONSTART == Fr_ConfigParamIdx) || (FR_CIDX_GLISTENNOISE == Fr_ConfigParamIdx)) /* PRQA S 2004 # JV-01 */ { *Fr_ConfigParamValuePtr = *Fr_ConfigParamValuePtr + (uint32)FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ } /* else No Action required */ } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..62', 'Name': 'Fr_ConfigParamIdx', 'Value': 'FR_CIDX_GDWAKEUPRXIDLE'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ConfigParamValuePtr', 'Value': '&map_Fr_ConfigParamValuePtr[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC1', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC2', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC3', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC4', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC5', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC6', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC7', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC8', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC9', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC10', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRMHDC', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNEMC', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC1', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC2', 'Value': '0x12345678'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC1', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC2', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC3', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '0..1023', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFrPKeySlotId', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '0..127', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].ucFrPPayloadLengthDynMax', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ConfigParamValuePtr[0]', 'Value': '0x38'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateCCConfig(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) Fr_ConfigParamIdx, CONSTP2VAR(uint32, AUTOMATIC, FR_APPL_DATA) Fr_ConfigParamValuePtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ uint32 LulOffSet; uint8 LucBitsTobeMovedRight; boolean LblReturnFlag; Std_ReturnType LucReturnValue; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the return flag */ LblReturnFlag = FR_59_RENESAS_FALSE; /* Initialize the return value */ LucReturnValue = E_OK; /* Initialize the bit to move */ LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; LulOffSet = (uint32)FR_59_RENESAS_ZERO; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Read Data from the communication Controller */ switch (Fr_ConfigParamIdx) { /* pMicroPerCycle FLX0GTUC01(19:0) */ case FR_CIDX_PMICROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC1 & FR_59_RENESAS_CIDX_PMICROPERCYCLE_MASK; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; /* FrIfGMacroPerCycle FLX0GTUC02 FLX0MPC[13:0] */ case FR_CIDX_GMACROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GMACROPERCYCLE_MASK; break; /* FrIfGSyncFrameIDCountMax FLX0GTUC02 FLX0SNM[19:16] */ case FR_CIDX_GSYNCFRAMEIDCOUNTMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GSYNCFRAMEIDCOUNTMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetA FLX0GTUC03 FLX0MIOA[22:16] */ case FR_CIDX_PMACROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETA_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetB FLX0GTUC03 FLX0MIOB[30:24] */ case FR_CIDX_PMACROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPMicroInitialOffsetA FLX0GTUC03 FLX0UIOA[7:0] */ case FR_CIDX_PMICROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETA_MASK; break; /* FrPMicroInitialOffsetB FLX0GTUC03 FLX0UIOB[15:8] */ case FR_CIDX_PMICROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPOffsetCorrectionStart FLX0GTUC04 FLX0OCS[29:16] */ case FR_CIDX_POFFSETCORRECTIONSTART: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC4 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONSTART_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPClusterDriftDamping FLX0GTUC05 FLX0CDD[20:16] */ case FR_CIDX_PCLUSTERDRIFTDAMPING: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PCLUSTERDRIFTDAMPING_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPDecodingCorrection FLX0GTUC05 FLX0DEC[31:24] */ case FR_CIDX_PDECODINGCORRECTION: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDECODINGCORRECTION_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPDelayCompensationA FLX0GTUC05 FLX0DCA[7:0] */ case FR_CIDX_PDELAYCOMPENSATIONA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONA_MASK; break; /* FrPDelayCompensationB FLX0GTUC05 FLX0DCB[15:8] */ case FR_CIDX_PDELAYCOMPENSATIONB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPdAcceptedStartupRange FLX0GTUC06 FLX0ASR[26:16] */ case FR_CIDX_PDACCEPTEDSTARTUPRANGE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC6 & FR_59_RENESAS_CIDX_PDACCEPTEDSTARTUPRANGE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; break; /* FrIfGNumberOfStaticSlots FLX0GTUC07 FLX0NSS[25:16] */ case FR_CIDX_GNUMBEROFSTATICSLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GNUMBEROFSTATICSLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdStaticSlot FLX0GTUC07 FLX0SSL[9:0] */ case FR_CIDX_GDSTATICSLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GDSTATICSLOT_MASK; break; /* FrIfGdMinislot FLX0GTUC08 FLX0MSL[5:0] */ case FR_CIDX_GDMINISLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GDMINISLOT_MASK; break; /* FrIfGNumberOfMinislots FLX0GTUC08 FLX0NMS[28:16] */ case FR_CIDX_GNUMBEROFMINISLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GNUMBEROFMINISLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrIfGdDynamicSlotIdlePhase FLX0GTUC09 FLX0DSI[17:16] */ case FR_CIDX_GDDYNAMICSLOTIDLEPHASE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDDYNAMICSLOTIDLEPHASE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdMiniSlotActionPointOffset FLX0GTUC09 FLX0MAPO[12:8] */ case FR_CIDX_GDMINISLOTACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDMINISLOTACTIONPOINTOFFSET_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdSymbolWindowActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDSYMBOLWINDOWACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrPOffsetCorrectionOut FLX0GTUC10 FLX0MOC[13:0] */ case FR_CIDX_POFFSETCORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONOUT_MASK; break; /* FrPRateCorrectionOut FLX0GTUC10 FLX0MRC[26:16] */ case FR_CIDX_PRATECORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_PRATECORRECTIONOUT_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGPayloadLengthStatic FLX0MHDC FLX0SFDL[6:0] */ case FR_CIDX_GPAYLOADLENGTHSTATIC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_GPAYLOADLENGTHSTATIC_MASK; break; /* FrPLatestTx FLX0MHDC FLX0SLT[28:16] */ case FR_CIDX_PLATESTTX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_PLATESTTX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGNetworkManagementVectorLength FLX0NEMC FLX0NML[3:0] */ case FR_CIDX_GNETWORKMANAGEMENTVECTORLENGTH: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRNEMC & FR_59_RENESAS_CIDX_GNETWORKMANAGEMENTVECTORLENGTH_MASK; break; /* FrPdMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PDMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PDMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrPSamplesPerMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PSAMPLESPERMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PSAMPLESPERMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdTSSTransmitter FLX0PRTC1 FLX0TSST[3:0] */ case FR_CIDX_GDTSSTRANSMITTER: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDTSSTRANSMITTER_MASK; break; /* FrIfGdCasRxLowMax FLX0PRTC1 FLX0CASM[10:4] */ case FR_CIDX_GDCASRXLOWMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDCASRXLOWMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrPWakeupPattern FLX0PRTC1 FLX0RWP[31:26] */ case FR_CIDX_PWAKEUPPATTERN: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PWAKEUPPATTERN_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrIfGdSampleClockPeriod FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_GDSAMPLECLOCKPERIOD: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDSAMPLECLOCKPERIOD_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdWakeupRxWindow FLX0PRTC1 FLX0RXW(24:16) */ case FR_CIDX_GDWAKEUPRXWINDOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDWAKEUPRXWINDOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdWakeupRxIdle FLX0PRTC2 FLX0RXL[13:8] */ case FR_CIDX_GDWAKEUPRXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXIDLE_MASK; break; /* FrIfGdWakeupRxLow FLX0PRTC2 FLX0RXI[5:0] */ case FR_CIDX_GDWAKEUPRXLOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXLOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdWakeupTxActive FLX0PRTC2 FLX0TXL[29:24] */ case FR_CIDX_GDWAKEUPTXACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrIfGdWakeupTxIdle FLX0PRTC2 FLX0TXI[23:16] */ case FR_CIDX_GDWAKEUPTXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXIDLE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGColdStartAttempts FLX0SUCC1 FLX0CSA[15:11] */ case FR_CIDX_GCOLDSTARTATTEMPTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_GCOLDSTARTATTEMPTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ELEVEN; break; /* FrPChannels FLX0SUCC1 FLX0CCHA, FLX0CCHB */ case FR_CIDX_PCHANNELS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PCHANNELS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrPKeySlotUsedForSync FLX0SUCC1 FLX0TXSY */ case FR_CIDX_PKEYSLOTUSEDFORSYNC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSYNC_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_NINE; break; /* FrPKeySlotUsedForStartup FLX0SUCC1 FLX0TXST */ case FR_CIDX_PKEYSLOTUSEDFORSTARTUP: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSTARTUP_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPKeySlotOnlyEnabled FLX0SUCC1 FLX0TSM */ case FR_CIDX_PKEYSLOTONLYENABLED: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTONLYENABLED_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTWO; break; /* FrPAllowHaltDueToClock FLX0SUCC1 FLX0HCSE */ case FR_CIDX_PALLOWHALTDUETOCLOCK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWHALTDUETOCLOCK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTHREE; break; /* FrPWakeupChannel FLX0SUCC1 FLX0WUCS */ case FR_CIDX_PWAKEUPCHANNEL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PWAKEUPCHANNEL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYONE; break; /* FrPAllowPassiveToActive FLX0SUCC1 FLX0PTA[20:16] */ case FR_CIDX_PALLOWPASSIVETOACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWPASSIVETOACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGListenNoise FLX0SUCC2 FLX0LTN[27:24] */ case FR_CIDX_GLISTENNOISE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_GLISTENNOISE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPdListenTimeout FLX0SUCC2 FLX0LT[20:00] */ case FR_CIDX_PDLISTENTIMEOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_PDLISTENTIMEOUT_MASK; break; /* FrIfGMaxWithoutClockCorrectFatal FLX0SUCC3 FLX0WCP[7:4] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrIfGMaxWithoutClockCorrectPassive FLX0SUCC3 FLX0WCF[3:0] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE_MASK; break; /* Set to 63 for FlexRay Protocol 2.1 Rev. A compliance. */ case FR_CIDX_GCYCLECOUNTMAX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_MAX_CYCLE_COUNT; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_PSECONDKEYSLOTID: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_GDIGNOREAFTERTX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPExternalSync : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PEXTERNALSYNC: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPFallBackInternal : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PFALLBACKINTERNAL: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPNmVectorEarlyUpdate : Set to 'false' for FlexRay Protocol 2.1 * Rev. A compliance */ case FR_CIDX_PNMVECTOREARLYUPDATE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPTwoKeySlotMode : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PTWOKEYSLOTMODE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDCYCLE */ case FR_CIDX_GDCYCLE: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDCYCLE * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDMACRO_TICK */ case FR_CIDX_GDMACROTICK: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDMACRO_TICK * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PKEYSLOTID */ case FR_CIDX_PKEYSLOTID: *Fr_ConfigParamValuePtr = LpCtrlTable->usFrPKeySlotId; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDBIT */ case FR_CIDX_GDBIT: *Fr_ConfigParamValuePtr = FR_59_RENESAS_GDBIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDSYMBOL_WINDOW */ case FR_CIDX_GDSYMBOLWINDOW: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDSYMBOL_WINDOW; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PPAYLOADLENGTHDYNMAX */ case FR_CIDX_PPAYLOADLENGTHDYNMAX: *Fr_ConfigParamValuePtr = LpCtrlTable->ucFrPPayloadLengthDynMax; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FrIfGdNit */ case FR_CIDX_GDNIT: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDNIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; default: /* No action required */ break; } if (FR_59_RENESAS_FALSE == LblReturnFlag) { *Fr_ConfigParamValuePtr = LulOffSet >> LucBitsTobeMovedRight; if (FR_CIDX_PSAMPLESPERMICROTICK == Fr_ConfigParamIdx) { /* pSamplepermicrotick */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N2SAMPLES; } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } } else if ((FR_CIDX_GDSAMPLECLOCKPERIOD == Fr_ConfigParamIdx) || (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx)) { /* gdSampleClockPeriod */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { if (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T12_5NS; } } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } } else if (FR_CIDX_PCHANNELS == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } else if ((uint32)FR_59_RENESAS_THREE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_AB; } else { /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else if (FR_CIDX_PWAKEUPCHANNEL == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } } else if ((FR_CIDX_POFFSETCORRECTIONSTART == Fr_ConfigParamIdx) || (FR_CIDX_GLISTENNOISE == Fr_ConfigParamIdx)) /* PRQA S 2004 # JV-01 */ { *Fr_ConfigParamValuePtr = *Fr_ConfigParamValuePtr + (uint32)FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ } /* else No Action required */ } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..62', 'Name': 'Fr_ConfigParamIdx', 'Value': 'FR_CIDX_GCYCLECOUNTMAX'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ConfigParamValuePtr', 'Value': '&map_Fr_ConfigParamValuePtr[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC1', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC2', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC3', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC4', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC5', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC6', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC7', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC8', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC9', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC10', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRMHDC', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNEMC', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC1', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC2', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC1', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC2', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC3', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '0..1023', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFrPKeySlotId', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '0..127', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].ucFrPPayloadLengthDynMax', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ConfigParamValuePtr[0]', 'Value': 'FR_59_RENESAS_MAX_CYCLE_COUNT'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateCCConfig(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint8, AUTOMATIC) Fr_ConfigParamIdx, CONSTP2VAR(uint32, AUTOMATIC, FR_APPL_DATA) Fr_ConfigParamValuePtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ uint32 LulOffSet; uint8 LucBitsTobeMovedRight; boolean LblReturnFlag; Std_ReturnType LucReturnValue; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the return flag */ LblReturnFlag = FR_59_RENESAS_FALSE; /* Initialize the return value */ LucReturnValue = E_OK; /* Initialize the bit to move */ LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; LulOffSet = (uint32)FR_59_RENESAS_ZERO; LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); /* Read Data from the communication Controller */ switch (Fr_ConfigParamIdx) { /* pMicroPerCycle FLX0GTUC01(19:0) */ case FR_CIDX_PMICROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC1 & FR_59_RENESAS_CIDX_PMICROPERCYCLE_MASK; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; /* FrIfGMacroPerCycle FLX0GTUC02 FLX0MPC[13:0] */ case FR_CIDX_GMACROPERCYCLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GMACROPERCYCLE_MASK; break; /* FrIfGSyncFrameIDCountMax FLX0GTUC02 FLX0SNM[19:16] */ case FR_CIDX_GSYNCFRAMEIDCOUNTMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC2 & FR_59_RENESAS_CIDX_GSYNCFRAMEIDCOUNTMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetA FLX0GTUC03 FLX0MIOA[22:16] */ case FR_CIDX_PMACROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETA_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPMacroInitialOffsetB FLX0GTUC03 FLX0MIOB[30:24] */ case FR_CIDX_PMACROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMACROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPMicroInitialOffsetA FLX0GTUC03 FLX0UIOA[7:0] */ case FR_CIDX_PMICROINITIALOFFSETA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETA_MASK; break; /* FrPMicroInitialOffsetB FLX0GTUC03 FLX0UIOB[15:8] */ case FR_CIDX_PMICROINITIALOFFSETB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC3 & FR_59_RENESAS_CIDX_PMICROINITIALOFFSETB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPOffsetCorrectionStart FLX0GTUC04 FLX0OCS[29:16] */ case FR_CIDX_POFFSETCORRECTIONSTART: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC4 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONSTART_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPClusterDriftDamping FLX0GTUC05 FLX0CDD[20:16] */ case FR_CIDX_PCLUSTERDRIFTDAMPING: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PCLUSTERDRIFTDAMPING_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrPDecodingCorrection FLX0GTUC05 FLX0DEC[31:24] */ case FR_CIDX_PDECODINGCORRECTION: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDECODINGCORRECTION_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPDelayCompensationA FLX0GTUC05 FLX0DCA[7:0] */ case FR_CIDX_PDELAYCOMPENSATIONA: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONA_MASK; break; /* FrPDelayCompensationB FLX0GTUC05 FLX0DCB[15:8] */ case FR_CIDX_PDELAYCOMPENSATIONB: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC5 & FR_59_RENESAS_CIDX_PDELAYCOMPENSATIONB_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPdAcceptedStartupRange FLX0GTUC06 FLX0ASR[26:16] */ case FR_CIDX_PDACCEPTEDSTARTUPRANGE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC6 & FR_59_RENESAS_CIDX_PDACCEPTEDSTARTUPRANGE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ZERO; break; /* FrIfGNumberOfStaticSlots FLX0GTUC07 FLX0NSS[25:16] */ case FR_CIDX_GNUMBEROFSTATICSLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GNUMBEROFSTATICSLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdStaticSlot FLX0GTUC07 FLX0SSL[9:0] */ case FR_CIDX_GDSTATICSLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC7 & FR_59_RENESAS_CIDX_GDSTATICSLOT_MASK; break; /* FrIfGdMinislot FLX0GTUC08 FLX0MSL[5:0] */ case FR_CIDX_GDMINISLOT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GDMINISLOT_MASK; break; /* FrIfGNumberOfMinislots FLX0GTUC08 FLX0NMS[28:16] */ case FR_CIDX_GNUMBEROFMINISLOTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC8 & FR_59_RENESAS_CIDX_GNUMBEROFMINISLOTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrIfGdDynamicSlotIdlePhase FLX0GTUC09 FLX0DSI[17:16] */ case FR_CIDX_GDDYNAMICSLOTIDLEPHASE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDDYNAMICSLOTIDLEPHASE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdMiniSlotActionPointOffset FLX0GTUC09 FLX0MAPO[12:8] */ case FR_CIDX_GDMINISLOTACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDMINISLOTACTIONPOINTOFFSET_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdSymbolWindowActionPointOffset FLX0GTUC09 FLX0APO[5:0] */ case FR_CIDX_GDSYMBOLWINDOWACTIONPOINTOFFSET: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC9 & FR_59_RENESAS_CIDX_GDACTIONPOINTOFFSET_MASK; break; /* FrPOffsetCorrectionOut FLX0GTUC10 FLX0MOC[13:0] */ case FR_CIDX_POFFSETCORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_POFFSETCORRECTIONOUT_MASK; break; /* FrPRateCorrectionOut FLX0GTUC10 FLX0MRC[26:16] */ case FR_CIDX_PRATECORRECTIONOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRGTUC10 & FR_59_RENESAS_CIDX_PRATECORRECTIONOUT_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGPayloadLengthStatic FLX0MHDC FLX0SFDL[6:0] */ case FR_CIDX_GPAYLOADLENGTHSTATIC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_GPAYLOADLENGTHSTATIC_MASK; break; /* FrPLatestTx FLX0MHDC FLX0SLT[28:16] */ case FR_CIDX_PLATESTTX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRMHDC & FR_59_RENESAS_CIDX_PLATESTTX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGNetworkManagementVectorLength FLX0NEMC FLX0NML[3:0] */ case FR_CIDX_GNETWORKMANAGEMENTVECTORLENGTH: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRNEMC & FR_59_RENESAS_CIDX_GNETWORKMANAGEMENTVECTORLENGTH_MASK; break; /* FrPdMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PDMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PDMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrPSamplesPerMicrotick FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_PSAMPLESPERMICROTICK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PSAMPLESPERMICROTICK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdTSSTransmitter FLX0PRTC1 FLX0TSST[3:0] */ case FR_CIDX_GDTSSTRANSMITTER: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDTSSTRANSMITTER_MASK; break; /* FrIfGdCasRxLowMax FLX0PRTC1 FLX0CASM[10:4] */ case FR_CIDX_GDCASRXLOWMAX: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDCASRXLOWMAX_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrPWakeupPattern FLX0PRTC1 FLX0RWP[31:26] */ case FR_CIDX_PWAKEUPPATTERN: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_PWAKEUPPATTERN_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrIfGdSampleClockPeriod FLX0PRTC1 FLX0BRP[15:14] */ case FR_CIDX_GDSAMPLECLOCKPERIOD: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDSAMPLECLOCKPERIOD_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOURTEEN; break; /* FrIfGdWakeupRxWindow FLX0PRTC1 FLX0RXW(24:16) */ case FR_CIDX_GDWAKEUPRXWINDOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC1 & FR_59_RENESAS_CIDX_GDWAKEUPRXWINDOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGdWakeupRxIdle FLX0PRTC2 FLX0RXL[13:8] */ case FR_CIDX_GDWAKEUPRXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXIDLE_MASK; break; /* FrIfGdWakeupRxLow FLX0PRTC2 FLX0RXI[5:0] */ case FR_CIDX_GDWAKEUPRXLOW: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPRXLOW_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrIfGdWakeupTxActive FLX0PRTC2 FLX0TXL[29:24] */ case FR_CIDX_GDWAKEUPTXACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrIfGdWakeupTxIdle FLX0PRTC2 FLX0TXI[23:16] */ case FR_CIDX_GDWAKEUPTXIDLE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRPRTC2 & FR_59_RENESAS_CIDX_GDWAKEUPTXIDLE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGColdStartAttempts FLX0SUCC1 FLX0CSA[15:11] */ case FR_CIDX_GCOLDSTARTATTEMPTS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_GCOLDSTARTATTEMPTS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_ELEVEN; break; /* FrPChannels FLX0SUCC1 FLX0CCHA, FLX0CCHB */ case FR_CIDX_PCHANNELS: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PCHANNELS_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYSIX; break; /* FrPKeySlotUsedForSync FLX0SUCC1 FLX0TXSY */ case FR_CIDX_PKEYSLOTUSEDFORSYNC: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSYNC_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_NINE; break; /* FrPKeySlotUsedForStartup FLX0SUCC1 FLX0TXST */ case FR_CIDX_PKEYSLOTUSEDFORSTARTUP: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTUSEDFORSTARTUP_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_EIGHT; break; /* FrPKeySlotOnlyEnabled FLX0SUCC1 FLX0TSM */ case FR_CIDX_PKEYSLOTONLYENABLED: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PKEYSLOTONLYENABLED_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTWO; break; /* FrPAllowHaltDueToClock FLX0SUCC1 FLX0HCSE */ case FR_CIDX_PALLOWHALTDUETOCLOCK: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWHALTDUETOCLOCK_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYTHREE; break; /* FrPWakeupChannel FLX0SUCC1 FLX0WUCS */ case FR_CIDX_PWAKEUPCHANNEL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PWAKEUPCHANNEL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYONE; break; /* FrPAllowPassiveToActive FLX0SUCC1 FLX0PTA[20:16] */ case FR_CIDX_PALLOWPASSIVETOACTIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC1 & FR_59_RENESAS_CIDX_PALLOWPASSIVETOACTIVE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_SIXTEEN; break; /* FrIfGListenNoise FLX0SUCC2 FLX0LTN[27:24] */ case FR_CIDX_GLISTENNOISE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_GLISTENNOISE_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_TWENTYFOUR; break; /* FrPdListenTimeout FLX0SUCC2 FLX0LT[20:00] */ case FR_CIDX_PDLISTENTIMEOUT: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC2 & FR_59_RENESAS_CIDX_PDLISTENTIMEOUT_MASK; break; /* FrIfGMaxWithoutClockCorrectFatal FLX0SUCC3 FLX0WCP[7:4] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTFATAL_MASK; LucBitsTobeMovedRight = FR_59_RENESAS_FOUR; break; /* FrIfGMaxWithoutClockCorrectPassive FLX0SUCC3 FLX0WCF[3:0] */ case FR_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE: /* Update Offset */ LulOffSet = LpCCCtrlReg->ulFLXAnFRSUCC3 & FR_59_RENESAS_CIDX_GMAXWITHOUTCLOCKCORRECTPASSIVE_MASK; break; /* Set to 63 for FlexRay Protocol 2.1 Rev. A compliance. */ case FR_CIDX_GCYCLECOUNTMAX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_MAX_CYCLE_COUNT; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_PSECONDKEYSLOTID: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Set to 0 for FlexRay Protocol 2.1 Rev A compliance */ case FR_CIDX_GDIGNOREAFTERTX: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPExternalSync : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PEXTERNALSYNC: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPFallBackInternal : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PFALLBACKINTERNAL: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPNmVectorEarlyUpdate : Set to 'false' for FlexRay Protocol 2.1 * Rev. A compliance */ case FR_CIDX_PNMVECTOREARLYUPDATE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* * FrPTwoKeySlotMode : Set to 'false' for FlexRay Protocol 2.1 Rev. A * compliance */ case FR_CIDX_PTWOKEYSLOTMODE: *Fr_ConfigParamValuePtr = FR_59_RENESAS_ZERO; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDCYCLE */ case FR_CIDX_GDCYCLE: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDCYCLE * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDMACRO_TICK */ case FR_CIDX_GDMACROTICK: *Fr_ConfigParamValuePtr = (uint32)(FR_59_RENESAS_GDMACRO_TICK * FR_59_RENESAS_NANOSEC_CONVERSION); LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PKEYSLOTID */ case FR_CIDX_PKEYSLOTID: *Fr_ConfigParamValuePtr = LpCtrlTable->usFrPKeySlotId; /* PRQA S 2814 # JV-03 */ LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDBIT */ case FR_CIDX_GDBIT: *Fr_ConfigParamValuePtr = FR_59_RENESAS_GDBIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_59_RENESAS_GDSYMBOL_WINDOW */ case FR_CIDX_GDSYMBOLWINDOW: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDSYMBOL_WINDOW; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FR_PPAYLOADLENGTHDYNMAX */ case FR_CIDX_PPAYLOADLENGTHDYNMAX: *Fr_ConfigParamValuePtr = LpCtrlTable->ucFrPPayloadLengthDynMax; LblReturnFlag = FR_59_RENESAS_TRUE; break; /* Not present in registers FrIfGdNit */ case FR_CIDX_GDNIT: *Fr_ConfigParamValuePtr = (uint32)FR_59_RENESAS_GDNIT; LblReturnFlag = FR_59_RENESAS_TRUE; break; default: /* No action required */ break; } if (FR_59_RENESAS_FALSE == LblReturnFlag) { *Fr_ConfigParamValuePtr = LulOffSet >> LucBitsTobeMovedRight; if (FR_CIDX_PSAMPLESPERMICROTICK == Fr_ConfigParamIdx) { /* pSamplepermicrotick */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N2SAMPLES; } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_N1SAMPLES; } } else if ((FR_CIDX_GDSAMPLECLOCKPERIOD == Fr_ConfigParamIdx) || (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx)) { /* gdSampleClockPeriod */ if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { if (FR_CIDX_PDMICROTICK == Fr_ConfigParamIdx) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else { /* T12_5NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T12_5NS; } } else if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { /* FR_59_RENESAS_T25NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T25NS; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } else { /* T50NS */ *Fr_ConfigParamValuePtr = FR_59_RENESAS_T50NS; } } else if (FR_CIDX_PCHANNELS == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ONE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else if ((uint32)FR_59_RENESAS_TWO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } else if ((uint32)FR_59_RENESAS_THREE == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_AB; } else { /* Update the return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } } else if (FR_CIDX_PWAKEUPCHANNEL == Fr_ConfigParamIdx) { if ((uint32)FR_59_RENESAS_ZERO == *Fr_ConfigParamValuePtr) { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_A; } else { *Fr_ConfigParamValuePtr = (uint32)FR_CHANNEL_B; } } else if ((FR_CIDX_POFFSETCORRECTIONSTART == Fr_ConfigParamIdx) || (FR_CIDX_GLISTENNOISE == Fr_ConfigParamIdx)) /* PRQA S 2004 # JV-01 */ { *Fr_ConfigParamValuePtr = *Fr_ConfigParamValuePtr + (uint32)FR_59_RENESAS_ONE; /* PRQA S 3383 # JV-01 */ } /* else No Action required */ } /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..62', 'Name': 'Fr_ConfigParamIdx', 'Value': 'FR_CIDX_GDWAKEUPRXIDLE'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ConfigParamValuePtr', 'Value': '&map_Fr_ConfigParamValuePtr[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC1', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC2', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC3', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC4', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC5', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC6', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC7', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC8', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC9', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRGTUC10', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRMHDC', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRNEMC', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC1', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRPRTC2', 'Value': '0x12345678'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC1', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC2', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRSUCC3', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '0..1023', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFrPKeySlotId', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '0..127', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].ucFrPPayloadLengthDynMax', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ConfigParamValuePtr[0]', 'Value': '0x38'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateChannelEvenList(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro, CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelAEvenListPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelBEvenListPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store framelist */ uint32 LulFrameList; /* Declare the variable to store Receive Sync Flag */ uint8 LucRxSyncFlag; /* Initialize the frame list */ LulFrameList = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ switch (RegMacro) { case FR_59_RENESAS_FLX0ESID1: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; case FR_59_RENESAS_FLX0ESID2: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID2; break; case FR_59_RENESAS_FLX0ESID3: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID3; break; case FR_59_RENESAS_FLX0ESID4: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID4; break; case FR_59_RENESAS_FLX0ESID5: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID5; break; case FR_59_RENESAS_FLX0ESID6: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID6; break; case FR_59_RENESAS_FLX0ESID7: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID7; break; case FR_59_RENESAS_FLX0ESID8: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID8; break; case FR_59_RENESAS_FLX0ESID9: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID9; break; case FR_59_RENESAS_FLX0ESID10: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID10; break; case FR_59_RENESAS_FLX0ESID11: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID11; break; case FR_59_RENESAS_FLX0ESID12: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID12; break; case FR_59_RENESAS_FLX0ESID13: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID13; break; case FR_59_RENESAS_FLX0ESID14: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID14; break; case FR_59_RENESAS_FLX0ESID15: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID15; break; default: /* No action required */ break; } LucRxSyncFlag = (uint8)((LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0RXEA_FLX0RXEB_MASK) >> FR_59_RENESAS_FOURTEEN); *Fr_ChannelAEvenListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ *Fr_ChannelBEvenListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ /* Received on both Channels AB */ if (FR_59_RENESAS_THREE == LucRxSyncFlag) { *Fr_ChannelAEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); *Fr_ChannelBEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } else if (FR_59_RENESAS_ONE == LucRxSyncFlag) { *Fr_ChannelAEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } else if (FR_59_RENESAS_TWO == LucRxSyncFlag) /* PRQA S 2004 # JV-01 */ { *Fr_ChannelBEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } /* else No Action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0ESID8'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelAEvenListPtr', 'Value': '&map_Fr_ChannelAEvenListPtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelBEvenListPtr', 'Value': '&map_Fr_ChannelBEvenListPtr[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID1', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID2', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID3', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID4', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID5', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID6', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID7', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID8', 'Value': '0x4002'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID9', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID10', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID11', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID12', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID13', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID14', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID15', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelAEvenListPtr[0]', 'Value': 'FR_59_RENESAS_TWO'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelBEvenListPtr[0]', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateChannelEvenList(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro, CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelAEvenListPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelBEvenListPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store framelist */ uint32 LulFrameList; /* Declare the variable to store Receive Sync Flag */ uint8 LucRxSyncFlag; /* Initialize the frame list */ LulFrameList = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ switch (RegMacro) { case FR_59_RENESAS_FLX0ESID1: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; case FR_59_RENESAS_FLX0ESID2: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID2; break; case FR_59_RENESAS_FLX0ESID3: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID3; break; case FR_59_RENESAS_FLX0ESID4: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID4; break; case FR_59_RENESAS_FLX0ESID5: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID5; break; case FR_59_RENESAS_FLX0ESID6: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID6; break; case FR_59_RENESAS_FLX0ESID7: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID7; break; case FR_59_RENESAS_FLX0ESID8: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID8; break; case FR_59_RENESAS_FLX0ESID9: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID9; break; case FR_59_RENESAS_FLX0ESID10: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID10; break; case FR_59_RENESAS_FLX0ESID11: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID11; break; case FR_59_RENESAS_FLX0ESID12: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID12; break; case FR_59_RENESAS_FLX0ESID13: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID13; break; case FR_59_RENESAS_FLX0ESID14: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID14; break; case FR_59_RENESAS_FLX0ESID15: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID15; break; default: /* No action required */ break; } LucRxSyncFlag = (uint8)((LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0RXEA_FLX0RXEB_MASK) >> FR_59_RENESAS_FOURTEEN); *Fr_ChannelAEvenListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ *Fr_ChannelBEvenListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ /* Received on both Channels AB */ if (FR_59_RENESAS_THREE == LucRxSyncFlag) { *Fr_ChannelAEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); *Fr_ChannelBEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } else if (FR_59_RENESAS_ONE == LucRxSyncFlag) { *Fr_ChannelAEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } else if (FR_59_RENESAS_TWO == LucRxSyncFlag) /* PRQA S 2004 # JV-01 */ { *Fr_ChannelBEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } /* else No Action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0ESID13'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelAEvenListPtr', 'Value': '&map_Fr_ChannelAEvenListPtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelBEvenListPtr', 'Value': '&map_Fr_ChannelBEvenListPtr[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID1', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID2', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID3', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID4', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID5', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID6', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID7', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID8', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID9', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID10', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID11', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID12', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID13', 'Value': '0x4002'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID14', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID15', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelAEvenListPtr[0]', 'Value': 'FR_59_RENESAS_TWO'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelBEvenListPtr[0]', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateChannelEvenList(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro, CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelAEvenListPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelBEvenListPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store framelist */ uint32 LulFrameList; /* Declare the variable to store Receive Sync Flag */ uint8 LucRxSyncFlag; /* Initialize the frame list */ LulFrameList = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ switch (RegMacro) { case FR_59_RENESAS_FLX0ESID1: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; case FR_59_RENESAS_FLX0ESID2: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID2; break; case FR_59_RENESAS_FLX0ESID3: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID3; break; case FR_59_RENESAS_FLX0ESID4: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID4; break; case FR_59_RENESAS_FLX0ESID5: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID5; break; case FR_59_RENESAS_FLX0ESID6: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID6; break; case FR_59_RENESAS_FLX0ESID7: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID7; break; case FR_59_RENESAS_FLX0ESID8: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID8; break; case FR_59_RENESAS_FLX0ESID9: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID9; break; case FR_59_RENESAS_FLX0ESID10: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID10; break; case FR_59_RENESAS_FLX0ESID11: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID11; break; case FR_59_RENESAS_FLX0ESID12: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID12; break; case FR_59_RENESAS_FLX0ESID13: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID13; break; case FR_59_RENESAS_FLX0ESID14: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID14; break; case FR_59_RENESAS_FLX0ESID15: /* Read the Even Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFRESID15; break; default: /* No action required */ break; } LucRxSyncFlag = (uint8)((LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0RXEA_FLX0RXEB_MASK) >> FR_59_RENESAS_FOURTEEN); *Fr_ChannelAEvenListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ *Fr_ChannelBEvenListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ /* Received on both Channels AB */ if (FR_59_RENESAS_THREE == LucRxSyncFlag) { *Fr_ChannelAEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); *Fr_ChannelBEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } else if (FR_59_RENESAS_ONE == LucRxSyncFlag) { *Fr_ChannelAEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } else if (FR_59_RENESAS_TWO == LucRxSyncFlag) /* PRQA S 2004 # JV-01 */ { *Fr_ChannelBEvenListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0EID_MASK); } /* else No Action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0ESID5'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelAEvenListPtr', 'Value': '&map_Fr_ChannelAEvenListPtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelBEvenListPtr', 'Value': '&map_Fr_ChannelBEvenListPtr[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID1', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID2', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID3', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID4', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID5', 'Value': '0x8003'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID6', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID7', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID8', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID9', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID10', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID11', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID12', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID13', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID14', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRESID15', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelAEvenListPtr[0]', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelBEvenListPtr[0]', 'Value': 'FR_59_RENESAS_THREE'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateChannelOddList(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegAdd, CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelAOddListPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelBOddListPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store framelist */ uint32 LulFrameList; uint8 LucRxSyncFlag; /* Initialize the frame list */ LulFrameList = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ switch (RegAdd) { case FR_59_RENESAS_FLX0OSID1: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; case FR_59_RENESAS_FLX0OSID2: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID2; break; case FR_59_RENESAS_FLX0OSID3: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID3; break; case FR_59_RENESAS_FLX0OSID4: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID4; break; case FR_59_RENESAS_FLX0OSID5: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID5; break; case FR_59_RENESAS_FLX0OSID6: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID6; break; case FR_59_RENESAS_FLX0OSID7: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID7; break; case FR_59_RENESAS_FLX0OSID8: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID8; break; case FR_59_RENESAS_FLX0OSID9: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID9; break; case FR_59_RENESAS_FLX0OSID10: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID10; break; case FR_59_RENESAS_FLX0OSID11: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID11; break; case FR_59_RENESAS_FLX0OSID12: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID12; break; case FR_59_RENESAS_FLX0OSID13: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID13; break; case FR_59_RENESAS_FLX0OSID14: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID14; break; case FR_59_RENESAS_FLX0OSID15: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID15; break; default: /* No action required */ break; } LucRxSyncFlag = (uint8)((LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0RXEA_FLX0RXEB_MASK) >> FR_59_RENESAS_FOURTEEN); *Fr_ChannelAOddListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ *Fr_ChannelBOddListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ /* Received on both Channels AB */ if (FR_59_RENESAS_THREE == LucRxSyncFlag) { *Fr_ChannelAOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); *Fr_ChannelBOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } else if (FR_59_RENESAS_ONE == LucRxSyncFlag) { *Fr_ChannelAOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } else if (FR_59_RENESAS_TWO == LucRxSyncFlag) /* PRQA S 2004 # JV-01 */ { *Fr_ChannelBOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } /* else No Action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegAdd', 'Value': 'FR_59_RENESAS_FLX0OSID7'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelAOddListPtr', 'Value': '&map_Fr_ChannelAOddListPtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelBOddListPtr', 'Value': '&map_Fr_ChannelBOddListPtr[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID1', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID2', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID3', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID4', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID5', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID6', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID7', 'Value': '0x4002'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID8', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID9', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID10', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID11', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID12', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID13', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID14', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID15', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelAOddListPtr[0]', 'Value': 'FR_59_RENESAS_TWO'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelBOddListPtr[0]', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateChannelOddList(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegAdd, CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelAOddListPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelBOddListPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store framelist */ uint32 LulFrameList; uint8 LucRxSyncFlag; /* Initialize the frame list */ LulFrameList = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ switch (RegAdd) { case FR_59_RENESAS_FLX0OSID1: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; case FR_59_RENESAS_FLX0OSID2: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID2; break; case FR_59_RENESAS_FLX0OSID3: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID3; break; case FR_59_RENESAS_FLX0OSID4: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID4; break; case FR_59_RENESAS_FLX0OSID5: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID5; break; case FR_59_RENESAS_FLX0OSID6: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID6; break; case FR_59_RENESAS_FLX0OSID7: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID7; break; case FR_59_RENESAS_FLX0OSID8: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID8; break; case FR_59_RENESAS_FLX0OSID9: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID9; break; case FR_59_RENESAS_FLX0OSID10: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID10; break; case FR_59_RENESAS_FLX0OSID11: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID11; break; case FR_59_RENESAS_FLX0OSID12: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID12; break; case FR_59_RENESAS_FLX0OSID13: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID13; break; case FR_59_RENESAS_FLX0OSID14: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID14; break; case FR_59_RENESAS_FLX0OSID15: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID15; break; default: /* No action required */ break; } LucRxSyncFlag = (uint8)((LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0RXEA_FLX0RXEB_MASK) >> FR_59_RENESAS_FOURTEEN); *Fr_ChannelAOddListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ *Fr_ChannelBOddListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ /* Received on both Channels AB */ if (FR_59_RENESAS_THREE == LucRxSyncFlag) { *Fr_ChannelAOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); *Fr_ChannelBOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } else if (FR_59_RENESAS_ONE == LucRxSyncFlag) { *Fr_ChannelAOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } else if (FR_59_RENESAS_TWO == LucRxSyncFlag) /* PRQA S 2004 # JV-01 */ { *Fr_ChannelBOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } /* else No Action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegAdd', 'Value': 'FR_59_RENESAS_FLX0OSID9'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelAOddListPtr', 'Value': '&map_Fr_ChannelAOddListPtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelBOddListPtr', 'Value': '&map_Fr_ChannelBOddListPtr[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID1', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID2', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID3', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID4', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID5', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID6', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID7', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID8', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID9', 'Value': '0x1'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID10', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID11', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID12', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID13', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID14', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID15', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelAOddListPtr[0]', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelBOddListPtr[0]', 'Value': 'FR_59_RENESAS_ZERO'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateChannelOddList(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegAdd, CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelAOddListPtr, /* PRQA S 3432 # JV-01 */ CONSTP2VAR(uint16, AUTOMATIC, FR_APPL_DATA) Fr_ChannelBOddListPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare variable to store framelist */ uint32 LulFrameList; uint8 LucRxSyncFlag; /* Initialize the frame list */ LulFrameList = FR_59_RENESAS_ZERO; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ switch (RegAdd) { case FR_59_RENESAS_FLX0OSID1: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; case FR_59_RENESAS_FLX0OSID2: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID2; break; case FR_59_RENESAS_FLX0OSID3: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID3; break; case FR_59_RENESAS_FLX0OSID4: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID4; break; case FR_59_RENESAS_FLX0OSID5: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID5; break; case FR_59_RENESAS_FLX0OSID6: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID6; break; case FR_59_RENESAS_FLX0OSID7: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID7; break; case FR_59_RENESAS_FLX0OSID8: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID8; break; case FR_59_RENESAS_FLX0OSID9: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID9; break; case FR_59_RENESAS_FLX0OSID10: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID10; break; case FR_59_RENESAS_FLX0OSID11: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID11; break; case FR_59_RENESAS_FLX0OSID12: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID12; break; case FR_59_RENESAS_FLX0OSID13: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID13; break; case FR_59_RENESAS_FLX0OSID14: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID14; break; case FR_59_RENESAS_FLX0OSID15: /* Read the Odd Sync ID register */ LulFrameList = LpCCStatusReg->ulFLXAnFROSID15; break; default: /* No action required */ break; } LucRxSyncFlag = (uint8)((LulFrameList & FR_59_RENESAS_FLX0ESID_FLX0RXEA_FLX0RXEB_MASK) >> FR_59_RENESAS_FOURTEEN); *Fr_ChannelAOddListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ *Fr_ChannelBOddListPtr = FR_59_RENESAS_ZERO; /* PRQA S 2814 # JV-03 */ /* Received on both Channels AB */ if (FR_59_RENESAS_THREE == LucRxSyncFlag) { *Fr_ChannelAOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); *Fr_ChannelBOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } else if (FR_59_RENESAS_ONE == LucRxSyncFlag) { *Fr_ChannelAOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } else if (FR_59_RENESAS_TWO == LucRxSyncFlag) /* PRQA S 2004 # JV-01 */ { *Fr_ChannelBOddListPtr = (uint16)(LulFrameList & FR_59_RENESAS_FLX0OSID_FLX0OID_MASK); } /* else No Action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegAdd', 'Value': 'FR_59_RENESAS_FLX0OSID13'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelAOddListPtr', 'Value': '&map_Fr_ChannelAOddListPtr[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_ChannelBOddListPtr', 'Value': '&map_Fr_ChannelBOddListPtr[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID1', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID2', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID3', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID4', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID5', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID6', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID7', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID8', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID9', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID10', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID11', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID12', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID13', 'Value': '0xC004'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID14', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFROSID15', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelAOddListPtr[0]', 'Value': 'FR_59_RENESAS_FOUR'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_ChannelBOddListPtr[0]', 'Value': 'FR_59_RENESAS_FOUR'], 'Output_Param_002': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateInputPtrTable(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_InputTableContentPtr) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferControlRegType, AUTOMATIC, REGSPACE) LpDataTransferCtrlReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_DataTransferStatusRegType, AUTOMATIC, REGSPACE) LpDataTransferStatusReg; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store return value */ Std_ReturnType LucReturnValue; /* Declare the variable to store the access error */ uint32 LulAccessError; /* Declare the variable to store register value */ uint32 LulData; /* Declare the variable to store the index */ uint32 LulPut_index; /* Declare the pointer to which Input Table point */ P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) /* PRQA S 3432 # JV-01 */ LpInputPointerTablePtr; /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpDataTransferCtrlReg = LpCtrlRegSet->pDataTransferCtrlReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LpDataTransferStatusReg = LpCtrlRegSet->pDataTransferStatusReg; LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); LulData = LpDataTransferStatusReg->ulFLXAnFRITS; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Writing in to FlexRay Access Error Status Register and mirror address */ LpDataTransferStatusReg->ulFLXAnFRAES = FR_59_RENESAS_FLX0FRAES_RESET; /* Check for Input Transfer enable and Input queue not halted */ if ((FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK == (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_ITS_MASK)) && (FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK != (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_IQH_MASK))) { /* Get the putindex */ LulData = LpDataTransferStatusReg->ulFLXAnFRITS; LulPut_index = ((LulData & FR_59_RENESAS_FLX0FRITS_FLX0_IPIDX_MASK) >> FR_59_RENESAS_SIXTEEN); /* Check for input queue is not full */ if (FR_59_RENESAS_FLX0FRITS_FLX0_IQFP_MASK != (LulData & FR_59_RENESAS_FLX0FRITS_FLX0_IQFP_MASK)) { LulData = LpDataTransferCtrlReg->ulFLXAnFRIBA; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Get the address to write the control reg and data pointer */ LpInputPointerTablePtr = (P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA)) /* PRQA S 0303, 3432 # JV-01, JV-01 */ (LulData + (LulPut_index * (uint32)FR_59_RENESAS_EIGHT)); /* PRQA S 3383 # JV-01 */ /* Write the control reg in input pointer */ LpInputPointerTablePtr->ulFLX0FRWRHS4 = (Fr_InputTableContentPtr->ulFLX0FRWRHS4); /* PRQA S 2814 # JV-01 */ /* Write the Data pointer in input pointer */ LpInputPointerTablePtr->Fr_59_Renesas_pInputDataPtr = (Fr_InputTableContentPtr->Fr_59_Renesas_pInputDataPtr); /* Get the Message buffer from control register */ LulData = ((Fr_InputTableContentPtr->ulFLX0FRWRHS4) & FR_59_RENESAS_FLX0FRWRHS4_FLX0_IMBNR); /* Update the Message buffer in Input Queue Control Register */ /* Writing in to register and mirror address */ LpDataTransferCtrlReg->ulFLXAnFRIQC = LulData; LulAccessError = LpDataTransferStatusReg->ulFLXAnFRAES; if ((uint32)FR_59_RENESAS_ZERO < (LulAccessError & FR_59_RENESAS_FLX0FRAES_ERR_MASK)) { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; } else { LucReturnValue = E_OK; } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; } } else { /* Raise DEM Error FAILED */ if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr[0].ulFLX0FRWRHS4', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_InputTableContentPtr[0].Fr_59_Renesas_pInputDataPtr', 'Value': '&map_pInputDataPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLX0FRWRHS1', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferStatusReg', 'Value': '&map_DataTransferStatusReg[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRITS', 'Value': '0x00001001'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pDataTransferCtrlReg', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '&map_Fr_59_Renesas_DemEventId[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '1'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIBA', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferStatusReg[0].ulFLXAnFRAES', 'Value': 'FR_59_RENESAS_FLX0FRAES_RESET'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_DataTransferCtrlReg[0].ulFLXAnFRIQC', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_InputData[0].ulFLX0FRWRHS4', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_InputData[0].Fr_59_Renesas_pInputDataPtr', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_InputData[127].ulFLX0FRWRHS4', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_InputData[127].Fr_59_Renesas_pInputDataPtr', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateLPduTxSts(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint16, AUTOMATIC) Fr_LPduIdx, CONST(uint8, AUTOMATIC) LucMessageBuffer, CONSTP2VAR(Fr_TxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_TxLPduStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_MessageBufferStatusRegType, AUTOMATIC, REGSPACE) LpMBStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the address of Frame configuration */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the value of FLXAnFRTXRQm register */ uint32 LulTXRData; /* Declare return value */ uint8 LucReturnValue; /* Message buffer register offset */ uint8 LucMBRegNumber; uint32 LulMBBitMask; #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Pointer to Output buffer register */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the value of Channel */ uint8 LucChannel; /* Declare the variable to store the value of Message buffer status */ uint32 LulFLXAnFRMBSRegVal; #endif /* Calculate the Message buffer register number and bit number */ LucMBRegNumber = FR_59_RENESAS_REGNUMBER_OFFSET(LucMessageBuffer); LulMBBitMask = FR_59_RENESAS_BITNUMBER_MASK(LucMessageBuffer); /* PRQA S 3469 # JV-01 */ /* Initial return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpMBStatusReg = LpCtrlRegSet->pMBStatusReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the value of register */ LulTXRData = (uint32)FR_59_RENESAS_ZERO; /* Initialize the value of pointer */ LpFrameConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig; LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Copy global pointer to local pointer */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* Get channel value of target LPdu */ LucChannel = LpFrameConfigPtr->ucChannelFilter; /* PRQA S 2814 # JV-02 */ /* Initial the value of Message buffer status */ LulFLXAnFRMBSRegVal = (uint32)FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ #endif switch (LucMBRegNumber) { /* Using FLXAnFRTXRQ1 */ case FR_59_RENESAS_ZERO: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; /* Using FLXAnFRTXRQ2 */ case FR_59_RENESAS_ONE: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ2; break; /* Using FLXAnFRTXRQ2 */ case FR_59_RENESAS_TWO: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ3; break; /* Using FLXAnFRTXRQ3 */ case FR_59_RENESAS_THREE: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ4; break; default: /* No action required */ break; } #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Read out the message header and status from Message RAM to Output buffer */ LucReturnValue = Fr_59_Renesas_WriteOutputBufferCommand(Fr_CtrlIdx, Fr_LPduIdx); if (E_OK == LucReturnValue) { /* Read Message buffer status */ LulFLXAnFRMBSRegVal = LpOutputBuffReg->ulFLXAnFRMBS; /* PRQA S 2814, 2844 # JV-02, JV-01 */ } /* else No Action required */ /* Check the conflict transmission */ if (E_OK == LucReturnValue) { if ((((LulFLXAnFRMBSRegVal & FR_59_RENESAS_FLX0FRMBS_TCIA_MASK) == FR_59_RENESAS_FLX0FRMBS_TCIA_MASK) && (((uint8)FR_59_RENESAS_CHANNEL_A == LucChannel) || ((uint8)FR_59_RENESAS_CHANNEL_AB == LucChannel))) || (((LulFLXAnFRMBSRegVal & FR_59_RENESAS_FLX0FRMBS_TCIB_MASK) == FR_59_RENESAS_FLX0FRMBS_TCIB_MASK) && (((uint8)FR_59_RENESAS_CHANNEL_B == LucChannel) || ((uint8)FR_59_RENESAS_CHANNEL_AB == LucChannel)))) { /* Set the status to FR_TRANSMITTED_CONFLICT when conflict transmission exist */ *Fr_TxLPduStatusPtr = FR_TRANSMITTED_CONFLICT; /* PRQA S 2814 # JV-03 */ } else if ((uint32)FR_59_RENESAS_ZERO == (LulTXRData & LulMBBitMask)) #else /* Check TXR flag in register FLXAnFRMBSCi value */ if ((uint32)FR_59_RENESAS_ZERO == (LulTXRData & LulMBBitMask)) #endif { /* Check whether the frame is configured for single shot */ if (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode) /* PRQA S 2814 # JV-02 */ { *Fr_TxLPduStatusPtr = FR_TRANSMITTED; /* PRQA S 2814 # JV-03 */ } else /* Continuous Mode */ { *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; } } else /* Transmission request present */ { /* Check whether the frame is configured for single shot */ if (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode) { *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; } else /* Continuous Mode */ { *Fr_TxLPduStatusPtr = FR_TRANSMITTED; } } #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) } /* else No Action required */ #endif /* Return checking process is succeed or failed */ return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_TxLPduStatusPtr', 'Value': '&map_Fr_TxLPduStatusPtr'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucChannelFilter', 'Value': 'FR_59_RENESAS_CHANNEL_B'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucTransmissionMode', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pMBStatusReg', 'Value': '&map_MBStatusReg[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRMBS', 'Value': '0x300'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ1', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ2', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ3', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ4', 'Value': '-'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_TxLPduStatusPtr', 'Value': 'FR_TRANSMITTED_CONFLICT'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '0'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateLPduTxSts(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint16, AUTOMATIC) Fr_LPduIdx, CONST(uint8, AUTOMATIC) LucMessageBuffer, CONSTP2VAR(Fr_TxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_TxLPduStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_MessageBufferStatusRegType, AUTOMATIC, REGSPACE) LpMBStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the address of Frame configuration */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the value of FLXAnFRTXRQm register */ uint32 LulTXRData; /* Declare return value */ uint8 LucReturnValue; /* Message buffer register offset */ uint8 LucMBRegNumber; uint32 LulMBBitMask; #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Pointer to Output buffer register */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the value of Channel */ uint8 LucChannel; /* Declare the variable to store the value of Message buffer status */ uint32 LulFLXAnFRMBSRegVal; #endif /* Calculate the Message buffer register number and bit number */ LucMBRegNumber = FR_59_RENESAS_REGNUMBER_OFFSET(LucMessageBuffer); LulMBBitMask = FR_59_RENESAS_BITNUMBER_MASK(LucMessageBuffer); /* PRQA S 3469 # JV-01 */ /* Initial return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpMBStatusReg = LpCtrlRegSet->pMBStatusReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the value of register */ LulTXRData = (uint32)FR_59_RENESAS_ZERO; /* Initialize the value of pointer */ LpFrameConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig; LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Copy global pointer to local pointer */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* Get channel value of target LPdu */ LucChannel = LpFrameConfigPtr->ucChannelFilter; /* PRQA S 2814 # JV-02 */ /* Initial the value of Message buffer status */ LulFLXAnFRMBSRegVal = (uint32)FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ #endif switch (LucMBRegNumber) { /* Using FLXAnFRTXRQ1 */ case FR_59_RENESAS_ZERO: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; /* Using FLXAnFRTXRQ2 */ case FR_59_RENESAS_ONE: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ2; break; /* Using FLXAnFRTXRQ2 */ case FR_59_RENESAS_TWO: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ3; break; /* Using FLXAnFRTXRQ3 */ case FR_59_RENESAS_THREE: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ4; break; default: /* No action required */ break; } #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Read out the message header and status from Message RAM to Output buffer */ LucReturnValue = Fr_59_Renesas_WriteOutputBufferCommand(Fr_CtrlIdx, Fr_LPduIdx); if (E_OK == LucReturnValue) { /* Read Message buffer status */ LulFLXAnFRMBSRegVal = LpOutputBuffReg->ulFLXAnFRMBS; /* PRQA S 2814, 2844 # JV-02, JV-01 */ } /* else No Action required */ /* Check the conflict transmission */ if (E_OK == LucReturnValue) { if ((((LulFLXAnFRMBSRegVal & FR_59_RENESAS_FLX0FRMBS_TCIA_MASK) == FR_59_RENESAS_FLX0FRMBS_TCIA_MASK) && (((uint8)FR_59_RENESAS_CHANNEL_A == LucChannel) || ((uint8)FR_59_RENESAS_CHANNEL_AB == LucChannel))) || (((LulFLXAnFRMBSRegVal & FR_59_RENESAS_FLX0FRMBS_TCIB_MASK) == FR_59_RENESAS_FLX0FRMBS_TCIB_MASK) && (((uint8)FR_59_RENESAS_CHANNEL_B == LucChannel) || ((uint8)FR_59_RENESAS_CHANNEL_AB == LucChannel)))) { /* Set the status to FR_TRANSMITTED_CONFLICT when conflict transmission exist */ *Fr_TxLPduStatusPtr = FR_TRANSMITTED_CONFLICT; /* PRQA S 2814 # JV-03 */ } else if ((uint32)FR_59_RENESAS_ZERO == (LulTXRData & LulMBBitMask)) #else /* Check TXR flag in register FLXAnFRMBSCi value */ if ((uint32)FR_59_RENESAS_ZERO == (LulTXRData & LulMBBitMask)) #endif { /* Check whether the frame is configured for single shot */ if (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode) /* PRQA S 2814 # JV-02 */ { *Fr_TxLPduStatusPtr = FR_TRANSMITTED; /* PRQA S 2814 # JV-03 */ } else /* Continuous Mode */ { *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; } } else /* Transmission request present */ { /* Check whether the frame is configured for single shot */ if (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode) { *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; } else /* Continuous Mode */ { *Fr_TxLPduStatusPtr = FR_TRANSMITTED; } } #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) } /* else No Action required */ #endif /* Return checking process is succeed or failed */ return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '63'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_TxLPduStatusPtr', 'Value': '&map_Fr_TxLPduStatusPtr'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucChannelFilter', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucTransmissionMode', 'Value': '0U'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pMBStatusReg', 'Value': '&map_MBStatusReg[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRMBS', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ1', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ2', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ3', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ4', 'Value': '-'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_TxLPduStatusPtr', 'Value': 'FR_NOT_TRANSMITTED'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '0'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateLPduTxSts(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint16, AUTOMATIC) Fr_LPduIdx, CONST(uint8, AUTOMATIC) LucMessageBuffer, CONSTP2VAR(Fr_TxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_TxLPduStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_MessageBufferStatusRegType, AUTOMATIC, REGSPACE) LpMBStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the address of Frame configuration */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the value of FLXAnFRTXRQm register */ uint32 LulTXRData; /* Declare return value */ uint8 LucReturnValue; /* Message buffer register offset */ uint8 LucMBRegNumber; uint32 LulMBBitMask; #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Pointer to Output buffer register */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the value of Channel */ uint8 LucChannel; /* Declare the variable to store the value of Message buffer status */ uint32 LulFLXAnFRMBSRegVal; #endif /* Calculate the Message buffer register number and bit number */ LucMBRegNumber = FR_59_RENESAS_REGNUMBER_OFFSET(LucMessageBuffer); LulMBBitMask = FR_59_RENESAS_BITNUMBER_MASK(LucMessageBuffer); /* PRQA S 3469 # JV-01 */ /* Initial return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpMBStatusReg = LpCtrlRegSet->pMBStatusReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the value of register */ LulTXRData = (uint32)FR_59_RENESAS_ZERO; /* Initialize the value of pointer */ LpFrameConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig; LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Copy global pointer to local pointer */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* Get channel value of target LPdu */ LucChannel = LpFrameConfigPtr->ucChannelFilter; /* PRQA S 2814 # JV-02 */ /* Initial the value of Message buffer status */ LulFLXAnFRMBSRegVal = (uint32)FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ #endif switch (LucMBRegNumber) { /* Using FLXAnFRTXRQ1 */ case FR_59_RENESAS_ZERO: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; /* Using FLXAnFRTXRQ2 */ case FR_59_RENESAS_ONE: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ2; break; /* Using FLXAnFRTXRQ2 */ case FR_59_RENESAS_TWO: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ3; break; /* Using FLXAnFRTXRQ3 */ case FR_59_RENESAS_THREE: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ4; break; default: /* No action required */ break; } #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Read out the message header and status from Message RAM to Output buffer */ LucReturnValue = Fr_59_Renesas_WriteOutputBufferCommand(Fr_CtrlIdx, Fr_LPduIdx); if (E_OK == LucReturnValue) { /* Read Message buffer status */ LulFLXAnFRMBSRegVal = LpOutputBuffReg->ulFLXAnFRMBS; /* PRQA S 2814, 2844 # JV-02, JV-01 */ } /* else No Action required */ /* Check the conflict transmission */ if (E_OK == LucReturnValue) { if ((((LulFLXAnFRMBSRegVal & FR_59_RENESAS_FLX0FRMBS_TCIA_MASK) == FR_59_RENESAS_FLX0FRMBS_TCIA_MASK) && (((uint8)FR_59_RENESAS_CHANNEL_A == LucChannel) || ((uint8)FR_59_RENESAS_CHANNEL_AB == LucChannel))) || (((LulFLXAnFRMBSRegVal & FR_59_RENESAS_FLX0FRMBS_TCIB_MASK) == FR_59_RENESAS_FLX0FRMBS_TCIB_MASK) && (((uint8)FR_59_RENESAS_CHANNEL_B == LucChannel) || ((uint8)FR_59_RENESAS_CHANNEL_AB == LucChannel)))) { /* Set the status to FR_TRANSMITTED_CONFLICT when conflict transmission exist */ *Fr_TxLPduStatusPtr = FR_TRANSMITTED_CONFLICT; /* PRQA S 2814 # JV-03 */ } else if ((uint32)FR_59_RENESAS_ZERO == (LulTXRData & LulMBBitMask)) #else /* Check TXR flag in register FLXAnFRMBSCi value */ if ((uint32)FR_59_RENESAS_ZERO == (LulTXRData & LulMBBitMask)) #endif { /* Check whether the frame is configured for single shot */ if (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode) /* PRQA S 2814 # JV-02 */ { *Fr_TxLPduStatusPtr = FR_TRANSMITTED; /* PRQA S 2814 # JV-03 */ } else /* Continuous Mode */ { *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; } } else /* Transmission request present */ { /* Check whether the frame is configured for single shot */ if (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode) { *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; } else /* Continuous Mode */ { *Fr_TxLPduStatusPtr = FR_TRANSMITTED; } } #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) } /* else No Action required */ #endif /* Return checking process is succeed or failed */ return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '4095'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '95'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_TxLPduStatusPtr', 'Value': '&map_Fr_TxLPduStatusPtr'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucChannelFilter', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucTransmissionMode', 'Value': '0U'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pMBStatusReg', 'Value': '&map_MBStatusReg[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRMBS', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ1', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ2', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ3', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ4', 'Value': '-'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_TxLPduStatusPtr', 'Value': 'FR_NOT_TRANSMITTED'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '4095'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateLPduTxSts(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONST(uint16, AUTOMATIC) Fr_LPduIdx, CONST(uint8, AUTOMATIC) LucMessageBuffer, CONSTP2VAR(Fr_TxLPduStatusType, AUTOMATIC, FR_APPL_DATA) Fr_TxLPduStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_MessageBufferStatusRegType, AUTOMATIC, REGSPACE) LpMBStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the address of Frame configuration */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfigPtr; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the value of FLXAnFRTXRQm register */ uint32 LulTXRData; /* Declare return value */ uint8 LucReturnValue; /* Message buffer register offset */ uint8 LucMBRegNumber; uint32 LulMBBitMask; #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION) || \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Pointer to Output buffer register */ P2VAR(volatile Fr_59_Renesas_OutputBufferRegType, AUTOMATIC, REGSPACE) LpOutputBuffReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the value of Channel */ uint8 LucChannel; /* Declare the variable to store the value of Message buffer status */ uint32 LulFLXAnFRMBSRegVal; #endif /* Calculate the Message buffer register number and bit number */ LucMBRegNumber = FR_59_RENESAS_REGNUMBER_OFFSET(LucMessageBuffer); LulMBBitMask = FR_59_RENESAS_BITNUMBER_MASK(LucMessageBuffer); /* PRQA S 3469 # JV-01 */ /* Initial return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpMBStatusReg = LpCtrlRegSet->pMBStatusReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Initialize the value of register */ LulTXRData = (uint32)FR_59_RENESAS_ZERO; /* Initialize the value of pointer */ LpFrameConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig; LpFrameConfigPtr = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Copy global pointer to local pointer */ LpOutputBuffReg = LpCtrlRegSet->pOutputBuffReg; /* Get channel value of target LPdu */ LucChannel = LpFrameConfigPtr->ucChannelFilter; /* PRQA S 2814 # JV-02 */ /* Initial the value of Message buffer status */ LulFLXAnFRMBSRegVal = (uint32)FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ #endif switch (LucMBRegNumber) { /* Using FLXAnFRTXRQ1 */ case FR_59_RENESAS_ZERO: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ break; /* Using FLXAnFRTXRQ2 */ case FR_59_RENESAS_ONE: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ2; break; /* Using FLXAnFRTXRQ2 */ case FR_59_RENESAS_TWO: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ3; break; /* Using FLXAnFRTXRQ3 */ case FR_59_RENESAS_THREE: LulTXRData = LpMBStatusReg->ulFLXAnFRTXRQ4; break; default: /* No action required */ break; } #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) /* Read out the message header and status from Message RAM to Output buffer */ LucReturnValue = Fr_59_Renesas_WriteOutputBufferCommand(Fr_CtrlIdx, Fr_LPduIdx); if (E_OK == LucReturnValue) { /* Read Message buffer status */ LulFLXAnFRMBSRegVal = LpOutputBuffReg->ulFLXAnFRMBS; /* PRQA S 2814, 2844 # JV-02, JV-01 */ } /* else No Action required */ /* Check the conflict transmission */ if (E_OK == LucReturnValue) { if ((((LulFLXAnFRMBSRegVal & FR_59_RENESAS_FLX0FRMBS_TCIA_MASK) == FR_59_RENESAS_FLX0FRMBS_TCIA_MASK) && (((uint8)FR_59_RENESAS_CHANNEL_A == LucChannel) || ((uint8)FR_59_RENESAS_CHANNEL_AB == LucChannel))) || (((LulFLXAnFRMBSRegVal & FR_59_RENESAS_FLX0FRMBS_TCIB_MASK) == FR_59_RENESAS_FLX0FRMBS_TCIB_MASK) && (((uint8)FR_59_RENESAS_CHANNEL_B == LucChannel) || ((uint8)FR_59_RENESAS_CHANNEL_AB == LucChannel)))) { /* Set the status to FR_TRANSMITTED_CONFLICT when conflict transmission exist */ *Fr_TxLPduStatusPtr = FR_TRANSMITTED_CONFLICT; /* PRQA S 2814 # JV-03 */ } else if ((uint32)FR_59_RENESAS_ZERO == (LulTXRData & LulMBBitMask)) #else /* Check TXR flag in register FLXAnFRMBSCi value */ if ((uint32)FR_59_RENESAS_ZERO == (LulTXRData & LulMBBitMask)) #endif { /* Check whether the frame is configured for single shot */ if (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode) /* PRQA S 2814 # JV-02 */ { *Fr_TxLPduStatusPtr = FR_TRANSMITTED; /* PRQA S 2814 # JV-03 */ } else /* Continuous Mode */ { *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; } } else /* Transmission request present */ { /* Check whether the frame is configured for single shot */ if (FR_59_RENESAS_TXM_SINGLESHOT == LpFrameConfigPtr->ucTransmissionMode) { *Fr_TxLPduStatusPtr = FR_NOT_TRANSMITTED; } else /* Continuous Mode */ { *Fr_TxLPduStatusPtr = FR_TRANSMITTED; } } #if ((FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_431_VERSION)|| \\ (FR_59_RENESAS_AR_VERSION == FR_59_RENESAS_AR_1911_VERSION)) } /* else No Action required */ #endif /* Return checking process is succeed or failed */ return LucReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '4095'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucMessageBuffer', 'Value': '127'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Fr_TxLPduStatusPtr', 'Value': '&map_Fr_TxLPduStatusPtr'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucChannelFilter', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0, 1', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucTransmissionMode', 'Value': '0U'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pMBStatusReg', 'Value': '&map_MBStatusReg[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pOutputBuffReg', 'Value': '&map_OutputBufferReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_OutputBufferReg[0].ulFLXAnFRMBS', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ1', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ2', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ3', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRTXRQ4', 'Value': '0x80000000'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_TxLPduStatusPtr', 'Value': 'FR_TRANSMITTED'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_LPduIdx', 'Value': '4095'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateNumOfStartupFrame(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(uint8, AUTOMATIC, FR_APPL_DATA) Fr_NumOfStartupFramesPtr) /* PRQA S 3432 # JV-01 */ { /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store return value */ Std_ReturnType LucReturnValue; /* Declare the variable to store the FLX0ACS register value */ uint32 LulRegData; /* Initialize the return value */ LucReturnValue = E_OK; /* Read the POC State by getting FLX0CCSV register value */ LulRegData = Fr_59_Renesas_GetPOCStsFlag(Fr_CtrlIdx); /* Check if the CC is in normal active state */ if ((FR_59_RENESAS_NORMAL_ACTIVE_STATE == LulRegData) || (FR_59_RENESAS_NORMAL_PASSIVE_STATE == LulRegData)) { *Fr_NumOfStartupFramesPtr = FR_59_RENESAS_TWO; /* PRQA S 2814 # JV-03 */ } else { /* Report Error to DEM */ LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_NumOfStartupFramesPtr', 'Value': '&map_Fr_NumOfStartupFramesPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pDemEventId', 'Value': '[0] = &map_Fr_59_Renesas_DemEventId[0]\\n[1] = &map_Fr_59_Renesas_DemEventId[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usHardwareTestFailure', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[1].usHardwareTestFailure', 'Value': '-'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '0UL']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_NumOfStartupFramesPtr[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '1'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdatePOCSts(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ CONSTP2VAR(Fr_POCStatusType, AUTOMATIC, FR_APPL_DATA) Fr_POCStatusPtr) /* PRQA S 3432 # JV-01 */ { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCStatusRegType, AUTOMATIC, REGSPACE) LpCCStatusReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Declare the variable to store the return value */ Std_ReturnType LucReturnValue; uint32 LulData; /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ /* Initialize the return value */ LucReturnValue = E_OK; LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCStatusReg = LpCtrlRegSet->pCCStatusReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Read the POC State by getting FLX0CCSV register value */ LulData = LpCCStatusReg->ulFLXAnFRCCSV; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* CHIReadyRequest is set to OFF (parameter not present in FlexRay Version 2.1 Revision A) */ Fr_POCStatusPtr->CHIReadyRequest = STD_OFF; /* PRQA S 2814 # JV-03 */ /* Update WakeupStatus with curent value of WSV[2:0] */ Fr_POCStatusPtr->WakeupStatus = (Fr_WakeupStatusType)((LulData & FR_59_RENESAS_FLX0CCSV_FLX0WSV_MASK) >> FR_59_RENESAS_FLX0CCSV_FLX0WSV_SHIFT); /* PRQA S 4394, 4342 # JV-01, JV-01 */ /* Check for the POC states */ switch ((uint32)(LulData & FR_59_RENESAS_FLX0CCSV_FLX0POCS_MASK)) { /* Default config state*/ case FR_59_RENESAS_DEFAULT_CONFIG_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_DEFAULT_CONFIG; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; /* Ready State */ case FR_59_RENESAS_READY_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_READY; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; /* Normal Active State */ case FR_59_RENESAS_NORMAL_ACTIVE_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_NORMAL_ACTIVE; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; /* Normal Passive State */ case FR_59_RENESAS_NORMAL_PASSIVE_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_NORMAL_PASSIVE; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; /* Halt State */ case FR_59_RENESAS_HALT_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_HALT; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; /* Config State */ case FR_59_RENESAS_CONFIG_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_CONFIG; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; /* Wakeup Standby State, Wakeup Listen State, Wakeup Send State, Wakeup Detect State */ case FR_59_RENESAS_WAKEUP_STANDBY_STATE: case FR_59_RENESAS_WAKEUP_LISTEN_STATE: case FR_59_RENESAS_WAKEUP_SEND_STATE: case FR_59_RENESAS_WAKEUP_DETECT_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_WAKEUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; /* Startup Prepare State */ case FR_59_RENESAS_STARTUP_PREPARE_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; /* Coldstart Listen State */ case FR_59_RENESAS_COLDSTART_LISTEN_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_COLDSTART_LISTEN; break; /* Coldstart Collision Resolution State */ case FR_59_RENESAS_COLDSTART_COLLISION_RESOLUTION_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_COLDSTART_COLLISION_RESOLUTION; break; /* Coldstart Consistency Check State */ case FR_59_RENESAS_COLDSTART_CONSISTENCY_CHECK_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_COLDSTART_CONSISTENCY_CHECK; break; /* Coldstart State */ case FR_59_RENESAS_COLDSTART_GAP_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_COLDSTART_GAP; break; /* Coldstart Join State */ case FR_59_RENESAS_COLDSTART_JOIN_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_COLDSTART_JOIN; break; /* Integration Coldstart Check State */ case FR_59_RENESAS_INTEGRATION_COLDSTART_CHECK_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_INTEGRATION_COLDSTART_CHECK; break; /* Integration Listen State */ case FR_59_RENESAS_INTEGRATION_LISTEN_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_INTEGRATION_LISTEN; break; /* Integration Consistency Check State */ case FR_59_RENESAS_INTEGRATION_CONSISTENCY_CHECK_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_INTEGRATION_CONSISTENCY_CHECK; break; /* Initialize Schedule State */ case FR_59_RENESAS_INITIALIZE_SCHEDULE_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_INITIALIZE_SCHEDULE; break; /* Abort Startup State */ case FR_59_RENESAS_ABORT_STARTUP_STATE: Fr_POCStatusPtr->State = FR_POCSTATE_STARTUP; Fr_POCStatusPtr->StartupState = FR_STARTUP_UNDEFINED; break; default: if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; break; } /* End of switch(LulData & FR_59_RENESAS_FLX0CCSV_FLX0POCS_MASK) */ /* Check if the return value is E_OK */ if (E_OK == LucReturnValue) { /* Confirmation of Freeze Status Indicator */ if (FR_59_RENESAS_FLX0CCSV_FLX0FSI_MASK == (LulData & FR_59_RENESAS_FLX0CCSV_FLX0FSI_MASK)) { /* Update the parameter freeze of statusptr */ Fr_POCStatusPtr->Freeze = STD_ON; } else { /* Update the parameter freeze of statusptr */ Fr_POCStatusPtr->Freeze = STD_OFF; } /* Confirmation of Halt Request */ if (FR_59_RENESAS_FLX0CCSV_FLX0HRQ_MASK == (LulData & FR_59_RENESAS_FLX0CCSV_FLX0HRQ_MASK)) { Fr_POCStatusPtr->CHIHaltRequest = STD_ON; } else { Fr_POCStatusPtr->CHIHaltRequest = STD_OFF; } /* Confirmation of Coldstart Noise Indicator */ if (FR_59_RENESAS_FLX0CCSV_FLX0CSNI_MASK == (LulData & FR_59_RENESAS_FLX0CCSV_FLX0CSNI_MASK)) { Fr_POCStatusPtr->ColdstartNoise = STD_ON; } else { Fr_POCStatusPtr->ColdstartNoise = STD_OFF; } /* Confirmation of Slot Mode */ switch ((uint8)((LulData & FR_59_RENESAS_FLX0CCSV_FLX0SLM_MASK) >> FR_59_RENESAS_FLX0CCSV_FLX0SLM_SHIFT)) { case FR_59_RENESAS_SLM_SINGLE: Fr_POCStatusPtr->SlotMode = FR_SLOTMODE_KEYSLOT; break; case FR_59_RENESAS_SLM_ALL_PENDING: Fr_POCStatusPtr->SlotMode = FR_SLOTMODE_ALL_PENDING; break; case FR_59_RENESAS_SLM_ALL: Fr_POCStatusPtr->SlotMode = FR_SLOTMODE_ALL; break; default: if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; break; } /* Check if the return value is E_OK */ if (E_OK == LucReturnValue) { /* Confirmation of Error Mode */ LulData = LpCCStatusReg->ulFLXAnFRCCEV; /* Check for the error mode */ switch ((uint8)((LulData & FR_59_RENESAS_FLX0CCEV_FLX0ERRM_MASK) >> FR_59_RENESAS_FLX0CCEV_FLX0ERRM_SHIFT)) { case FR_59_RENESAS_ERRM_ACTIVE: Fr_POCStatusPtr->ErrorMode = FR_ERRORMODE_ACTIVE; break; case FR_59_RENESAS_ERRM_PASSIVE: Fr_POCStatusPtr->ErrorMode = FR_ERRORMODE_PASSIVE; break; case FR_59_RENESAS_ERRM_COMM_HALT: Fr_POCStatusPtr->ErrorMode = FR_ERRORMODE_COMM_HALT; break; default: if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usHardwareTestFailure) { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usHardwareTestFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; break; } } /* else No Action required */ } /* End of if (E_OK == LucReturnValue) */ /* else No Action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_POCStatusPtr', 'Value': '&map_Fr_POCStatusPtr[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCStatusReg', 'Value': '&map_CCStatusReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_CCStatusReg[0].ulFLXAnFRCCSV', 'Value': '0x0005'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_CCStatusReg[0].ulFLXAnFRCCEV', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pDemEventId', 'Value': '[0] = &map_Fr_59_Renesas_DemEventId[0]\\n[1] = &map_Fr_59_Renesas_DemEventId[1]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_CTRL_TESTRESULT_00', 'Name': 'map_Fr_59_Renesas_DemEventId[CURRENT_TEST.Fr_CtrlIdx].usHardwareTestFailure', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '1'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].CHIReadyRequest', 'Value': 'STD_OFF'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].WakeupStatus', 'Value': 'FR_WAKEUP_UNDEFINED'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].State', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].StartupState', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].Freeze', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].CHIHaltRequest', 'Value': '-'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].ColdstartNoise', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].SlotMode', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_Fr_POCStatusPtr[0].ErrorMode', 'Value': '-'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateWRHReg(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1532 # JV-01 */ VAR(uint32, AUTOMATIC) RegValue, CONST(uint16, AUTOMATIC) Fr_HeaderCRC, CONST(uint8, AUTOMATIC) Fr_PayloadLength, CONST(uint16, AUTOMATIC) Fr_LPduIdx) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_InputBufferRegType, AUTOMATIC, REGSPACE) LpInputBuffReg; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to CC configuration */ P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlTable; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpBufferHeader; /* PRQA S 3432 # JV-01 */ P2CONST(Fr_59_Renesas_FrameHeaderType, AUTOMATIC, FR_CONFIG_DATA) LpFrameConfig; /* PRQA S 3432 # JV-01 */ /* Declare local pointer to Dem Event Id */ P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, FR_CONFIG_DATA) LpDemEventId; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; volatile uint16 LusLoopCount; /* Initialize the return value */ LucReturnValue = E_OK; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpInputBuffReg = LpCtrlRegSet->pInputBuffReg; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Read the frame pointer */ LpCtrlTable = (P2CONST(Fr_59_Renesas_CtrlTableType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pCtrlTable); LpFrameConfig = Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pFrameConfig; LpBufferHeader = &LpFrameConfig[Fr_LPduIdx]; /* PRQA S 2824 # JV-02 */ /* Write the value of the header in FlexRay Write Header Section Register 1 and mirror address */ Fr_59_Renesas_WriteHeaderSection(Fr_CtrlIdx, FR_59_RENESAS_FLX0WRHS1, RegValue); #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_OFF) /* Since the Header CRC masking is considered when */ /* 'FR_59_RENESAS_DEV_ERROR_DETECT'is ON */ /* Get the value of the CRC calculated for the header data */ RegValue = (Fr_HeaderCRC & FR_59_RENESAS_CRC_MASK); /* PRQA S 1338 # JV-01 */ #else RegValue = Fr_HeaderCRC; /* PRQA S 1338 # JV-01 */ #endif #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Since the 'Fr_PayloadLength' masking is considered when */ /* FR_59_RENESAS_DEV_ERROR_DETECT is ON*/ /* Get the value of the Payload length configured */ RegValue = RegValue | ((uint32)Fr_PayloadLength << FR_59_RENESAS_PLC_SHIFT); /* PRQA S 1338 # JV-01 */ #else /* Get the value of the Payload length configured */ RegValue = RegValue | ((uint32)((Fr_PayloadLength)&FR_59_RENESAS_PLC_MASK) << FR_59_RENESAS_PLC_SHIFT); /* PRQA S 1338 # JV-01 */ #endif /* Write the value of the header in the register FRWRHS2 */ Fr_59_Renesas_WriteHeaderSection(Fr_CtrlIdx, FR_59_RENESAS_FLX0WRHS2, RegValue); /* Get the value of the Data pointer(Frame ID) */ RegValue = ((LpBufferHeader->usDataPointer) & FR_59_RENESAS_DP_MASK); /* PRQA S 1338, 2814 # JV-01, JV-02 */ /* Write the value of the header in the register FRWRHS3 */ Fr_59_Renesas_WriteHeaderSection(Fr_CtrlIdx, FR_59_RENESAS_FLX0WRHS3, RegValue); /* Initialize the loop count to FR_59_RENESAS_ZERO */ LusLoopCount = FR_59_RENESAS_ZERO; while ((FR_59_RENESAS_FLX0IBCR_FLX0IBSYH_MASK == (LpInputBuffReg->ulFLXAnFRIBCR /* PRQA S 3415, 3416, 2814, 2844 # JV-01, JV-01, JV-02, JV-01 */ & FR_59_RENESAS_FLX0IBCR_FLX0IBSYH_MASK)) && (LusLoopCount < (uint16)(LpCtrlTable->usFlagClearMaxWait))) /* PRQA S 2814 # JV-02 */ { /* Increment the loop count */ LusLoopCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ } if (LusLoopCount == (uint16)(LpCtrlTable->usFlagClearMaxWait)) /* PRQA S 3416 # JV-01 */ { LpDemEventId = (P2CONST(Fr_59_Renesas_DemEventIdType, AUTOMATIC, /* PRQA S 3432 # JV-01 */ FR_CONFIG_DATA))(Fr_59_Renesas_GpControllerConfigPtr[Fr_CtrlIdx].pDemEventId); if (FR_59_RENESAS_DEM_NOT_CONFIGURED != LpDemEventId->usReadTimeoutFailure) /* PRQA S 2814 # JV-02 */ { FR_59_RENESAS_DEM_REPORT_ERROR(LpDemEventId->usReadTimeoutFailure, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ } /* else No Action required */ LucReturnValue = E_NOT_OK; } else { /* Write the value of the header in the register FRIBCM */ /* Writing in to FlexRay Input Buffer Command Mask Register and mirror address */ LpInputBuffReg->ulFLXAnFRIBCM = FR_59_RENESAS_FLX0IBCM_FLX0LHSH_MASK; /* Get the value of the message buffer configured and load the value in the FRIBCR register */ RegValue = ((LpBufferHeader->ucMsgBuffer) & FR_59_RENESAS_FLX0IBCR_FLX0IBRH_MASK); /* PRQA S 1338 # JV-01 */ /* Write the value of the header in the register FRIBCR */ /* Writing in to FlexRay Input Buffer Command Request Register and mirror address */ LpInputBuffReg->ulFLXAnFRIBCR = RegValue; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'FR_59_RENESAS_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '1.. uint32', 'Name': 'RegValue', 'Value': '0x3'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..2047', 'Name': 'Fr_HeaderCRC', 'Value': '0x100'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..127', 'Name': 'Fr_PayloadLength', 'Value': '8'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..4095', 'Name': 'Fr_LPduIdx', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GpControllerConfigPtr', 'Value': '&map_Fr_59_Renesas_GpControllerConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pFrameConfig', 'Value': '&map_Fr_59_Renesas_FrameHeader[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0..8192\\n(Data section in the Message RAM)', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].usDataPointer', 'Value': '0x0200'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pInputBuffReg', 'Value': '&map_InputBuffReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_InputBuffReg[0].ulFLXAnFRIBCR', 'Value': '0x0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[CURRENT_TEST.Fr_CtrlIdx].pDemEventId', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_00, FR_59_RENESAS_E_READ_TIMEOUT_FAILURE_01.', 'Name': 'map_Fr_59_Renesas_DemEventId[0].usReadTimeoutFailure', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '!NULL_PTR', 'Name': 'map_Fr_59_Renesas_GpControllerConfigPtr[0 to 1].pCtrlTable', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlTableConfigPtr[1]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '1 .. 65535', 'Name': 'map_Fr_59_Renesas_GpCtrlTableConfigPtr[CURRENT_TEST.Fr_CtrlIdx].usFlagClearMaxWait', 'Value': '65535'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'map_Fr_59_Renesas_FrameHeader[CURRENT_TEST.Fr_LPduIdx].ucMsgBuffer', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '[1] = 0\\n[2] = 0\\n[3] = 0'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegMacro', 'Value': '[1] = FR_59_RENESAS_FLX0WRHS1\\n[2] = FR_59_RENESAS_FLX0WRHS2\\n[3] = FR_59_RENESAS_FLX0WRHS3'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'RegValue', 'Value': '[1] = 3\\n[2] = 0x80100\\n[3] = 0x200'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_InputBuffReg[0].ulFLXAnFRIBCM', 'Value': 'FR_59_RENESAS_FLX0IBCM_FLX0LHSH_MASK'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_InputBuffReg[0].ulFLXAnFRIBCR', 'Value': '0'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateWriteDataSection(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro, CONST(uint32, AUTOMATIC) Data) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_InputBufferRegType, AUTOMATIC, REGSPACE) LpInputBuffReg; /* PRQA S 3432 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpInputBuffReg = LpCtrlRegSet->pInputBuffReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ switch (RegMacro) { case FR_59_RENESAS_FLX0WRDS1: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS1 = Data; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; case FR_59_RENESAS_FLX0WRDS2: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS2 = Data; break; case FR_59_RENESAS_FLX0WRDS3: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS3 = Data; break; case FR_59_RENESAS_FLX0WRDS4: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS4 = Data; break; case FR_59_RENESAS_FLX0WRDS5: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS5 = Data; break; case FR_59_RENESAS_FLX0WRDS6: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS6 = Data; break; case FR_59_RENESAS_FLX0WRDS7: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS7 = Data; break; case FR_59_RENESAS_FLX0WRDS8: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS8 = Data; break; case FR_59_RENESAS_FLX0WRDS9: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS9 = Data; break; case FR_59_RENESAS_FLX0WRDS10: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS10 = Data; break; case FR_59_RENESAS_FLX0WRDS11: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS11 = Data; break; case FR_59_RENESAS_FLX0WRDS12: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS12 = Data; break; case FR_59_RENESAS_FLX0WRDS13: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS13 = Data; break; case FR_59_RENESAS_FLX0WRDS14: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS14 = Data; break; case FR_59_RENESAS_FLX0WRDS15: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS15 = Data; break; case FR_59_RENESAS_FLX0WRDS16: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS16 = Data; break; case FR_59_RENESAS_FLX0WRDS17: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS17 = Data; break; case FR_59_RENESAS_FLX0WRDS18: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS18 = Data; break; case FR_59_RENESAS_FLX0WRDS19: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS19 = Data; break; case FR_59_RENESAS_FLX0WRDS20: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS20 = Data; break; case FR_59_RENESAS_FLX0WRDS21: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS21 = Data; break; case FR_59_RENESAS_FLX0WRDS22: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS22 = Data; break; case FR_59_RENESAS_FLX0WRDS23: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS23 = Data; break; case FR_59_RENESAS_FLX0WRDS24: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS24 = Data; break; case FR_59_RENESAS_FLX0WRDS25: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS25 = Data; break; case FR_59_RENESAS_FLX0WRDS26: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS26 = Data; break; case FR_59_RENESAS_FLX0WRDS27: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS27 = Data; break; case FR_59_RENESAS_FLX0WRDS28: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS28 = Data; break; case FR_59_RENESAS_FLX0WRDS29: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS29 = Data; break; case FR_59_RENESAS_FLX0WRDS30: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS30 = Data; break; case FR_59_RENESAS_FLX0WRDS31: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS31 = Data; break; case FR_59_RENESAS_FLX0WRDS32: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS32 = Data; break; case FR_59_RENESAS_FLX0WRDS33: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS33 = Data; break; case FR_59_RENESAS_FLX0WRDS34: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS34 = Data; break; case FR_59_RENESAS_FLX0WRDS35: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS35 = Data; break; case FR_59_RENESAS_FLX0WRDS36: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS36 = Data; break; case FR_59_RENESAS_FLX0WRDS37: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS37 = Data; break; case FR_59_RENESAS_FLX0WRDS38: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS38 = Data; break; case FR_59_RENESAS_FLX0WRDS39: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS39 = Data; break; case FR_59_RENESAS_FLX0WRDS40: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS40 = Data; break; case FR_59_RENESAS_FLX0WRDS41: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS41 = Data; break; case FR_59_RENESAS_FLX0WRDS42: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS42 = Data; break; case FR_59_RENESAS_FLX0WRDS43: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS43 = Data; break; case FR_59_RENESAS_FLX0WRDS44: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS44 = Data; break; case FR_59_RENESAS_FLX0WRDS45: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS45 = Data; break; case FR_59_RENESAS_FLX0WRDS46: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS46 = Data; break; case FR_59_RENESAS_FLX0WRDS47: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS47 = Data; break; case FR_59_RENESAS_FLX0WRDS48: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS48 = Data; break; case FR_59_RENESAS_FLX0WRDS49: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS49 = Data; break; case FR_59_RENESAS_FLX0WRDS50: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS50 = Data; break; case FR_59_RENESAS_FLX0WRDS51: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS51 = Data; break; case FR_59_RENESAS_FLX0WRDS52: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS52 = Data; break; case FR_59_RENESAS_FLX0WRDS53: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS53 = Data; break; case FR_59_RENESAS_FLX0WRDS54: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS54 = Data; break; case FR_59_RENESAS_FLX0WRDS55: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS55 = Data; break; case FR_59_RENESAS_FLX0WRDS56: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS56 = Data; break; case FR_59_RENESAS_FLX0WRDS57: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS57 = Data; break; case FR_59_RENESAS_FLX0WRDS58: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS58 = Data; break; case FR_59_RENESAS_FLX0WRDS59: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS59 = Data; break; case FR_59_RENESAS_FLX0WRDS60: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS60 = Data; break; case FR_59_RENESAS_FLX0WRDS61: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS61 = Data; break; case FR_59_RENESAS_FLX0WRDS62: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS62 = Data; break; case FR_59_RENESAS_FLX0WRDS63: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS63 = Data; break; case FR_59_RENESAS_FLX0WRDS64: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS64 = Data; break; default: /* No action required */ break; } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0WRDS8'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Data', 'Value': '15'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pInputBuffReg', 'Value': '&map_InputBuffReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS1', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS2', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS3', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS4', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS5', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS6', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS7', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS8', 'Value': '15'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS9', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS10', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS11', 'Value': '-'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS12', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS13', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS14', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS15', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS16', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS17', 'Value': '-'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS18', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS19', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS20', 'Value': '-'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS21', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS22', 'Value': '-'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS23', 'Value': '-'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS24', 'Value': '-'], 'Output_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS25', 'Value': '-'], 'Output_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS26', 'Value': '-'], 'Output_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS27', 'Value': '-'], 'Output_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS28', 'Value': '-'], 'Output_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS29', 'Value': '-'], 'Output_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS30', 'Value': '-'], 'Output_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS31', 'Value': '-'], 'Output_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS32', 'Value': '-'], 'Output_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS33', 'Value': '-'], 'Output_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS34', 'Value': '-'], 'Output_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS35', 'Value': '-'], 'Output_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS36', 'Value': '-'], 'Output_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS37', 'Value': '-'], 'Output_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS38', 'Value': '-'], 'Output_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS39', 'Value': '-'], 'Output_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS40', 'Value': '-'], 'Output_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS41', 'Value': '-'], 'Output_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS42', 'Value': '-'], 'Output_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS43', 'Value': '-'], 'Output_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS44', 'Value': '-'], 'Output_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS45', 'Value': '-'], 'Output_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS46', 'Value': '-'], 'Output_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS47', 'Value': '-'], 'Output_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS48', 'Value': '-'], 'Output_Param_048': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS49', 'Value': '-'], 'Output_Param_049': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS50', 'Value': '-'], 'Output_Param_050': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS51', 'Value': '-'], 'Output_Param_051': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS52', 'Value': '-'], 'Output_Param_052': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS53', 'Value': '-'], 'Output_Param_053': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS54', 'Value': '-'], 'Output_Param_054': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS55', 'Value': '-'], 'Output_Param_055': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS56', 'Value': '-'], 'Output_Param_056': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS57', 'Value': '-'], 'Output_Param_057': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS58', 'Value': '-'], 'Output_Param_058': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS59', 'Value': '-'], 'Output_Param_059': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS60', 'Value': '-'], 'Output_Param_060': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS61', 'Value': '-'], 'Output_Param_061': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS62', 'Value': '-'], 'Output_Param_062': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS63', 'Value': '-'], 'Output_Param_063': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS64', 'Value': '-'], 'Output_Param_064': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateWriteDataSection(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro, CONST(uint32, AUTOMATIC) Data) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_InputBufferRegType, AUTOMATIC, REGSPACE) LpInputBuffReg; /* PRQA S 3432 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpInputBuffReg = LpCtrlRegSet->pInputBuffReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ switch (RegMacro) { case FR_59_RENESAS_FLX0WRDS1: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS1 = Data; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; case FR_59_RENESAS_FLX0WRDS2: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS2 = Data; break; case FR_59_RENESAS_FLX0WRDS3: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS3 = Data; break; case FR_59_RENESAS_FLX0WRDS4: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS4 = Data; break; case FR_59_RENESAS_FLX0WRDS5: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS5 = Data; break; case FR_59_RENESAS_FLX0WRDS6: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS6 = Data; break; case FR_59_RENESAS_FLX0WRDS7: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS7 = Data; break; case FR_59_RENESAS_FLX0WRDS8: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS8 = Data; break; case FR_59_RENESAS_FLX0WRDS9: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS9 = Data; break; case FR_59_RENESAS_FLX0WRDS10: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS10 = Data; break; case FR_59_RENESAS_FLX0WRDS11: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS11 = Data; break; case FR_59_RENESAS_FLX0WRDS12: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS12 = Data; break; case FR_59_RENESAS_FLX0WRDS13: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS13 = Data; break; case FR_59_RENESAS_FLX0WRDS14: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS14 = Data; break; case FR_59_RENESAS_FLX0WRDS15: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS15 = Data; break; case FR_59_RENESAS_FLX0WRDS16: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS16 = Data; break; case FR_59_RENESAS_FLX0WRDS17: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS17 = Data; break; case FR_59_RENESAS_FLX0WRDS18: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS18 = Data; break; case FR_59_RENESAS_FLX0WRDS19: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS19 = Data; break; case FR_59_RENESAS_FLX0WRDS20: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS20 = Data; break; case FR_59_RENESAS_FLX0WRDS21: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS21 = Data; break; case FR_59_RENESAS_FLX0WRDS22: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS22 = Data; break; case FR_59_RENESAS_FLX0WRDS23: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS23 = Data; break; case FR_59_RENESAS_FLX0WRDS24: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS24 = Data; break; case FR_59_RENESAS_FLX0WRDS25: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS25 = Data; break; case FR_59_RENESAS_FLX0WRDS26: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS26 = Data; break; case FR_59_RENESAS_FLX0WRDS27: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS27 = Data; break; case FR_59_RENESAS_FLX0WRDS28: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS28 = Data; break; case FR_59_RENESAS_FLX0WRDS29: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS29 = Data; break; case FR_59_RENESAS_FLX0WRDS30: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS30 = Data; break; case FR_59_RENESAS_FLX0WRDS31: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS31 = Data; break; case FR_59_RENESAS_FLX0WRDS32: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS32 = Data; break; case FR_59_RENESAS_FLX0WRDS33: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS33 = Data; break; case FR_59_RENESAS_FLX0WRDS34: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS34 = Data; break; case FR_59_RENESAS_FLX0WRDS35: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS35 = Data; break; case FR_59_RENESAS_FLX0WRDS36: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS36 = Data; break; case FR_59_RENESAS_FLX0WRDS37: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS37 = Data; break; case FR_59_RENESAS_FLX0WRDS38: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS38 = Data; break; case FR_59_RENESAS_FLX0WRDS39: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS39 = Data; break; case FR_59_RENESAS_FLX0WRDS40: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS40 = Data; break; case FR_59_RENESAS_FLX0WRDS41: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS41 = Data; break; case FR_59_RENESAS_FLX0WRDS42: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS42 = Data; break; case FR_59_RENESAS_FLX0WRDS43: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS43 = Data; break; case FR_59_RENESAS_FLX0WRDS44: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS44 = Data; break; case FR_59_RENESAS_FLX0WRDS45: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS45 = Data; break; case FR_59_RENESAS_FLX0WRDS46: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS46 = Data; break; case FR_59_RENESAS_FLX0WRDS47: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS47 = Data; break; case FR_59_RENESAS_FLX0WRDS48: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS48 = Data; break; case FR_59_RENESAS_FLX0WRDS49: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS49 = Data; break; case FR_59_RENESAS_FLX0WRDS50: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS50 = Data; break; case FR_59_RENESAS_FLX0WRDS51: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS51 = Data; break; case FR_59_RENESAS_FLX0WRDS52: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS52 = Data; break; case FR_59_RENESAS_FLX0WRDS53: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS53 = Data; break; case FR_59_RENESAS_FLX0WRDS54: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS54 = Data; break; case FR_59_RENESAS_FLX0WRDS55: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS55 = Data; break; case FR_59_RENESAS_FLX0WRDS56: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS56 = Data; break; case FR_59_RENESAS_FLX0WRDS57: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS57 = Data; break; case FR_59_RENESAS_FLX0WRDS58: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS58 = Data; break; case FR_59_RENESAS_FLX0WRDS59: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS59 = Data; break; case FR_59_RENESAS_FLX0WRDS60: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS60 = Data; break; case FR_59_RENESAS_FLX0WRDS61: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS61 = Data; break; case FR_59_RENESAS_FLX0WRDS62: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS62 = Data; break; case FR_59_RENESAS_FLX0WRDS63: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS63 = Data; break; case FR_59_RENESAS_FLX0WRDS64: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS64 = Data; break; default: /* No action required */ break; } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0WRDS13'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Data', 'Value': '26'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pInputBuffReg', 'Value': '&map_InputBuffReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS1', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS2', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS3', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS4', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS5', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS6', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS7', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS8', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS9', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS10', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS11', 'Value': '-'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS12', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS13', 'Value': '26'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS14', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS15', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS16', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS17', 'Value': '-'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS18', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS19', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS20', 'Value': '-'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS21', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS22', 'Value': '-'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS23', 'Value': '-'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS24', 'Value': '-'], 'Output_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS25', 'Value': '-'], 'Output_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS26', 'Value': '-'], 'Output_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS27', 'Value': '-'], 'Output_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS28', 'Value': '-'], 'Output_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS29', 'Value': '-'], 'Output_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS30', 'Value': '-'], 'Output_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS31', 'Value': '-'], 'Output_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS32', 'Value': '-'], 'Output_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS33', 'Value': '-'], 'Output_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS34', 'Value': '-'], 'Output_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS35', 'Value': '-'], 'Output_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS36', 'Value': '-'], 'Output_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS37', 'Value': '-'], 'Output_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS38', 'Value': '-'], 'Output_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS39', 'Value': '-'], 'Output_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS40', 'Value': '-'], 'Output_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS41', 'Value': '-'], 'Output_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS42', 'Value': '-'], 'Output_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS43', 'Value': '-'], 'Output_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS44', 'Value': '-'], 'Output_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS45', 'Value': '-'], 'Output_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS46', 'Value': '-'], 'Output_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS47', 'Value': '-'], 'Output_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS48', 'Value': '-'], 'Output_Param_048': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS49', 'Value': '-'], 'Output_Param_049': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS50', 'Value': '-'], 'Output_Param_050': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS51', 'Value': '-'], 'Output_Param_051': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS52', 'Value': '-'], 'Output_Param_052': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS53', 'Value': '-'], 'Output_Param_053': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS54', 'Value': '-'], 'Output_Param_054': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS55', 'Value': '-'], 'Output_Param_055': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS56', 'Value': '-'], 'Output_Param_056': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS57', 'Value': '-'], 'Output_Param_057': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS58', 'Value': '-'], 'Output_Param_058': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS59', 'Value': '-'], 'Output_Param_059': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS60', 'Value': '-'], 'Output_Param_060': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS61', 'Value': '-'], 'Output_Param_061': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS62', 'Value': '-'], 'Output_Param_062': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS63', 'Value': '-'], 'Output_Param_063': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS64', 'Value': '-'], 'Output_Param_064': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, FR_PRIVATE_CODE) Fr_59_Renesas_UpdateWriteDataSection(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1505 # JV-01 */ CONST(uint32, AUTOMATIC) RegMacro, CONST(uint32, AUTOMATIC) Data) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_InputBufferRegType, AUTOMATIC, REGSPACE) LpInputBuffReg; /* PRQA S 3432 # JV-01 */ /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpInputBuffReg = LpCtrlRegSet->pInputBuffReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ switch (RegMacro) { case FR_59_RENESAS_FLX0WRDS1: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS1 = Data; /* PRQA S 2814, 2844 # JV-02, JV-01 */ break; case FR_59_RENESAS_FLX0WRDS2: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS2 = Data; break; case FR_59_RENESAS_FLX0WRDS3: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS3 = Data; break; case FR_59_RENESAS_FLX0WRDS4: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS4 = Data; break; case FR_59_RENESAS_FLX0WRDS5: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS5 = Data; break; case FR_59_RENESAS_FLX0WRDS6: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS6 = Data; break; case FR_59_RENESAS_FLX0WRDS7: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS7 = Data; break; case FR_59_RENESAS_FLX0WRDS8: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS8 = Data; break; case FR_59_RENESAS_FLX0WRDS9: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS9 = Data; break; case FR_59_RENESAS_FLX0WRDS10: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS10 = Data; break; case FR_59_RENESAS_FLX0WRDS11: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS11 = Data; break; case FR_59_RENESAS_FLX0WRDS12: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS12 = Data; break; case FR_59_RENESAS_FLX0WRDS13: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS13 = Data; break; case FR_59_RENESAS_FLX0WRDS14: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS14 = Data; break; case FR_59_RENESAS_FLX0WRDS15: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS15 = Data; break; case FR_59_RENESAS_FLX0WRDS16: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS16 = Data; break; case FR_59_RENESAS_FLX0WRDS17: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS17 = Data; break; case FR_59_RENESAS_FLX0WRDS18: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS18 = Data; break; case FR_59_RENESAS_FLX0WRDS19: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS19 = Data; break; case FR_59_RENESAS_FLX0WRDS20: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS20 = Data; break; case FR_59_RENESAS_FLX0WRDS21: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS21 = Data; break; case FR_59_RENESAS_FLX0WRDS22: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS22 = Data; break; case FR_59_RENESAS_FLX0WRDS23: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS23 = Data; break; case FR_59_RENESAS_FLX0WRDS24: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS24 = Data; break; case FR_59_RENESAS_FLX0WRDS25: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS25 = Data; break; case FR_59_RENESAS_FLX0WRDS26: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS26 = Data; break; case FR_59_RENESAS_FLX0WRDS27: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS27 = Data; break; case FR_59_RENESAS_FLX0WRDS28: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS28 = Data; break; case FR_59_RENESAS_FLX0WRDS29: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS29 = Data; break; case FR_59_RENESAS_FLX0WRDS30: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS30 = Data; break; case FR_59_RENESAS_FLX0WRDS31: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS31 = Data; break; case FR_59_RENESAS_FLX0WRDS32: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS32 = Data; break; case FR_59_RENESAS_FLX0WRDS33: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS33 = Data; break; case FR_59_RENESAS_FLX0WRDS34: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS34 = Data; break; case FR_59_RENESAS_FLX0WRDS35: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS35 = Data; break; case FR_59_RENESAS_FLX0WRDS36: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS36 = Data; break; case FR_59_RENESAS_FLX0WRDS37: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS37 = Data; break; case FR_59_RENESAS_FLX0WRDS38: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS38 = Data; break; case FR_59_RENESAS_FLX0WRDS39: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS39 = Data; break; case FR_59_RENESAS_FLX0WRDS40: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS40 = Data; break; case FR_59_RENESAS_FLX0WRDS41: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS41 = Data; break; case FR_59_RENESAS_FLX0WRDS42: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS42 = Data; break; case FR_59_RENESAS_FLX0WRDS43: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS43 = Data; break; case FR_59_RENESAS_FLX0WRDS44: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS44 = Data; break; case FR_59_RENESAS_FLX0WRDS45: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS45 = Data; break; case FR_59_RENESAS_FLX0WRDS46: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS46 = Data; break; case FR_59_RENESAS_FLX0WRDS47: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS47 = Data; break; case FR_59_RENESAS_FLX0WRDS48: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS48 = Data; break; case FR_59_RENESAS_FLX0WRDS49: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS49 = Data; break; case FR_59_RENESAS_FLX0WRDS50: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS50 = Data; break; case FR_59_RENESAS_FLX0WRDS51: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS51 = Data; break; case FR_59_RENESAS_FLX0WRDS52: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS52 = Data; break; case FR_59_RENESAS_FLX0WRDS53: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS53 = Data; break; case FR_59_RENESAS_FLX0WRDS54: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS54 = Data; break; case FR_59_RENESAS_FLX0WRDS55: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS55 = Data; break; case FR_59_RENESAS_FLX0WRDS56: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS56 = Data; break; case FR_59_RENESAS_FLX0WRDS57: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS57 = Data; break; case FR_59_RENESAS_FLX0WRDS58: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS58 = Data; break; case FR_59_RENESAS_FLX0WRDS59: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS59 = Data; break; case FR_59_RENESAS_FLX0WRDS60: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS60 = Data; break; case FR_59_RENESAS_FLX0WRDS61: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS61 = Data; break; case FR_59_RENESAS_FLX0WRDS62: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS62 = Data; break; case FR_59_RENESAS_FLX0WRDS63: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS63 = Data; break; case FR_59_RENESAS_FLX0WRDS64: /* Load 32-value into the input buffer register */ LpInputBuffReg->ulFLXAnFRWRDS64 = Data; break; default: /* No action required */ break; } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': '0'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_FLX0WRHSi (i = 1, 2, 3)', 'Name': 'RegMacro', 'Value': 'FR_59_RENESAS_FLX0WRDS54'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Data', 'Value': '43'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pInputBuffReg', 'Value': '&map_InputBuffReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS1', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS2', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS3', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS4', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS5', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS6', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS7', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS8', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS9', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS10', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS11', 'Value': '-'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS12', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS13', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS14', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS15', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS16', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS17', 'Value': '-'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS18', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS19', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS20', 'Value': '-'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS21', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS22', 'Value': '-'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS23', 'Value': '-'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS24', 'Value': '-'], 'Output_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS25', 'Value': '-'], 'Output_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS26', 'Value': '-'], 'Output_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS27', 'Value': '-'], 'Output_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS28', 'Value': '-'], 'Output_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS29', 'Value': '-'], 'Output_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS30', 'Value': '-'], 'Output_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS31', 'Value': '-'], 'Output_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS32', 'Value': '-'], 'Output_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS33', 'Value': '-'], 'Output_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS34', 'Value': '-'], 'Output_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS35', 'Value': '-'], 'Output_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS36', 'Value': '-'], 'Output_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS37', 'Value': '-'], 'Output_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS38', 'Value': '-'], 'Output_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS39', 'Value': '-'], 'Output_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS40', 'Value': '-'], 'Output_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS41', 'Value': '-'], 'Output_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS42', 'Value': '-'], 'Output_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS43', 'Value': '-'], 'Output_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS44', 'Value': '-'], 'Output_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS45', 'Value': '-'], 'Output_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS46', 'Value': '-'], 'Output_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS47', 'Value': '-'], 'Output_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS48', 'Value': '-'], 'Output_Param_048': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS49', 'Value': '-'], 'Output_Param_049': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS50', 'Value': '-'], 'Output_Param_050': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS51', 'Value': '-'], 'Output_Param_051': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS52', 'Value': '-'], 'Output_Param_052': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS53', 'Value': '-'], 'Output_Param_053': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS54', 'Value': '43'], 'Output_Param_054': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS55', 'Value': '-'], 'Output_Param_055': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS56', 'Value': '-'], 'Output_Param_056': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS57', 'Value': '-'], 'Output_Param_057': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS58', 'Value': '-'], 'Output_Param_058': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS59', 'Value': '-'], 'Output_Param_059': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS60', 'Value': '-'], 'Output_Param_060': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS61', 'Value': '-'], 'Output_Param_061': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS62', 'Value': '-'], 'Output_Param_062': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS63', 'Value': '-'], 'Output_Param_063': ['Type': 'Variable', 'Range': '', 'Name': 'ulFLXAnFRWRDS64', 'Value': '-'], 'Output_Param_064': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((FR_59_RENESAS_ENABLE_INPUT_TX_HANDLER == STD_ON) && (FR_59_RENESAS_ENABLE_USER_REQUEST_INPUT_TRANSFER == STD_ON)) #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_UserInputTransferRequest( VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ P2VAR(volatile Fr_59_Renesas_InputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_InputTableContentPtr) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module and transfer handler are initialized */ if ((FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) || /* PRQA S 3415, 3416 # JV-01, JV-01 */ (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblTransferHandlerInitDone)) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_USERINPUTTRANSFERREQUEST_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check the validity of the parameter Fr_CtrlIdx */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_USERINPUTTRANSFERREQUEST_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if Fr_InputTableContentPtr is a NULL pointer or Fr_59_Renesas_pInputDataPtr element is NULL_PTR */ if ((NULL_PTR == Fr_InputTableContentPtr) || (NULL_PTR == Fr_InputTableContentPtr->Fr_59_Renesas_pInputDataPtr)) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_USERINPUTTRANSFERREQUEST_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { /* Update the Input pointer table index requested for input transfer */ LucReturnValue = Fr_59_Renesas_InputTransferRequest(Fr_CtrlIdx, Fr_InputTableContentPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED -1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL, !NULL', 'Name': 'Fr_59_Renesas_pInputDataPtr', 'Value': '&map_pInputDataPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblTransferHandlerInitDone', 'Value': 'FR_59_RENESAS_TRUE'], 'Input_Param_005': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED -1'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_InputTableContentPtr', 'Value': '&map_Fr_InputTableContentPtr[0]'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((FR_59_RENESAS_ENABLE_OUTPUT_RX_HANDLER == STD_ON) && \\ (FR_59_RENESAS_ENABLE_USER_REQUEST_OUTPUT_TRANSFER == STD_ON)) #define FR_59_RENESAS_START_SEC_PUBLIC_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PUBLIC_CODE) Fr_59_Renesas_UserOutputTransferRequest(VAR(uint8, AUTOMATIC) Fr_CtrlIdx, /* PRQA S 1503 # JV-01 */ P2VAR(volatile Fr_59_Renesas_OutputPointerTableType, AUTOMATIC, FR_APPL_DATA) Fr_OutputTableContentPtr) /* PRQA S 3432 # JV-01 */ { Std_ReturnType LucReturnValue; #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ boolean LblDevErrDetect; /* Initialize development detection flag */ LblDevErrDetect = FR_59_RENESAS_FALSE; #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) /* Check if the module and transfer handler initialized */ if ((FR_59_RENESAS_FALSE == Fr_59_Renesas_GblInitDone) || /* PRQA S 3415, 3416 # JV-01, JV-01 */ (FR_59_RENESAS_FALSE == Fr_59_Renesas_GblTransferHandlerInitDone)) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_USEROUTPUTTRANSFERREQUEST_SID, FR_59_RENESAS_E_INIT_FAILED); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check the validity of the parameter Fr_CtrlIdx */ if (FR_59_RENESAS_NUM_CTRL_SUPPORTED <= Fr_CtrlIdx) { /* Report Error to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_USEROUTPUTTRANSFERREQUEST_SID, FR_59_RENESAS_E_INV_CTRL_IDX); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if Fr_OutputTableContentPtr is a NULL pointer or the input pointer and value is invalid */ if ((NULL_PTR == Fr_OutputTableContentPtr) || ((NULL_PTR == Fr_OutputTableContentPtr ->Fr_59_Renesas_pOutputDataPtr) || (FR_59_RENESAS_MAX_MB_NUMBER < Fr_OutputTableContentPtr->ucMsgBuffer))) { /* Report to DET */ (void)Det_ReportError(FR_59_RENESAS_MODULE_ID, FR_59_RENESAS_INSTANCE_ID, FR_59_RENESAS_USEROUTPUTTRANSFERREQUEST_SID, FR_59_RENESAS_E_PARAM_POINTER); /* Default error is detected */ LblDevErrDetect = FR_59_RENESAS_TRUE; } /* else No Action required */ /* Check if any DET error has occurred */ if (FR_59_RENESAS_FALSE == LblDevErrDetect) #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ { LucReturnValue = Fr_59_Renesas_OutputTransferRequest(Fr_CtrlIdx, Fr_OutputTableContentPtr); } #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) else { /* Set Return Value as E_NOT_OK */ LucReturnValue = E_NOT_OK; } #endif /* #if (FR_59_RENESAS_DEV_ERROR_DETECT == STD_ON) */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED -1'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL, !NULL', 'Name': 'Fr_OutputTableContentPtr', 'Value': '&map_Fr_OutputTableContentPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL, !NULL', 'Name': 'Fr_59_Renesas_pOutputDataPtr', 'Value': '&map_pOutputDataPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucMsgBuffer', 'Value': '127'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblInitDone', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Fr_59_Renesas_GblTransferHandlerInitDone', 'Value': 'FR_59_RENESAS_FALSE'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'FR_59_RENESAS_E_INIT_FAILED'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'FR_59_RENESAS_MODULE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'FR_59_RENESAS_INSTANCE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'FR_59_RENESAS_USEROUTPUTTRANSFERREQUEST_SID'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_NOT_OK'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_OutputTableContentPtr', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define FR_59_RENESAS_START_SEC_PRIVATE_CODE #include \"Fr_59_Renesas_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, FR_PRIVATE_CODE) Fr_59_Renesas_WriteCHICmd(CONST(uint8, AUTOMATIC) Fr_CtrlIdx, CONST(uint32, AUTOMATIC) CHICmd) { /* Declare pointer to register */ P2CONST(volatile Fr_59_Renesas_RegisterSetType, AUTOMATIC, FR_CONFIG_DATA) LpCtrlRegSet; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Fr_59_Renesas_CCControlRegType, AUTOMATIC, REGSPACE) LpCCCtrlReg; /* PRQA S 3432 # JV-01 */ uint32 LulData; Std_ReturnType LucReturnValue; /* Copy global pointer to local pointer */ LpCtrlRegSet = Fr_59_Renesas_GpCtrlRegSet[Fr_CtrlIdx]; /* PRQA S 2844 # JV-01 */ LpCCCtrlReg = LpCtrlRegSet->pCCCtrlReg; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Initialize internal variable */ LulData = FR_59_RENESAS_ZERO; /* PRQA S 2982 # JV-01 */ LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Check whether POC is busy and FLXAnFRSUCC1.CMD locked or not */ LucReturnValue = Fr_59_Renesas_CheckIfCCBusy(Fr_CtrlIdx); /* Check if the return value is E_OK */ if (E_OK == LucReturnValue) { /* Check whether CHICmd is FR_59_RENESAS_CMD_NOT_ACCEPTED */ if (FR_59_RENESAS_CMD_NOT_ACCEPTED != CHICmd) { /* Read the value of the FLX0SUCC1 register */ LulData = LpCCCtrlReg->ulFLXAnFRSUCC1; /* PRQA S 2844, 2814 # JV-01, JV-02 */ LulData = (LulData & FR_59_RENESAS_FLX0SUCC1_FLX0CMD_MASK) | CHICmd; /* Writing in to FlexRay SUC Configuration Register and mirror address */ LpCCCtrlReg->ulFLXAnFRSUCC1 = LulData; } /* else No Action required */ /* * All accepted commands with exception of CLEAR_RAMS and SEND_MTS will cause a change of the POC state in the * FlexRay domain after at most 8 cycles of the slower of the two clocks \"bus clock\" and \"FlexRay sample clock\" */ } /* else No Action required */ return (LucReturnValue); /* End of function Fr_59_Renesas_WriteCHICmd */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0, 1', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 2'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'FR_59_RENESAS_READY\\nFR_59_RENESAS_RUN\\nFR_59_RENESAS_ALLOW_COLDSTART\\nFR_59_RENESAS_ALL_SLOTS\\nFR_59_RENESAS_HALT\\nFR_59_RENESAS_FREEZE\\nFR_59_RENESAS_WAKEUP\\nFR_59_RENESAS_CONFIG\\n', 'Name': 'CHICmd', 'Value': '0x0000'], 'Input_Param_002': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Fr_59_Renesas_GpCtrlRegSet[0 to 1]', 'Value': '[0] = &map_Fr_59_Renesas_GpCtrlRegSet[0]\\n[1] = &map_Fr_59_Renesas_GpCtrlRegSet[1]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0\u20260xFFFFFFFF', 'Name': 'map_Fr_59_Renesas_GpCtrlRegSet[CURRENT_TEST.Fr_CtrlIdx].pCCCtrlReg', 'Value': '&map_CCCtrlReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_CCCtrlReg[0].ulFLXAnFRSUCC1', 'Value': '0x00001000']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': '-', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'Fr_CtrlIdx', 'Value': 'FR_59_RENESAS_NUM_CTRL_SUPPORTED - 2'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_CCCtrlReg[0].ulFLXAnFRSUCC1', 'Value': '0x00001000'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_ATUD00_CH0_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATUD00_CH0_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(ATUD00_CH0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) ATUD00_CH0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Atu_CbkNotification((uint8)GPT_ATUD00_CH0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUDmn_CH0_ISR_API ', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '14 = ATUD14_CH0_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x1C'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_ATUD00_CH0_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATUD00_CH0_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(ATUD00_CH0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) ATUD00_CH0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Atu_CbkNotification((uint8)GPT_ATUD00_CH0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUDmn_CH0_ISR_API ', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '5 = ATUD05_CH0_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x10'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_ATUD00_CH0_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATUD00_CH0_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(ATUD00_CH0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) ATUD00_CH0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Atu_CbkNotification((uint8)GPT_ATUD00_CH0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUDmn_CH0_ISR_API ', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '8 = ATUD08_CH0_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x13'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_ATUD00_CH0_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATUD00_CH0_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(ATUD00_CH0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) ATUD00_CH0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Atu_CbkNotification((uint8)GPT_ATUD00_CH0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUDmn_CH0_ISR_API ', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '8 = ATUD08_CH0_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x17'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_ATUD00_CH0_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATUD00_CH0_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(ATUD00_CH0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) ATUD00_CH0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Atu_CbkNotification((uint8)GPT_ATUD00_CH0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUDmn_CH0_ISR_API ', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '6 = ATUD06_CH0_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x11'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_ATUG00_CH0_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATUG00_CH0_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(ATUG00_CH0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) ATUG00_CH0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Atu_CbkNotification((uint8)GPT_ATUG00_CH0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUGmn_CH0_ISR_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '3 = ATUG03_CH0_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x16'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_CheckWakeup(EcuM_WakeupSourceType WakeupSource) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Flags of wakeup function */ VAR(boolean, AUTOMATIC) LblWakeupFlag; /* Index of channel ID */ VAR(uint8, AUTOMATIC) LucChannelID; /* Initialize Channel ID */ LucChannelID = (uint8)GPT_ZERO; #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Check if the GPT Driver is initialized properly */ if (GPT_INITIALIZED != Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_CHECK_WAKEUP_SID, GPT_E_UNINIT); } else #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Update the local pointer to Channel config */ LpChannel = Gpt_GpChannelConfig; do { #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_RAM_DATA_PROTECTION); #endif /* End of GPT_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Save the Wakeup status into the local variable */ LblWakeupFlag = Gpt_GpChannelRamData[LucChannelID].blWakeupOccurrence; if ((GPT_TRUE == LblWakeupFlag) && (((EcuM_WakeupSourceType)GPT_ONE << (LpChannel[LucChannelID].ucWakeupSourceId)) == WakeupSource)) /* PRQA S 2824, 2844 # JV-01, JV-01 */ { /* Reset wakeup flag for Channel */ Gpt_GpChannelRamData[LucChannelID].blWakeupOccurrence = GPT_FALSE; #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_RAM_DATA_PROTECTION); #endif /* Invoke the EcuM Set Wakeup API */ EcuM_SetWakeupEvent(WakeupSource); /* Update the ChannelID with maximum number of Channel configured to break loop */ LucChannelID = GPT_TOTAL_CHANNELS_CONFIG; } else { #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_RAM_DATA_PROTECTION); #endif /* End of GPT_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Increment Channel ID count */ LucChannelID++; /* PRQA S 3383 # JV-01 */ } } while (GPT_TOTAL_CHANNELS_CONFIG != LucChannelID); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\\n0xFFFFFFFF', 'Name': 'WakeupSource', 'Value': '0x80000000'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'GPT_INITIALIZED\\nGPT_UNINITIALIZED', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '0\\n0xFF', 'Name': 'ucWakeupSourceId', 'Value': '[0] = 0x1F'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': 'GPT_TRUE\\nGPT_FALSE', 'Name': 'blWakeupOccurrence', 'Value': '[0] = GPT_TRUE']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupOccurrence', 'Value': '[0] = GPT_FALSE'], 'Output_Param_005': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_006': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'sources', 'Value': '0x80000000UL'], 'Output_Param_008': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_009': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'sources', 'Value': '-'], 'Output_Param_011': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_020': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_021': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_023': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_024': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_025': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_026': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_027': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_028': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_030': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_031': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_032': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_033': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_034': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_035': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_036': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_037': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_038': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_039': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_040': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_041': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_042': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_043': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_044': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_045': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_046': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_047': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_048': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_049': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_050': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_051': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_052': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_053': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_054': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_055': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_056': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_057': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_058': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_059': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_060': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_061': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_062': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_063': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_064': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_065': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_066': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_067': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_068': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_069': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_070': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_071': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_072': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_073': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_074': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_075': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_076': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_077': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_078': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_079': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_080': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_081': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_082': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_083': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_084': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_085': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_086': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_087': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_088': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_089': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_090': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_091': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_092': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_093': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_094': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_095': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_096': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_097': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_098': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_099': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_100': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_101': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_102': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_103': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_104': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_105': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_106': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_107': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_108': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_109': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_110': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_111': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_112': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_113': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_114': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_115': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_116': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_117': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_118': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_119': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_120': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_121': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_122': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_123': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_124': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_125': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_126': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_127': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_128': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_129': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_130': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_131': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_132': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_133': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_134': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_135': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_136': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_137': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_138': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_139': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_140': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_141': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_142': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_143': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_144': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_145': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_146': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_147': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_148': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_149': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_150': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_151': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_152': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_153': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_154': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_155': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_156': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_157': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_158': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_159': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_160': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_161': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_DE_INIT_API == STD_ON) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_DeInit(void) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Index of loop count */ VAR(volatile uint8, AUTOMATIC) LucCount; /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) /* Defining a local pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Initialize local variable to first Channel */ VAR(uint8, AUTOMATIC) LucChannelID; /* Declare the variable to store the DET return value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Initialize Channel ID */ LucChannelID = (uint8)GPT_ZERO; /* Load the global pointer to local pointer */ LpRamData = Gpt_GpChannelRamData; #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) */ #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Check if the GPT Driver is Initialized properly */ if (GPT_INITIALIZED != Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_DEINIT_SID, GPT_E_UNINIT); /* Set return value */ LddReturnValue = E_NOT_OK; } else { #endif /* (GPT_DEV_ERROR_DETECT == STD_ON) */ #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) do { /* Check if the Channel is in Running State */ if (GPT_CH_RUNNING == LpRamData[LucChannelID].ucChannelStatus) /* PRQA S 2824, 2844 # JV-01, JV-01 */ { /* Set return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ /* Increment the Channel ID count */ LucChannelID++; /* PRQA S 3383 # JV-01 */ } while (((uint8)GPT_TOTAL_CHANNELS_CONFIG != LucChannelID) && (E_OK == LddReturnValue)); /* Check if the Channel is in Running State */ if (E_NOT_OK == LddReturnValue) { /* Report to Development Errors */ GPT_DET_REPORT_ERROR(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_DEINIT_SID, GPT_E_BUSY); } /* else No action required */ #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION))*/ #if (GPT_DEV_ERROR_DETECT == STD_ON) } #endif /* (GPT_DEV_ERROR_DETECT == STD_ON) */ #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION))*/ { /* Set Driver state to uninitialized */ Gpt_SetStatus(GPT_UNINITIALIZED); #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer(); } /* else No action required */ } #endif for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_HW_IP_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { LucHWIPType = Gpt_GaaHWIP[LucCount].ucIndex; if (NULL_PTR != Gpt_GaaHwFunc[LucHWIPType]->pHWUnitDeInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for De-initializing the hardware */ Gpt_GaaHwFunc[LucHWIPType]->pHWUnitDeInit(); } /* else No action required */ } #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the Timer Type for given channel */ LucHWIPType = Gpt_GpChannelConfig[LucCount].ucTimerUnitType; if (NULL_PTR != Gpt_GaaHwFunc[LucHWIPType]->pHWChannelDeInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for De-initializing the hardware */ Gpt_GaaHwFunc[LucHWIPType]->pHWChannelDeInit((Gpt_ChannelType)LucCount); } /* else No action required */ } #endif } /* else No action required */ /* End of LddReturnValue == E_NOT_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'GPT_AR_1911_VERSION\\nGPT_AR_431_VERSION\\nGPT_AR_422_VERSION', 'Name': 'GPT_AR_VERSION', 'Value': 'GPT_AR_431_VERSION'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'GPT_CH_NOTSTARTED\\nGPT_CH_RUNNING\\nGPT_CH_STOPPED\\nGPT_CH_EXPIRED', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_STOPPED'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'GPT_INITIALIZED\\nGPT_UNINITIALIZED', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '&Gpt_GaaPredefTimerConfig[0] '], 'Input_Param_008': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucPredefTimerType', 'Value': '[0 to 1] = 0x03'], 'Input_Param_009': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pHWUnitDeInit', 'Value': '[0 to 3] = NULL_PTR\\n'], 'Input_Param_010': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pStopPredefTimer', 'Value': '[0 to 3] = NULL_PTR\\n'], 'Input_Param_011': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pHWChannelDeInit', 'Value': '[0 to 2] = NULL_PTR\\n[3] = &ISOLATE_void_func_ptr_Gpt_ChannelType\\n'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_013': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '[0 to 19] = 0x03'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaHWIP', 'Value': '&Gpt_GaaHWIP[0]'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = GPT_HWIP_OSTM\\n[1] = GPT_HWIP_TAUD\\n[2] = GPT_HWIP_TAUJ\\n[3] = NULL_PTR'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatusType', 'Value': 'GPT_UNINITIALIZED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucCount', 'Value': '[0 to 19] = <Called>'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_EnableWakeup(Gpt_ChannelType Channel) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if ((GPT_TIMER_IP_TMU == STD_ON) || (GPT_TIMER_IP_TPU == STD_ON)) /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; #endif /* (GPT_TIMER_IP_TMU == STD_ON) && (GPT_TIMER_IP_TPU == STD_ON)*/ #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ LddReturnValue = Gpt_CheckDetErrors(Channel, GPT_ENABLE_WAKEUP_SID); /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Check if the wake up status if GPT_FALSE */ if (GPT_FALSE == Gpt_GpChannelConfig[Channel].blGptWakeupSupport) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_ENABLE_WAKEUP_SID, GPT_E_PARAM_CHANNEL); } else #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) /* Storing Notification in sleep mode */ Gpt_GpChannelRamData[Channel].blWakeupStatus = GPT_TRUE; #else LpChannel = &Gpt_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup) /* PRQA S 2814 # JV-01 */ { /* Disable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup(Channel); } /* else No action required */ #endif } } /* else No action required */ /* End of LddReturnValue == E_NOT_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..GPT_MAX_CHANNEL_ID_CONFIGURED', 'Name': 'Channel', 'Value': 'GPT_MAX_CHANNEL_ID_CONFIGURED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'GPT_TRUE\\nGPT_FALSE', 'Name': 'blGptWakeupSupport', 'Value': 'GPT_TRUE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupStatus', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[0 to 14] = 0x04'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]\\n'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': 'GPT_MAX_CHANNEL_ID_CONFIGURED'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApi_SID', 'Value': 'GPT_ENABLE_WAKEUP_SID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupStatus', 'Value': 'GPT_TRUE'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TIME_REMAINING_API == STD_ON) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Gpt_ValueType, GPT_PUBLIC_CODE) Gpt_GetTimeRemaining(Gpt_ChannelType Channel) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; /* Declare the variable to store the return value */ VAR(Gpt_ValueType, AUTOMATIC) LddTimeRemaining; #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #endif #if (GPT_TIMER_IP_TPU == STD_OFF) /* Initialize the return value as zero */ LddTimeRemaining = (uint32)GPT_ZERO; #else /* Initialize the return value as zero */ LddTimeRemaining = (uint16)GPT_ZERO; #endif #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Check if the GPT Driver is initialized properly */ LddReturnValue = Gpt_CheckDetErrors(Channel, GPT_GET_TIME_REMAINING_SID); /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Updating the channel config parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pGetTimeRemaining) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for getting Remaining Time */ LddTimeRemaining = Gpt_GaaHwFunc[LucCheckTimerType]->pGetTimeRemaining(Channel); } /* else No action required */ } /* else No action required */ /* End of LddReturnValue == E_NOT_OK */ /* Return the Remaining Time */ return (LddTimeRemaining); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..GPT_MAX_CHANNEL_ID_CONFIGURED', 'Name': 'Channel', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'GPT_HWIP_TMU\\nGPT_HWIP_ATU\\nGPT_HWIP_OSTM\\nGPT_HWIP_TAUJ\\nGPT_HWIP_TAUD', 'Name': 'ucTimerUnitType', 'Value': 'GPT_HWIP_TAUD'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]'], 'Input_Param_005': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pGetTimeRemaining', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_006': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApi_SID', 'Value': 'GPT_GET_TIME_REMAINING_SID'], 'Output_Param_002': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddTimeRemaining', 'Value': 'GPT_ZERO'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_DE_INIT_API == STD_ON) #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PRIVATE_CODE) Gpt_HW_Atu_ChannelDeInit(Gpt_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Variable to Timer Type */ VAR(uint8, AUTOMATIC) LucTimerType; #if ((GPT_ATUC_UNIT_USED == STD_ON) || (GPT_ATUD_UNIT_USED == STD_ON) || (GPT_ATUG_UNIT_USED == STD_ON)) /* Variable to index of unit structure */ VAR(uint8, AUTOMATIC) LucUnitIndex; /* Pointer to the Unit configuration */ P2CONST(Gpt_ATUUnitConfigType, AUTOMATIC, GPT_CONFIG_CONST) LpATUUnitConfig; /* PRQA S 3432 # JV-01 */ /* Variable to hold start register start mask of configured sub block */ VAR(uint16, AUTOMATIC) LusCntstartMsk; #endif #if ((GPT_ATUC_UNIT_USED == STD_ON) || (GPT_ATUD_UNIT_USED == STD_ON)) /* Pointer to the Channel registers */ P2CONST(Gpt_ATUChannelConfigType, AUTOMATIC, GPT_CONFIG_CONST) LpAtuChannelConfig; /* PRQA S 3432 # JV-01 */ #endif #if (GPT_ATUC_UNIT_USED == STD_ON) /* Pointer to the ATUC Unit registers */ P2VAR(Gpt_ATUCnUnitRegs, AUTOMATIC, REGSPACE) LpATUCnUnitReg; /* PRQA S 3432 # JV-01 */ #endif #if (GPT_ATUD_UNIT_USED == STD_ON) /* Pointer to the ATUD Unit registers */ P2VAR(Gpt_ATUDnUnitRegs, AUTOMATIC, REGSPACE) LpATUDnUnitReg; /* PRQA S 3432 # JV-01 */ #endif #if (GPT_ATUG_UNIT_USED == STD_ON) /* Pointer to the ATUG Unit registers */ P2VAR(Gpt_ATUGnUnitRegs, AUTOMATIC, REGSPACE) LpATUGnUnitReg; /* PRQA S 3432 # JV-01 */ #endif /* Update the channel configuration pointer to point to the first channel */ LpChannel = &Gpt_GpChannelConfig[LddChannel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucTimerType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if ((GPT_HW_ATUC == LucTimerType) || (GPT_HW_ATUD == LucTimerType) || (GPT_HW_ATUG == LucTimerType)) { #if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) /* Set the Notification status as GPT_FALSE */ Gpt_GpChannelRamData[LddChannel].blNotifyStatus = GPT_FALSE; #endif /* Disable Interrupt */ Gpt_HW_Atu_DisableInterrupt(LddChannel); /* Assign the timer status to the Channel */ Gpt_GpChannelRamData[LddChannel].ucChannelStatus = GPT_CH_NOTSTARTED; #if ((GPT_ATUC_UNIT_USED == STD_ON) || (GPT_ATUD_UNIT_USED == STD_ON) || (GPT_ATUG_UNIT_USED == STD_ON)) /* Read the Timer unit index for given channel */ LucUnitIndex = LpChannel->ucTimerUnitIndex; /* load the current channel unit config address to local pointer */ LpATUUnitConfig = &Gpt_GpATUUnitConfig[LucUnitIndex]; #endif switch (LucTimerType) { /* check for ATUC Units Used */ #if (GPT_ATUC_UNIT_USED == STD_ON) case GPT_HW_ATUC: /* load start register start mask of configured sub block */ LusCntstartMsk = LpATUUnitConfig->usATUnTSTRnmMaskValue; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Disable the ATUC Timer Start Register */ *((volatile uint16 *)LpATUUnitConfig->pATUnTSTRnm) &= (uint16) ~(LusCntstartMsk); /* PRQA S 0316, 2814 # JV-01, JV-01 */ /* load current channel ATUC Register base address to local pointer */ LpATUCnUnitReg = (P2VAR(Gpt_ATUCnUnitRegs, AUTOMATIC, REGSPACE))LpATUUnitConfig->pATUUnitRegsAddress; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Reset timer interrupt control register of the configured channel */ LpATUCnUnitReg->usATUCTIERCn = GPT_RESET_ATUC_INTERRUPT_ENABLE; /* PRQA S 2814 # JV-01 */ /* Clear the compare match flag */ LpATUCnUnitReg->usATUCTSCRCn = GPT_ATUC_CLEAR_CMP_FLG; /* Reset the clock source selection control register */ LpATUCnUnitReg->usATUCTCRCn = GPT_RESET_ATUCD_CONTROL_REG; /* Reset input output control register of configured channel */ LpATUCnUnitReg->usATUCTIORCn = GPT_RESET_ATUCD_IO_CONTROL_REG; /* Load the reset value to the timer counter register */ LpATUCnUnitReg->ulATUCTCNTCn = GPT_RESET_COUNTER_REG; /* Read the Timer Sub block channel id */ LpAtuChannelConfig = LpChannel->pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ if (GPT_CH_MODE_ONESHOT == LpChannel->ucGptChannelMode) { /* Load the value into the compare match register */ LpATUCnUnitReg->ulATUOCRCnm[LpAtuChannelConfig->ucSubblockChannelId] = GPT_RESET_ATUCDG_CMP_REG; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } /* else No action required */ /* Reset the output compare register of the configured channel */ LpATUCnUnitReg->ulATUCGRCnm[LpAtuChannelConfig->ucSubblockChannelId] = GPT_RESET_ATUCDG_CMP_REG; /* PRQA S 2844 # JV-01 */ break; #endif /* End of (GPT_ATUC_UNIT_USED == STD_ON) */ /* check for ATUD Units Used */ #if (GPT_ATUD_UNIT_USED == STD_ON) case GPT_HW_ATUD: /* load start register start mask of configured sub block */ LusCntstartMsk = LpATUUnitConfig->usATUnTSTRnmMaskValue; /* Disable the ATUD Timer Start Register */ *((volatile uint16 *)LpATUUnitConfig->pATUnTSTRnm) &= (uint16) ~(LusCntstartMsk); /* PRQA S 0316 # JV-01 */ /* load current channel ATUD Register base address to local pointer */ LpATUDnUnitReg = (P2VAR(Gpt_ATUDnUnitRegs, AUTOMATIC, REGSPACE))LpATUUnitConfig->pATUUnitRegsAddress; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Reset timer interrupt control register */ LpATUDnUnitReg->ucATUDTIER1Dnm = GPT_RESET_ATUD_INTERRUPT_ENABLE1; /* PRQA S 2814 # JV-01 */ LpATUDnUnitReg->ulATUDTIER2Dnm = GPT_RESET_ATUD_INTERRUPT_ENABLE2; /* Clear the compare match flag */ LpATUDnUnitReg->usATUDTSCRDn = GPT_ATUD_CLEAR_CMP_FLG; /* Reset the value of timer control register */ LpATUDnUnitReg->usATUDTCRDn = GPT_RESET_ATUCD_CONTROL_REG; /* Reset the value of compare match source select register */ LpATUDnUnitReg->usATUDTIOR1Dn = GPT_RESET_ATUCD_IO_CONTROL_REG; /* Load the reset value to the timer counter register */ LpATUDnUnitReg->ulATUDTCNT1Dn = GPT_RESET_COUNTER_REG; /* Read the Timer Sub block channel id */ LpAtuChannelConfig = LpChannel->pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ /* Reset the value of output compare register */ LpATUDnUnitReg->aaATUDnOCR1Dnm[LpAtuChannelConfig->ucSubblockChannelId].ulATUDOCR1Dnm = /* PRQA S 2814, 2844 # JV-01, JV-01 */ GPT_RESET_ATUCDG_CMP_REG; /* Reset the Counter Upper-Limit Setting Compare Register */ LpATUDnUnitReg->ulATUDCUCR1Dn = GPT_RESET_ATUD_CUCR1D; break; #endif /* End of (GPT_ATUD_UNIT_USED == STD_ON) */ /* Check for ATUG Units Used */ #if (GPT_ATUG_UNIT_USED == STD_ON) case GPT_HW_ATUG: /* load start register start mask of configured sub block */ LusCntstartMsk = LpATUUnitConfig->usATUnTSTRnmMaskValue; /* Disable the ATUG Timer Start Register */ *((volatile uint16 *)LpATUUnitConfig->pATUnTSTRnm) &= (uint16) ~(LusCntstartMsk); /* PRQA S 0316 # JV-01 */ /* load current channel ATUG Register base address to local pointer */ LpATUGnUnitReg = (P2VAR(Gpt_ATUGnUnitRegs, AUTOMATIC, REGSPACE))LpATUUnitConfig->pATUUnitRegsAddress; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Disable Interrupt of configured sub block */ *(volatile uint16 *)(LpATUUnitConfig->pATUGTIERG) &= (uint16) ~(LusCntstartMsk); /* PRQA S 2814 # JV-01 */ /* Clear the compare match flag */ LpATUGnUnitReg->ucATUGTSCRGn = GPT_ATUG_CLEAR_CMP_FLG; /* PRQA S 2814 # JV-01 */ /* Reset the value of timer control register */ LpATUGnUnitReg->ucATUGTCRGn = GPT_RESET_ATUG_CONTROL_REG; /* Set the initial value to the compare match register */ LpATUGnUnitReg->ulATUGOCRGn = GPT_RESET_ATUCDG_CMP_REG; /* Reset the value of timer register */ LpATUGnUnitReg->ulATUGTCNTGn = GPT_RESET_COUNTER_REG; break; #endif /* End of (GPT_ATUG_UNIT_USED == STD_ON) */ default: /* No action required */ break; } /* End of switch (LucTimerType) */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUC_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUD_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUG_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ENABLE_DISABLE_NOTIFICATION_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerUnitIndex', 'Value': '0x00'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerType', 'Value': '0x06'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'GPT_CH_MODE_ONESHOT\\nGPT_CH_MODE_CONTINUOUS', 'Name': 'ucGptChannelMode', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSubblockChannelId', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpATUUnitConfig', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'usATUnTSTRnmMaskValue', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pATUUnitRegsAddress', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pATUnTSTRnm', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_pATUnTSTRnm[0]', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pATUGTIERG', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pATUGTIERG[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'usATUCTIERCn', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'usATUCTSCRCn', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'usATUCTCRCn', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usATUCTIORCn', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUCTCNTCn', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUOCRCnm[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUCGRCnm[0]', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucATUDTIER1Dnm', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUDTIER2Dnm', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usATUDTSCRDn', 'Value': '-'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'usATUDTCRDn', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'usATUDTIOR1Dn', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUDTCNT1Dn', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'aaATUDnOCR1Dnm[0].ulATUDOCR1Dnm', 'Value': '-'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUDCUCR1Dn', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucATUGTSCRGn', 'Value': '-'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucATUGTCRGn', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUGOCRGn', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUGTCNTGn', 'Value': '-'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '-'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_pATUnTSTRnm[0]', 'Value': '-'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_pATUGTIERG[0]', 'Value': '-'], 'Output_Param_024': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PRIVATE_CODE) Gpt_HW_Atu_DisableInterrupt(Gpt_ChannelType LddChannel) { /* Pointer to the channel configuration */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Updating the channel config parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[LddChannel]; if (NULL_PTR != LpChannel->pEICReg) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Disable Interrupt */ RH850_SV_MODE_ICR_OR(8, (LpChannel->pEICReg), GPT_EIMK_DISABLE_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ /* Dummy read */ RH850_SV_MODE_REG_READ_ONLY(8, (LpChannel->pEICReg)); /* PRQA S 0751 # JV-01 */ /* Execute syncp */ EXECUTE_SYNCP(); } /* else No action required */ #if (GPT_CLEAR_PENDING_INTERRUPT == STD_ON) if (NULL_PTR != LpChannel->pEICReg) { /* Increment the pointer to next byte address of * Interrupt control register */ RH850_SV_MODE_ICR_AND(16, (LpChannel->pEICReg), GPT_CLEAR_PENDING_INTR_MASK); /* Dummy read */ RH850_SV_MODE_REG_READ_ONLY(16, (LpChannel->pEICReg)); /* Execute syncp */ EXECUTE_SYNCP(); } /* else No action required */ #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CLEAR_PENDING_INTERRUPT', 'Value': ''], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!= NULL_PTR', 'Name': 'pEICReg', 'Value': ''], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': ''], 'Input_Param_005': ['Type': 'Macro', 'Range': 'uint8', 'Name': 'GPT_CLEAR_PENDING_INTR_MASK', 'Value': ''], 'Input_Param_006': ['Type': 'Macro', 'Range': 'uint8', 'Name': 'GPT_EIMK_DISABLE_MASK', 'Value': '']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': ''], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PRIVATE_CODE) Gpt_HW_Atu_EnableInterrupt(Gpt_ChannelType LddChannel) { /* Pointer to the channel configuration */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Updating the channel config parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[LddChannel]; #if (GPT_CLEAR_PENDING_INTERRUPT == STD_ON) if (NULL_PTR != LpChannel->pEICReg) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Clear the Interrupt flag of Interrupt control register */ RH850_SV_MODE_ICR_AND(16, (LpChannel->pEICReg), GPT_CLEAR_PENDING_INTR_MASK); /* PRQA S 2814 # JV-01 */ /* Dummy read */ RH850_SV_MODE_REG_READ_ONLY(16, (LpChannel->pEICReg)); /* Execute syncp */ EXECUTE_SYNCP(); } /* else No action required */ #endif if (NULL_PTR != LpChannel->pEICReg) { /* Enable Interrupt */ RH850_SV_MODE_ICR_AND(8, (LpChannel->pEICReg), GPT_EIMK_ENABLE_MASK); /* PRQA S 0751 # JV-01 */ /* Dummy read */ RH850_SV_MODE_REG_READ_ONLY(8, (LpChannel->pEICReg)); /* PRQA S 0751 # JV-01 */ /* Execute syncp */ EXECUTE_SYNCP(); } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CLEAR_PENDING_INTERRUPT', 'Value': ''], 'Input_Param_001': ['Type': 'Macro', 'Range': 'uint8', 'Name': 'GPT_CLEAR_PENDING_INTR_MASK', 'Value': ''], 'Input_Param_002': ['Type': 'Macro', 'Range': 'uint8', 'Name': 'GPT_EIMK_ENABLE_MASK', 'Value': ''], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..\\nGPT_MAX_CHANNEL_ID_CONFIGURED', 'Name': 'LddChannel', 'Value': ''], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': ''], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!= NULL_PTR', 'Name': 'pEICReg', 'Value': ''], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': '']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': ''], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TIME_ELAPSED_API == STD_ON) #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Gpt_ValueType, GPT_PRIVATE_CODE) Gpt_HW_Atu_GetTimeElapsed(Gpt_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Variable to hold timer Elapsed time */ VAR(Gpt_ValueType, AUTOMATIC) LddTimeElapsed; #if ((GPT_ATUC_UNIT_USED == STD_ON) || (GPT_ATUD_UNIT_USED == STD_ON) || (GPT_ATUG_UNIT_USED == STD_ON)) /* Variable to hold unit index of unit structure */ VAR(uint8, AUTOMATIC) LucUnitIndex; /* Pointer to the unit configuration */ P2CONST(Gpt_ATUUnitConfigType, AUTOMATIC, GPT_CONFIG_CONST) LpATUUnitConfig; /* PRQA S 3432 # JV-01 */ #endif /* Variable to hold channel type */ VAR(uint8, AUTOMATIC) LucTimerType; #if (GPT_ATUC_UNIT_USED == STD_ON) /* Variable to hold channel number inside the timer sub block */ P2CONST(Gpt_ATUChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpAtuChannelConfig; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the ATUC Unit registers */ P2VAR(Gpt_ATUCnUnitRegs, AUTOMATIC, REGSPACE) LpATUCnUnitReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif #if (GPT_ATUD_UNIT_USED == STD_ON) /* Pointer pointing to the ATUD Unit registers */ P2VAR(Gpt_ATUDnUnitRegs, AUTOMATIC, REGSPACE) LpATUDnUnitReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif #if (GPT_ATUG_UNIT_USED == STD_ON) /* Pointer pointing to the ATUG Unit registers */ P2VAR(Gpt_ATUGnUnitRegs, AUTOMATIC, REGSPACE) LpATUGnUnitReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif /* Initialize Return Value to zero */ LddTimeElapsed = (uint32)GPT_ZERO; /* Updating the channel configuration parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[LddChannel]; /* Updating the channel RAM data parameter to the current channel */ LpRamData = &Gpt_GpChannelRamData[LddChannel]; #if ((GPT_ATUC_UNIT_USED == STD_ON) || (GPT_ATUD_UNIT_USED == STD_ON) || (GPT_ATUG_UNIT_USED == STD_ON)) /* Read the timer unit index for given channel */ LucUnitIndex = LpChannel->ucTimerUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Update the ATU configuration pointer to point to the current ATU */ LpATUUnitConfig = &Gpt_GpATUUnitConfig[LucUnitIndex]; #endif /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucTimerType; if (GPT_CH_NOTSTARTED != LpRamData->ucChannelStatus) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif switch (LucTimerType) { #if (GPT_ATUC_UNIT_USED == STD_ON) case GPT_HW_ATUC: /* load current channel ATUC Register base address to local pointer */ LpATUCnUnitReg = (P2VAR(Gpt_ATUCnUnitRegs, AUTOMATIC, REGSPACE))LpATUUnitConfig->pATUUnitRegsAddress; /* PRQA S 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01 */ /* Assign the final return value */ LddTimeElapsed = LpATUCnUnitReg->ulATUCTCNTCn; /* PRQA S 2814 # JV-01 */ if ((GPT_CH_EXPIRED == (LpRamData->ucChannelStatus)) || ((uint16)GPT_ZERO != (uint16)((LpATUCnUnitReg->usATUCTSRCn) & (GPT_ATUC_OVERFLOW_CHECK_VALUE)))) { if (GPT_CH_MODE_ONESHOT == LpChannel->ucGptChannelMode) { /* Read the Timer Sub block channel id */ LpAtuChannelConfig = LpChannel->pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ /* Assign the final return value */ LddTimeElapsed = LpATUCnUnitReg->ulATUCGRCnm[LpAtuChannelConfig->ucSubblockChannelId]; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } /* else No action required */ } /* else No action required */ break; #endif /* End of(GPT_ATUC_UNIT_USED == STD_ON) */ #if (GPT_ATUD_UNIT_USED == STD_ON) case GPT_HW_ATUD: /* load current channel ATUD Register base address to local pointer */ LpATUDnUnitReg = (P2VAR(Gpt_ATUDnUnitRegs, AUTOMATIC, REGSPACE))LpATUUnitConfig->pATUUnitRegsAddress; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Assign the final return value */ LddTimeElapsed = LpATUDnUnitReg->ulATUDTCNT1Dn; /* PRQA S 2814 # JV-01 */ if (GPT_CH_MODE_ONESHOT == LpChannel->ucGptChannelMode) { if ((GPT_CH_EXPIRED == (LpRamData->ucChannelStatus)) || ((uint16)GPT_ZERO != (uint16)((LpATUDnUnitReg->usATUDTSRDn) & (GPT_ATUD_OVERFLOW_CHECK_VALUE)))) { /* Assign the final return value */ LddTimeElapsed = LpATUDnUnitReg->ulATUDCUCR1Dn; } /* else No action required */ } /* else No action required */ break; #endif /* End of (GPT_ATUD_UNIT_USED == STD_ON) */ #if (GPT_ATUG_UNIT_USED == STD_ON) case GPT_HW_ATUG: /* load current channel ATUG Register base address to local pointer */ LpATUGnUnitReg = (P2VAR(Gpt_ATUGnUnitRegs, AUTOMATIC, REGSPACE))LpATUUnitConfig->pATUUnitRegsAddress; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Assign the final return value */ LddTimeElapsed = LpATUGnUnitReg->ulATUGTCNTGn; /* PRQA S 2814 # JV-01 */ if (GPT_CH_MODE_ONESHOT == LpChannel->ucGptChannelMode) { if ((GPT_CH_EXPIRED == (LpRamData->ucChannelStatus)) || ((uint8)GPT_ZERO != (uint8)((LpATUGnUnitReg->ucATUGTSRGn) & (GPT_ATUG_OVERFLOW_CHECK_VALUE)))) { /* Assign the final return value */ LddTimeElapsed = LpATUGnUnitReg->ulATUGOCRGn; } /* else No action required */ } /* else No action required */ break; #endif /* End of (GPT_ATUG_UNIT_USED == STD_ON) */ default: /* No action required */ break; } #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ /* End of (GPT_CH_NOTSTARTED != LpRamData->ucChannelStatus) */ return (LddTimeElapsed); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUC_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUD_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUG_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerUnitIndex', 'Value': '0x00'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerType', 'Value': 'GPT_HW_ATUC'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!= NULL_PTR', 'Name': 'pHWIPChannelConfig', 'Value': '&map_pHWIPChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'GPT_CH_MODE_ONESHOT\\nGPT_CH_MODE_CONTINUOUS', 'Name': 'ucGptChannelMode', 'Value': 'GPT_CH_MODE_ONESHOT'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSubblockChannelId', 'Value': '0x00'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'GPT_CH_NOTSTARTED\\nGPT_CH_RUNNING\\nGPT_CH_STOPPED\\nGPT_CH_EXPIRED', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_RUNNING'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpATUUnitConfig', 'Value': '&map_Gpt_GpATUUnitConfig[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!= NULL_PTR', 'Name': 'pATUUnitRegsAddress', 'Value': '&map_Gpt_ATUCnUnitRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUCTCNTCn', 'Value': '0x00000000'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUCGRCnm[0]', 'Value': '0x00000000'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'usATUCTSRCn', 'Value': '0x0001'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUDTCNT1Dn', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUDCUCR1Dn', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'usATUDTSRDn', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUGTCNTGn', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'ulATUGOCRGn', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucATUGTSRGn', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_002': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddTimeElapsed', 'Value': '0x00000000'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) && (GPT_ATUA_UNIT_USED == STD_ON)) #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PRIVATE_CODE) Gpt_HW_Atu_StartPredefTimer(void) /* PRQA S 1532 # JV-01 */ { /* Pointer to Predef Timer config */ P2CONST(Gpt_PredefTimerConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpPredefTimerConfig; /* PRQA S 3432 # JV-01 */ /* Pointer to Predef Timer channel config */ P2CONST(Gpt_PredefTimerATUChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpPT_ChConfig; /* PRQA S 3432 # JV-01 */ /* Initialize the PredefTimer */ LpPredefTimerConfig = Gpt_GpPredefTimerConfig; LpPT_ChConfig = LpPredefTimerConfig->pPT_ChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ /* Select Clock bus of Timer A by use TCR1A Register */ *((volatile uint8 *)LpPT_ChConfig->pTCR1AReg) = LpPT_ChConfig->ucPT_ClockselectValue; /* PRQA S 2814 # JV-01 */ /* reset Predef Timer counter Value */ *((volatile uint32 *)LpPT_ChConfig->pTCNTAReg) = GPT_RESET_COUNTER_REG; /* Start Predef Timer */ *(GPT_ATU_ATUENR) |= GPT_ATU_ATUENR_TAE_MASK_VALUE; /* PRQA S 0303, 2810, 3432 # JV-01, JV-01, JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ATUA_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpPredefTimerConfig', 'Value': '&map_Gpt_GpPredefTimerConfig[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!= NULL_PTR', 'Name': 'pPT_ChannelConfig', 'Value': '&map_pPT_ChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!= NULL_PTR', 'Name': 'pTCR1AReg', 'Value': '&map_pTCR1AReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!= NULL_PTR', 'Name': 'pTCNTAReg', 'Value': '&map_pTCNTAReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucPT_ClockselectValue', 'Value': '0x01'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_GPT_ATU_ATUENR', 'Value': '0x00'], 'Input_Param_007': ['Type': 'Macro', 'Range': 'uint8', 'Name': 'GPT_ATU_ATUENR_TAE_MASK_VALUE', 'Value': '0x02']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTCR1AReg[0]', 'Value': '0x01'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTCNTAReg[0]', 'Value': 'GPT_RESET_COUNTER_REG'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_GPT_ATU_ATUENR', 'Value': 'GPT_ATU_ATUENR_TAE_MASK_VALUE'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TIME_REMAINING_API == STD_ON) #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Gpt_ValueType, GPT_PRIVATE_CODE) Gpt_HW_Taud_GetTimeRemaining(Gpt_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Variable to hold timer remaining time */ VAR(Gpt_ValueType, AUTOMATIC) LddTimeRemaining; /* Pointer to the Unit configuration */ P2CONST(Gpt_TAUChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpTAUChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the TAUD registers */ P2VAR(Gpt_TAUDChannelUserRegs, AUTOMATIC, REGSPACE) LpTAUDChannelRegs; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Defining a pointer to point to the TAUD registers */ P2VAR(Gpt_TAUDUnitUserRegs, AUTOMATIC, REGSPACE) LpTAUDUnitUserRegs; /* PRQA S 3432 # JV-01 */ /* Initialize Return Value to zero */ LddTimeRemaining = (uint32)GPT_ZERO; /* Updating the channel configuration parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[LddChannel]; /* load the Ram Data for current channel */ LpRamData = &Gpt_GpChannelRamData[LddChannel]; /* Updating the unit configuration parameter to the current unit */ LpTAUChannelConfigData = LpChannel->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ if (GPT_CH_NOTSTARTED != LpRamData->ucChannelStatus) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif /* Set the pointer to TAU register base address */ LpTAUDChannelRegs = (P2VAR(Gpt_TAUDChannelUserRegs, AUTOMATIC, REGSPACE))LpTAUChannelConfigData->pCDRReg; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* Assign the final return value and it is incremented by one to * compensate the decrement done in start timer function. */ LddTimeRemaining = (uint32)(LpTAUDChannelRegs->usTAUDnCNTm) + (uint32)GPT_ONE; /* PRQA S 2814, 3383 # JV-01, JV-01 */ /* Channel is expired and is configured for one-shot mode will return zero value */ if (GPT_CH_EXPIRED == LpRamData->ucChannelStatus) { /* Return ZERO */ LddTimeRemaining = (uint32)GPT_ZERO; } /* else No action required */ /* GPT channel in one-shot mode shall return a value of 0 if timer expires */ if (NULL_PTR != LpChannel->pEICReg) { /* Increment the pointer to next byte address of Interrupt control register */ if ((GPT_CHECK_INTR_REQUEST_MASK == (uint16)(*(LpChannel->pEICReg) & GPT_CHECK_INTR_REQUEST_MASK)) && /* PRQA S 2814 # JV-01 */ (GPT_CH_MODE_ONESHOT == LpChannel->ucGptChannelMode)) { /* Return ZERO */ LddTimeRemaining = (uint32)GPT_ZERO; /* Initialize pointer to the base address of the current timer user control registers */ LpTAUDUnitUserRegs = (P2VAR(Gpt_TAUDUnitUserRegs, AUTOMATIC, REGSPACE))Gpt_GpTAUUnitConfig[LpChannel->ucTimerUnitIndex] /* PRQA S 0316, 2824, 3432 # JV-01, JV-01, JV-01 */ .pTAUUnitUserCntlRegs; /* Stop the timer TAUD */ LpTAUDUnitUserRegs->usTAUDnTT = LpTAUChannelConfigData->usChannelBitValue; /* PRQA S 2814 # JV-01 */ } /* else No action required */ } /* else No action required */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else The ucChannelStatus is GPT_CH_NOTSTARTED case: No action required */ /* End of (GPT_CH_NOTSTARTED != LpRamData->ucChannelStatus) */ return (LddTimeRemaining); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '&map_pHWIPChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!NULL_PTR', 'Name': 'pEICReg', 'Value': '&map_pEICReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'GPT_CH_MODE_ONESHOT\\nGPT_CH_MODE_CONTINUOUS', 'Name': 'ucGptChannelMode', 'Value': 'GPT_CH_MODE_ONESHOT'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerUnitIndex', 'Value': '0x01'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': '0x1000'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pCDRReg', 'Value': '&map_pCDRReg[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelBitValue', 'Value': '0x0001'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usTAUDnCNTm', 'Value': '0x00000001'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'GPT_CH_EXPIRED\\nGPT_CH_NOTSTARTED\\nGPT_CH_RUNNING\\nGPT_CH_STOPPED', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_EXPIRED'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpTAUUnitConfig', 'Value': '&map_Gpt_GpTAUUnitConfig[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'pTAUUnitUserCntlRegs', 'Value': '[0 to 1] = &map_pTAUUnitUserCntlRegs[0]']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'usTAUDnTT', 'Value': '0x0001'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddTimeRemaining', 'Value': 'GPT_ZERO'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TIME_REMAINING_API == STD_ON) #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Gpt_ValueType, GPT_PRIVATE_CODE) Gpt_HW_Tauj_GetTimeRemaining(Gpt_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Pointer to the Unit configuration */ P2CONST(Gpt_TAUChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpTAUChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the TAUJ registers */ P2VAR(Gpt_TAUJChannelUserRegs, AUTOMATIC, REGSPACE) LpTAUJChannelRegs; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Defining a pointer to point to the TAUJ registers */ P2VAR(Gpt_TAUJUnitUserRegs, AUTOMATIC, REGSPACE) LpTAUJUnitUserRegs; /* PRQA S 3432 # JV-01 */ /* Pointer to the channel configuration */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Variable to hold timer remaining time */ VAR(Gpt_ValueType, AUTOMATIC) LddTimeRemaining; /* Initialize Return Value to zero */ LddTimeRemaining = (uint32)GPT_ZERO; /* Updating the channel configuration parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[LddChannel]; /* load the Ram Data for current channel */ LpRamData = &Gpt_GpChannelRamData[LddChannel]; /* Updating the unit configuration parameter to the current unit */ LpTAUChannelConfigData = LpChannel->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ if (GPT_CH_NOTSTARTED != LpRamData->ucChannelStatus) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif /* Set the pointer to TAU register base address */ LpTAUJChannelRegs = (P2VAR(Gpt_TAUJChannelUserRegs, AUTOMATIC, REGSPACE))LpTAUChannelConfigData->pCDRReg; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* Assign the final return value and it is incremented by one to * compensate the decrement done in start timer function. */ LddTimeRemaining = (uint32)(LpTAUJChannelRegs->ulTAUJnCNTm) + (uint32)GPT_ONE; /* PRQA S 2814, 3383 # JV-01, JV-01 */ /* Channel is expired and is configured for one-shot mode will return zero value */ if (GPT_CH_EXPIRED == LpRamData->ucChannelStatus) { /* Return ZERO */ LddTimeRemaining = (uint32)GPT_ZERO; } /* else No action required */ /* GPT channel in one-shot mode shall return a value of 0 if timer expires */ if (NULL_PTR != LpChannel->pEICReg) { /* Increment the pointer to next byte address of Interrupt control register */ if ((GPT_CHECK_INTR_REQUEST_MASK == (uint16)(*(LpChannel->pEICReg) & GPT_CHECK_INTR_REQUEST_MASK)) && /* PRQA S 2814 # JV-01 */ (GPT_CH_MODE_ONESHOT == LpChannel->ucGptChannelMode)) { /* Return ZERO */ LddTimeRemaining = (uint32)GPT_ZERO; /* Initialize pointer to the base address of the current timer user control registers */ LpTAUJUnitUserRegs = (P2VAR(Gpt_TAUJUnitUserRegs, AUTOMATIC, REGSPACE))Gpt_GpTAUUnitConfig[LpChannel->ucTimerUnitIndex] /* PRQA S 0316, 2824, 3432 # JV-01, JV-01, JV-01 */ .pTAUUnitUserCntlRegs; /* Stop the timer TAUJ */ LpTAUJUnitUserRegs->ucTAUJnTT = (uint8)LpTAUChannelConfigData->usChannelBitValue; /* PRQA S 2814 # JV-01 */ } /* else No action required */ } /* else No action required */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ /* End of (GPT_CH_NOTSTARTED != LpRamData->ucChannelStatus) */ return (LddTimeRemaining); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '&map_pHWIPChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!NULL_PTR', 'Name': 'pEICReg', 'Value': '&map_pEICReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'GPT_CH_MODE_ONESHOT\\nGPT_CH_MODE_CONTINUOUS', 'Name': 'ucGptChannelMode', 'Value': 'GPT_CH_MODE_ONESHOT'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerUnitIndex', 'Value': '0x00'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': '0x1000'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pCDRReg', 'Value': '&map_pCDRReg[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelBitValue', 'Value': '0x01'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulTAUJnCNTm', 'Value': '0x00000001'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_EXPIRED'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpTAUUnitConfig', 'Value': '&map_Gpt_GpTAUUnitConfig[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pTAUUnitUserCntlRegs', 'Value': '&map_pTAUUnitUserCntlRegs[0]']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddTimeRemaining', 'Value': 'GPT_ZERO'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucTAUJnTT', 'Value': '0x0001'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PRIVATE_CODE) Gpt_HW_Tauj_StartTimer(Gpt_ChannelType LddChannel, Gpt_ValueType LddValue) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432 # JV-01 */ /* Pointer to the unit configuration */ P2CONST(Gpt_TAUChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpTAUChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the TAUJ registers */ P2VAR(Gpt_TAUJUnitUserRegs, AUTOMATIC, REGSPACE) LpTAUJUnitUserRegs; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the channel control registers of TAUJ */ P2VAR(Gpt_TAUJChannelUserRegs, AUTOMATIC, REGSPACE) LpTAUJChannelRegs; /* PRQA S 3432 # JV-01 */ /* Updating the channel configuration parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[LddChannel]; /* load the channel RAM data to the local */ LpRamData = &Gpt_GpChannelRamData[LddChannel]; #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif if ((uint8)GPT_MODE_NORMAL == Gpt_GucDriverMode) /* PRQA S 3416 # JV-01 */ { /* Set base address for unit registers */ LpTAUJUnitUserRegs = (P2VAR(Gpt_TAUJUnitUserRegs, AUTOMATIC, REGSPACE))Gpt_GpTAUUnitConfig[LpChannel->ucTimerUnitIndex] /* PRQA S 0316, 2814, 2824, 2844, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ .pTAUUnitUserCntlRegs; /* Set TAU channel config data pointer */ LpTAUChannelConfigData = LpChannel->pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ /* Stopping tiner counter */ LpTAUJUnitUserRegs->ucTAUJnTT = (uint8)LpTAUChannelConfigData->usChannelBitValue; /* PRQA S 2814 # JV-01 */ if (GPT_CH_MODE_ONESHOT == LpChannel->ucGptChannelMode) { /* Enable Interrupt */ Gpt_HW_Tauj_EnableInterrupt(LddChannel); } else { #if (GPT_CLEAR_PENDING_INTERRUPT == STD_ON) if (NULL_PTR != LpChannel->pEICReg) { /* Clear the Interrupt flag of Interrupt control register */ RH850_SV_MODE_ICR_AND(16, (LpChannel->pEICReg), GPT_CLEAR_PENDING_INTR_MASK); /* PRQA S 2814 # JV-01 */ /* Dummy read */ RH850_SV_MODE_REG_READ_ONLY(16, (LpChannel->pEICReg)); /* Execute syncp */ EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ } /* else No action required */ #endif } /* End of LpChannel->ucGptChannelMode == GPT_CH_MODE_ONESHOT */ /* Set base address for channel register */ LpTAUJChannelRegs = (P2VAR(Gpt_TAUJChannelUserRegs, AUTOMATIC, REGSPACE))LpTAUChannelConfigData->pCDRReg; /* PRQA S 0316, 3432, 2814 # JV-01, JV-01, JV-01 */ /* Load the value into the Data register */ LpTAUJChannelRegs->ulTAUJnCDRm = LddValue - (uint32)GPT_ONE; /* PRQA S 2814, 3383 # JV-01, JV-01 */ /* Start the timer counter */ LpTAUJUnitUserRegs->ucTAUJnTS = (uint8)LpTAUChannelConfigData->usChannelBitValue; /* PRQA S 2814 # JV-01 */ /* Assign the timer status to the Channel */ LpRamData->ucChannelStatus = GPT_CH_RUNNING; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } /* else No action required */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CLEAR_PENDING_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LddValue', 'Value': '0xFFFFFFFF'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_SLEEP'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerUnitIndex', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '&map_pHWIPChannelConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'GPT_CH_MODE_ONESHOT\\nGPT_CH_MODE_CONTINUOUS', 'Name': 'ucGptChannelMode', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pEICReg', 'Value': '&map_pEICReg[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelBitValue', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pCDRReg', 'Value': '&map_pCDRReg[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpTAUUnitConfig', 'Value': '&map_Gpt_GpTAUUnitConfig[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pTAUUnitUserCntlRegs', 'Value': '&map_pTAUUnitUserCntlRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucTAUJnTT', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucTAUJnTS', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulTAUJnCDRm', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEICReg[0]', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PRIVATE_CODE) Gpt_HW_Tmu_EnableWakeup(const Gpt_ChannelType channel) /* PRQA S 1532 # JV-01 */ { /* Pointer to locate the targeted register of a channel */ P2VAR(Gpt_ChannelRegs, AUTOMATIC, REGSPACE) LpTMUChannelRegs; /* PRQA S 3432 # JV-01 */ /* Updating the channel config parameter to the current channel */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432 # JV-01 */ /* Updating the channel configure parameter to the current channel */ LpChannelConfig = &Gpt_GpChannelConfig[channel]; /* Updating the channel ram data to the current channel */ LpRamData = &Gpt_GpChannelRamData[channel]; /* Update the channel's base address to local pointer */ LpTMUChannelRegs = LpChannelConfig->pBaseTCORAddress; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Check if the GPT driver is in sleep mode */ if (GPT_MODE_SLEEP == Gpt_GucDriverMode) /* PRQA S 1881, 3416 # JV-01, JV-01 */ { if (GPT_CH_MODE_ONESHOT != LpChannelConfig->ucGptChannelMode) { #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif /* Clear the underflow flag of the control register TCR */ LpTMUChannelRegs->usTMUnTCR &= GPT_UNDERFLOW_CLEAR; /* PRQA S 2814 # JV-01 */ /* Clear the underflow flag of the control register TCR */ LpTMUChannelRegs->usTMUnTCR |= GPT_UNDERFLOW_INT_MASK; #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } /* else No action required */ /* Storing Wakeup in normal mode */ LpRamData->blWakeupStatus = GPT_TRUE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ENABLE_DISABLE_NOTIFICATION_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_REPORT_WAKEUP_SOURCE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_WAKEUP_FUNCTIONALITY_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'channel', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pBaseTCORAddress', 'Value': '&map_pBaseTCORAddress[0]\\n'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pTSTRAddress', 'Value': '&map_pTSTRAddress[0]\\n'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucTCRValue', 'Value': '0x00'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulTMUnTCOR', 'Value': '0xFFFFFFFF'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulTMUnTCNT', 'Value': '0xFFFFFFFF'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'usTMUnTCR', 'Value': '0x00'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTSTRAddress[0]', 'Value': '0x00'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucGptChannelMode', 'Value': 'GPT_CH_MODE_CONTINUOUS'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_NORMAL']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'usTMUnTCR', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupStatus', 'Value': 'GPT_TRUE'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TIME_REMAINING_API == STD_ON) #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Gpt_ValueType, GPT_PRIVATE_CODE) Gpt_HW_Tmu_GetTimeRemaining(Gpt_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Pointer to locate the TMU register of a channel */ P2VAR(Gpt_ChannelRegs, AUTOMATIC, REGSPACE) LpTMUChannelRegs; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Updating the channel config parameter to the current channel */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Variable to hold timer Elapsed time */ VAR(Gpt_ValueType, AUTOMATIC) LddTimeRemaining; /* Initialize Return Value to zero */ LddTimeRemaining = (uint32)GPT_ZERO; /* Updating the channel configuration parameter to the current channel */ LpChannelConfig = &Gpt_GpChannelConfig[LddChannel]; /* Updating the channel RAM data parameter to the current channel */ LpRamData = &Gpt_GpChannelRamData[LddChannel]; if (GPT_CH_NOTSTARTED != LpRamData->ucChannelStatus) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif /* Update the channel's base Gpt_TMU_LLDriver to local pointer */ LpTMUChannelRegs = LpChannelConfig->pBaseTCORAddress; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Assign the final return value */ /* The target value is decreased 1 in Gpt_HW_Tmu_StartTimer */ /* Thus Remaining Time is increased 1 */ LddTimeRemaining = (LpTMUChannelRegs->ulTMUnTCNT + (uint32)GPT_ONE); /* PRQA S 2814, 3383 # JV-01, JV-01 */ /* Expired Chack of current channel */ if (GPT_CH_MODE_ONESHOT == LpChannelConfig->ucGptChannelMode) { if ((GPT_CH_EXPIRED == LpRamData->ucChannelStatus) || ((LpTMUChannelRegs->usTMUnTCR & GPT_UNDERFLOW_MASK) != (uint16)GPT_ZERO)) { /* Set the return value to zero */ LddTimeRemaining = (uint32)GPT_ZERO; } /* else No action required */ } /* else No action required */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ return (LddTimeRemaining); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucGptChannelMode', 'Value': 'GPT_CH_MODE_ONESHOT'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pBaseTCORAddress', 'Value': '&map_pBaseTCORAddress[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulTMUnTCNT', 'Value': '0x00000001'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'usTMUnTCR', 'Value': '0x0003'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_RUNNING']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddTimeRemaining', 'Value': '0x00000002'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TIME_REMAINING_API == STD_ON) #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Gpt_ValueType, GPT_PRIVATE_CODE) Gpt_HW_Tmu_GetTimeRemaining(Gpt_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Pointer to locate the TMU register of a channel */ P2VAR(Gpt_ChannelRegs, AUTOMATIC, REGSPACE) LpTMUChannelRegs; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Updating the channel config parameter to the current channel */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Variable to hold timer Elapsed time */ VAR(Gpt_ValueType, AUTOMATIC) LddTimeRemaining; /* Initialize Return Value to zero */ LddTimeRemaining = (uint32)GPT_ZERO; /* Updating the channel configuration parameter to the current channel */ LpChannelConfig = &Gpt_GpChannelConfig[LddChannel]; /* Updating the channel RAM data parameter to the current channel */ LpRamData = &Gpt_GpChannelRamData[LddChannel]; if (GPT_CH_NOTSTARTED != LpRamData->ucChannelStatus) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif /* Update the channel's base Gpt_TMU_LLDriver to local pointer */ LpTMUChannelRegs = LpChannelConfig->pBaseTCORAddress; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Assign the final return value */ /* The target value is decreased 1 in Gpt_HW_Tmu_StartTimer */ /* Thus Remaining Time is increased 1 */ LddTimeRemaining = (LpTMUChannelRegs->ulTMUnTCNT + (uint32)GPT_ONE); /* PRQA S 2814, 3383 # JV-01, JV-01 */ /* Expired Chack of current channel */ if (GPT_CH_MODE_ONESHOT == LpChannelConfig->ucGptChannelMode) { if ((GPT_CH_EXPIRED == LpRamData->ucChannelStatus) || ((LpTMUChannelRegs->usTMUnTCR & GPT_UNDERFLOW_MASK) != (uint16)GPT_ZERO)) { /* Set the return value to zero */ LddTimeRemaining = (uint32)GPT_ZERO; } /* else No action required */ } /* else No action required */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ return (LddTimeRemaining); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucGptChannelMode', 'Value': 'GPT_CH_MODE_ONESHOT'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pBaseTCORAddress', 'Value': '&map_pBaseTCORAddress[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ulTMUnTCNT', 'Value': '0x00000001'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'usTMUnTCR', 'Value': '0x0003'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_RUNNING']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_001': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddTimeRemaining', 'Value': '0x00000002'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PRIVATE_CODE #include \"Gpt_Mapping.h\" FUNC(void, GPT_PRIVATE_CODE) Gpt_HW_TPU_Init(void) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(volatile Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the Channel Ram Data */ P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA) LpRamData; /* PRQA S 3432 # JV-01 */ /* Pointer to locate the TPU register of a channel */ P2VAR(Gpt_ChannelRegs, AUTOMATIC, REGSPACE) LpTPUChannelRegs; /* PRQA S 3432 # JV-01 */ /* Intiate the local variable to mask the base address of the channel */ VAR(uint32, AUTOMATIC) LulBaseAddress; /* Intiate the local counter variable to count the channels */ VAR(volatile uint8, AUTOMATIC) LucCount; /* Initialize the TSTR address local variable*/ VAR(uint8, AUTOMATIC) LucTSTRAddressValue; /* Update the channel configuration pointer to point to the current channel */ LpChannelConfig = Gpt_GpChannelConfig; /* Updating the channel RamData parameter by global */ LpRamData = Gpt_GpChannelRamData; for (LucCount = GPT_ZERO; LucCount < GPT_TOTAL_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Update the local variable with the base Gpt_TPU_LLDriver of */ /* the configured channel */ LulBaseAddress = (uint32)(LpChannelConfig->pBaseTCRAddress); /* PRQA S 0306, 2814, 2844 # JV-01, JV-01, JV-01 */ /* Mask the first 3 bits of Timer Start Register*/ LucTSTRAddressValue = *LpChannelConfig->pTSTRAddress & GPT_TSTR_CHANNELS_CONTROL; /* PRQA S 0404 # JV-01 */ /* Reset the relative bit of the configured channel's in start register */ switch (LulBaseAddress & GPT_CHANNEL_BASE_ADRESS_MASK) { /* Stop the first channel of the timer */ case GPT_FIRST_CHANNEL_MASK: LucTSTRAddressValue &= (uint8)(~GPT_TSTR_FIRST_CHANNEL_MASK); break; /* Stop the second channel of the timer */ case GPT_SECOND_CHANNEL_MASK: LucTSTRAddressValue &= (uint8)(~GPT_TSTR_SECOND_CHANNEL_MASK); break; /* Stop the third channel of the timer */ case GPT_THIRD_CHANNEL_MASK: LucTSTRAddressValue &= (uint8)(~GPT_TSTR_THIRD_CHANNEL_MASK); break; /* Stop the four channel of the timer */ case GPT_FOUR_CHANNEL_MASK: LucTSTRAddressValue &= (uint8)(~GPT_TSTR_FOUR_CHANNEL_MASK); break; default: /*No action required */ break; } /* Assign the local variable value to the TSTR regiter */ *LpChannelConfig->pTSTRAddress &= LucTSTRAddressValue; /* Bring the base Gpt_TPU_LLDriver of the channel to local pointer */ LpTPUChannelRegs = LpChannelConfig->pBaseTCRAddress; switch (LpChannelConfig->ucGptTimerGeneralSelect) { case TPU_TGRA: /* Reset the Timer General TPUnTGRA Register of the configured channel */ LpTPUChannelRegs->usTPUnTGRA = GPT_INITIAL_GENERAL_REG; /* PRQA S 2814, 2844 # JV-01, JV-01 */ break; case TPU_TGRB: /* Reset the Timer General TPUnTGRB Register of the configured channel */ LpTPUChannelRegs->usTPUnTGRB = GPT_INITIAL_GENERAL_REG; break; case TPU_TGRC: /* Reset the Timer General TPUnTGRC Register of the configured channel */ LpTPUChannelRegs->usTPUnTGRC = GPT_INITIAL_GENERAL_REG; break; case TPU_TGRD: /* Reset the Timer General TPUnTGRD Register of the configured channel */ LpTPUChannelRegs->usTPUnTGRD = GPT_INITIAL_GENERAL_REG; break; default: /* No action required */ break; } /* Reset the Counter TPUnTCNT Register of the configured channel */ LpTPUChannelRegs->usTPUnTCNT = GPT_RESET_WORD; /* Reset timer interrupt control TIER register of the configured channel */ LpTPUChannelRegs->usTPUnTIER = GPT_RESET_BYTE; /* Clear the compare match flag in TSR register*/ LpTPUChannelRegs->usTPUnTSR = GPT_RESET_BYTE; /* Set the Prescaler bits */ LpTPUChannelRegs->usTPUnTCR = GPT_RESET_BYTE; LpTPUChannelRegs->usTPUnTCR |= (((uint16)(LpChannelConfig->ucTCRValue)) & ((uint16)GPT_TPUTCR_PRESCALER_BITS)); /* Ram data resetting for each channel */ #if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) /* Set the Notification status as GPT_FALSE */ LpRamData->blNotifyStatus = GPT_FALSE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #endif /* END of (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) */ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) /* Assign the Wakeup status to the Channel */ LpRamData->blWakeupStatus = GPT_FALSE; /* Clearing wakeup occurence status for all configured channels */ LpRamData->blWakeupOccurrence = GPT_FALSE; #endif /* GPT_REPORT_WAKEUP_SOURCE == STD_ON && \\ GPT_WAKEUP_FUNCTIONALITY_API == STD_ON */ /* Assign the timer status to the Channel */ LpRamData->ucChannelStatus = GPT_CH_NOTSTARTED; /* Increment the pointer to the next channel */ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ /* Increment the pointer to the next Ram data channel */ LpRamData++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ENABLE_DISABLE_NOTIFICATION_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_REPORT_WAKEUP_SOURCE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_WAKEUP_FUNCTIONALITY_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pBaseTCRAddress', 'Value': '[0]= &map_pBaseTCRAddress[0]\\n[1]= &map_pBaseTCRAddress[1]\\n[2]= &map_pBaseTCRAddress[2]\\n[3]= &map_pBaseTCRAddress[3]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRA', 'Value': '[0]= 0x0028\\n[1]= 0x0068\\n[2]= 0x00A8\\n[3]= 0x00E8'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRB', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRC', 'Value': '-'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRD', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pTSTRAddress', 'Value': '[0]= &map_pTSTRAddress[0]\\n[1]= &map_pTSTRAddress[1]\\n[2]= &map_pTSTRAddress[2]\\n[3]= &map_pTSTRAddress[3]'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'map_pTSTRAddress[0 to 3]', 'Value': '[0]= 0x00\\n[1]= 0x01\\n[2]= 0x07\\n[3]= 0x00'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucTCRValue', 'Value': '[0]= 0x1U\\n[1]= 0x1U\\n[2]= 0x1U\\n[3]= 0x0U'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ucGptTimerGeneralSelect', 'Value': '[0]= TPU_TGRA\\n[1]= TPU_TGRA\\n[2]= TPU_TGRA\\n[3]= TPU_TGRA'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTCR', 'Value': '[0]= 0x0010\\n[1]= 0x0050\\n[2]= 0x0090\\n[3]= 0x00D0'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTCNT', 'Value': '[0 to 3]= GPT_RESET_WORD'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTIER', 'Value': '[0 to 3]= GPT_RESET_BYTE'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTSR', 'Value': '[0 to 3]= GPT_RESET_BYTE'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '[0] = GPT_FALSE\\n[1] = GPT_FALSE\\n[2] = GPT_FALSE\\n[3] = GPT_FALSE'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupStatus', 'Value': '[0] = GPT_FALSE\\n[1] = GPT_FALSE\\n[2] = GPT_FALSE\\n[3] = GPT_FALSE'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupOccurrence', 'Value': '[0] = GPT_FALSE\\n[1] = GPT_FALSE\\n[2] = GPT_FALSE\\n[3] = GPT_FALSE'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[0] = GPT_CH_NOTSTARTED\\n[1] = GPT_CH_NOTSTARTED\\n[2] = GPT_CH_NOTSTARTED\\n[3] = GPT_CH_NOTSTARTED']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'map_pTSTRAddress[0 to 3]', 'Value': '[0]= 0x00\\n[1]= 0x01\\n[2]= 0x07\\n[3]= 0x00'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRA', 'Value': '[0 to 3]= GPT_INITIAL_CONSTANT_REG'], 'Output_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRB', 'Value': '-'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRC', 'Value': '-'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRD', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTCNT', 'Value': '[0 to 3]= GPT_RESET_WORD'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTIER', 'Value': '[0 to 3]= GPT_RESET_BYTE'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTSR', 'Value': '[0 to 3]= GPT_RESET_BYTE'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTCR', 'Value': '[0]= 0x0001\\n[1]= 0x0001\\n[2]= 0x0001\\n[3]= 0x0000'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '[0] = GPT_FALSE\\n[1] = GPT_FALSE\\n[2] = GPT_FALSE\\n[3] = GPT_FALSE'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupStatus', 'Value': '[0] = GPT_FALSE\\n[1] = GPT_FALSE\\n[2] = GPT_FALSE\\n[3] = GPT_FALSE'], 'Output_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupOccurrence', 'Value': '[0] = GPT_FALSE\\n[1] = GPT_FALSE\\n[2] = GPT_FALSE\\n[3] = GPT_FALSE'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[0] = GPT_CH_NOTSTARTED\\n[1] = GPT_CH_NOTSTARTED\\n[2] = GPT_CH_NOTSTARTED\\n[3] = GPT_CH_NOTSTARTED'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulWakeupSource', 'Value': '-'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_Init(P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_APPL_CONST) ConfigPtr) /* PRQA S 1503, 3432, 1532 # JV-01, JV-01, JV-01 */ { /* Index of loop count */ VAR(volatile uint8, AUTOMATIC) LucCount; /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Check if configure pointer is NULL pointer */ if (NULL_PTR == ConfigPtr) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_PARAM_POINTER); /* Set Return value */ LddReturnValue = E_NOT_OK; } else if ((NULL_PTR == ConfigPtr->pChannelConfig) || (NULL_PTR == ConfigPtr->pChannelRamData) /* PRQA S 2004 # JV-01 */ #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) || (NULL_PTR == ConfigPtr->pPredefTimerConfig) #endif ) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_INIT_FAILED); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ else { /* Use HWIP TMU or TPU*/ #if ((GPT_TIMER_IP_TMU == STD_ON) || (GPT_TIMER_IP_TPU == STD_ON)) if ((NULL_PTR == ConfigPtr->pChannelConfig->pTSTRAddress) || /* PRQA S 2814 # JV-01 */ #if (GPT_TIMER_IP_TMU == STD_ON) (NULL_PTR == ConfigPtr->pChannelConfig->pBaseTCORAddress)) #else /* GPT_TIMER_IP_TPU == STD_ON */ (NULL_PTR == ConfigPtr->pChannelConfig->pBaseTCRAddress)) #endif { /* Report to DET */ (void)Det_ReportError (GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_PARAM_POINTER); LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* end of GPT_TIMER_IP_TMU == STD_ON*/ } #if (GPT_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if the GPT Driver is already Initialized */ if (GPT_INITIALIZED == Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_ALREADY_INITIALIZED); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Check whether the existing database is correct */ if (GPT_DBTOC_VALUE == ConfigPtr->ulStartOfDbToc) /* PRQA S 2814 # JV-01 */ { /* Store the global pointer to first Channel Configuration */ Gpt_GpChannelConfig = (P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pChannelConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Store the global pointer to First Channel's Ram data */ Gpt_GpChannelRamData = (P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pChannelRamData; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) /* Store the global pointer to first Predef Timer Configuration */ Gpt_GpPredefTimerConfig = (P2CONST(Gpt_PredefTimerConfigType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pPredefTimerConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #endif for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_HW_IP_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { LucHWIPType = Gpt_GaaHWIP[LucCount].ucIndex; if (NULL_PTR != Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit(ConfigPtr); #else Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit(); #endif } /* else No action required */ } #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the Timer Type for given channel */ LucHWIPType = Gpt_GpChannelConfig[LucCount].ucTimerUnitType; if (NULL_PTR != Gpt_GaaHwFunc[LucHWIPType]->pHWChannelInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Gpt_GaaHwFunc[LucHWIPType]->pHWChannelInit((Gpt_ChannelType)LucCount); } /* else No action required */ } #endif #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer(); } /* else No action required */ } #endif /* Set Driver state to Initialized */ Gpt_SetStatus(GPT_INITIALIZED); /* Set the Driver Mode to Normal */ Gpt_GucDriverMode = (uint8)GPT_MODE_NORMAL; } /* End of ConfigPtr->ulStartOfDbToc) == GPT_DBTOC_VALUE */ else { #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_INVALID_DATABASE); #endif } } /* else No action required */ /* End of LddReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ALREADY_INIT_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pChannelConfig', 'Value': '&map_pChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pChannelRamData', 'Value': '&map_pChannelRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pTSTRAddress', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pBaseTCORAddress', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pPredefTimerConfig', 'Value': '&map_pPredefTimerConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelRamData[0]', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..0XFFFFFFF', 'Name': 'ulStartOfDbToc', 'Value': 'GPT_DBTOC_VALUE'], 'Input_Param_011': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '[0 to 72] = 0x02'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '&Gpt_GaaPredefTimerConfig[0] '], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '0x02'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]'], 'Input_Param_015': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pHWUnitInit', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_016': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pStartPredefTimer', 'Value': '[0 to 3] = &ISOLATE_void_func_ptr\\n'], 'Input_Param_017': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pHWChannelInit', 'Value': '[0 to 3] = NULL_PTR\\n'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'GPT_INITIALIZED\\nGPT_UNINITIALIZED', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_UNINITIALIZED'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaHWIP', 'Value': '&Gpt_GaaHWIP[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = GPT_HWIP_OSTM\\n[1] = GPT_HWIP_TAUD\\n[2] = GPT_HWIP_TAUJ\\n[3] = NULL_PTR'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigPtr', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_UNINITIALIZED'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_pChannelConfig[0]'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_pChannelRamData[0]'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpPredefTimerConfig', 'Value': '&map_pPredefTimerConfig[0]'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_NORMAL'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatusType', 'Value': 'GPT_INITIALIZED'], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_Init(P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_APPL_CONST) ConfigPtr) /* PRQA S 1503, 3432, 1532 # JV-01, JV-01, JV-01 */ { /* Index of loop count */ VAR(volatile uint8, AUTOMATIC) LucCount; /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Check if configure pointer is NULL pointer */ if (NULL_PTR == ConfigPtr) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_PARAM_POINTER); /* Set Return value */ LddReturnValue = E_NOT_OK; } else if ((NULL_PTR == ConfigPtr->pChannelConfig) || (NULL_PTR == ConfigPtr->pChannelRamData) /* PRQA S 2004 # JV-01 */ #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) || (NULL_PTR == ConfigPtr->pPredefTimerConfig) #endif ) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_INIT_FAILED); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ else { /* Use HWIP TMU or TPU*/ #if ((GPT_TIMER_IP_TMU == STD_ON) || (GPT_TIMER_IP_TPU == STD_ON)) if ((NULL_PTR == ConfigPtr->pChannelConfig->pTSTRAddress) || /* PRQA S 2814 # JV-01 */ #if (GPT_TIMER_IP_TMU == STD_ON) (NULL_PTR == ConfigPtr->pChannelConfig->pBaseTCORAddress)) #else /* GPT_TIMER_IP_TPU == STD_ON */ (NULL_PTR == ConfigPtr->pChannelConfig->pBaseTCRAddress)) #endif { /* Report to DET */ (void)Det_ReportError (GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_PARAM_POINTER); LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* end of GPT_TIMER_IP_TMU == STD_ON*/ } #if (GPT_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if the GPT Driver is already Initialized */ if (GPT_INITIALIZED == Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_ALREADY_INITIALIZED); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Check whether the existing database is correct */ if (GPT_DBTOC_VALUE == ConfigPtr->ulStartOfDbToc) /* PRQA S 2814 # JV-01 */ { /* Store the global pointer to first Channel Configuration */ Gpt_GpChannelConfig = (P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pChannelConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Store the global pointer to First Channel's Ram data */ Gpt_GpChannelRamData = (P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pChannelRamData; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) /* Store the global pointer to first Predef Timer Configuration */ Gpt_GpPredefTimerConfig = (P2CONST(Gpt_PredefTimerConfigType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pPredefTimerConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #endif for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_HW_IP_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { LucHWIPType = Gpt_GaaHWIP[LucCount].ucIndex; if (NULL_PTR != Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit(ConfigPtr); #else Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit(); #endif } /* else No action required */ } #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the Timer Type for given channel */ LucHWIPType = Gpt_GpChannelConfig[LucCount].ucTimerUnitType; if (NULL_PTR != Gpt_GaaHwFunc[LucHWIPType]->pHWChannelInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Gpt_GaaHwFunc[LucHWIPType]->pHWChannelInit((Gpt_ChannelType)LucCount); } /* else No action required */ } #endif #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer(); } /* else No action required */ } #endif /* Set Driver state to Initialized */ Gpt_SetStatus(GPT_INITIALIZED); /* Set the Driver Mode to Normal */ Gpt_GucDriverMode = (uint8)GPT_MODE_NORMAL; } /* End of ConfigPtr->ulStartOfDbToc) == GPT_DBTOC_VALUE */ else { #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_INVALID_DATABASE); #endif } } /* else No action required */ /* End of LddReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ALREADY_INIT_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pChannelConfig', 'Value': '&map_pChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pChannelRamData', 'Value': '&map_pChannelRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pTSTRAddress', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pBaseTCORAddress', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pPredefTimerConfig', 'Value': '&map_pPredefTimerConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelRamData[0]', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..0XFFFFFFF', 'Name': 'ulStartOfDbToc', 'Value': 'GPT_DBTOC_VALUE'], 'Input_Param_011': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '[0 to 67] = 0x01'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '&Gpt_GaaPredefTimerConfig[0] '], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '0x01'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]'], 'Input_Param_015': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pHWUnitInit', 'Value': '[0] = NULL_PTR\\n[1] = &ISOLATE_void_func_ptr_const_Gpt_ConfigType_p\\n[2] = NULL_PTR'], 'Input_Param_016': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pStartPredefTimer', 'Value': '[0 to 3] = NULL_PTR\\n'], 'Input_Param_017': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pHWChannelInit', 'Value': '[0] = NULL_PTR\\n[1] = &ISOLATE_void_func_ptr_Gpt_ChannelType\\n[2 to 3]= NULL_PTR'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'GPT_INITIALIZED\\nGPT_UNINITIALIZED', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_UNINITIALIZED'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaHWIP', 'Value': '&Gpt_GaaHWIP[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = GPT_HWIP_OSTM\\n[1] = GPT_HWIP_TAUD\\n[2] = GPT_HWIP_TAUJ\\n[3] = NULL_PTR'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '[0 to 67] = <Called>'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_UNINITIALIZED'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_pChannelConfig[0]'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_pChannelRamData[0]'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpPredefTimerConfig', 'Value': '&map_pPredefTimerConfig[0]'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_NORMAL'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatusType', 'Value': 'GPT_INITIALIZED'], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_Init(P2CONST(Gpt_ConfigType, AUTOMATIC, GPT_APPL_CONST) ConfigPtr) /* PRQA S 1503, 3432, 1532 # JV-01, JV-01, JV-01 */ { /* Index of loop count */ VAR(volatile uint8, AUTOMATIC) LucCount; /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Check if configure pointer is NULL pointer */ if (NULL_PTR == ConfigPtr) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_PARAM_POINTER); /* Set Return value */ LddReturnValue = E_NOT_OK; } else if ((NULL_PTR == ConfigPtr->pChannelConfig) || (NULL_PTR == ConfigPtr->pChannelRamData) /* PRQA S 2004 # JV-01 */ #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) || (NULL_PTR == ConfigPtr->pPredefTimerConfig) #endif ) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_INIT_FAILED); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ else { /* Use HWIP TMU or TPU*/ #if ((GPT_TIMER_IP_TMU == STD_ON) || (GPT_TIMER_IP_TPU == STD_ON)) if ((NULL_PTR == ConfigPtr->pChannelConfig->pTSTRAddress) || /* PRQA S 2814 # JV-01 */ #if (GPT_TIMER_IP_TMU == STD_ON) (NULL_PTR == ConfigPtr->pChannelConfig->pBaseTCORAddress)) #else /* GPT_TIMER_IP_TPU == STD_ON */ (NULL_PTR == ConfigPtr->pChannelConfig->pBaseTCRAddress)) #endif { /* Report to DET */ (void)Det_ReportError (GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_PARAM_POINTER); LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* end of GPT_TIMER_IP_TMU == STD_ON*/ } #if (GPT_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if the GPT Driver is already Initialized */ if (GPT_INITIALIZED == Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_ALREADY_INITIALIZED); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ #endif /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Check whether the existing database is correct */ if (GPT_DBTOC_VALUE == ConfigPtr->ulStartOfDbToc) /* PRQA S 2814 # JV-01 */ { /* Store the global pointer to first Channel Configuration */ Gpt_GpChannelConfig = (P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pChannelConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Store the global pointer to First Channel's Ram data */ Gpt_GpChannelRamData = (P2VAR(Gpt_ChannelRamDataType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pChannelRamData; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) /* Store the global pointer to first Predef Timer Configuration */ Gpt_GpPredefTimerConfig = (P2CONST(Gpt_PredefTimerConfigType, AUTOMATIC, GPT_CONFIG_DATA))ConfigPtr->pPredefTimerConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #endif for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_HW_IP_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { LucHWIPType = Gpt_GaaHWIP[LucCount].ucIndex; if (NULL_PTR != Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit(ConfigPtr); #else Gpt_GaaHwFunc[LucHWIPType]->pHWUnitInit(); #endif } /* else No action required */ } #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the Timer Type for given channel */ LucHWIPType = Gpt_GpChannelConfig[LucCount].ucTimerUnitType; if (NULL_PTR != Gpt_GaaHwFunc[LucHWIPType]->pHWChannelInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Gpt_GaaHwFunc[LucHWIPType]->pHWChannelInit((Gpt_ChannelType)LucCount); } /* else No action required */ } #endif #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer(); } /* else No action required */ } #endif /* Set Driver state to Initialized */ Gpt_SetStatus(GPT_INITIALIZED); /* Set the Driver Mode to Normal */ Gpt_GucDriverMode = (uint8)GPT_MODE_NORMAL; } /* End of ConfigPtr->ulStartOfDbToc) == GPT_DBTOC_VALUE */ else { #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_INIT_SID, GPT_E_INVALID_DATABASE); #endif } } /* else No action required */ /* End of LddReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ALREADY_INIT_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pChannelConfig', 'Value': '&map_pChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pChannelRamData', 'Value': '&map_pChannelRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pTSTRAddress', 'Value': '&map_pTSTRAddress[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pBaseTCORAddress', 'Value': '&map_pBaseTCORAddress[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pPredefTimerConfig', 'Value': 'NULL_PTR'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelRamData[0]', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..0XFFFFFFF', 'Name': 'ulStartOfDbToc', 'Value': '-'], 'Input_Param_011': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '&Gpt_GaaPredefTimerConfig[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '-'], 'Input_Param_015': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pHWUnitInit', 'Value': '-'], 'Input_Param_016': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_017': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pHWChannelInit', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'GPT_INITIALIZED\\nGPT_UNINITIALIZED', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaHWIP', 'Value': '&Gpt_GaaHWIP[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'GPT_MODULE_ID\\n'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'GPT_INSTANCE_ID\\n'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'GPT_INIT_SID\\n'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'GPT_E_INIT_FAILED'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'GPT_MODULE_ID\\n'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'GPT_INSTANCE_ID\\n'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'GPT_INIT_SID\\n'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'GPT_E_ALREADY_INITIALIZED'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigPtr', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': '-'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '-'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpPredefTimerConfig', 'Value': '-'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatusType', 'Value': '-'], 'Output_Param_026': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_SetMode(Gpt_ModeType Mode) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; /* Declare a Local variable to store Wakeup status */ VAR(uint8, AUTOMATIC) LucWakeupStatus; /* Declare a Local variable to store Channel Index */ VAR(uint8, AUTOMATIC) LucChannelID; #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) VAR(volatile uint8, AUTOMATIC) LucCount; #endif #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Check if the GPT Driver is initialized properly */ if (GPT_INITIALIZED != Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_UNINIT); /* Set Return value */ LddReturnValue = E_NOT_OK; } else { /* Check if the GPT mode is correct */ if ((GPT_MODE_NORMAL != Mode) && (GPT_MODE_SLEEP != Mode)) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_PARAM_MODE); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ } /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Updating the local pointer to Channel config data */ LpChannel = Gpt_GpChannelConfig; /* Check if the Mode is Sleep Mode */ if (GPT_MODE_SLEEP == Mode) { for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucWakeupStatus = (uint8)Gpt_GpChannelRamData[LucChannelID].blWakeupStatus; /* PRQA S 4304 # JV-01 */ /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* PRQA S 2824, 2844 # JV-01, JV-01 */ /* Check for disable wakeup status of a Channel */ if ((GPT_CH_RUNNING == Gpt_GpChannelRamData[LucChannelID].ucChannelStatus) && ((GPT_FALSE == (LpChannel[LucChannelID].blGptWakeupSupport)) || (GPT_FALSE == LucWakeupStatus)))/* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver to Stop the Particular Channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer(LucChannelID); } /* else No action required */ } /* else No action required */ /* Check for disable wakeup status */ if (GPT_FALSE == LucWakeupStatus) /* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup) /* PRQA S 2814 # JV-01 */ { /* Disable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup(LucChannelID); } /* else No action required */ } else /* LucWakeupStatus is GPT_TRUE */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup) { /* Enable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup(LucChannelID); } /* else No action required */ } } #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer(); } /* else No action required */ } #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ } /* In case of Mode == GPT_MODE_NORMAL */ else { #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) /* Only If the driver is in sleep mode, the function shall restart all enabled GPT PreDef Timers */ if ((uint8)GPT_MODE_SLEEP == Gpt_GucDriverMode) /* PRQA S 3416 # JV-01 */ { for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer(); } /* else No action required */ } } /* else No action required */ #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) #if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* Check for status of a Channel */ if ((NULL_PTR != Gpt_GpChannelConfig[LucChannelID].pGptNotificationPointer) && (GPT_TRUE == Gpt_GpChannelRamData[LucChannelID].blNotifyStatus)) { if (GPT_CH_MODE_CONTINUOUS == Gpt_GpChannelConfig[LucChannelID].ucGptChannelMode) { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt) /* PRQA S 2814 # JV-01 */ { /* Enable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } /* else No action required */ } else { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt) { /* Disable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } } #endif /* end of GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON */ #endif /* end of GPT_TIMER_IP_TMU == STD_OFF && GPT_TIMER_IP_TPU == STD_OFF*/ } /* Set the Mode to the Global variable */ Gpt_GucDriverMode = (uint8)Mode; } /* else No action required */ /* End of LddReturnValue == E_NOT_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ENABLE_DISABLE_NOTIFICATION_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Mode', 'Value': 'GPT_MODE_SLEEP'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '[0 to 72] = 0x02'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'blGptWakeupSupport', 'Value': '[0 to 72] = GPT_FALSE'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucGptChannelMode', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pGptNotificationPointer', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]\\n'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '&Gpt_GaaPredefTimerConfig[0] '], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupStatus', 'Value': '[0 to 72] = GPT_FALSE'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[0 to 72] = GPT_CH_EXPIRED\\n'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '-'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '[0 to 1] = 0x00\\n'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pStopTimer', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_018': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_021': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_024': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_025': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_027': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_028': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_030': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_031': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_033': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_034': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_036': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_037': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_039': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_040': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_042': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_043': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_045': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_046': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_048': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_049': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_051': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_052': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_053': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_054': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_055': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_056': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_057': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_058': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_059': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_060': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_061': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_062': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_063': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_064': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_065': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_066': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_067': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_068': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_069': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_070': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_071': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_072': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_073': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_074': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_075': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_076': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_077': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_078': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_079': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_080': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_081': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_082': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_083': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_084': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_085': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_086': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_087': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_088': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_089': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_090': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_091': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_092': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_093': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_094': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_095': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_096': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_097': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_098': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_099': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_100': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_101': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_102': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_103': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_104': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_105': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_106': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_107': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_108': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_109': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_110': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_111': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_112': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_113': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_114': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_115': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_116': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_117': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_118': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_119': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_120': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_121': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_122': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_123': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_124': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_125': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_126': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_127': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_128': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_129': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_130': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_131': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_132': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_133': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_134': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_135': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_136': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_137': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_138': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_139': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_140': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_141': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_142': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_143': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_144': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_145': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_146': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_147': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_148': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_149': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_150': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_151': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_152': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_153': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_154': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_155': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_156': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_157': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_158': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_159': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_160': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_161': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_162': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_163': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_164': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_165': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_166': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_167': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_168': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_169': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_170': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_171': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_172': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_173': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_174': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_175': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_176': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_177': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_178': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_179': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_180': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_181': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_182': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_183': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_184': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_185': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_186': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_187': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_188': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_189': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_190': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_191': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_192': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_193': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_194': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_195': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_196': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_197': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_198': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_199': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_200': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_201': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_202': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_203': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_204': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_205': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_206': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_207': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_208': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_209': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_210': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_211': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_212': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_213': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_214': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_215': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_216': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_217': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_218': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_219': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_220': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_221': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_222': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_223': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_224': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_225': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_226': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_227': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_228': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_229': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_230': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_231': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_232': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_233': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_234': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_235': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_236': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_237': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_238': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_239': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_240': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_241': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_SLEEP'], 'Output_Param_242': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_243': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_244': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_245': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_246': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_247': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_248': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_249': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_250': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_251': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_252': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_253': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_254': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_255': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_256': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_257': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_258': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_259': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_260': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_261': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_262': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_263': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_264': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_265': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_266': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_267': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_268': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_269': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_270': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_271': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_272': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_273': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_274': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_275': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_276': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_277': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_278': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_279': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_280': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_281': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_282': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_283': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_284': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_285': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_286': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_287': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_288': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_289': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_290': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_291': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_292': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_293': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_294': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_295': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_296': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_297': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_298': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_299': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_300': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_301': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_302': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_303': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_304': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_305': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_306': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_307': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_308': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_309': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_310': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_311': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_312': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_313': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_314': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_315': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_316': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_317': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_318': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_319': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_320': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_321': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_322': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_323': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_324': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_325': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_326': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_327': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_328': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_329': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_330': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_331': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_332': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_333': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_334': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_335': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_336': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_337': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_338': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_339': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_340': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_341': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_342': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_343': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_344': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_345': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_346': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_347': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_348': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_349': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_350': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_351': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_352': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_353': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_354': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_355': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_356': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_357': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_358': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_359': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_360': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_361': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_362': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_363': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_364': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_365': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_366': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_367': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_368': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_369': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_370': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_371': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_372': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_373': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_374': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_375': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_376': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_377': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_378': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_379': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_380': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_381': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_382': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_383': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_384': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_385': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_386': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_387': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_388': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_389': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_390': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_391': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_392': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_393': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_394': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_395': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_396': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_397': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_398': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_399': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_400': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_401': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_402': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_403': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_404': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_405': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_406': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_407': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_408': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_409': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_410': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_411': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_412': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_413': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_414': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_415': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_416': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_417': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_418': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_419': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_420': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_421': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_422': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_423': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_424': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_425': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_426': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_427': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_428': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_429': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_430': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_431': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_432': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_433': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_434': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_435': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_436': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_437': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_438': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_439': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_440': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_441': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_442': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_443': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_444': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_445': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_446': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_447': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_448': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_449': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_450': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_451': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_452': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_453': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_454': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_455': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_456': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_457': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_458': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_459': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_460': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_461': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_462': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_463': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_464': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_465': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_466': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_467': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_468': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_469': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_470': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_471': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_472': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_473': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_474': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_475': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_476': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_477': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_478': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_479': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_480': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_481': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_482': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_483': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_484': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_485': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_486': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_487': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_488': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_489': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_490': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_491': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_492': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_493': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_494': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_495': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_496': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_497': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_498': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_499': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_500': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_501': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_502': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_503': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_504': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_505': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_506': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_507': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_508': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_509': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_510': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_511': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_512': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_513': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_514': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_515': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_516': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_517': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_518': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_519': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_520': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_521': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_522': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_523': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_524': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_525': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_526': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_527': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_528': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_529': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_530': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_531': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_532': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_533': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_534': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_535': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_536': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_537': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_538': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_539': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_540': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_541': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_542': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_543': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_544': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_545': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_546': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_547': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_548': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_549': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_550': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_551': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_552': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_553': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_554': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_555': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_556': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_557': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_558': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_559': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_560': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_561': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_562': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_563': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_564': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_565': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_566': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_567': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_568': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_569': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_570': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_571': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_572': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_573': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_574': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_575': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_576': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_577': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_578': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_579': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_580': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_581': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_582': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_583': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_584': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_585': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_586': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_587': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_588': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_589': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_590': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_591': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_592': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_593': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_594': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_595': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_596': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_597': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_598': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_599': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_600': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_601': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_602': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_603': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_604': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_605': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_606': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_607': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_608': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_609': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_610': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_611': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_612': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_613': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_614': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_615': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_616': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_617': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_618': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_619': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_620': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_621': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_622': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_623': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_624': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_625': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_626': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_627': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_628': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_629': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_630': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_631': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_632': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_633': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_634': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_635': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_636': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_637': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_638': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_639': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_640': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_641': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_642': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_643': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_644': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_645': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_646': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_647': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_648': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_649': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_650': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_651': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_652': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_653': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_654': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_655': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_656': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_657': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_658': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_659': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_660': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_661': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_662': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_663': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_664': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_665': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_666': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_667': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_668': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_669': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_670': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_671': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_672': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_673': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_674': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_675': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_676': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_677': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_678': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_679': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_680': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_681': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_682': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_683': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_684': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_685': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_686': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_687': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_688': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_689': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_690': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_691': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_692': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_693': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_694': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_695': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_696': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_697': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_698': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_699': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_700': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_701': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_702': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_703': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_704': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_705': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Output_Param_706': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_707': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_SetMode(Gpt_ModeType Mode) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; /* Declare a Local variable to store Wakeup status */ VAR(uint8, AUTOMATIC) LucWakeupStatus; /* Declare a Local variable to store Channel Index */ VAR(uint8, AUTOMATIC) LucChannelID; #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) VAR(volatile uint8, AUTOMATIC) LucCount; #endif #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Check if the GPT Driver is initialized properly */ if (GPT_INITIALIZED != Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_UNINIT); /* Set Return value */ LddReturnValue = E_NOT_OK; } else { /* Check if the GPT mode is correct */ if ((GPT_MODE_NORMAL != Mode) && (GPT_MODE_SLEEP != Mode)) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_PARAM_MODE); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ } /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Updating the local pointer to Channel config data */ LpChannel = Gpt_GpChannelConfig; /* Check if the Mode is Sleep Mode */ if (GPT_MODE_SLEEP == Mode) { for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucWakeupStatus = (uint8)Gpt_GpChannelRamData[LucChannelID].blWakeupStatus; /* PRQA S 4304 # JV-01 */ /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* PRQA S 2824, 2844 # JV-01, JV-01 */ /* Check for disable wakeup status of a Channel */ if ((GPT_CH_RUNNING == Gpt_GpChannelRamData[LucChannelID].ucChannelStatus) && ((GPT_FALSE == (LpChannel[LucChannelID].blGptWakeupSupport)) || (GPT_FALSE == LucWakeupStatus)))/* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver to Stop the Particular Channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer(LucChannelID); } /* else No action required */ } /* else No action required */ /* Check for disable wakeup status */ if (GPT_FALSE == LucWakeupStatus) /* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup) /* PRQA S 2814 # JV-01 */ { /* Disable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup(LucChannelID); } /* else No action required */ } else /* LucWakeupStatus is GPT_TRUE */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup) { /* Enable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup(LucChannelID); } /* else No action required */ } } #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer(); } /* else No action required */ } #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ } /* In case of Mode == GPT_MODE_NORMAL */ else { #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) /* Only If the driver is in sleep mode, the function shall restart all enabled GPT PreDef Timers */ if ((uint8)GPT_MODE_SLEEP == Gpt_GucDriverMode) /* PRQA S 3416 # JV-01 */ { for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer(); } /* else No action required */ } } /* else No action required */ #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) #if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* Check for status of a Channel */ if ((NULL_PTR != Gpt_GpChannelConfig[LucChannelID].pGptNotificationPointer) && (GPT_TRUE == Gpt_GpChannelRamData[LucChannelID].blNotifyStatus)) { if (GPT_CH_MODE_CONTINUOUS == Gpt_GpChannelConfig[LucChannelID].ucGptChannelMode) { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt) /* PRQA S 2814 # JV-01 */ { /* Enable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } /* else No action required */ } else { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt) { /* Disable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } } #endif /* end of GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON */ #endif /* end of GPT_TIMER_IP_TMU == STD_OFF && GPT_TIMER_IP_TPU == STD_OFF*/ } /* Set the Mode to the Global variable */ Gpt_GucDriverMode = (uint8)Mode; } /* else No action required */ /* End of LddReturnValue == E_NOT_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ENABLE_DISABLE_NOTIFICATION_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Mode', 'Value': 'GPT_MODE_NORMAL'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_NORMAL'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '[0 to 76] = 0x00'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'blGptWakeupSupport', 'Value': '[0 to 76] = GPT_FALSE\\n'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucGptChannelMode', 'Value': '[0 to 76] = GPT_CH_MODE_CONTINUOUS'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pGptNotificationPointer', 'Value': '[0 to 76] = &ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]\\n'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '&Gpt_GaaPredefTimerConfig[0] '], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupStatus', 'Value': '[0 to 76] = GPT_FALSE\\n'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[0 to 76] = GPT_CH_RUNNING\\n'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '[0 to 76] = GPT_TRUE'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pStopTimer', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '[0 to 3] = NULL_PTR\\n'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '[0] = &ISOLATE_void_func_ptr_Gpt_ChannelType\\n[1 to 3] = NULL_PTR'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_018': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_021': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_024': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_025': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_027': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_028': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_030': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_031': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_033': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_034': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_036': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_037': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_039': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_040': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_042': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_043': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_045': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_046': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_048': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_049': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_051': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_052': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_053': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_054': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_055': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_056': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_057': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_058': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_059': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_060': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_061': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_062': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_063': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_064': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_065': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_066': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_067': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_068': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_069': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_070': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_071': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_072': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_073': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_074': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_075': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_076': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_077': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_078': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_079': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_080': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_081': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_082': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_083': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_084': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_085': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_086': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_087': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_088': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_089': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_090': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_091': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_092': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_093': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_094': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_095': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_096': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_097': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_098': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_099': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_100': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_101': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_102': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_103': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_104': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_105': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_106': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_107': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_108': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_109': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_110': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_111': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_112': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_113': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_114': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_115': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_116': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_117': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_118': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_119': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_120': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_121': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_122': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_123': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_124': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_125': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_126': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_127': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_128': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_129': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_130': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_131': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_132': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_133': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_134': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_135': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_136': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_137': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_138': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_139': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_140': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_141': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_142': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_143': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_144': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_145': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_146': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_147': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_148': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_149': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_150': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_151': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_152': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_153': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_154': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_155': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_156': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_157': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_158': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_159': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_160': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_161': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_162': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_163': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_164': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_165': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_166': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_167': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_168': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_169': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_170': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_171': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_172': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_173': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_174': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_175': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_176': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_177': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_178': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_179': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_180': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_181': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_182': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_183': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_184': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_185': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_186': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_187': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_188': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_189': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_190': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_191': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_192': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_193': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_194': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_195': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_196': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_197': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_198': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_199': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_200': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_201': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_202': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_203': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_204': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_205': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_206': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_207': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_208': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_209': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_210': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_211': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_212': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_213': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_214': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_215': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_216': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_217': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_218': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_219': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_220': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_221': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_222': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_223': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_224': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_225': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_226': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_227': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_228': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_229': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_230': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_231': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_232': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_233': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_234': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_235': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_236': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_237': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_238': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_239': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_240': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_241': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_NORMAL'], 'Output_Param_242': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_243': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_244': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_245': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_246': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_247': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_248': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_249': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_250': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_251': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_252': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_253': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_254': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_255': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_256': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_257': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_258': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_259': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_260': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_261': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_262': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_263': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_264': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_265': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_266': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_267': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_268': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_269': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_270': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_271': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_272': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_273': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_274': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_275': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_276': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_277': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_278': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_279': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_280': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_281': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_282': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_283': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_284': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_285': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_286': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_287': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_288': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_289': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_290': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_291': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_292': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_293': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_294': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_295': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_296': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_297': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_298': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_299': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_300': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_301': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_302': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_303': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_304': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_305': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_306': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_307': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_308': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_309': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_310': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_311': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_312': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_313': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_314': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_315': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_316': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_317': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_318': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_319': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_320': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_321': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_322': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_323': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_324': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_325': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_326': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_327': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_328': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_329': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_330': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_331': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_332': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_333': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_334': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_335': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_336': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_337': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_338': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_339': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_340': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_341': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_342': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_343': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_344': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_345': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_346': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_347': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_348': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_349': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_350': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_351': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_352': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_353': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_354': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_355': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_356': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_357': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_358': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_359': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_360': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_361': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_362': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_363': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_364': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_365': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_366': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_367': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_368': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_369': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_370': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_371': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_372': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_373': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_374': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_375': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_376': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_377': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_378': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_379': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_380': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_381': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_382': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_383': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_384': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_385': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_386': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_387': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_388': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_389': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_390': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_391': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_392': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_393': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_394': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_395': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_396': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_397': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_398': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_399': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_400': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_401': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_402': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_403': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_404': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_405': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_406': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_407': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_408': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_409': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_410': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_411': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_412': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_413': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_414': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_415': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_416': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_417': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_418': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_419': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_420': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_421': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_422': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_423': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_424': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_425': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_426': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_427': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_428': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_429': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_430': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_431': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_432': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_433': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_434': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_435': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_436': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_437': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_438': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_439': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_440': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_441': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_442': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_443': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_444': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_445': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_446': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_447': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_448': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_449': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_450': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_451': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_452': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_453': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_454': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_455': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_456': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_457': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_458': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_459': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_460': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_461': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_462': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_463': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_464': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_465': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_466': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_467': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_468': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_469': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_470': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_471': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_472': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_473': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_474': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_475': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_476': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_477': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_478': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_479': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_480': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_481': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_482': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_483': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_484': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_485': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_486': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_487': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_488': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_489': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_490': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_491': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_492': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_493': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_494': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_495': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_496': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_497': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_498': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_499': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_500': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_501': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_502': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_503': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_504': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_505': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_506': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_507': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_508': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_509': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_510': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_511': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_512': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_513': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_514': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_515': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_516': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_517': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_518': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_519': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_520': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_521': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_522': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_523': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_524': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_525': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_526': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_527': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_528': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_529': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_530': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_531': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_532': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_533': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_534': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_535': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_536': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_537': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_538': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_539': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_540': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_541': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_542': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_543': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_544': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_545': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_546': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_547': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_548': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_549': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_550': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_551': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_552': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_553': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_554': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_555': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_556': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_557': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_558': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_559': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_560': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_561': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_562': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_563': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_564': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_565': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_566': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_567': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_568': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_569': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_570': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_571': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_572': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_573': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_574': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_575': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_576': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_577': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_578': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_579': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_580': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_581': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_582': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_583': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_584': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_585': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_586': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_587': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_588': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_589': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_590': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_591': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_592': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_593': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_594': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_595': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_596': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_597': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_598': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_599': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_600': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_601': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_602': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_603': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_604': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_605': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_606': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_607': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_608': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_609': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_610': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_611': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_612': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_613': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_614': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_615': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_616': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_617': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_618': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_619': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_620': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_621': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_622': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_623': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_624': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_625': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_626': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_627': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_628': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_629': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_630': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_631': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_632': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_633': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_634': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_635': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_636': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_637': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_638': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_639': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_640': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_641': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_642': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_643': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_644': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_645': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_646': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_647': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_648': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_649': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_650': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_651': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_652': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_653': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_654': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_655': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_656': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_657': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_658': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_659': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_660': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_661': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_662': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_663': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_664': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_665': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_666': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_667': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_668': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_669': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_670': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_671': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_672': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_673': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_674': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_675': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_676': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_677': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_678': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_679': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_680': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_681': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_682': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_683': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_684': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_685': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_686': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_687': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_688': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_689': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_690': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_691': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_692': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_693': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_694': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_695': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_696': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_697': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_698': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_699': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_700': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_701': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_702': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_703': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_704': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_705': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Output_Param_706': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_707': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_SetMode(Gpt_ModeType Mode) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; /* Declare a Local variable to store Wakeup status */ VAR(uint8, AUTOMATIC) LucWakeupStatus; /* Declare a Local variable to store Channel Index */ VAR(uint8, AUTOMATIC) LucChannelID; #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) VAR(volatile uint8, AUTOMATIC) LucCount; #endif #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Check if the GPT Driver is initialized properly */ if (GPT_INITIALIZED != Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_UNINIT); /* Set Return value */ LddReturnValue = E_NOT_OK; } else { /* Check if the GPT mode is correct */ if ((GPT_MODE_NORMAL != Mode) && (GPT_MODE_SLEEP != Mode)) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_PARAM_MODE); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ } /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Updating the local pointer to Channel config data */ LpChannel = Gpt_GpChannelConfig; /* Check if the Mode is Sleep Mode */ if (GPT_MODE_SLEEP == Mode) { for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucWakeupStatus = (uint8)Gpt_GpChannelRamData[LucChannelID].blWakeupStatus; /* PRQA S 4304 # JV-01 */ /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* PRQA S 2824, 2844 # JV-01, JV-01 */ /* Check for disable wakeup status of a Channel */ if ((GPT_CH_RUNNING == Gpt_GpChannelRamData[LucChannelID].ucChannelStatus) && ((GPT_FALSE == (LpChannel[LucChannelID].blGptWakeupSupport)) || (GPT_FALSE == LucWakeupStatus)))/* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver to Stop the Particular Channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer(LucChannelID); } /* else No action required */ } /* else No action required */ /* Check for disable wakeup status */ if (GPT_FALSE == LucWakeupStatus) /* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup) /* PRQA S 2814 # JV-01 */ { /* Disable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup(LucChannelID); } /* else No action required */ } else /* LucWakeupStatus is GPT_TRUE */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup) { /* Enable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup(LucChannelID); } /* else No action required */ } } #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer(); } /* else No action required */ } #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ } /* In case of Mode == GPT_MODE_NORMAL */ else { #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) /* Only If the driver is in sleep mode, the function shall restart all enabled GPT PreDef Timers */ if ((uint8)GPT_MODE_SLEEP == Gpt_GucDriverMode) /* PRQA S 3416 # JV-01 */ { for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer(); } /* else No action required */ } } /* else No action required */ #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) #if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* Check for status of a Channel */ if ((NULL_PTR != Gpt_GpChannelConfig[LucChannelID].pGptNotificationPointer) && (GPT_TRUE == Gpt_GpChannelRamData[LucChannelID].blNotifyStatus)) { if (GPT_CH_MODE_CONTINUOUS == Gpt_GpChannelConfig[LucChannelID].ucGptChannelMode) { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt) /* PRQA S 2814 # JV-01 */ { /* Enable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } /* else No action required */ } else { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt) { /* Disable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } } #endif /* end of GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON */ #endif /* end of GPT_TIMER_IP_TMU == STD_OFF && GPT_TIMER_IP_TPU == STD_OFF*/ } /* Set the Mode to the Global variable */ Gpt_GucDriverMode = (uint8)Mode; } /* else No action required */ /* End of LddReturnValue == E_NOT_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ENABLE_DISABLE_NOTIFICATION_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Mode', 'Value': 'GPT_MODE_NORMAL'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_SLEEP'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '[0 to 47] = 0x00'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'blGptWakeupSupport', 'Value': '[0 to 47] = GPT_FALSE\\n'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucGptChannelMode', 'Value': '[0 to 47] = GPT_CH_MODE_CONTINUOUS'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pGptNotificationPointer', 'Value': '[0 to 47] = &ISOLATE_void_func_ptr'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]\\n'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupStatus', 'Value': '[0 to 47] = GPT_FALSE'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[0 to 47] = GPT_CH_RUNNING\\n'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '[0 to 47] = GPT_TRUE'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pStopTimer', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '[3] = &ISOLATE_void_func_ptr_Gpt_ChannelType\\n[0 to 2] = NULL_PTR'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_018': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_021': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_024': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_025': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_027': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_028': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_030': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_031': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_033': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_034': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_036': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_037': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_039': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_040': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_042': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_043': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_045': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_046': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_048': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_049': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_051': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_052': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_053': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_054': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_055': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_056': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_057': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_058': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_059': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_060': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_061': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_062': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_063': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_064': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_065': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_066': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_067': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_068': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_069': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_070': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_071': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_072': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_073': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_074': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_075': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_076': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_077': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_078': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_079': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_080': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_081': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_082': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_083': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_084': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_085': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_086': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_087': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_088': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_089': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_090': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_091': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_092': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_093': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_094': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_095': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_096': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_097': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_098': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_099': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_100': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_101': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_102': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_103': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_104': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_105': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_106': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_107': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_108': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_109': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_110': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_111': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_112': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_113': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_114': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_115': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_116': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_117': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_118': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_119': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_120': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_121': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_122': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_123': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_124': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_125': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_126': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_127': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_128': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_129': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_130': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_131': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_132': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_133': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_134': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_135': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_136': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_137': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_138': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_139': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_140': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_141': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_142': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_143': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_144': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_145': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_146': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_147': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_148': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_149': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_150': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_151': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_152': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_153': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_154': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_155': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_156': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_157': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_158': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_159': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_160': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_161': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_162': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_163': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_164': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_165': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_166': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_167': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_168': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_169': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_170': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_171': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_172': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_173': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_174': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_175': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_176': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_177': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_178': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_179': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_180': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_181': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_182': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_183': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_184': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_185': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_186': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_187': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_188': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_189': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_190': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_191': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_192': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_193': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_194': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_195': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_196': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_197': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_198': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_199': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_200': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_201': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_202': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_203': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_204': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_205': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_206': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_207': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_208': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_209': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_210': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_211': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_212': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_213': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_214': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_215': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_216': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_217': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_218': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_219': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_220': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_221': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_222': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_223': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_224': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_225': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_226': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_227': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_228': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_229': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_230': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_231': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_232': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_233': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_234': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_235': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_236': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_237': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_238': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_239': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_240': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_241': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_NORMAL'], 'Output_Param_242': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_243': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_244': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_245': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_246': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_247': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_248': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_249': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_250': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_251': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_252': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_253': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_254': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_255': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_256': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_257': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_258': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_259': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_260': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_261': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_262': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_263': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_264': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_265': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_266': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_267': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_268': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_269': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_270': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_271': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_272': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_273': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_274': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_275': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_276': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_277': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_278': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_279': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_280': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_281': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_282': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_283': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_284': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_285': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_286': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_287': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_288': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_289': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_290': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_291': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_292': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_293': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_294': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_295': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_296': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_297': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_298': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_299': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_300': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_301': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_302': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_303': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_304': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_305': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_306': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_307': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_308': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_309': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_310': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_311': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_312': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_313': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_314': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_315': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_316': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_317': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_318': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_319': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_320': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_321': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_322': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_323': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_324': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_325': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_326': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_327': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_328': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_329': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_330': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_331': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_332': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_333': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_334': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_335': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_336': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_337': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_338': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_339': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_340': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_341': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_342': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_343': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_344': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_345': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_346': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_347': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_348': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_349': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_350': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_351': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_352': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_353': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_354': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_355': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_356': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_357': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_358': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_359': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_360': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_361': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_362': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_363': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_364': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_365': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_366': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_367': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_368': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_369': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_370': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_371': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_372': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_373': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_374': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_375': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_376': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_377': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_378': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_379': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_380': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_381': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_382': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_383': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_384': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_385': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_386': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_387': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_388': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_389': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_390': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_391': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_392': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_393': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_394': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_395': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_396': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_397': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_398': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_399': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_400': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_401': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_402': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_403': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_404': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_405': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_406': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_407': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_408': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_409': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_410': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_411': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_412': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_413': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_414': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_415': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_416': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_417': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_418': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_419': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_420': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_421': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_422': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_423': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_424': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_425': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_426': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_427': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_428': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_429': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_430': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_431': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_432': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_433': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_434': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_435': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_436': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_437': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_438': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_439': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_440': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_441': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_442': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_443': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_444': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_445': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_446': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_447': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_448': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_449': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_450': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_451': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_452': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_453': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_454': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_455': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_456': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_457': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_458': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_459': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_460': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_461': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_462': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_463': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_464': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_465': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_466': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_467': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_468': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_469': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_470': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_471': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_472': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_473': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_474': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_475': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_476': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_477': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_478': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_479': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_480': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_481': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_482': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_483': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_484': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_485': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_486': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_487': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_488': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_489': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_490': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_491': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_492': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_493': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_494': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_495': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_496': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_497': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_498': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_499': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_500': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_501': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_502': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_503': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_504': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_505': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_506': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_507': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_508': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_509': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_510': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_511': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_512': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_513': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_514': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_515': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_516': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_517': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_518': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_519': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_520': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_521': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_522': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_523': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_524': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_525': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_526': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_527': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_528': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_529': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_530': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_531': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_532': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_533': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_534': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_535': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_536': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_537': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_538': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_539': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_540': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_541': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_542': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_543': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_544': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_545': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_546': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_547': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_548': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_549': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_550': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_551': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_552': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_553': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_554': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_555': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_556': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_557': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_558': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_559': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_560': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_561': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_562': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_563': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_564': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_565': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_566': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_567': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_568': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_569': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_570': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_571': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_572': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_573': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_574': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_575': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_576': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_577': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_578': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_579': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_580': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_581': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_582': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_583': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_584': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_585': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_586': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_587': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_588': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_589': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_590': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_591': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_592': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_593': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_594': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_595': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_596': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_597': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_598': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_599': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_600': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_601': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_602': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_603': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_604': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_605': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_606': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_607': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_608': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_609': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_610': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_611': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_612': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_613': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_614': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_615': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_616': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_617': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_618': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_619': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_620': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_621': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_622': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_623': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_624': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_625': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_626': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_627': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_628': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_629': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_630': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_631': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_632': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_633': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_634': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_635': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_636': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_637': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_638': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_639': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_640': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_641': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_642': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_643': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_644': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_645': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_646': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_647': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_648': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_649': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_650': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_651': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_652': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_653': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_654': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_655': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_656': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_657': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_658': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_659': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_660': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_661': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_662': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_663': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_664': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_665': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_666': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_667': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_668': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_669': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_670': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_671': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_672': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_673': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_674': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_675': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_676': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_677': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_678': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_679': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_680': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_681': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_682': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_683': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_684': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_685': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_686': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_687': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_688': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_689': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_690': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_691': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_692': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_693': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_694': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_695': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_696': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_697': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_698': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_699': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_700': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_701': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_702': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_703': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_704': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_705': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Output_Param_706': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_707': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_SetMode(Gpt_ModeType Mode) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; /* Declare a Local variable to store Wakeup status */ VAR(uint8, AUTOMATIC) LucWakeupStatus; /* Declare a Local variable to store Channel Index */ VAR(uint8, AUTOMATIC) LucChannelID; #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) VAR(volatile uint8, AUTOMATIC) LucCount; #endif #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Check if the GPT Driver is initialized properly */ if (GPT_INITIALIZED != Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_UNINIT); /* Set Return value */ LddReturnValue = E_NOT_OK; } else { /* Check if the GPT mode is correct */ if ((GPT_MODE_NORMAL != Mode) && (GPT_MODE_SLEEP != Mode)) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_PARAM_MODE); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ } /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Updating the local pointer to Channel config data */ LpChannel = Gpt_GpChannelConfig; /* Check if the Mode is Sleep Mode */ if (GPT_MODE_SLEEP == Mode) { for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucWakeupStatus = (uint8)Gpt_GpChannelRamData[LucChannelID].blWakeupStatus; /* PRQA S 4304 # JV-01 */ /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* PRQA S 2824, 2844 # JV-01, JV-01 */ /* Check for disable wakeup status of a Channel */ if ((GPT_CH_RUNNING == Gpt_GpChannelRamData[LucChannelID].ucChannelStatus) && ((GPT_FALSE == (LpChannel[LucChannelID].blGptWakeupSupport)) || (GPT_FALSE == LucWakeupStatus)))/* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver to Stop the Particular Channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer(LucChannelID); } /* else No action required */ } /* else No action required */ /* Check for disable wakeup status */ if (GPT_FALSE == LucWakeupStatus) /* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup) /* PRQA S 2814 # JV-01 */ { /* Disable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup(LucChannelID); } /* else No action required */ } else /* LucWakeupStatus is GPT_TRUE */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup) { /* Enable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup(LucChannelID); } /* else No action required */ } } #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer(); } /* else No action required */ } #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ } /* In case of Mode == GPT_MODE_NORMAL */ else { #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) /* Only If the driver is in sleep mode, the function shall restart all enabled GPT PreDef Timers */ if ((uint8)GPT_MODE_SLEEP == Gpt_GucDriverMode) /* PRQA S 3416 # JV-01 */ { for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer(); } /* else No action required */ } } /* else No action required */ #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) #if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* Check for status of a Channel */ if ((NULL_PTR != Gpt_GpChannelConfig[LucChannelID].pGptNotificationPointer) && (GPT_TRUE == Gpt_GpChannelRamData[LucChannelID].blNotifyStatus)) { if (GPT_CH_MODE_CONTINUOUS == Gpt_GpChannelConfig[LucChannelID].ucGptChannelMode) { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt) /* PRQA S 2814 # JV-01 */ { /* Enable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } /* else No action required */ } else { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt) { /* Disable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } } #endif /* end of GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON */ #endif /* end of GPT_TIMER_IP_TMU == STD_OFF && GPT_TIMER_IP_TPU == STD_OFF*/ } /* Set the Mode to the Global variable */ Gpt_GucDriverMode = (uint8)Mode; } /* else No action required */ /* End of LddReturnValue == E_NOT_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ENABLE_DISABLE_NOTIFICATION_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Mode', 'Value': 'GPT_MODE_SLEEP'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '[0 to 47] = 0x00'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'blGptWakeupSupport', 'Value': '[0 to 47] = GPT_FALSE\\n'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucGptChannelMode', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pGptNotificationPointer', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]\\n'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupStatus', 'Value': '[0 to 47] = GPT_TRUE'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[0 to 47] = GPT_CH_RUNNING\\n'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '-'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pStopTimer', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_018': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_021': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_024': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_025': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_027': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_028': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_030': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_031': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_033': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_034': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_036': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_037': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_039': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_040': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_042': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_043': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_045': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_046': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_048': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_049': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_051': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_052': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_053': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_054': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_055': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_056': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_057': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_058': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_059': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_060': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_061': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_062': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_063': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_064': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_065': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_066': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_067': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_068': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_069': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_070': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_071': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_072': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_073': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_074': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_075': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_076': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_077': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_078': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_079': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_080': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_081': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_082': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_083': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_084': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_085': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_086': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_087': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_088': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_089': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_090': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_091': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_092': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_093': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_094': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_095': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_096': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_097': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_098': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_099': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_100': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_101': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_102': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_103': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_104': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_105': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_106': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_107': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_108': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_109': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_110': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_111': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_112': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_113': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_114': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_115': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_116': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_117': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_118': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_119': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_120': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_121': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_122': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_123': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_124': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_125': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_126': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_127': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_128': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_129': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_130': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_131': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_132': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_133': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_134': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_135': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_136': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_137': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_138': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_139': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_140': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_141': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_142': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_143': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_144': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_145': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_146': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_147': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_148': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_149': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_150': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_151': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_152': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_153': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_154': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_155': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_156': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_157': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_158': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_159': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_160': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_161': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_162': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_163': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_164': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_165': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_166': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_167': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_168': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_169': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_170': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_171': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_172': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_173': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_174': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_175': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_176': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_177': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_178': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_179': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_180': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_181': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_182': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_183': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_184': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_185': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_186': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_187': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_188': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_189': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_190': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_191': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_192': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_193': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_194': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_195': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_196': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_197': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_198': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_199': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_200': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_201': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_202': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_203': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_204': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_205': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_206': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_207': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_208': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_209': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_210': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_211': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_212': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_213': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_214': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_215': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_216': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_217': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_218': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_219': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_220': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_221': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_222': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_223': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_224': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_225': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_226': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_227': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_228': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_229': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_230': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_231': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_232': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_233': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_234': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_235': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_236': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_237': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_238': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_239': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_240': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_241': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_SLEEP'], 'Output_Param_242': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_243': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_244': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_245': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_246': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_247': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_248': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_249': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_250': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_251': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_252': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_253': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_254': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_255': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_256': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_257': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_258': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_259': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_260': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_261': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_262': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_263': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_264': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_265': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_266': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_267': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_268': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_269': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_270': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_271': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_272': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_273': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_274': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_275': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_276': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_277': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_278': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_279': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_280': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_281': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_282': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_283': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_284': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_285': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_286': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_287': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_288': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_289': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_290': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_291': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_292': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_293': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_294': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_295': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_296': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_297': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_298': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_299': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_300': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_301': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_302': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_303': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_304': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_305': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_306': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_307': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_308': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_309': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_310': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_311': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_312': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_313': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_314': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_315': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_316': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_317': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_318': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_319': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_320': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_321': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_322': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_323': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_324': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_325': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_326': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_327': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_328': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_329': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_330': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_331': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_332': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_333': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_334': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_335': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_336': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_337': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_338': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_339': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_340': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_341': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_342': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_343': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_344': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_345': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_346': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_347': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_348': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_349': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_350': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_351': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_352': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_353': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_354': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_355': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_356': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_357': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_358': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_359': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_360': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_361': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_362': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_363': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_364': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_365': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_366': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_367': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_368': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_369': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_370': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_371': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_372': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_373': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_374': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_375': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_376': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_377': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_378': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_379': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_380': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_381': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_382': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_383': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_384': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_385': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_386': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_387': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_388': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_389': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_390': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_391': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_392': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_393': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_394': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_395': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_396': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_397': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_398': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_399': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_400': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_401': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_402': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_403': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_404': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_405': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_406': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_407': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_408': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_409': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_410': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_411': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_412': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_413': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_414': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_415': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_416': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_417': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_418': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_419': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_420': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_421': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_422': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_423': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_424': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_425': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_426': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_427': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_428': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_429': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_430': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_431': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_432': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_433': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_434': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_435': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_436': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_437': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_438': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_439': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_440': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_441': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_442': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_443': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_444': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_445': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_446': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_447': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_448': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_449': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_450': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_451': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_452': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_453': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_454': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_455': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_456': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_457': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_458': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_459': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_460': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_461': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_462': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_463': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_464': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_465': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_466': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_467': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_468': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_469': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_470': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_471': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_472': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_473': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_474': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_475': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_476': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_477': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_478': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_479': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_480': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_481': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_482': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_483': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_484': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_485': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_486': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_487': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_488': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_489': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_490': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_491': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_492': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_493': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_494': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_495': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_496': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_497': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_498': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_499': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_500': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_501': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_502': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_503': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_504': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_505': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_506': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_507': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_508': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_509': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_510': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_511': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_512': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_513': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_514': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_515': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_516': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_517': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_518': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_519': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_520': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_521': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_522': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_523': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_524': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_525': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_526': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_527': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_528': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_529': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_530': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_531': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_532': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_533': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_534': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_535': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_536': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_537': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_538': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_539': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_540': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_541': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_542': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_543': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_544': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_545': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_546': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_547': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_548': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_549': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_550': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_551': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_552': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_553': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_554': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_555': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_556': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_557': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_558': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_559': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_560': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_561': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_562': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_563': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_564': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_565': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_566': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_567': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_568': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_569': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_570': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_571': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_572': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_573': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_574': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_575': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_576': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_577': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_578': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_579': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_580': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_581': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_582': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_583': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_584': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_585': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_586': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_587': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_588': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_589': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_590': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_591': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_592': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_593': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_594': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_595': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_596': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_597': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_598': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_599': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_600': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_601': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_602': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_603': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_604': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_605': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_606': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_607': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_608': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_609': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_610': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_611': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_612': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_613': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_614': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_615': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_616': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_617': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_618': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_619': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_620': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_621': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_622': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_623': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_624': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_625': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_626': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_627': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_628': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_629': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_630': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_631': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_632': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_633': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_634': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_635': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_636': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_637': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_638': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_639': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_640': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_641': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_642': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_643': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_644': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_645': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_646': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_647': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_648': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_649': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_650': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_651': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_652': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_653': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_654': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_655': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_656': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_657': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_658': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_659': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_660': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_661': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_662': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_663': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_664': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_665': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_666': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_667': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_668': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_669': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_670': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_671': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_672': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_673': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_674': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_675': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_676': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_677': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_678': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_679': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_680': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_681': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_682': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_683': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_684': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_685': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_686': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_687': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_688': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_689': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_690': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_691': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_692': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_693': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_694': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_695': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_696': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_697': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_698': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_699': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_700': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_701': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_702': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_703': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_704': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_705': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Output_Param_706': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_707': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((GPT_REPORT_WAKEUP_SOURCE == STD_ON) && (GPT_WAKEUP_FUNCTIONALITY_API == STD_ON)) #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_SetMode(Gpt_ModeType Mode) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; /* Declare a Local variable to store Wakeup status */ VAR(uint8, AUTOMATIC) LucWakeupStatus; /* Declare a Local variable to store Channel Index */ VAR(uint8, AUTOMATIC) LucChannelID; #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) VAR(volatile uint8, AUTOMATIC) LucCount; #endif #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* Check if the GPT Driver is initialized properly */ if (GPT_INITIALIZED != Gpt_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_UNINIT); /* Set Return value */ LddReturnValue = E_NOT_OK; } else { /* Check if the GPT mode is correct */ if ((GPT_MODE_NORMAL != Mode) && (GPT_MODE_SLEEP != Mode)) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_SET_MODE_SID, GPT_E_PARAM_MODE); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ } /* Check if any DET error was reported */ if (E_OK == LddReturnValue) #endif /* End of GPT_DEV_ERROR_DETECT == STD_ON */ { /* Updating the local pointer to Channel config data */ LpChannel = Gpt_GpChannelConfig; /* Check if the Mode is Sleep Mode */ if (GPT_MODE_SLEEP == Mode) { for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucWakeupStatus = (uint8)Gpt_GpChannelRamData[LucChannelID].blWakeupStatus; /* PRQA S 4304 # JV-01 */ /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* PRQA S 2824, 2844 # JV-01, JV-01 */ /* Check for disable wakeup status of a Channel */ if ((GPT_CH_RUNNING == Gpt_GpChannelRamData[LucChannelID].ucChannelStatus) && ((GPT_FALSE == (LpChannel[LucChannelID].blGptWakeupSupport)) || (GPT_FALSE == LucWakeupStatus)))/* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver to Stop the Particular Channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pStopTimer(LucChannelID); } /* else No action required */ } /* else No action required */ /* Check for disable wakeup status */ if (GPT_FALSE == LucWakeupStatus) /* PRQA S 1881 # JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup) /* PRQA S 2814 # JV-01 */ { /* Disable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pDisableWakeup(LucChannelID); } /* else No action required */ } else /* LucWakeupStatus is GPT_TRUE */ { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup) { /* Enable wake-up for the channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pEnableWakeup(LucChannelID); } /* else No action required */ } } #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStopPredefTimer(); } /* else No action required */ } #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ } /* In case of Mode == GPT_MODE_NORMAL */ else { #if (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) /* Only If the driver is in sleep mode, the function shall restart all enabled GPT PreDef Timers */ if ((uint8)GPT_MODE_SLEEP == Gpt_GucDriverMode) /* PRQA S 3416 # JV-01 */ { for (LucCount = (uint8)GPT_ZERO; LucCount < (uint8)GPT_TOTAL_PREDEF_CHANNELS_CONFIG; LucCount++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { if (NULL_PTR != Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Initializing the GPT PreDef registers */ Gpt_GaaHwFunc[Gpt_GaaPredefTimerConfig[LucCount].ucPredefTimerType]->pStartPredefTimer(); } /* else No action required */ } } /* else No action required */ #endif /* End of (GPT_GET_PREDEF_TIMER_VALUE_API == STD_ON) */ #if ((GPT_TIMER_IP_TMU == STD_OFF) && (GPT_TIMER_IP_TPU == STD_OFF)) #if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) for (LucChannelID = (uint8)GPT_ZERO; LucChannelID < (uint8)GPT_TOTAL_CHANNELS_CONFIG; LucChannelID++) { LucCheckTimerType = LpChannel[LucChannelID].ucTimerUnitType; /* Check for status of a Channel */ if ((NULL_PTR != Gpt_GpChannelConfig[LucChannelID].pGptNotificationPointer) && (GPT_TRUE == Gpt_GpChannelRamData[LucChannelID].blNotifyStatus)) { if (GPT_CH_MODE_CONTINUOUS == Gpt_GpChannelConfig[LucChannelID].ucGptChannelMode) { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt) /* PRQA S 2814 # JV-01 */ { /* Enable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pEnableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } /* else No action required */ } else { if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt) { /* Disable interrupt for using channel */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ GPT_ENTER_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif Gpt_GaaHwFunc[LucCheckTimerType]->pDisableInterrupt(LucChannelID); /* PRQA S 2814 # JV-01 */ #if (GPT_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ GPT_EXIT_CRITICAL_SECTION(GPT_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ } } #endif /* end of GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON */ #endif /* end of GPT_TIMER_IP_TMU == STD_OFF && GPT_TIMER_IP_TPU == STD_OFF*/ } /* Set the Mode to the Global variable */ Gpt_GucDriverMode = (uint8)Mode; } /* else No action required */ /* End of LddReturnValue == E_NOT_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ENABLE_DISABLE_NOTIFICATION_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_GET_PREDEF_TIMER_VALUE_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Mode', 'Value': 'GPT_MODE_SLEEP'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_SLEEP'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GblDriverStatus', 'Value': 'GPT_INITIALIZED'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': 'GPT_HWIP_TMU(0x04)\\nGPT_HWIP_ATU(0x03)\\nGPT_HWIP_OSTM (0x00)\\nGPT_HWIP_TAUJ(0x02)\\nGPT_HWIP_TAUD(0x01)', 'Name': 'ucTimerUnitType', 'Value': '[0 to 13] = 0x04'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'blGptWakeupSupport', 'Value': '[0 to 13] = GPT_FALSE'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucGptChannelMode', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pGptNotificationPointer', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]\\n'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Gpt_GaaPredefTimerConfig', 'Value': '&Gpt_GaaPredefTimerConfig[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupStatus', 'Value': '[0 to 13] = GPT_TRUE'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[0 to 13] = GPT_CH_RUNNING\\n'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'blNotifyStatus', 'Value': '-'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': '-'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pStopTimer', 'Value': '[0 to 2] = NULL_PTR\\n[3] = &ISOLATE_void_func_ptr_Gpt_ChannelType\\n'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '[0 to 2] = NULL_PTR\\n[3] = &ISOLATE_void_func_ptr_Gpt_ChannelType\\n'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '[0 to 3] = NULL_PTR'], 'Input_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'ucPredefTimerType', 'Value': 'GPT_HWIP_TMU'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': 'NULL_PTR'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '&ISOLATE_void_func_ptr']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStartPredefTimer', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_018': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_021': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_024': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_025': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_027': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_028': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_030': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_031': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_033': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_034': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_036': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_037': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_039': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_040': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_042': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_043': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_045': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_046': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_048': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_049': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_051': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_052': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_053': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_054': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_055': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_056': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_057': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_058': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_059': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_060': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_061': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_062': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_063': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_064': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_065': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_066': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_067': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_068': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_069': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_070': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_071': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_072': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_073': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_074': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_075': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_076': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_077': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_078': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_079': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_080': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_081': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_082': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_083': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_084': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_085': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_086': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_087': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_088': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_089': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_090': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_091': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_092': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_093': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_094': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_095': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_096': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_097': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_098': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_099': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_100': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_101': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_102': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_103': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_104': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_105': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_106': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_107': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_108': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_109': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_110': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_111': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_112': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_113': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_114': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_115': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_116': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_117': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_118': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_119': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_120': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_121': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_122': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_123': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_124': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_125': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_126': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_127': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_128': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_129': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_130': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_131': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_132': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_133': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_134': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_135': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_136': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_137': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_138': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_139': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_140': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_141': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_142': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_143': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_144': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_145': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_146': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_147': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_148': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_149': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_150': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_151': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_152': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_153': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_154': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_155': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_156': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_157': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_158': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_159': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_160': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_161': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_162': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_163': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_164': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_165': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_166': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_167': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_168': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_169': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_170': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_171': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_172': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_173': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_174': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_175': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_176': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_177': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_178': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_179': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_180': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_181': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_182': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_183': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_184': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_185': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_186': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_187': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_188': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_189': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_190': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_191': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_192': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_193': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_194': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_195': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_196': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_197': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_198': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_199': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_200': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_201': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_202': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_203': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_204': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_205': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_206': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_207': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_208': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_209': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_210': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_211': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_212': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_213': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_214': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_215': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_216': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_217': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_218': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_219': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_220': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_221': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_222': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_223': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_224': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_225': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_226': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_227': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_228': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_229': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_230': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_231': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_232': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_233': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_234': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_235': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_236': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_237': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_238': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_239': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableInterrupt', 'Value': '-'], 'Output_Param_240': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_241': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GucDriverMode', 'Value': 'GPT_MODE_SLEEP'], 'Output_Param_242': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_243': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_244': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_245': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_246': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_247': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_248': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_249': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_250': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_251': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_252': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_253': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_254': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_255': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_256': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_257': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_258': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_259': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_260': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_261': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_262': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_263': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_264': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_265': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_266': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_267': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_268': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_269': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_270': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_271': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_272': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_273': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_274': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_275': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_276': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_277': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_278': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_279': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_280': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_281': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '<Called>'], 'Output_Param_282': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_283': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '<Called>'], 'Output_Param_284': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_285': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_286': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_287': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_288': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_289': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_290': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_291': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_292': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_293': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_294': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_295': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_296': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_297': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_298': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_299': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_300': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_301': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_302': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_303': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_304': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_305': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_306': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_307': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_308': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_309': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_310': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_311': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_312': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_313': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_314': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_315': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_316': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_317': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_318': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_319': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_320': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_321': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_322': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_323': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_324': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_325': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_326': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_327': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_328': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_329': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_330': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_331': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_332': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_333': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_334': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_335': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_336': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_337': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_338': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_339': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_340': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_341': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_342': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_343': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_344': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_345': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_346': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_347': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_348': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_349': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_350': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_351': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_352': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_353': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_354': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_355': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_356': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_357': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_358': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_359': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_360': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_361': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_362': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_363': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_364': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_365': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_366': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_367': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_368': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_369': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_370': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_371': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_372': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_373': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_374': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_375': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_376': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_377': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_378': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_379': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_380': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_381': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_382': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_383': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_384': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_385': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_386': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_387': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_388': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_389': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_390': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_391': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_392': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_393': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_394': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_395': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_396': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_397': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_398': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_399': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_400': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_401': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_402': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_403': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_404': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_405': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_406': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_407': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_408': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_409': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_410': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_411': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_412': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_413': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_414': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_415': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_416': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_417': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_418': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_419': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_420': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_421': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_422': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_423': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_424': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_425': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_426': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_427': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_428': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_429': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_430': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_431': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_432': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_433': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_434': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_435': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_436': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_437': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_438': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_439': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_440': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_441': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_442': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_443': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_444': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_445': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_446': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_447': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_448': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_449': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_450': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_451': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_452': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_453': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_454': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_455': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_456': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_457': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_458': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_459': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_460': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_461': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_462': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_463': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_464': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_465': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_466': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_467': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_468': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_469': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_470': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopTimer', 'Value': '-'], 'Output_Param_471': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableWakeup', 'Value': '-'], 'Output_Param_472': ['Type': 'Function_Call', 'Range': '', 'Name': 'pEnableWakeup', 'Value': '-'], 'Output_Param_473': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Called>'], 'Output_Param_474': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_475': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_476': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_477': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_478': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_479': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_480': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_481': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_482': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_483': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_484': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_485': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_486': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_487': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_488': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_489': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_490': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_491': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_492': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_493': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_494': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_495': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_496': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_497': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_498': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_499': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_500': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_501': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_502': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_503': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_504': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_505': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_506': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_507': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_508': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_509': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_510': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_511': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_512': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_513': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_514': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_515': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_516': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_517': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_518': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_519': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_520': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_521': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_522': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_523': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_524': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_525': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_526': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_527': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_528': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_529': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_530': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_531': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_532': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_533': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_534': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_535': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_536': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_537': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_538': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_539': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_540': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_541': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_542': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_543': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_544': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_545': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_546': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_547': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_548': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_549': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_550': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_551': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_552': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_553': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_554': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_555': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_556': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_557': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_558': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_559': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_560': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_561': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_562': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_563': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_564': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_565': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_566': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_567': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_568': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_569': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_570': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_571': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_572': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_573': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_574': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_575': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_576': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_577': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_578': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_579': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_580': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_581': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_582': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_583': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_584': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_585': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_586': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_587': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_588': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_589': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_590': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_591': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_592': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_593': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_594': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_595': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_596': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_597': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_598': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_599': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_600': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_601': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_602': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_603': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_604': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_605': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_606': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_607': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_608': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_609': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_610': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_611': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_612': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_613': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_614': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_615': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_616': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_617': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_618': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_619': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_620': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_621': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_622': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_623': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_624': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_625': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_626': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_627': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_628': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_629': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_630': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_631': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_632': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_633': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_634': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_635': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_636': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_637': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_638': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_639': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_640': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_641': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_642': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_643': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_644': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_645': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_646': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_647': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_648': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_649': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_650': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_651': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_652': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_653': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_654': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_655': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_656': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_657': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_658': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_659': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_660': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_661': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_662': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_663': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_664': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_665': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_666': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_667': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_668': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_669': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_670': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_671': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_672': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_673': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_674': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_675': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_676': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_677': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_678': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_679': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_680': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_681': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_682': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_683': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_684': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_685': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_686': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_687': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_688': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_689': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_690': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_691': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_692': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_693': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_694': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_695': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_696': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_697': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_698': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_699': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_700': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_701': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_702': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_703': ['Type': 'Function_Call', 'Range': '', 'Name': 'pDisableInterrupt', 'Value': '-'], 'Output_Param_704': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_705': ['Type': 'Function_Call', 'Range': '', 'Name': 'pStopPredefTimer', 'Value': '-'], 'Output_Param_706': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_707': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_StartTimer(Gpt_ChannelType Channel, Gpt_ValueType Value) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) /* Declare the variable to store the DET return value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION))*/ #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Check the Det error */ LddReturnValue = Gpt_CheckDetErrors(Channel, GPT_START_TIMER_SID); /* Check if any DET error was reported */ if (E_OK == LddReturnValue) { /* Check if the Channel value is more than Max count value or ZERO */ if (((Gpt_GpChannelConfig[Channel].ulMaxTickValue) < Value) || ((uint32)GPT_ZERO == Value)) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_START_TIMER_SID, GPT_E_PARAM_VALUE); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ /* Check if the timer is already running */ #endif /* (GPT_DEV_ERROR_DETECT == STD_ON) */ #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) if (GPT_CH_RUNNING == Gpt_GpChannelRamData[Channel].ucChannelStatus) { /* Report to Development Errors */ GPT_DET_REPORT_ERROR(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_START_TIMER_SID, GPT_E_BUSY); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ if (E_OK == LddReturnValue) #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) */ { /* Updating the channel config parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pStartTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for starting the Channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pStartTimer(Channel, Value); } /* else No action required */ } /* else No action required */ #if (GPT_DEV_ERROR_DETECT == STD_ON) } /* else No action required */ /* End of (E_OK == LddReturnValue) */ #endif /* (GPT_DEV_ERROR_DETECT == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'GPT_AR_1911_VERSION\\nGPT_AR_431_VERSION\\nGPT_AR_422_VERSION', 'Name': 'GPT_AR_VERSION', 'Value': 'GPT_AR_422_VERSION'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..GPT_MAX_CHANNEL_ID_CONFIGURED', 'Name': 'Channel', 'Value': '0x01'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0\\n0XFFFFFFF', 'Name': 'Value', 'Value': '0xFFFFFFFE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\\n0XFFFFFFF', 'Name': 'ulMaxTickValue', 'Value': '0xFFFFFFFD'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'GPT_HWIP_TMU\\nGPT_HWIP_ATU\\nGPT_HWIP_OSTM\\nGPT_HWIP_TAUJ\\nGPT_HWIP_TAUD', 'Name': 'ucTimerUnitType', 'Value': 'GPT_HWIP_ATU'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'GPT_CH_NOTSTARTED\\nGPT_CH_RUNNING\\nGPT_CH_STOPPED\\nGPT_CH_EXPIRED', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_NOTSTARTED'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pStartTimer', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0x01'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApi_SID', 'Value': 'GPT_START_TIMER_SID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'GPT_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'GPT_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'GPT_START_TIMER_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'GPT_E_PARAM_VALUE'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '-', 'Name': 'pStartTimer', 'Value': '-'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_StartTimer(Gpt_ChannelType Channel, Gpt_ValueType Value) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) /* Declare the variable to store the DET return value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION))*/ #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Check the Det error */ LddReturnValue = Gpt_CheckDetErrors(Channel, GPT_START_TIMER_SID); /* Check if any DET error was reported */ if (E_OK == LddReturnValue) { /* Check if the Channel value is more than Max count value or ZERO */ if (((Gpt_GpChannelConfig[Channel].ulMaxTickValue) < Value) || ((uint32)GPT_ZERO == Value)) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_START_TIMER_SID, GPT_E_PARAM_VALUE); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ /* Check if the timer is already running */ #endif /* (GPT_DEV_ERROR_DETECT == STD_ON) */ #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) if (GPT_CH_RUNNING == Gpt_GpChannelRamData[Channel].ucChannelStatus) { /* Report to Development Errors */ GPT_DET_REPORT_ERROR(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_START_TIMER_SID, GPT_E_BUSY); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ if (E_OK == LddReturnValue) #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) */ { /* Updating the channel config parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pStartTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for starting the Channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pStartTimer(Channel, Value); } /* else No action required */ } /* else No action required */ #if (GPT_DEV_ERROR_DETECT == STD_ON) } /* else No action required */ /* End of (E_OK == LddReturnValue) */ #endif /* (GPT_DEV_ERROR_DETECT == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'GPT_AR_1911_VERSION\\nGPT_AR_431_VERSION\\nGPT_AR_422_VERSION', 'Name': 'GPT_AR_VERSION', 'Value': 'GPT_AR_422_VERSION'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..GPT_MAX_CHANNEL_ID_CONFIGURED', 'Name': 'Channel', 'Value': 'GPT_MAX_CHANNEL_ID_CONFIGURED + 1'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0\\n0XFFFFFFF', 'Name': 'Value', 'Value': '0xFFFFFFFF'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\\n0XFFFFFFF', 'Name': 'ulMaxTickValue', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'GPT_HWIP_TMU\\nGPT_HWIP_ATU\\nGPT_HWIP_OSTM\\nGPT_HWIP_TAUJ\\nGPT_HWIP_TAUD', 'Name': 'ucTimerUnitType', 'Value': 'GPT_HWIP_ATU'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'GPT_CH_NOTSTARTED\\nGPT_CH_RUNNING\\nGPT_CH_STOPPED\\nGPT_CH_EXPIRED', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_STOPPED\\n'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '-'], 'Input_Param_010': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pStartTimer', 'Value': '-'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': 'GPT_MAX_CHANNEL_ID_CONFIGURED +1'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApi_SID', 'Value': 'GPT_START_TIMER_SID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '-', 'Name': 'pStartTimer', 'Value': '-'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define GPT_START_SEC_PUBLIC_CODE #include \"Gpt_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, GPT_PUBLIC_CODE) Gpt_StartTimer(Gpt_ChannelType Channel, Gpt_ValueType Value) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Declare a local pointer to point to the Channel Config Data */ P2CONST(Gpt_ChannelConfigType, AUTOMATIC, GPT_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ VAR(volatile uint8, AUTOMATIC) LucCheckTimerType; #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) /* Declare the variable to store the DET return value */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize return value */ LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION))*/ #if (GPT_DEV_ERROR_DETECT == STD_ON) /* Check the Det error */ LddReturnValue = Gpt_CheckDetErrors(Channel, GPT_START_TIMER_SID); /* Check if any DET error was reported */ if (E_OK == LddReturnValue) { /* Check if the Channel value is more than Max count value or ZERO */ if (((Gpt_GpChannelConfig[Channel].ulMaxTickValue) < Value) || ((uint32)GPT_ZERO == Value)) { /* Report to DET */ (void)Det_ReportError(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_START_TIMER_SID, GPT_E_PARAM_VALUE); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ /* Check if the timer is already running */ #endif /* (GPT_DEV_ERROR_DETECT == STD_ON) */ #if ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) if (GPT_CH_RUNNING == Gpt_GpChannelRamData[Channel].ucChannelStatus) { /* Report to Development Errors */ GPT_DET_REPORT_ERROR(GPT_MODULE_ID, GPT_INSTANCE_ID, GPT_START_TIMER_SID, GPT_E_BUSY); /* Set Return value */ LddReturnValue = E_NOT_OK; } /* else No action required */ if (E_OK == LddReturnValue) #endif /* ((GPT_DEV_ERROR_DETECT == STD_ON) || (GPT_AR_VERSION == GPT_AR_431_VERSION) || \\ (GPT_AR_VERSION == GPT_AR_1911_VERSION) || (GPT_AR_VERSION == GPT_AR_R22_11_VERSION)) */ { /* Updating the channel config parameter to the current channel */ LpChannel = &Gpt_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucCheckTimerType = LpChannel->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Gpt_GaaHwFunc[LucCheckTimerType]->pStartTimer) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for starting the Channel */ Gpt_GaaHwFunc[LucCheckTimerType]->pStartTimer(Channel, Value); } /* else No action required */ } /* else No action required */ #if (GPT_DEV_ERROR_DETECT == STD_ON) } /* else No action required */ /* End of (E_OK == LddReturnValue) */ #endif /* (GPT_DEV_ERROR_DETECT == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'GPT_AR_1911_VERSION\\nGPT_AR_431_VERSION\\nGPT_AR_422_VERSION', 'Name': 'GPT_AR_VERSION', 'Value': 'GPT_AR_431_VERSION'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..GPT_MAX_CHANNEL_ID_CONFIGURED', 'Name': 'Channel', 'Value': '0x02'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0\\n0XFFFFFFF', 'Name': 'Value', 'Value': '0xFFFFFFFE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelConfig', 'Value': '&map_Gpt_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0\\n0XFFFFFFF', 'Name': 'ulMaxTickValue', 'Value': '0xFFFFFFFE'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'GPT_HWIP_TMU\\nGPT_HWIP_ATU\\nGPT_HWIP_OSTM\\nGPT_HWIP_TAUJ\\nGPT_HWIP_TAUD', 'Name': 'ucTimerUnitType', 'Value': 'GPT_HWIP_OSTM'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Gpt_GpChannelRamData', 'Value': '&map_Gpt_GpChannelRamData[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'GPT_CH_NOTSTARTED\\nGPT_CH_RUNNING\\nGPT_CH_STOPPED\\nGPT_CH_EXPIRED', 'Name': 'ucChannelStatus', 'Value': 'GPT_CH_STOPPED'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'Gpt_GaaHwFunc[0 to 3]', 'Value': '[0] = &map_Gpt_GaaHwFunc[0]\\n[1] = &map_Gpt_GaaHwFunc[1]\\n[2] = &map_Gpt_GaaHwFunc[2]\\n[3] = &map_Gpt_GaaHwFunc[3]'], 'Input_Param_010': ['Type': 'Array', 'Range': 'NULL_PTR \\n!NULL_PTR', 'Name': 'pStartTimer', 'Value': '[0 to 3] = NULL_PTR '], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0x02'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApi_SID', 'Value': 'GPT_START_TIMER_SID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '-', 'Name': 'pStartTimer', 'Value': '-'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_OSTM00_CH0_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_OSTM00_CH0_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(OSTM00_CH0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) OSTM00_CH0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Ostm_CbkNotification((uint8)GPT_OSTM00_CH0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_OSTMmn_CH0_ISR_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '3 = OSTM03_CH0_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x42'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TAUD0_CH00_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Taud_CbkNotification((uint8)GPT_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_TAUDx_CHmn_ISR_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '31 = TAUD1_CH15_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x1F'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TAUD0_CH00_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Taud_CbkNotification((uint8)GPT_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_TAUDx_CHmn_ISR_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '51 = TAUD3_CH03_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x40'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (GPT_TAUD0_CH00_ISR_API == STD_ON) #define GPT_START_SEC_CODE_FAST #include \"Gpt_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (GPT_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, GPT_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Gpt_HW_Taud_CbkNotification((uint8)GPT_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_TAUDx_CHmn_ISR_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'GPT_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Count_Irq', 'Value': '59 = TAUD3_CH11_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIdx', 'Value': '0x48'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_ATU_TIMERC0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATU_TIMERC0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(ATU_TIMERC0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) ATU_TIMERC0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_TimerIsr((Icu_ChannelType)ICU_ATU_TIMERC0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '6 = ATU_TIMERC1_CH02_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '14'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_ATU_TIMERC0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATU_TIMERC0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(ATU_TIMERC0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) ATU_TIMERC0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_TimerIsr((Icu_ChannelType)ICU_ATU_TIMERC0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '8 = ATU_TIMERC2_CH00_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '16'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_ATU_TIMERC0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATU_TIMERC0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(ATU_TIMERC0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) ATU_TIMERC0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_TimerIsr((Icu_ChannelType)ICU_ATU_TIMERC0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '9 = ATU_TIMERC2_CH01_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '17'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_ATU_TIMERC0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATU_TIMERC0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(ATU_TIMERC0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) ATU_TIMERC0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_TimerIsr((Icu_ChannelType)ICU_ATU_TIMERC0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '31 = ATU_TIMERC7_CH03_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '39'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_ATU_TIMERC0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATU_TIMERC0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(ATU_TIMERC0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) ATU_TIMERC0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_TimerIsr((Icu_ChannelType)ICU_ATU_TIMERC0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '9 = ATU_TIMERC2_CH01_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '79'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_ATU_TIMERC0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATU_TIMERC0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(ATU_TIMERC0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) ATU_TIMERC0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_TimerIsr((Icu_ChannelType)ICU_ATU_TIMERC0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '20 = ATU_TIMERC5_CH00_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '92'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EXT_INTP_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_EXT_INTP_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(EXT_INTP_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) EXT_INTP_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Pin_ExternalInterruptIsr(ICU_EXT_INTP_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '5 = EXT_INTP_CH05_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '69'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EXT_INTP_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_EXT_INTP_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(EXT_INTP_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) EXT_INTP_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Pin_ExternalInterruptIsr(ICU_EXT_INTP_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '2 = EXT_INTP_CH02_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '142'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EXT_INTP_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_EXT_INTP_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(EXT_INTP_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) EXT_INTP_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Pin_ExternalInterruptIsr(ICU_EXT_INTP_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '6 = EXT_INTP_CH06_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '122'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EXT_INTP_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_EXT_INTP_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(EXT_INTP_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) EXT_INTP_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Pin_ExternalInterruptIsr(ICU_EXT_INTP_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '9 = EXT_INTP_CH09_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '125'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EXT_INTP_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_EXT_INTP_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(EXT_INTP_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) EXT_INTP_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Pin_ExternalInterruptIsr(ICU_EXT_INTP_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '12 = EXT_INTP_CH12_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '128'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EXT_INTP_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_EXT_INTP_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(EXT_INTP_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) EXT_INTP_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Pin_ExternalInterruptIsr(ICU_EXT_INTP_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '32 = EXT_INTP_CH32_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '72'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_COUNT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_DisableEdgeCount(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_EDGE_COUNT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge counting */ if ((uint8)(ICU_MODE_EDGE_COUNTER) != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Invoke the Low Level Driver for disabling the edge count */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pStopCountMeasurement) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucTimerType]->pStopCountMeasurement(Channel); } /* else No action required */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Initialize the channel status as idle */ Icu_GpChannelRamData[Channel].ucChannelStatus = (uint8)ICU_IDLE; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of LucReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '75'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[75] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[75] = ICU_HW_ATU_TIMERC'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pStopCountMeasurement', 'Value': '[5] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[75] = ICU_IDLE'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '75'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_011': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_COUNT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_DisableEdgeCount(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_EDGE_COUNT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge counting */ if ((uint8)(ICU_MODE_EDGE_COUNTER) != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Invoke the Low Level Driver for disabling the edge count */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pStopCountMeasurement) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucTimerType]->pStopCountMeasurement(Channel); } /* else No action required */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Initialize the channel status as idle */ Icu_GpChannelRamData[Channel].ucChannelStatus = (uint8)ICU_IDLE; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of LucReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '129'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[129] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[129] = ICU_HW_TAUJ'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pStopCountMeasurement', 'Value': '[3] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[129] = ICU_IDLE'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '129'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_011': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_DisableNotification(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_NOTIFICATION_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_NOTIFICATION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Time Stamp measurement */ if (((uint8)ICU_MODE_SIGNAL_MEASUREMENT == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) || ((uint8)ICU_MODE_EDGE_COUNTER == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode)) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_NOTIFICATION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #if (ICU_ALREADY_ENABLEDISABLE_DET_CHECK == STD_ON) /* Check if the notification for the channel is already Disabled */ if ((uint8)ICU_FALSE == Icu_GpChannelRamData[Channel].ucNotificationEnable) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_DISABLE_NOTIFICATION_SID, ICU_E_ALREADY_DISABLED); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of (ICU_ALREADY_ENABLEDISABLE_DET_CHECK == STD_ON) */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Store the disabled notification into RAM */ Icu_GpChannelRamData[Channel].ucNotificationEnable = (uint8)ICU_FALSE; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of (LucReturnValue == E_OK) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ALREADY_ENABLEDISABLE_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '60'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucNotificationEnable', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_DISABLE_NOTIFICATION_SID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_PARAM_CHANNEL \\n'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucNotificationEnable', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_COUNT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableEdgeCount(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge counting */ if ((uint8)(ICU_MODE_EDGE_COUNTER) != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Start count measurement for the channel */ /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pStartCountMeasurement) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucTimerType]->pStartCountMeasurement(Channel); } /* else No action required */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Initialize the channel status as active */ Icu_GpChannelRamData[Channel].ucChannelStatus = (uint8)ICU_ACTIVE; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '77'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[77] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[77] = ICU_HW_TAUD'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pStartCountMeasurement', 'Value': '[2] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[77] = ICU_ACTIVE'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '77'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_011': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_COUNT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableEdgeCount(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge counting */ if ((uint8)(ICU_MODE_EDGE_COUNTER) != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Start count measurement for the channel */ /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pStartCountMeasurement) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucTimerType]->pStartCountMeasurement(Channel); } /* else No action required */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Initialize the channel status as active */ Icu_GpChannelRamData[Channel].ucChannelStatus = (uint8)ICU_ACTIVE; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '59'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[59] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[59] = ICU_HW_ATU_TIMERA'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pStartCountMeasurement', 'Value': '[4] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[59] = ICU_ACTIVE'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '59'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_011': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_COUNT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableEdgeCount(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge counting */ if ((uint8)(ICU_MODE_EDGE_COUNTER) != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Start count measurement for the channel */ /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pStartCountMeasurement) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucTimerType]->pStartCountMeasurement(Channel); } /* else No action required */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Initialize the channel status as active */ Icu_GpChannelRamData[Channel].ucChannelStatus = (uint8)ICU_ACTIVE; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '59'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[59] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[59] = ICU_HW_ATU_TIMERC'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pStartCountMeasurement', 'Value': '[5] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '[59] = ICU_ACTIVE'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '59'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_011': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_DETECT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableEdgeDetection(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Declare a Local variable to Timer Type */ volatile uint8 LucHWIPType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge Detection */ if ((uint8)ICU_MODE_SIGNAL_EDGE_DETECT != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Read the Timer Type for given channel */ LucHWIPType = Icu_GpChannelConfig[Channel].ucIcuChannelType; /* Enable the edge Detect for the channel */ /* Enable the edge Detect for the channel */ if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pEnableEdgeDetection) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucHWIPType]->pEnableEdgeDetection(Channel); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '1'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[1] = ICU_MODE_TIMESTAMP'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pEnableEdgeDetection', 'Value': '[0 to 5] = NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_ENABLE_EDGE_DETECTION_SID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_PARAM_CHANNEL\\n'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_DETECT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableEdgeDetection(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Declare a Local variable to Timer Type */ volatile uint8 LucHWIPType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge Detection */ if ((uint8)ICU_MODE_SIGNAL_EDGE_DETECT != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Read the Timer Type for given channel */ LucHWIPType = Icu_GpChannelConfig[Channel].ucIcuChannelType; /* Enable the edge Detect for the channel */ /* Enable the edge Detect for the channel */ if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pEnableEdgeDetection) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucHWIPType]->pEnableEdgeDetection(Channel); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '101'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[101] = ICU_MODE_SIGNAL_EDGE_DETECT'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[101] = ICU_HW_EXT_INTP '], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pEnableEdgeDetection', 'Value': '[0 to 5] = NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_DETECT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableEdgeDetection(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Declare a Local variable to Timer Type */ volatile uint8 LucHWIPType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge Detection */ if ((uint8)ICU_MODE_SIGNAL_EDGE_DETECT != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_EDGE_DETECTION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Read the Timer Type for given channel */ LucHWIPType = Icu_GpChannelConfig[Channel].ucIcuChannelType; /* Enable the edge Detect for the channel */ /* Enable the edge Detect for the channel */ if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pEnableEdgeDetection) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucHWIPType]->pEnableEdgeDetection(Channel); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '183'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[183] = ICU_MODE_SIGNAL_EDGE_DETECT'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[183] = ICU_HW_TAUJ '], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pEnableEdgeDetection', 'Value': '[3] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '183'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableNotification(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Time Stamp measurement */ if (((uint8)ICU_MODE_SIGNAL_MEASUREMENT == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) || ((uint8)ICU_MODE_EDGE_COUNTER == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode)) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #if (ICU_ALREADY_ENABLEDISABLE_DET_CHECK == STD_ON) /* Check if the notification for the channel is already Enabled */ if ((uint8)ICU_TRUE == Icu_GpChannelRamData[Channel].ucNotificationEnable) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_ALREADY_ENABLED); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of (ICU_ALREADY_ENABLEDISABLE_DET_CHECK == STD_ON) */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Store enabled notification into RAM */ Icu_GpChannelRamData[Channel].ucNotificationEnable = (uint8)ICU_TRUE; #if (ICU_NOTIFY_WAKEUP_INTERRUPT == STD_ON) /* Check if the channel is wakeup capable */ if ((uint8)ICU_TRUE == Icu_GpChannelConfig[Channel].ucIcuWakeupCapability) { /* Store the enabled wakeup status into RAM */ Icu_GpChannelRamData[Channel].ucWakeupEnable = (uint8)ICU_TRUE; #if (ICU_REPORT_WAKEUP_SOURCE == STD_ON) /* Set the wakeup source information */ Icu_GulWakeupSource = (Icu_GulWakeupSource | ((EcuM_WakeupSourceType)(ICU_DOUBLE_ONE << Icu_GpChannelConfig[Channel].ucEcuMChannelWakeupInfo))); #endif /* End of (ICU_REPORT_WAKEUP_SOURCE == STD_ON) */ } /* else No action required */ #endif /* End of (ICU_NOTIFY_WAKEUP_INTERRUPT == STD_ON) */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of LucReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ALREADY_ENABLEDISABLE_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_NOTIFY_WAKEUP_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_REPORT_WAKEUP_SOURCE', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '59'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GulWakeupSource', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[59] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_011': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucNotificationEnable', 'Value': '-'], 'Input_Param_012': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucIcuWakeupCapability', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ucEcuMChannelWakeupInfo', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_ENABLE_NOTIFICATION_SID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_PARAM_CHANNEL\\n'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucNotificationEnable', 'Value': '-'], 'Output_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ucWakeupEnable', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GulWakeupSource', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableNotification(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Time Stamp measurement */ if (((uint8)ICU_MODE_SIGNAL_MEASUREMENT == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) || ((uint8)ICU_MODE_EDGE_COUNTER == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode)) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #if (ICU_ALREADY_ENABLEDISABLE_DET_CHECK == STD_ON) /* Check if the notification for the channel is already Enabled */ if ((uint8)ICU_TRUE == Icu_GpChannelRamData[Channel].ucNotificationEnable) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_ALREADY_ENABLED); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of (ICU_ALREADY_ENABLEDISABLE_DET_CHECK == STD_ON) */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Store enabled notification into RAM */ Icu_GpChannelRamData[Channel].ucNotificationEnable = (uint8)ICU_TRUE; #if (ICU_NOTIFY_WAKEUP_INTERRUPT == STD_ON) /* Check if the channel is wakeup capable */ if ((uint8)ICU_TRUE == Icu_GpChannelConfig[Channel].ucIcuWakeupCapability) { /* Store the enabled wakeup status into RAM */ Icu_GpChannelRamData[Channel].ucWakeupEnable = (uint8)ICU_TRUE; #if (ICU_REPORT_WAKEUP_SOURCE == STD_ON) /* Set the wakeup source information */ Icu_GulWakeupSource = (Icu_GulWakeupSource | ((EcuM_WakeupSourceType)(ICU_DOUBLE_ONE << Icu_GpChannelConfig[Channel].ucEcuMChannelWakeupInfo))); #endif /* End of (ICU_REPORT_WAKEUP_SOURCE == STD_ON) */ } /* else No action required */ #endif /* End of (ICU_NOTIFY_WAKEUP_INTERRUPT == STD_ON) */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of LucReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ALREADY_ENABLEDISABLE_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_NOTIFY_WAKEUP_INTERRUPT', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_REPORT_WAKEUP_SOURCE', 'Value': 'STD_OFF'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '74'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GulWakeupSource', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[74] = ICU_MODE_SIGNAL_EDGE_DETECT'], 'Input_Param_011': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucNotificationEnable', 'Value': '[74] = ICU_TRUE'], 'Input_Param_012': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucIcuWakeupCapability', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ucEcuMChannelWakeupInfo', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_ENABLE_NOTIFICATION_SID'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_ALREADY_ENABLED\\n'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucNotificationEnable', 'Value': '-'], 'Output_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ucWakeupEnable', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GulWakeupSource', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_EnableNotification(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Time Stamp measurement */ if (((uint8)ICU_MODE_SIGNAL_MEASUREMENT == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) || ((uint8)ICU_MODE_EDGE_COUNTER == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode)) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #if (ICU_ALREADY_ENABLEDISABLE_DET_CHECK == STD_ON) /* Check if the notification for the channel is already Enabled */ if ((uint8)ICU_TRUE == Icu_GpChannelRamData[Channel].ucNotificationEnable) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_ENABLE_NOTIFICATION_SID, ICU_E_ALREADY_ENABLED); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of (ICU_ALREADY_ENABLEDISABLE_DET_CHECK == STD_ON) */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Store enabled notification into RAM */ Icu_GpChannelRamData[Channel].ucNotificationEnable = (uint8)ICU_TRUE; #if (ICU_NOTIFY_WAKEUP_INTERRUPT == STD_ON) /* Check if the channel is wakeup capable */ if ((uint8)ICU_TRUE == Icu_GpChannelConfig[Channel].ucIcuWakeupCapability) { /* Store the enabled wakeup status into RAM */ Icu_GpChannelRamData[Channel].ucWakeupEnable = (uint8)ICU_TRUE; #if (ICU_REPORT_WAKEUP_SOURCE == STD_ON) /* Set the wakeup source information */ Icu_GulWakeupSource = (Icu_GulWakeupSource | ((EcuM_WakeupSourceType)(ICU_DOUBLE_ONE << Icu_GpChannelConfig[Channel].ucEcuMChannelWakeupInfo))); #endif /* End of (ICU_REPORT_WAKEUP_SOURCE == STD_ON) */ } /* else No action required */ #endif /* End of (ICU_NOTIFY_WAKEUP_INTERRUPT == STD_ON) */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of LucReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ALREADY_ENABLEDISABLE_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_NOTIFY_WAKEUP_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_REPORT_WAKEUP_SOURCE', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '100'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GulWakeupSource', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[100] = ICU_MODE_SIGNAL_EDGE_DETECT'], 'Input_Param_011': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucNotificationEnable', 'Value': '[100] = ICU_TRUE'], 'Input_Param_012': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucIcuWakeupCapability', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ucEcuMChannelWakeupInfo', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_ENABLE_NOTIFICATION_SID'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_ALREADY_ENABLED\\n'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucNotificationEnable', 'Value': '-'], 'Output_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'ucWakeupEnable', 'Value': '-'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GulWakeupSource', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_COUNT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Icu_EdgeNumberType, ICU_PUBLIC_CODE) Icu_GetEdgeNumbers(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { Icu_EdgeNumberType LddEdgeCount; uint8 LucRamIndex; /* Declare a Local variable to Timer Type */ /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ LddEdgeCount = (uint32)ICU_ZERO; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_EDGE_NUMBERS_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_EDGE_NUMBERS_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge counting */ if ((uint8)(ICU_MODE_EDGE_COUNTER) != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_EDGE_NUMBERS_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Read the channel ram index */ LucRamIndex = Icu_GpChannelUserRegConfig[Channel].ucRamDataIndex; /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pGetEdgeNumbers) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucTimerType]->pGetEdgeNumbers(Channel); } /* else No action required */ LddEdgeCount = (Icu_EdgeNumberType)Icu_GpEdgeCountData[LucRamIndex].ulIcuEdgeCount; } /* else No action required */ return (LddEdgeCount); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'STD_ON/STD_OFF', 'Name': 'Channel', 'Value': '75'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpEdgeCountData', 'Value': '&map_Icu_GpEdgeCountData[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[75] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[75] = ICU_HW_ATU_TIMERA'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '[75] = 0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulIcuEdgeCount', 'Value': '0x01'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'pGetEdgeNumbers', 'Value': '[4] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddEdgeCount', 'Value': '0x01'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '75'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_GET_INPUT_LEVEL_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Icu_LevelType, ICU_PUBLIC_CODE) Icu_GetInputLevel(Icu_ChannelType LddChannel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucHWIPType; /* Local variable to store the return level value */ Icu_LevelType LddInputLevel; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ LddInputLevel = ICU_LOW; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_INPUT_LEVEL_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < LddChannel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_INPUT_LEVEL_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[LddChannel]; /* Read the Timer Type for given channel */ LucHWIPType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Updating the channel config parameter to the current channel */ if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pGetInputLevel) /* PRQA S 2814 # JV-01 */ { LddInputLevel = Icu_GaaHwDepFunc[LucHWIPType]->pGetInputLevel(LddChannel); } /* else No action required */ /* End of LucReturnValue == E_OK */ } /* else No action required */ return (LddInputLevel); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'LddChannel', 'Value': '183'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[183] = ICU_HW_EXT_INTP '], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pGetInputLevel', 'Value': '[0 to 5] = NULL_PTR'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_005': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenInputLevel', 'Value': 'ICU_LOW'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_GET_INPUT_LEVEL_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Icu_LevelType, ICU_PUBLIC_CODE) Icu_GetInputLevel(Icu_ChannelType LddChannel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucHWIPType; /* Local variable to store the return level value */ Icu_LevelType LddInputLevel; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ LddInputLevel = ICU_LOW; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_INPUT_LEVEL_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < LddChannel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_INPUT_LEVEL_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[LddChannel]; /* Read the Timer Type for given channel */ LucHWIPType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Updating the channel config parameter to the current channel */ if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pGetInputLevel) /* PRQA S 2814 # JV-01 */ { LddInputLevel = Icu_GaaHwDepFunc[LucHWIPType]->pGetInputLevel(LddChannel); } /* else No action required */ /* End of LucReturnValue == E_OK */ } /* else No action required */ return (LddInputLevel); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_UNINITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pGetInputLevel', 'Value': '[0 to 5] = NULL_PTR'], 'Input_Param_007': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_GET_INPUT_LEVEL_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_UNINIT\\n'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_005': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenInputLevel', 'Value': 'ICU_LOW'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_GET_INPUT_STATE_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Icu_InputStateType, ICU_PUBLIC_CODE) Icu_GetInputState(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Local variable to store the channel status */ Icu_InputStateType LddChannelState; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Defining a pointer to point to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ /* Set the initial state to Idle */ LddChannelState = ICU_IDLE; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_INPUT_STATE_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_INPUT_STATE_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { if (((uint8)ICU_MODE_SIGNAL_EDGE_DETECT != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) && ((uint8)ICU_MODE_SIGNAL_MEASUREMENT != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode)) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_INPUT_STATE_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Read timer channel configuration pointer */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[Channel]; /* Check if the channel is configured for extra duty channel */ if (ICU_FIVE == (uint8)(LpChannelUserRegConfig->ucChannelProperties)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Report Error to Det */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_INPUT_STATE_SID, ICU_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } /* else No action required */ } } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ { #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Read the channel input status */ LddChannelState = (Icu_InputStateType)Icu_GpChannelRamData[Channel].ucChannelStatus; /* PRQA S 4342 # JV-01 */ /* Store channel status as idle */ Icu_GpChannelRamData[Channel].ucChannelStatus = (uint8)ICU_IDLE; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of (LucReturnValue == E_OK) */ /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ return (LddChannelState); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_UNINITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '-'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_GET_INPUT_STATE_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_UNINIT\\n'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucChannelStatus', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_014': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_015': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenChannelState', 'Value': 'ICU_IDLE'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_GET_TAU_COUNT_VALUE_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Icu_CounterValueType, ICU_PUBLIC_CODE) Icu_GetTAUInCountValue(Icu_ChannelType LddChannel) /* PRQA S 1503 # JV-01 */ { #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Local variable to store the DET value */ Std_ReturnType LucReturnValue; #endif Icu_CounterValueType LddTAUInCounterValue; /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; /* Initialize the return value */ LddTAUInCounterValue = ICU_TAU_CNT_INIT_VAL; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Set the DET value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to Det */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_COUNT_VALUE_SID, ICU_E_UNINIT); LucReturnValue = E_NOT_OK; } /* End of ICU_INITIALIZED != Icu_GblDriverStatus */ /* Check if the channel is valid */ else if (ICU_MAX_CHANNEL_ID_CONFIGURED < LddChannel) { /* Check if the channel is valid */ /* Report Error to Det */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_COUNT_VALUE_SID, ICU_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } /* End of ICU_MAX_CHANNEL_ID_CONFIGURED < Channel */ else { /* Check if the channel is valid */ if ((ICU_HW_TAUD != Icu_GpChannelConfig[LddChannel].ucIcuChannelType) && (ICU_HW_TAUJ != Icu_GpChannelConfig[LddChannel].ucIcuChannelType)) { /* Report Error to Det */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_COUNT_VALUE_SID, ICU_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } /* else No action required */ } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif { /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[LddChannel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pGetTAUInCountValue) /* PRQA S 2814 # JV-01 */ { LddTAUInCounterValue = Icu_GaaHwDepFunc[LucTimerType]->pGetTAUInCountValue(LddChannel); } /* else No action required */ /* End of E_NOT_OK == LucReturnValue */ } /* else No action required */ return (LddTAUInCounterValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_GET_TAU_COUNT_VALUE_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': 'ICU_HW_EXT_INTP/\\nICU_HW_TAUD/\\nICU_HW_TAUJ\\n', 'Name': 'ucIcuChannelType', 'Value': '[0] = ICU_HW_TAUD'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pGetTAUInCountValue', 'Value': '[2] = &ISOLATE_Icu_CounterValueType_func_ptr_Icu_ChannelType'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '0x00']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Output_Param_009': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddTAucnCounterValue', 'Value': '0x00'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_GET_TIME_ELAPSED_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Icu_ValueType, ICU_PUBLIC_CODE) Icu_GetTimeElapsed(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to point to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ uint8 LucMeasureProperty; uint8 LucIndex; Icu_ValueType LddSignalTime; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ /* Set the initial value for return value */ LddSignalTime = (uint32)ICU_SIGNAL_TIME_INIT_VAL; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIME_ELAPSED_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIME_ELAPSED_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Signal measurement */ if ((uint8)ICU_MODE_SIGNAL_MEASUREMENT != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIME_ELAPSED_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ else { /* Read timer channel configuration pointer */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[Channel]; /* Check if the channel is configured for extra duty channel */ if (ICU_FIVE == (uint8)(LpChannelUserRegConfig->ucChannelProperties)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Report Error to Det */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIME_ELAPSED_SID, ICU_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } /* else No action required */ } } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Read timer channel configuration pointer */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[Channel]; LucMeasureProperty = LpChannelUserRegConfig->ucChannelProperties; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Get the index of the RAM data */ LucIndex = LpChannelUserRegConfig->ucRamDataIndex; /* Check for the status of result channel */ if ((uint8)ICU_TRUE == Icu_GpChannelRamData[Channel].blResultComplete) { /* Check if measurement mode is either low or high */ if ((ICU_HIGH_TIME_MASK == (uint8)(LucMeasureProperty)) || (ICU_LOW_TIME_MASK == (uint8)(LucMeasureProperty))) { /* Read the captured Signal Active Time */ LddSignalTime = Icu_GpSignalMeasurementData[LucIndex].ulSignalActiveTime; /* PRQA S 2824 # JV-01 */ Icu_GpSignalMeasurementData[LucIndex].ulSignalActiveTime = (uint32)ICU_ACTIVE_TIME_RESET_VAL; /* Disable for the status of result Channel */ Icu_GpChannelRamData[Channel].blResultComplete = (uint8)ICU_FALSE; } /* End of ((LucMeasureProperty & ICU_HIGH_TIME_MASK) < ICU_TWO) */ /* Check if measurement mode is for period time */ else if ((uint8)ICU_PERIOD_TIME_MASK == (uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK)) /* PRQA S 2004 # JV-01 */ { /* Read the captured Signal Period Time */ LddSignalTime = Icu_GpSignalMeasurementData[LucIndex].ulSignalPeriodTime; Icu_GpSignalMeasurementData[LucIndex].ulSignalPeriodTime = (uint32)ICU_PERIOD_TIME_RESET_VAL; /* Disable for the status of result Channel */ Icu_GpChannelRamData[Channel].blResultComplete = (uint8)ICU_FALSE; } /* else No action required */ } /* else No action required */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of LucReturnValue == E_OK */ return (LddSignalTime); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '59'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[59] = ICU_MODE_SIGNAL_MEASUREMENT'], 'Input_Param_009': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'blResultComplete ', 'Value': '[59] = ICU_TRUE'], 'Input_Param_010': ['Type': 'Array', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '[59] = 0x02'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '[59] = 0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalActiveTime', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalPeriodTime', 'Value': '0x01']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalActiveTime', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalPeriodTime', 'Value': 'ICU_PERIOD_TIME_RESET_VAL'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'blResultComplete ', 'Value': '[59] = ICU_FALSE '], 'Output_Param_011': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_013': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddSignalTime', 'Value': '0x01'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TIMESTAMP_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Icu_IndexType, ICU_PUBLIC_CODE) Icu_GetTimestampIndex(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { Icu_IndexType LusTimestampIndex; uint8 LucIndex; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ LusTimestampIndex = (uint16)ICU_BUFFER_IDX_INIT_VAL; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIMESTAMP_INDEX_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIMESTAMP_INDEX_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Time Stamp measurement */ if ((uint8)ICU_MODE_TIMESTAMP != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIMESTAMP_INDEX_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { LucIndex = Icu_GpChannelUserRegConfig[Channel].ucRamDataIndex; /* If timestamping is started, then only return timestamp index value */ if (ICU_TRUE == Icu_GpTimeStampData[LucIndex].blTimestampingStarted) { LusTimestampIndex = Icu_GpTimeStampData[LucIndex].usTimestampIndex; } /* else No action required */ /* End of (LucReturnValue == E_OK) */ } /* else No action required */ /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ return (LusTimestampIndex); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '59'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTimeStampData', 'Value': '&map_Icu_GpTimeStampData[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[59] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'blTimestampingStarted', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usTimestampIndex', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_GET_TIMESTAMP_INDEX_SID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_PARAM_CHANNEL\\n'], 'Output_Param_008': ['Type': 'Return_Value', 'Range': '', 'Name': 'LusTimestampIndex', 'Value': 'ICU_BUFFER_IDX_INIT_VAL'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TIMESTAMP_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Icu_IndexType, ICU_PUBLIC_CODE) Icu_GetTimestampIndex(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { Icu_IndexType LusTimestampIndex; uint8 LucIndex; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ LusTimestampIndex = (uint16)ICU_BUFFER_IDX_INIT_VAL; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIMESTAMP_INDEX_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIMESTAMP_INDEX_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Time Stamp measurement */ if ((uint8)ICU_MODE_TIMESTAMP != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_GET_TIMESTAMP_INDEX_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { LucIndex = Icu_GpChannelUserRegConfig[Channel].ucRamDataIndex; /* If timestamping is started, then only return timestamp index value */ if (ICU_TRUE == Icu_GpTimeStampData[LucIndex].blTimestampingStarted) { LusTimestampIndex = Icu_GpTimeStampData[LucIndex].usTimestampIndex; } /* else No action required */ /* End of (LucReturnValue == E_OK) */ } /* else No action required */ /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ return (LusTimestampIndex); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '130'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTimeStampData', 'Value': '&map_Icu_GpTimeStampData[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '-'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'blTimestampingStarted', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usTimestampIndex', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': 'ICU_MODULE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'ICU_INSTANCE_ID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'ICU_GET_TIMESTAMP_INDEX_SID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'ICU_E_PARAM_CHANNEL\\n'], 'Output_Param_008': ['Type': 'Return_Value', 'Range': '', 'Name': 'LusTimestampIndex', 'Value': 'ICU_BUFFER_IDX_INIT_VAL'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (STD_ON == ICU_ATU_TIMER_UNIT_USED) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Atu_ChannelInit(const Icu_ChannelType LucChannelIndex) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ #if ((ICU_ATU_TIMERC_UNIT_USED == STD_ON) || (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) /* Defining a pointer to the ATU channel configuration parameters */ P2CONST(Icu_ATUChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpATUChannelConfig; /* PRQA S 3432 # JV-01 */ #endif /* Defining a pointer to the Channel Ram Data */ P2VAR(volatile Icu_ChannelRamDataType, AUTOMATIC, ICU_CONFIG_DATA) LpRamData; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the timer channel configuration parameters */ #if ((ICU_SIGNAL_MEASUREMENT_API == STD_ON) || (ICU_EDGE_COUNT_API == STD_ON) || (ICU_TIMESTAMP_API == STD_ON)) P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ #endif P2CONST(Icu_ATUChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpATUChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ #if (ICU_ATU_TIMERA_UNIT_USED == STD_ON) /* Initialize pointer to the base address of the current channel */ P2VAR(Icu_ATUTimerACommonUserRegs, AUTOMATIC, ICU_CONFIG_DATA) LpATUTimerACommonRegs; /* PRQA S 3432 # JV-01 */ #endif #if (ICU_ATU_TIMERC_UNIT_USED == STD_ON) /* Initialize pointer to the base address of the current channel */ P2VAR(Icu_ATUTimerCSubBlkUserRegs, AUTOMATIC, ICU_CONFIG_DATA) LpATUTimerCSubBlkRegs; /* PRQA S 3432 # JV-01 */ /* Initialize pointer to the base address of the current channel */ P2VAR(Icu_ATUTimerCChannelUserRegs, AUTOMATIC, ICU_CONFIG_DATA) LpATUTimerCChannelRegs; /* PRQA S 3432 # JV-01 */ #endif /* Local variable to store the measurement mode of a channel */ Icu_MeasurementModeType LddMeasurementMode; #if ((ICU_ATU_TIMERC_UNIT_USED == STD_ON) || (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) /* Initialize all the configured Icu Channels */ LpATUChannelConfig = Icu_GpChannelConfig[LucChannelIndex].pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ /* Update the global pointer with the first channel's ram address */ #endif LpRamData = &Icu_GpChannelRamData[LucChannelIndex]; /* Update the channel pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LucChannelIndex]; /* Initialize each channel status as idle */ LpRamData->ucChannelStatus = (uint8)ICU_IDLE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Disable notification for each channel */ LpRamData->ucNotificationEnable = (uint8)ICU_FALSE; /* Initialize result complete status for each channel */ LpRamData->blResultComplete = (uint8)ICU_FALSE; /* Update the Timer channel configuration pointer to point to the current channel */ #if ((ICU_SIGNAL_MEASUREMENT_API == STD_ON) || (ICU_EDGE_COUNT_API == STD_ON) || (ICU_TIMESTAMP_API == STD_ON)) LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[LucChannelIndex]; #endif LpATUChannelUserRegConfig = Icu_GpChannelUserRegConfig[LucChannelIndex].pHWChannelUserRegConfig; /* PRQA S 0317 # JV-01 */ /* Read the channel's measurement mode */ LddMeasurementMode = (Icu_MeasurementModeType)(LpChannelConfig->ucIcuMeasurementMode); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ #if (ICU_ATU_TIMERA_UNIT_USED == STD_ON) if (ICU_HW_ATU_TIMERA == LpChannelConfig->ucIcuChannelType) { /* Initialize pointer to the base address of the current channel */ LpATUTimerACommonRegs = (P2VAR(Icu_ATUTimerACommonUserRegs, AUTOMATIC, ICU_CONFIG_DATA))LpATUChannelUserRegConfig->pTimerCntlRegs; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* Enable TIERA timer interrupt enable register A */ LpATUTimerACommonRegs->usAtuTimerATIERA = ICU_ATU_TIMERA_TIERA_INIT_VAL; /* PRQA S 2814 # JV-01 */ /* If the measurement mode is edge counter, put the defined count value to TCNTA Register */ if (ICU_MODE_EDGE_COUNTER == LddMeasurementMode) { /* Assign the up count value to TCNTA register */ LpATUTimerACommonRegs->ulAtuTimerATCNTA = ICU_ATU_TIMER_INITIAL_CNT_VAL; } /* else No action required */ /* End of (LddMeasurementMode == ICU_MODE_EDGE_COUNTER) */ /* Mask and set the configured default start edges for the channel */ LpATUTimerACommonRegs->usAtuTimerATIOR1A &= (LpATUChannelUserRegConfig->usChannelModeUserRegSettings); if ((uint8)ICU_RISING_EDGE == LpChannelConfig->ucIcuDefaultStartEdge) { LpATUTimerACommonRegs->usAtuTimerATIOR1A |= (uint16)((uint16)ICU_ATU_RISING_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO)); /* PRQA S 3383 # JV-01 */ } else if ((uint8)ICU_FALLING_EDGE == LpChannelConfig->ucIcuDefaultStartEdge) { LpATUTimerACommonRegs->usAtuTimerATIOR1A |= (uint16)((uint16)ICU_ATU_FALLING_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO)); /* PRQA S 3383 # JV-01 */ } else if ((uint8)ICU_BOTH_EDGES == LpChannelConfig->ucIcuDefaultStartEdge) /* PRQA S 2004 # JV-01 */ { LpATUTimerACommonRegs->usAtuTimerATIOR1A |= (uint16)((uint16)ICU_ATU_BOTH_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO)); /* PRQA S 3383 # JV-01 */ } /* else No action required */ /* Reset Channel Status Clear Trigger Register */ LpATUTimerACommonRegs->usAtuTimerATSCRA = (uint16)((uint16)ICU_ATU_TIMER_STS_CLR << (LpChannelConfig->usChannelMaskValue)); } /* else No action required */ /* End of if (ICU_HW_ATU_TIMERA == LpChannelConfig->ucIcuChannelType) */ #endif /* End of (ICU_ATU_TIMERA_UNIT_USED == STD_ON) */ #if (ICU_ATU_TIMERC_UNIT_USED == STD_ON) if (ICU_HW_ATU_TIMERC == LpChannelConfig->ucIcuChannelType) { /* Initialize pointer to the base address of the current channel */ LpATUTimerCSubBlkRegs = (P2VAR(Icu_ATUTimerCSubBlkUserRegs, AUTOMATIC, ICU_CONFIG_DATA))LpATUChannelUserRegConfig->pTimerCntlRegs; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Initialize pointer to the base address of the current channel */ LpATUTimerCChannelRegs = (P2VAR(Icu_ATUTimerCChannelUserRegs, AUTOMATIC, ICU_CONFIG_DATA))LpATUChannelConfig->pTimerChannelUserRegs; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* If the measurement mode is edge counter, put the defined count value to TCNTC Register */ if (ICU_MODE_EDGE_COUNTER == LddMeasurementMode) { /* Assign the down count value to CDR register */ LpATUTimerCSubBlkRegs->ulAtuTimerCTCNTCm = ICU_ATU_TIMER_INITIAL_CNT_VAL; /* PRQA S 2814 # JV-01 */ LpATUTimerCChannelRegs->ulAtuTimerCGRCmn = ICU_ATU_TIMER_INITIAL_CNT_VAL; /* PRQA S 2814 # JV-01 */ } /* else No action required */ /* End of LddMeasurementMode == ICU_MODE_EDGE_COUNTER */ /* Enable TIERCx timer interrupt enable register */ LpATUTimerCSubBlkRegs->usAtuTimerCTIERCm = ICU_ATU_TIMERC_TIERC_INIT_VAL; /* Mask and set the configured default start edges for the channel */ LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm &= LpATUChannelUserRegConfig->usChannelModeUserRegSettings; if ((uint8)ICU_FALLING_EDGE == LpChannelConfig->ucIcuDefaultStartEdge) { LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm |= (uint16)((uint16)(ICU_SET_INPUT_CAPTURE_MODE | ICU_ATU_FALLING_EDGE_MASK) << (LpChannelConfig->usChannelMaskValue * ICU_FOUR)); /* PRQA S 3383 # JV-01 */ } else if ((uint8)ICU_RISING_EDGE == LpChannelConfig->ucIcuDefaultStartEdge) { LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm |= (uint16)((uint16)(ICU_SET_INPUT_CAPTURE_MODE | ICU_ATU_RISING_EDGE_MASK) << (LpChannelConfig->usChannelMaskValue * ICU_FOUR)); /* PRQA S 3383 # JV-01 */ } else if ((uint8)ICU_BOTH_EDGES == LpChannelConfig->ucIcuDefaultStartEdge) /* PRQA S 2004 # JV-01 */ { LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm |= (uint16)((uint16)(ICU_SET_INPUT_CAPTURE_MODE | ICU_ATU_BOTH_EDGE_MASK) << (LpChannelConfig->usChannelMaskValue * ICU_FOUR)); /* PRQA S 3383 # JV-01 */ } /* else No action required */ /* End of (ICU_FALLING_EDGE == LpChannelConfig->ucIcuChannelType) */ /* Reset Channel Status Clear Trigger Register */ LpATUTimerCSubBlkRegs->usAtuTimerCTSCRCm = ((uint16)ICU_ATU_TIMER_STS_CLR << (LpChannelConfig->usChannelMaskValue)); } /* else No action required */ /* End of (ICU_HW_ATU_TIMERC == LpChannelConfig->ucIcuChannelType) */ #endif /* End of (ICU_ATU_TIMERC_UNIT_USED == STD_ON) */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) { /* Disable interrupts */ RH850_SV_SET_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress),ICU_DISABLE_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ } /* else No action required */ switch (LddMeasurementMode) { /* Edge Counter Mode */ case ICU_MODE_EDGE_COUNTER: { #if (ICU_EDGE_COUNT_API == STD_ON) /* Configure the channel in Edge Counter Mode */ Icu_HW_Atu_EdgeCountingInit(LpChannelUserRegConfig); #endif break; } /* Timestamp Mode */ case ICU_MODE_TIMESTAMP: { #if (ICU_TIMESTAMP_API == STD_ON) /* Configure the channel in Timestamp Mode */ Icu_HW_Atu_TimestampInit(LpChannelUserRegConfig); #endif break; } /* Signal Measurement Mode */ case ICU_MODE_SIGNAL_MEASUREMENT: { #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) /* Configure the channel in Signal Measurement Mode */ Icu_HW_Atu_SignalMeasurementInit(LpChannelUserRegConfig); #endif break; } default: { /* edgedetect do nothing */ break; } } /* End of switch case */ #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) if (ICU_TRUE == LpATUChannelConfig->ucIcuEnableNoiseCancellation) { /* Loading value of Noise cancellation period into Noise Canceler Register*/ *(LpATUChannelConfig->pNCRPeriodRegAdress) = LpATUChannelConfig->usIcuNoiseCancellationPeriod; /* PRQA S 2814 # JV-01 */ } /* else No action required */ #endif /* End of #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON))*/ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERC_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERA_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATUC_NOISE_CANCELLATION_ENABLE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATUA_NOISE_CANCELLATION_ENABLE', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannelIndex', 'Value': '0x00'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '&map_Icu_GpATUChannelConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': 'ICU_MODE_SIGNAL_MEASUREMENT'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'ICU_HW_ATU_TIMERA\\nICU_HW_ATU_TIMERC\\nICU_HW_EXT_IRQ', 'Name': 'ucIcuChannelType', 'Value': '0x00'], 'Input_Param_009': ['Type': 'Variable', 'Range': '  ICU_FALLING_EDGE\\n  ICU_RISING_EDGE\\n  ICU_BOTH_EDGES', 'Name': 'ucIcuDefaultStartEdge', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelMaskValue', 'Value': '0x0000'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pHWChannelUserRegConfig', 'Value': '&map_Icu_GpATUChannelUserRegConfig[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pTimerCntlRegs', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelModeUserRegSettings', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerATIOR1A', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucIcuEnableNoiseCancellation', 'Value': 'ICU_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pNCRPeriodRegAdress', 'Value': '&map_pNCRPeriodRegAdress[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'pTimerChannelUserRegs', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerCTIORCm', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_pNCRPeriodRegAdress[0]', 'Value': '0x0000'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'usIcuNoiseCancellationPeriod', 'Value': '0x0001'], 'Input_Param_023': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pIntrCntlAddress', 'Value': 'NULL_PTR'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucNotificationEnable', 'Value': 'ICU_FALSE'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'blResultComplete', 'Value': 'ICU_FALSE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerATIERA', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulAtuTimerATCNTA', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerATIOR1A', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerATSCRA', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pNCRPeriodRegAdress[0]', 'Value': '0x0000'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulAtuTimerCTCNTCm', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulAtuTimerCGRCmn', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerCTIERCm', 'Value': '-'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerCTIORCm', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerCTSCRCm', 'Value': '-'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChannelUserRegConfig', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChannelUserRegConfig', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Output_Param_017': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (STD_ON == ICU_ATU_TIMER_UNIT_USED) #if (ICU_DE_INIT_API == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Atu_UnitDeInit(void) /* PRQA S 1532 # JV-01 */ { #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED) /* Defining a pointer to the clock bus selection configuration parameters */ P2CONST(Icu_ATU_ClockBusConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpTimerClkBusConfig; /* PRQA S 3432 # JV-01 */ #endif /* Defining a pointer to the clock bus selection Control Register */ P2VAR(volatile uint8, AUTOMATIC, ICU_CONFIG_DATA) LpClkBusCntrlReg; /* PRQA S 3432 # JV-01 */ /* Local counter variable */ uint8 LucCnt; #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) /* Defining a pointer to the Timer Noise Cancellation configuration */ P2CONST(Icu_NoiseCancellationConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpNoiseCancellationConfig; /* PRQA S 3432 # JV-01 */ #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) /* Defining a pointer to the NCCRC register Configuration parameter*/ P2CONST(Icu_NCCRCCntrlRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpNCCRCCntrlRegConfig; /* PRQA S 3432 # JV-01 */ #endif /* End of #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) */ #endif /* ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON))*/ #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED) /* Update the previous input use pointer to point to the current channel */ LpTimerClkBusConfig = Icu_GpTimerClkBusConfig; /* default Clock bus selection for the configured timer unit */ for (LucCnt = ICU_ZERO; LucCnt < ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED; LucCnt++) { /* Load clock bus selection for the timer unit */ LpClkBusCntrlReg = LpTimerClkBusConfig->pAtuClkBusCntrlRegs; /* PRQA S 0317, 2814 # JV-01, JV-01 */ *(LpClkBusCntrlReg) = (*(LpClkBusCntrlReg) & ICU_CLK_BUS_SELECT_MASK); /* PRQA S 2814 # JV-01 */ /* Increment the pointer to point to next previous input channel */ LpTimerClkBusConfig++; /* PRQA S 2824 # JV-01 */ } /* End of clock bus selection channel for loop */ #endif /* End of #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED)*/ #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) /* Update the local pointer to point to the Timer Noise Cancellation configuration. */ LpNoiseCancellationConfig = Icu_GpNoiseCancellationConfig; if (ICU_NC_PLL_ENABLE == LpNoiseCancellationConfig->ucAtuNCMRCntrlRegValue) /* PRQA S 2814 # JV-01 */ { /* Resetting the NCCSEL bit in the NCMR register to ZERO */ *(LpNoiseCancellationConfig->pAtuNCMRCntrlReg) &= (uint8)~ICU_NC_PLL_ENABLE; } /* else No action required */ #if (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) /* Resetting the Mode Selection Register values to ZERO */ *(LpNoiseCancellationConfig->pAtuNCMCR1ACntrlReg) = ICU_RESET_ATU_NCMCR1A_VAL; /* PRQA S 2814 # JV-01 */ /* Resetting the Mode Selection Register values to ZERO */ *(LpNoiseCancellationConfig->pAtuNCMCR2ACntrlReg) = ICU_RESET_ATU_NCMCR2A_VAL; /* PRQA S 2814 # JV-01 */ /* Reset Timer I/O Control Register 2A values to ZERO */ *(LpNoiseCancellationConfig->pAtuTIOR2ACntrlReg) = ICU_RESET_ATU_TIOR2A_VAL; /* PRQA S 2814 # JV-01 */ #endif /* End of #if (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) */ #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) /* Resetting the Mode Selection Register values to ZERO */ *(LpNoiseCancellationConfig->pAtuNCMCR1CCntrlReg) = (uint16)ICU_RESET_ATU_NCMCR1C_VAL; /* PRQA S 2814 # JV-01 */ /* Resetting the Mode Selection Register values to ZERO */ *(LpNoiseCancellationConfig->pAtuNCMCR2CCntrlReg) = (uint16)ICU_RESET_ATU_NCMCR2C_VAL; /* PRQA S 2814 # JV-01 */ LpNCCRCCntrlRegConfig = LpNoiseCancellationConfig->pNCCRCCntrlRegConfig; /* PRQA S 0317 # JV-01 */ for (LucCnt = ICU_ZERO; LucCnt < LpNoiseCancellationConfig->ucTotalTimerCConfigured; LucCnt++) { /* Reset the Noise Canceler Control Register values to ZERO */ *((LpNoiseCancellationConfig->pAtuNCCRCCntrlRegAdrs + LpNCCRCCntrlRegConfig->ucAtuNCCRCSubBlockIndex)) = /* PRQA S 0488, 2814, 2824 # JV-01, JV-01, JV-01 */ ICU_RESET_ATU_NOISE_CANCELER_VAL; LpNCCRCCntrlRegConfig++; /* PRQA S 2824 # JV-01 */ } #endif /* End of #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) */ #endif /* End of #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON))*/ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED', 'Value': '16'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERA_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERC_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATUA_NOISE_CANCELLATION_ENABLE', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATUC_NOISE_CANCELLATION_ENABLE', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTimerClkBusConfig', 'Value': '&map_Icu_GpTimerClkBusConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pAtuClkBusCntrlRegs', 'Value': '[0 to 15] = &map_pAtuClkBusCntrlRegs[0]\\n'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuClkBusCntrlRegs[0]', 'Value': '0x07'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpNoiseCancellationConfig', 'Value': '&map_Icu_GpNoiseCancellationConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCMRCntrlRegValue', 'Value': '0x00'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMRCntrlReg', 'Value': '&map_pAtuNCMRCntrlReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMRCntrlReg[0]', 'Value': '0x80'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR1ACntrlReg', 'Value': '&map_pAtuNCMCR1ACntrlReg[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1ACntrlReg[0]', 'Value': '0x00'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR2ACntrlReg', 'Value': '&map_pAtuNCMCR2ACntrlReg[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2ACntrlReg[0]', 'Value': '0x00'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuTIOR2ACntrlReg', 'Value': '&map_pAtuTIOR2ACntrlReg[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuTIOR2ACntrlReg[0]', 'Value': '0x00000000'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR1CCntrlReg', 'Value': '&map_pAtuNCMCR1CCntrlReg[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1CCntrlReg[0]', 'Value': '0x00'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR2CCntrlReg', 'Value': '&map_pAtuNCMCR2CCntrlReg[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2CCntrlReg[0]', 'Value': '0x00'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pNCCRCCntrlRegConfig', 'Value': '&map_pNCCRCCntrlRegConfig[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucTotalTimerCConfigured', 'Value': '0x01'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCCRCSubBlockIndex', 'Value': '0x00'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCCRCCntrlRegAdrs', 'Value': '&map_pAtuNCCRCCntrlRegAdrs[0]'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCCRCCntrlRegAdrs[0]', 'Value': '0x00']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuClkBusCntrlRegs[0]', 'Value': '0x00'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMRCntrlReg[0]', 'Value': '0x80'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1ACntrlReg[0]', 'Value': '0x00'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2ACntrlReg[0]', 'Value': '0x00'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuTIOR2ACntrlReg[0]', 'Value': '0x00000000'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1CCntrlReg[0]', 'Value': '0x00'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2CCntrlReg[0]', 'Value': '0x00'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCCRCCntrlRegAdrs[0]', 'Value': '0x00'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_ATU_TIMER_UNIT_USED == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Atu_UnitInit(P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { #if ((ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED) || \\ (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED)) /* Defining a pointer to the ATU configuration parameters */ P2CONST(Icu_ATUConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpATUConfig; /* PRQA S 3432 # JV-01 */ #endif #if (ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED) /* Defining a pointer to the ATU channel configuration parameters */ P2CONST(Icu_ATUChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpATUChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the common contrl Register */ P2VAR(Icu_ATUCommonCntlRegs, AUTOMATIC, ICU_CONFIG_DATA) LpCommonCntlReg; /* PRQA S 3432 # JV-01 */ P2CONST(Icu_ATU_CommonPrescalerConfigType, AUTOMATIC, ICU_CONFIG_DATA) LaaATUCommonPrescalerConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Icu_ATU_CommonPrescalerConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpCommonPrescalerConfig; /* PRQA S 3432 # JV-01 */ /* Store the global pointer to first Common Prescaler configuration */ #endif /* Counter variable*/ uint8 LucCnt; /* Local variable to hold the channel number */ volatile uint8 LucChannelNo; /* Index of HW IP Type */ volatile VAR(uint8, AUTOMATIC) LucHWIPType; #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED) /* Defining a pointer to the clock bus selection configuration parameters */ P2CONST(Icu_ATU_ClockBusConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpTimerClkBusConfig; /* PRQA S 3432 # JV-01 */ #endif /* Defining a pointer to the clock bus selection Control Register */ P2VAR(volatile uint8, AUTOMATIC, ICU_CONFIG_DATA) LpClkBusCntrlReg; /* PRQA S 3432 # JV-01 */ #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) /* Defining a pointer to the Timer Noise Cancellation configuration */ P2CONST(Icu_NoiseCancellationConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpNoiseCancellationConfig; /* PRQA S 3432 # JV-01 */ #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) /* Defining a pointer to the NCCRC register Configuration parameter*/ P2CONST(Icu_NCCRCCntrlRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpNCCRCCntrlRegConfig; #endif /* End of #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) */ #endif /* ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) */ /* Update the global pointer with the first channel's address of Signal Measurement mode type channel's RAM data */ #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) Icu_GpSignalMeasurementData = (P2VAR(Icu_SignalMeasurementModeRamDataType, ICU_VAR_NO_INIT, /* PRQA S 0312, 0316, 3432 # JV-01, JV-01, JV-01 */ ICU_APPL_CONST))ConfigPtr->pSignalMeasureAddress; /* PRQA S 2814 # JV-01 */ #endif /* Update the global pointer with the first channel's configuration database address */ #if ((ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED) || \\ (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED)) LpATUConfig = ConfigPtr->pATUConfig; /* PRQA S 0317 # JV-01 */ #endif #if (ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED) for (LucChannelNo = (uint8)ICU_ZERO; LucChannelNo < (uint8)ICU_MAX_CHANNEL; LucChannelNo++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the HWIP Type for given channel */ LucHWIPType = Icu_GpChannelConfig[LucChannelNo].ucIcuChannelType; if ((ICU_HW_ATU_TIMERA == LucHWIPType) || (ICU_HW_ATU_TIMERC == LucHWIPType)) /* PRQA S 3415, 3416 # JV-01, JV-01 */ { LpATUChannelConfig = Icu_GpChannelConfig[LucChannelNo].pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ break; } /* else No action required */ } LaaATUCommonPrescalerConfig = LpATUConfig->pCommonPrescalerConfig; /* PRQA S 0317, 2814 # JV-01, JV-01 */ /* Enable the configured ICU ATU Units in ATUENR register */ LpCommonCntlReg = (P2VAR(Icu_ATUCommonCntlRegs, AUTOMATIC, ICU_CONFIG_DATA))LpATUChannelConfig->pAtuCommonCntlRegs; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* Initialize the ATU-V Common Prescaler*/ for (LucCnt = ICU_ZERO; (uint16)LucCnt < (uint16)ICU_ATU_COMMON_PRESCALER_CONFIGURED; LucCnt++) { /* Initialized Pointer for Common Prescaler Config */ LpCommonPrescalerConfig = &LaaATUCommonPrescalerConfig[LucCnt]; /* PRQA S 2824 # JV-01 */ /* Set value of Prescaler*/ *((volatile uint16 *)LpCommonPrescalerConfig->pATUCommonPrescalerCntlReg) = /* PRQA S 0316 # JV-01 */ LpCommonPrescalerConfig->usAtuCommonPrescalerDivRatio; /* PRQA S 2814 # JV-01 */ } /* Enable the configured prescaler Units in ATUENR register */ (LpCommonCntlReg->ucAtuTimerATUENR) |= ICU_PSCE_MASK_VALUE; /* PRQA S 2814 # JV-01 */ #endif /* End of (ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED)) */ #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED) /* Update the global pointer with the ICU pTimerClock bus configuration */ Icu_GpTimerClkBusConfig = LpATUConfig->pTimerClkBusConfig; /* PRQA S 0317, 2916 # JV-01, JV-01 */ /* Update the previous input use pointer to point to the current channel */ LpTimerClkBusConfig = Icu_GpTimerClkBusConfig; /* Clock bus selection for the configured timer unit */ for (LucCnt = ICU_ZERO; LucCnt < ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED; LucCnt++) { /* Load clock bus selection for the timer unit */ LpClkBusCntrlReg = LpTimerClkBusConfig->pAtuClkBusCntrlRegs; /* PRQA S 0317, 2814 # JV-01, JV-01 */ *(LpClkBusCntrlReg) = ((*(LpClkBusCntrlReg)&ICU_CLK_BUS_SELECT_MASK) | (LpTimerClkBusConfig->ucClkBusSelect)); /* PRQA S 2814 # JV-01 */ /* Increment the pointer to point to next previous input channel */ LpTimerClkBusConfig++; /* PRQA S 2824 # JV-01 */ } /* End of clock bus selection channel for loop */ #endif /* #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED) */ #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) /* Update the Global pointer to point to first channel's the Timer Noise Cancellation configuration. */ Icu_GpNoiseCancellationConfig = LpATUConfig->pNoiseCancellationConfig; /* PRQA S 0317, 2916 # JV-01, JV-01 */ /* Update the local pointer to point to the Timer Noise Cancellation configuration. */ LpNoiseCancellationConfig = Icu_GpNoiseCancellationConfig; if (ICU_NC_PLL_ENABLE == LpNoiseCancellationConfig->ucAtuNCMRCntrlRegValue) /* PRQA S 2814 # JV-01 */ { /* Enabling the bit NCCSEL in the NCMR register */ *(LpNoiseCancellationConfig->pAtuNCMRCntrlReg) |= ICU_NC_PLL_ENABLE; } else { /* Resetting the bit NCCSEL in the NCMR register */ *(LpNoiseCancellationConfig->pAtuNCMRCntrlReg) &= (uint8)~ICU_NC_PLL_ENABLE; } /* Resetting the Noise Cancellation Mode Select bits of TimerA and TimerC */ *(LpNoiseCancellationConfig->pAtuNCMRCntrlReg) &= (uint8)~ICU_NC_NCMR_MASK; #if (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) /* Load the Noise Cancellation Selection mode in the Noise Cancellation Mode Channel Register 1A */ *(LpNoiseCancellationConfig->pAtuNCMCR1ACntrlReg) = LpNoiseCancellationConfig->ucAtuNCMCR1ACntrlRegValue; /* PRQA S 2814 # JV-01 */ /* Load the Noise Cancellation Selection mode in the Noise Cancellation Mode Channel Register 2A */ *(LpNoiseCancellationConfig->pAtuNCMCR2ACntrlReg) = LpNoiseCancellationConfig->ucAtuNCMCR2ACntrlRegValue; /* PRQA S 2814 # JV-01 */ /* Load the Timer I/O Control Register 2A based on the clock selection, and Enabling/Disabling the Noise Canceller */ *(LpNoiseCancellationConfig->pAtuTIOR2ACntrlReg) = LpNoiseCancellationConfig->ulAtuTIOR2ACntrlRegValue; /* PRQA S 2814 # JV-01 */ #endif /* End of #if (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) */ #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) /* Select the Noise cancellation modes for the TimerC subblocks */ *(LpNoiseCancellationConfig->pAtuNCMCR1CCntrlReg) = LpNoiseCancellationConfig->usAtuNCMCR1CCntrlRegValue; /* PRQA S 2814 # JV-01 */ /* Select the Noise cancellation modes for the TimerC subblocks */ *(LpNoiseCancellationConfig->pAtuNCMCR2CCntrlReg) = LpNoiseCancellationConfig->usAtuNCMCR2CCntrlRegValue; /* PRQA S 2814 # JV-01 */ /* Load the value for the Noise Canceler Clock Selection and the Noise Canceler Enable or Disable */ LpNCCRCCntrlRegConfig = LpNoiseCancellationConfig->pNCCRCCntrlRegConfig; /* PRQA S 0317 # JV-01 */ for (LucCnt = ICU_ZERO; LucCnt < LpNoiseCancellationConfig->ucTotalTimerCConfigured; LucCnt++) { /* Load the value of the Noise Canceler Control Register for the respective Timer C subblock. */ *((LpNoiseCancellationConfig->pAtuNCCRCCntrlRegAdrs + LpNCCRCCntrlRegConfig->ucAtuNCCRCSubBlockIndex)) = /* PRQA S 0488, 2824 # JV-01, JV-01 */ LpNCCRCCntrlRegConfig->ucAtuNCCRCCntrlRegValue; /* PRQA S 2814 # JV-01 */ LpNCCRCCntrlRegConfig++; /* PRQA S 2824 # JV-01 */ } #endif /* End of #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) */ #endif /* End of #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON))*/ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_COMMON_PRESCALER_CONFIGURED', 'Value': '0x01'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED', 'Value': '15'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERA_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERC_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATUA_NOISE_CANCELLATION_ENABLE', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATUC_NOISE_CANCELLATION_ENABLE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAU_UNIT_USED', 'Value': 'STD_OFF'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pSignalMeasureAddress', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pATUConfig', 'Value': '&map_Icu_GpATUConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '[0 to 1] = &map_Icu_GpATUChannelConfig[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[0] = ICU_HW_ATU_TIMERA\\n[1] = ICU_HW_EXT_IRQ'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pCommonPrescalerConfig', 'Value': '&map_Icu_GpATUCommonPrescalerConfig[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuCommonCntlRegs', 'Value': '&map_pAtuCommonCntlRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pATUCommonPrescalerCntlReg', 'Value': '&map_pATUCommonPrescalerCntlReg[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuCommonPrescalerDivRatio', 'Value': '0x0001'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pATUCommonPrescalerCntlReg[0]', 'Value': '0x0000'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuTimerATUENR', 'Value': '0x00'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'pTimerClkBusConfig', 'Value': '&map_Icu_GpTimerClkBusConfig[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pAtuClkBusCntrlRegs', 'Value': '[0 to 14] = &map_pAtuClkBusCntrlRegs[0]\\n'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'ucClkBusSelect', 'Value': '[0 to 14] = 0x01'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuClkBusCntrlRegs[0]', 'Value': '0x00'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'pNoiseCancellationConfig', 'Value': '&map_Icu_GpNoiseCancellationConfig[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCMRCntrlRegValue', 'Value': 'ICU_NC_PLL_ENABLE'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMRCntrlReg', 'Value': '&map_pAtuNCMRCntrlReg[0]'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR1ACntrlReg', 'Value': '&map_pAtuNCMCR1ACntrlReg[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCMCR1ACntrlRegValue', 'Value': '0x01'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR2ACntrlReg', 'Value': '&map_pAtuNCMCR2ACntrlReg[0]'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCMCR2ACntrlRegValue', 'Value': '0x01'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuTIOR2ACntrlReg', 'Value': '&map_pAtuTIOR2ACntrlReg[0]'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ulAtuTIOR2ACntrlRegValue', 'Value': '0x00000001'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR1CCntrlReg', 'Value': '&map_pAtuNCMCR1CCntrlReg[0]'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuNCMCR1CCntrlRegValue', 'Value': '0x0001'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR2CCntrlReg', 'Value': '&map_pAtuNCMCR2CCntrlReg[0]'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuNCMCR2CCntrlRegValue', 'Value': '0x0001'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'pNCCRCCntrlRegConfig', 'Value': '&map_pNCCRCCntrlRegConfig[0]'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCCRCCntrlRegAdrs', 'Value': '&map_pAtuNCCRCCntrlRegAdrs[0]'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'ucTotalTimerCConfigured', 'Value': '0x01'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMRCntrlReg[0]', 'Value': '0x00'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1ACntrlReg[0]', 'Value': '0x00'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2ACntrlReg[0]', 'Value': '0x00'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuTIOR2ACntrlReg[0]', 'Value': '0x00000000'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1CCntrlReg[0]', 'Value': '0x0000'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2CCntrlReg[0]', 'Value': '0x0000'], 'Input_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCCRCCntrlRegAdrs[0]', 'Value': '0x00'], 'Input_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCCRCSubBlockIndex', 'Value': '0x00'], 'Input_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCCRCCntrlRegValue', 'Value': '0x01']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTimerClkBusConfig', 'Value': '&map_Icu_GpTimerClkBusConfig[0]'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpNoiseCancellationConfig', 'Value': '&map_Icu_GpNoiseCancellationConfig[0]'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_pATUCommonPrescalerCntlReg[0]', 'Value': '0x0001'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuTimerATUENR', 'Value': '0x01'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuClkBusCntrlRegs[0]', 'Value': '0x01'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMRCntrlReg[0]', 'Value': '0x80'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1ACntrlReg[0]', 'Value': '0x01'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2ACntrlReg[0]', 'Value': '0x01'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuTIOR2ACntrlReg[0]', 'Value': '0x00000001'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1CCntrlReg[0]', 'Value': '0x0001'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2CCntrlReg[0]', 'Value': '0x0001'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCCRCCntrlRegAdrs[0]', 'Value': '0x01'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_ATU_TIMER_UNIT_USED == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Atu_UnitInit(P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { #if ((ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED) || \\ (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED)) /* Defining a pointer to the ATU configuration parameters */ P2CONST(Icu_ATUConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpATUConfig; /* PRQA S 3432 # JV-01 */ #endif #if (ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED) /* Defining a pointer to the ATU channel configuration parameters */ P2CONST(Icu_ATUChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpATUChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the common contrl Register */ P2VAR(Icu_ATUCommonCntlRegs, AUTOMATIC, ICU_CONFIG_DATA) LpCommonCntlReg; /* PRQA S 3432 # JV-01 */ P2CONST(Icu_ATU_CommonPrescalerConfigType, AUTOMATIC, ICU_CONFIG_DATA) LaaATUCommonPrescalerConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Icu_ATU_CommonPrescalerConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpCommonPrescalerConfig; /* PRQA S 3432 # JV-01 */ /* Store the global pointer to first Common Prescaler configuration */ #endif /* Counter variable*/ uint8 LucCnt; /* Local variable to hold the channel number */ volatile uint8 LucChannelNo; /* Index of HW IP Type */ volatile VAR(uint8, AUTOMATIC) LucHWIPType; #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED) /* Defining a pointer to the clock bus selection configuration parameters */ P2CONST(Icu_ATU_ClockBusConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpTimerClkBusConfig; /* PRQA S 3432 # JV-01 */ #endif /* Defining a pointer to the clock bus selection Control Register */ P2VAR(volatile uint8, AUTOMATIC, ICU_CONFIG_DATA) LpClkBusCntrlReg; /* PRQA S 3432 # JV-01 */ #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) /* Defining a pointer to the Timer Noise Cancellation configuration */ P2CONST(Icu_NoiseCancellationConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpNoiseCancellationConfig; /* PRQA S 3432 # JV-01 */ #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) /* Defining a pointer to the NCCRC register Configuration parameter*/ P2CONST(Icu_NCCRCCntrlRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) /* PRQA S 3432 # JV-01 */ LpNCCRCCntrlRegConfig; #endif /* End of #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) */ #endif /* ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) */ /* Update the global pointer with the first channel's address of Signal Measurement mode type channel's RAM data */ #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) Icu_GpSignalMeasurementData = (P2VAR(Icu_SignalMeasurementModeRamDataType, ICU_VAR_NO_INIT, /* PRQA S 0312, 0316, 3432 # JV-01, JV-01, JV-01 */ ICU_APPL_CONST))ConfigPtr->pSignalMeasureAddress; /* PRQA S 2814 # JV-01 */ #endif /* Update the global pointer with the first channel's configuration database address */ #if ((ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED) || \\ (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED)) LpATUConfig = ConfigPtr->pATUConfig; /* PRQA S 0317 # JV-01 */ #endif #if (ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED) for (LucChannelNo = (uint8)ICU_ZERO; LucChannelNo < (uint8)ICU_MAX_CHANNEL; LucChannelNo++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the HWIP Type for given channel */ LucHWIPType = Icu_GpChannelConfig[LucChannelNo].ucIcuChannelType; if ((ICU_HW_ATU_TIMERA == LucHWIPType) || (ICU_HW_ATU_TIMERC == LucHWIPType)) /* PRQA S 3415, 3416 # JV-01, JV-01 */ { LpATUChannelConfig = Icu_GpChannelConfig[LucChannelNo].pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ break; } /* else No action required */ } LaaATUCommonPrescalerConfig = LpATUConfig->pCommonPrescalerConfig; /* PRQA S 0317, 2814 # JV-01, JV-01 */ /* Enable the configured ICU ATU Units in ATUENR register */ LpCommonCntlReg = (P2VAR(Icu_ATUCommonCntlRegs, AUTOMATIC, ICU_CONFIG_DATA))LpATUChannelConfig->pAtuCommonCntlRegs; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* Initialize the ATU-V Common Prescaler*/ for (LucCnt = ICU_ZERO; (uint16)LucCnt < (uint16)ICU_ATU_COMMON_PRESCALER_CONFIGURED; LucCnt++) { /* Initialized Pointer for Common Prescaler Config */ LpCommonPrescalerConfig = &LaaATUCommonPrescalerConfig[LucCnt]; /* PRQA S 2824 # JV-01 */ /* Set value of Prescaler*/ *((volatile uint16 *)LpCommonPrescalerConfig->pATUCommonPrescalerCntlReg) = /* PRQA S 0316 # JV-01 */ LpCommonPrescalerConfig->usAtuCommonPrescalerDivRatio; /* PRQA S 2814 # JV-01 */ } /* Enable the configured prescaler Units in ATUENR register */ (LpCommonCntlReg->ucAtuTimerATUENR) |= ICU_PSCE_MASK_VALUE; /* PRQA S 2814 # JV-01 */ #endif /* End of (ICU_ATU_COMMON_PRESCALER_CONFIGURED != ICU_COMMON_PRESCALER_NOT_USED)) */ #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED) /* Update the global pointer with the ICU pTimerClock bus configuration */ Icu_GpTimerClkBusConfig = LpATUConfig->pTimerClkBusConfig; /* PRQA S 0317, 2916 # JV-01, JV-01 */ /* Update the previous input use pointer to point to the current channel */ LpTimerClkBusConfig = Icu_GpTimerClkBusConfig; /* Clock bus selection for the configured timer unit */ for (LucCnt = ICU_ZERO; LucCnt < ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED; LucCnt++) { /* Load clock bus selection for the timer unit */ LpClkBusCntrlReg = LpTimerClkBusConfig->pAtuClkBusCntrlRegs; /* PRQA S 0317, 2814 # JV-01, JV-01 */ *(LpClkBusCntrlReg) = ((*(LpClkBusCntrlReg)&ICU_CLK_BUS_SELECT_MASK) | (LpTimerClkBusConfig->ucClkBusSelect)); /* PRQA S 2814 # JV-01 */ /* Increment the pointer to point to next previous input channel */ LpTimerClkBusConfig++; /* PRQA S 2824 # JV-01 */ } /* End of clock bus selection channel for loop */ #endif /* #if (ICU_TIMER_CLK_BUS_NOT_USED != ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED) */ #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON)) /* Update the Global pointer to point to first channel's the Timer Noise Cancellation configuration. */ Icu_GpNoiseCancellationConfig = LpATUConfig->pNoiseCancellationConfig; /* PRQA S 0317, 2916 # JV-01, JV-01 */ /* Update the local pointer to point to the Timer Noise Cancellation configuration. */ LpNoiseCancellationConfig = Icu_GpNoiseCancellationConfig; if (ICU_NC_PLL_ENABLE == LpNoiseCancellationConfig->ucAtuNCMRCntrlRegValue) /* PRQA S 2814 # JV-01 */ { /* Enabling the bit NCCSEL in the NCMR register */ *(LpNoiseCancellationConfig->pAtuNCMRCntrlReg) |= ICU_NC_PLL_ENABLE; } else { /* Resetting the bit NCCSEL in the NCMR register */ *(LpNoiseCancellationConfig->pAtuNCMRCntrlReg) &= (uint8)~ICU_NC_PLL_ENABLE; } /* Resetting the Noise Cancellation Mode Select bits of TimerA and TimerC */ *(LpNoiseCancellationConfig->pAtuNCMRCntrlReg) &= (uint8)~ICU_NC_NCMR_MASK; #if (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) /* Load the Noise Cancellation Selection mode in the Noise Cancellation Mode Channel Register 1A */ *(LpNoiseCancellationConfig->pAtuNCMCR1ACntrlReg) = LpNoiseCancellationConfig->ucAtuNCMCR1ACntrlRegValue; /* PRQA S 2814 # JV-01 */ /* Load the Noise Cancellation Selection mode in the Noise Cancellation Mode Channel Register 2A */ *(LpNoiseCancellationConfig->pAtuNCMCR2ACntrlReg) = LpNoiseCancellationConfig->ucAtuNCMCR2ACntrlRegValue; /* PRQA S 2814 # JV-01 */ /* Load the Timer I/O Control Register 2A based on the clock selection, and Enabling/Disabling the Noise Canceller */ *(LpNoiseCancellationConfig->pAtuTIOR2ACntrlReg) = LpNoiseCancellationConfig->ulAtuTIOR2ACntrlRegValue; /* PRQA S 2814 # JV-01 */ #endif /* End of #if (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON) */ #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) /* Select the Noise cancellation modes for the TimerC subblocks */ *(LpNoiseCancellationConfig->pAtuNCMCR1CCntrlReg) = LpNoiseCancellationConfig->usAtuNCMCR1CCntrlRegValue; /* PRQA S 2814 # JV-01 */ /* Select the Noise cancellation modes for the TimerC subblocks */ *(LpNoiseCancellationConfig->pAtuNCMCR2CCntrlReg) = LpNoiseCancellationConfig->usAtuNCMCR2CCntrlRegValue; /* PRQA S 2814 # JV-01 */ /* Load the value for the Noise Canceler Clock Selection and the Noise Canceler Enable or Disable */ LpNCCRCCntrlRegConfig = LpNoiseCancellationConfig->pNCCRCCntrlRegConfig; /* PRQA S 0317 # JV-01 */ for (LucCnt = ICU_ZERO; LucCnt < LpNoiseCancellationConfig->ucTotalTimerCConfigured; LucCnt++) { /* Load the value of the Noise Canceler Control Register for the respective Timer C subblock. */ *((LpNoiseCancellationConfig->pAtuNCCRCCntrlRegAdrs + LpNCCRCCntrlRegConfig->ucAtuNCCRCSubBlockIndex)) = /* PRQA S 0488, 2824 # JV-01, JV-01 */ LpNCCRCCntrlRegConfig->ucAtuNCCRCCntrlRegValue; /* PRQA S 2814 # JV-01 */ LpNCCRCCntrlRegConfig++; /* PRQA S 2824 # JV-01 */ } #endif /* End of #if (ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) */ #endif /* End of #if ((ICU_ATUC_NOISE_CANCELLATION_ENABLE == STD_ON) || \\ (ICU_ATUA_NOISE_CANCELLATION_ENABLE == STD_ON))*/ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_COMMON_PRESCALER_CONFIGURED', 'Value': '0x01'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMER_CLK_BUS_SELECTION_CONFIGURED', 'Value': '6'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERA_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERC_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATUA_NOISE_CANCELLATION_ENABLE', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATUC_NOISE_CANCELLATION_ENABLE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAU_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pSignalMeasureAddress', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pATUConfig', 'Value': '&map_Icu_GpATUConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '[0 to 1] = &map_Icu_GpATUChannelConfig[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[0] = ICU_HW_ATU_TIMERA\\n[1] = ICU_HW_EXT_INTP'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pCommonPrescalerConfig', 'Value': '&map_Icu_GpATUCommonPrescalerConfig[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuCommonCntlRegs', 'Value': '&map_pAtuCommonCntlRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pATUCommonPrescalerCntlReg', 'Value': '&map_pATUCommonPrescalerCntlReg[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuCommonPrescalerDivRatio', 'Value': '0x0001'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pATUCommonPrescalerCntlReg[0]', 'Value': '0x0000'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuTimerATUENR', 'Value': '0x00'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'pTimerClkBusConfig', 'Value': '&map_Icu_GpTimerClkBusConfig[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'pAtuClkBusCntrlRegs', 'Value': '[0 to 5] = &map_pAtuClkBusCntrlRegs[0]\\n'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'ucClkBusSelect', 'Value': '[0 to 5] = 0x01'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuClkBusCntrlRegs[0]', 'Value': '0x00'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'pNoiseCancellationConfig', 'Value': '&map_Icu_GpNoiseCancellationConfig[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCMRCntrlRegValue', 'Value': 'ICU_NC_PLL_ENABLE'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMRCntrlReg', 'Value': '&map_pAtuNCMRCntrlReg[0]'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR1ACntrlReg', 'Value': '&map_pAtuNCMCR1ACntrlReg[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCMCR1ACntrlRegValue', 'Value': '0x01'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR2ACntrlReg', 'Value': '&map_pAtuNCMCR2ACntrlReg[0]'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCMCR2ACntrlRegValue', 'Value': '0x01'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuTIOR2ACntrlReg', 'Value': '&map_pAtuTIOR2ACntrlReg[0]'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ulAtuTIOR2ACntrlRegValue', 'Value': '0x00000001'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR1CCntrlReg', 'Value': '&map_pAtuNCMCR1CCntrlReg[0]'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuNCMCR1CCntrlRegValue', 'Value': '0x0001'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCMCR2CCntrlReg', 'Value': '&map_pAtuNCMCR2CCntrlReg[0]'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuNCMCR2CCntrlRegValue', 'Value': '0x0001'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'pNCCRCCntrlRegConfig', 'Value': '&map_pNCCRCCntrlRegConfig[0]'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'pAtuNCCRCCntrlRegAdrs', 'Value': '&map_pAtuNCCRCCntrlRegAdrs[0]'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'ucTotalTimerCConfigured', 'Value': '0x01'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMRCntrlReg[0]', 'Value': '0x00'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1ACntrlReg[0]', 'Value': '0x00'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2ACntrlReg[0]', 'Value': '0x00'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuTIOR2ACntrlReg[0]', 'Value': '0x00000000'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1CCntrlReg[0]', 'Value': '0x0000'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2CCntrlReg[0]', 'Value': '0x0000'], 'Input_Param_045': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCCRCCntrlRegAdrs[0]', 'Value': '0x00'], 'Input_Param_046': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCCRCSubBlockIndex', 'Value': '0x00'], 'Input_Param_047': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuNCCRCCntrlRegValue', 'Value': '0x01']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTimerClkBusConfig', 'Value': '&map_Icu_GpTimerClkBusConfig[0]'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpNoiseCancellationConfig', 'Value': '&map_Icu_GpNoiseCancellationConfig[0]'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_pATUCommonPrescalerCntlReg[0]', 'Value': '0x0001'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucAtuTimerATUENR', 'Value': '0x01'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuClkBusCntrlRegs[0]', 'Value': '0x01'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMRCntrlReg[0]', 'Value': '0x80'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1ACntrlReg[0]', 'Value': '0x01'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2ACntrlReg[0]', 'Value': '0x01'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuTIOR2ACntrlReg[0]', 'Value': '0x00000001'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR1CCntrlReg[0]', 'Value': '0x0001'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCMCR2CCntrlReg[0]', 'Value': '0x0001'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pAtuNCCRCCntrlRegAdrs[0]', 'Value': '0x01'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_GET_INPUT_LEVEL_API == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" FUNC(Icu_LevelType, ICU_PRIVATE_CODE) Icu_HW_GetInputLevel(const Icu_ChannelType LddChannel) { /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local variable to store the return level value */ Icu_LevelType LenInputLevel; LenInputLevel = ICU_LOW; /* Update the channel configuration pointer to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; if (NULL_PTR != LpChannelConfig->pPPRAddress) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Check the port type configured */ if (ICU_NORMAL_PORT == LpChannelConfig->ucIcuPortType) { /* Access data from 16 bit register and compare with the mask value */ if ((uint32)(*((uint16*)(LpChannelConfig->pPPRAddress)) & /* PRQA S 0312, 2814 # JV-01, JV-01 */ (LpChannelConfig->ulPortMaskValue)) == (LpChannelConfig->ulPortMaskValue)) { LenInputLevel = ICU_HIGH; } /* else No action required */ } else { /* Access data from 8 bit register and compare with the mask value */ if ((uint32)(*((uint8 *)(LpChannelConfig->pPPRAddress)) & /* PRQA S 0312, 0751 # JV-01, JV-01 */ (LpChannelConfig->ulPortMaskValue)) == (LpChannelConfig->ulPortMaskValue)) { LenInputLevel = ICU_HIGH; } /* else No action required */ } } /* End of LpChannelConfig->pPPRAddress != NULL_PTR */ else if (NULL_PTR != LpChannelConfig->pINDTAddress) /* PRQA S 2004 # JV-01 */ { /* Check the port type configured */ if (ICU_NORMAL_PORT == LpChannelConfig->ucIcuPortType) { /* Access data from 32 bit register and compare with the mask value */ if ((*(LpChannelConfig->pINDTAddress) & /* PRQA S 2814 # JV-01 */ (LpChannelConfig->ulPortMaskValue)) == (LpChannelConfig->ulPortMaskValue)) { LenInputLevel = ICU_HIGH; } /* else No action required */ } /* else No action required */ } /* else No action required */ /* End of LpChannelConfig->pINDTAddress != NULL_PTR */ return (LenInputLevel); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_GET_INPUT_LEVEL_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'ICU_NORMAL_PORT\\nICU_JTAG_PORT', 'Name': 'ucIcuPortType', 'Value': 'ICU_NORMAL_PORT'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pPPRAddress', 'Value': '&map_pPPRAddress[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pINDTAddress', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulPortMaskValue', 'Value': '0x8000'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPPRAddress[0]', 'Value': '0x0000'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pINDTAddress[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddInputLevel', 'Value': 'ICU_LOW'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((STD_ON == ICU_IRQ_EDGE_DETECT) || (STD_ON == ICU_INTP_EDGE_DETECT)) #if (ICU_DE_INIT_API == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Pin_ChannelDeInit(const Icu_ChannelType LucChannelIndex) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the Timer registers */ P2VAR(volatile Icu_ChannelRamDataType, AUTOMATIC, ICU_CONFIG_DATA) LpRamData; /* PRQA S 3432 # JV-01 */ /* INTP */ #if ((ICU_EDGE_DETECT_API == STD_ON) && (ICU_INTP_EDGE_DETECT == STD_ON)) /* Defining a pointer to point to the External Interrupt registers */ P2VAR(volatile uint8, AUTOMATIC, ICU_CONFIG_DATA) LpFCLAnCTLAddress; /* PRQA S 3432 # JV-01 */ #endif /* End of (ICU_EDGE_DETECT_API == STD_ON) */ #if (ICU_EDGE_DETECT_API == STD_ON) #if (ICU_IRQ_EDGE_DETECT == STD_ON) /* Defining a pointer to the timer channel configuration parameters */ P2CONST(Icu_PINChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpPINChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the External Interrupt registers */ P2VAR(volatile uint16, AUTOMATIC, ICU_CONFIG_DATA) LpExtIntpcntRegs; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif /* Local variable to store the measurement mode of a channel */ Icu_MeasurementModeType LenMeasurementMode; #endif /* Load the channel data pointer */ LpRamData = &Icu_GpChannelRamData[LucChannelIndex]; /* Disable notification for each channel */ LpRamData->ucNotificationEnable = (uint8)ICU_FALSE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Initialize each channel status as idle */ LpRamData->ucChannelStatus = (uint8)ICU_IDLE; /* Update the channel configuration pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LucChannelIndex]; if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Disabling the Interrupt processing */ RH850_SV_SET_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_DISABLE_EIMK_MASK); /* PRQA S 0751, 1006, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ /* INTP */ #if (ICU_INTP_EDGE_DETECT == STD_ON) #if ((ICU_DISABLE_WAKEUP_API == STD_ON) || (ICU_ENABLE_WAKEUP_API == STD_ON) || \\ (ICU_WAKEUP_FUNCTIONALITY_API == STD_ON)) /* Disable each channel wakeup from sleep mode */ LpRamData->ucWakeupEnable = (uint8)ICU_FALSE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Initialize wakeup occurrence for each channel */ LpRamData->ucWakeupOccurrence = (uint8)ICU_FALSE; #endif #if ((STD_ON == ICU_SET_MODE_API) || (STD_ON == ICU_BUSY_OPERATION_DET_CHECK) || (ICU_EDGE_DETECT_API == STD_ON)) /* Initialize running status for each channel */ LpRamData->ucChannelRunning = (uint8)ICU_FALSE; #endif #endif /* End of (ICU_INTP_EDGE_DETECT == STD_ON) */ #if (ICU_EDGE_DETECT_API == STD_ON) /* Read the channel's measurement mode */ LenMeasurementMode = (Icu_MeasurementModeType)(LpChannelConfig->ucIcuMeasurementMode); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ /* Edge Detection Mode */ if (ICU_MODE_SIGNAL_EDGE_DETECT == LenMeasurementMode) { /* E2x - IRQ */ #if (ICU_IRQ_EDGE_DETECT == STD_ON) if (ICU_HW_EXT_IRQ == LpChannelConfig->ucIcuChannelType) { /* Update the PIN channel configuration pointer to point to the current channel */ LpPINChannelUserRegConfig = Icu_GpChannelUserRegConfig[LucChannelIndex].pHWChannelUserRegConfig; /* PRQA S 0317 # JV-01 */ /* Read the base configuration interrupt address */ LpExtIntpcntRegs = LpChannelConfig->pCntlRegs; /* PRQA S 0317 # JV-01 */ /* Set EXINTCTL register to the reset value */ RH850_SV_CLEAR_ICR_SYNCP(16, LpExtIntpcntRegs, (LpPINChannelUserRegConfig->ddChannelModeUserRegSettings)); /* PRQA S 2814 # JV-01 */ } /* else No action required */ #endif /* End of ICU_IRQ_EDGE_DETECT == STD_ON */ /* INTP */ #if (ICU_INTP_EDGE_DETECT == STD_ON) /* Read the base configuration interrupt address */ LpFCLAnCTLAddress = LpChannelConfig->pCntlRegs; /* PRQA S 0317 # JV-01 */ /* Set FCLAnCTLm register to the reset value */ *(LpFCLAnCTLAddress) = ICU_FCLA_CTL_RESET_VAL; /* PRQA S 2814 # JV-01 */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(8, LpFCLAnCTLAddress); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif /* ENd of (ICU_INTP_EDGE_DETECT == STD_ON) */ } /* else No action required */ /* End of ICU_MODE_SIGNAL_EDGE_DETECT == LenMeasurementMode */ #endif /* End of (ICU_EDGE_DETECT_API == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DE_INIT_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_EDGE_DETECT_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DISABLE_WAKEUP_API', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ENABLE_WAKEUP_API', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_WAKEUP_FUNCTIONALITY_API', 'Value': 'STD_OFF'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMER_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_SET_MODE_API', 'Value': 'STD_OFF'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannelIndex', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': 'ICU_MODE_SIGNAL_EDGE_DETECT'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'ICU_HW_EXT_IRQ (E2x)\\nICU_HW_ATU_TIMERA (E2x)\\nICU_HW_ATU_TIMERC (E2x)', 'Name': 'ucIcuChannelType', 'Value': 'ICU_HW_ATU_TIMERC'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pIntrCntlAddress', 'Value': 'NULL_PTR'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCntlRegs[0]', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ddChannelModeUserRegSettings', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pHWChannelUserRegConfig', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pCntlRegs[0]', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucWakeupEnable', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucWakeupOccurrence', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucNotificationEnable', 'Value': 'ICU_FALSE'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelRunning', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((STD_ON == ICU_IRQ_EDGE_DETECT) || (STD_ON == ICU_INTP_EDGE_DETECT)) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Pin_ChannelInit(const Icu_ChannelType LucChannelIndex) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the Channel Ram Data */ P2VAR(volatile Icu_ChannelRamDataType, AUTOMATIC, ICU_CONFIG_DATA) LpRamData; /* PRQA S 3432 # JV-01 */ /* INTP */ #if ((ICU_INTP_EDGE_DETECT == STD_ON) && (ICU_EDGE_DETECT_API == STD_ON)) /* Local variable to store the measurement mode of a channel */ Icu_MeasurementModeType LenMeasurementMode; #endif /* End of (ICU_INTP_EDGE_DETECT == STD_ON) && (ICU_EDGE_DETECT_API == STD_ON)) */ /* IRQ */ #if (ICU_IRQ_EDGE_DETECT == STD_ON) /* Defining a pointer to point to the External Interrupt registers */ P2VAR(volatile uint16, AUTOMATIC, ICU_CONFIG_DATA) LpExtIntpcntRegs; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the External Interrupt registers */ P2VAR(volatile uint8, AUTOMATIC, ICU_CONFIG_DATA) LpEXINTSTCRegs; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the timer channel configuration parameters */ P2CONST(Icu_PINChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpPINChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_PINChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpPinChannelConfig; /* PRQA S 3432 # JV-01 */ #endif /* Update the channel configuration pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LucChannelIndex]; /* Update the global pointer with the first channel's ram address */ LpRamData = &Icu_GpChannelRamData[LucChannelIndex]; /* Disable notification for each channel */ LpRamData->ucNotificationEnable = (uint8)ICU_FALSE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Initialize each channel status as idle */ LpRamData->ucChannelStatus = (uint8)ICU_IDLE; /* IRQ */ #if (ICU_IRQ_EDGE_DETECT == STD_ON) LpPinChannelConfig = Icu_GpChannelConfig[LucChannelIndex].pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ /* Update the PIN channel configuration pointer to point to the current channel */ LpPINChannelUserRegConfig = Icu_GpChannelUserRegConfig[LucChannelIndex].pHWChannelUserRegConfig; /* PRQA S 0317 # JV-01 */ /* Initialize all the configured Icu Channels */ if (ICU_HW_EXT_IRQ == LpChannelConfig->ucIcuChannelType) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { LpExtIntpcntRegs = LpChannelConfig->pCntlRegs; /* PRQA S 0317 # JV-01 */ LpEXINTSTCRegs = LpPinChannelConfig->pEXINSTCRegsAddress; /* PRQA S 0317, 2814 # JV-01, JV-01 */ if ((uint8)ICU_RISING_EDGE == LpChannelConfig->ucIcuDefaultStartEdge) { *(LpExtIntpcntRegs) = (uint16)(*(LpExtIntpcntRegs) & (LpPINChannelUserRegConfig->ddChannelModeUserRegSettings)) | /* PRQA S 2814 # JV-01 */ (uint16)((uint16)ICU_IRQ_RISING_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO)); /* PRQA S 3383 # JV-01 */ } else if ((uint8)ICU_FALLING_EDGE == LpChannelConfig->ucIcuDefaultStartEdge) /* PRQA S 2004 # JV-01 */ { *(LpExtIntpcntRegs) = (uint16)(*(LpExtIntpcntRegs) & (LpPINChannelUserRegConfig->ddChannelModeUserRegSettings)) | ((uint16)((uint16)ICU_IRQ_FALLING_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO))); /* PRQA S 3383 # JV-01 */ } /* else No action required */ /* Clear the IRQ status flag */ *(LpEXINTSTCRegs) = (uint8)(ICU_ONE << (uint8)LpChannelConfig->usChannelMaskValue); /* PRQA S 2814 # JV-01 */ } /* else No action required */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) { /* Disable interrupts */ RH850_SV_SET_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_DISABLE_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ } /* else No action required */ #endif /* End of ICU_IRQ_EDGE_DETECT == STD_ON */ /* INTP */ #if (ICU_INTP_EDGE_DETECT == STD_ON) /* Initialize all the configured Icu Channels */ #if ((ICU_DISABLE_WAKEUP_API == STD_ON) || (ICU_ENABLE_WAKEUP_API == STD_ON) || \\ (ICU_WAKEUP_FUNCTIONALITY_API == STD_ON)) /* Disable each channel wakeup from sleep mode */ LpRamData->ucWakeupEnable = (uint8)ICU_FALSE; /* Initialize wakeup occurrence for each channel */ LpRamData->ucWakeupOccurrence = (uint8)ICU_FALSE; #endif #if ((STD_ON == ICU_SET_MODE_API) || (STD_ON == ICU_BUSY_OPERATION_DET_CHECK) || (ICU_EDGE_DETECT_API == STD_ON)) /* Initialize running status for each channel */ LpRamData->ucChannelRunning = (uint8)ICU_FALSE; #endif #if (ICU_EDGE_DETECT_API == STD_ON) /* Read the channel's measurement mode */ LenMeasurementMode = (Icu_MeasurementModeType)(LpChannelConfig->ucIcuMeasurementMode); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ #endif /* End of (ICU_EDGE_DETECT_API == STD_ON) */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) { /* Disable the Interrupt processing of the current channel */ RH850_SV_SET_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_DISABLE_EIMK_MASK); /* PRQA S 0751, 1006, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ #if (ICU_EDGE_DETECT_API == STD_ON) if (ICU_MODE_SIGNAL_EDGE_DETECT == LenMeasurementMode) { /* Configure external interrupt for the active edge */ Icu_HW_Pin_SetActivation((Icu_ChannelType)LucChannelIndex, (Icu_ActivationType)LpChannelConfig->ucIcuDefaultStartEdge); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ } /* else No action required */ /* End of ICU_MODE_SIGNAL_EDGE_DETECT == LenMeasurementMode */ #endif /* End of (ICU_EDGE_DETECT_API == STD_ON) */ #endif /* ICU_INTP_EDGE_DETECT == STD_ON */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DISABLE_WAKEUP_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ENABLE_WAKEUP_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_WAKEUP_FUNCTIONALITY_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMER_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_SET_MODE_API', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_EDGE_DETECT_API', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannelIndex', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pEXINSTCRegsAddress', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': 'ICU_MODE_SIGNAL_EDGE_DETECT'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'ICU_HW_EXT_IRQ (E2x)\\nICU_HW_ATU_TIMERA (E2x)\\nICU_HW_ATU_TIMERC (E2x)', 'Name': 'ucIcuChannelType', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pIntrCntlAddress', 'Value': '&map_pIntrCntlAddress[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '  ICU_FALLING_EDGE\\n  ICU_RISING_EDGE\\n  ICU_BOTH_EDGES', 'Name': 'ucIcuDefaultStartEdge', 'Value': 'ICU_FALLING_EDGE'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '0x0001'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCntlRegs[0]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEXINSTCRegsAddress[0]', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'pHWChannelUserRegConfig', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ddChannelModeUserRegSettings', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelMaskValue', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelIndex', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'ucIcuDefaultStartEdge', 'Value': 'ICU_FALLING_EDGE'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '0x0081'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_pCntlRegs[0]', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_pEXINSTCRegsAddress[0]', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucWakeupEnable', 'Value': 'ICU_FALSE'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucWakeupOccurrence', 'Value': 'ICU_FALSE'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelRunning', 'Value': 'ICU_FALSE'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucNotificationEnable', 'Value': 'ICU_FALSE'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((STD_ON == ICU_IRQ_EDGE_DETECT) || (STD_ON == ICU_INTP_EDGE_DETECT)) #if (ICU_EDGE_DETECT_API == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Pin_EnableEdgeDetection(const Icu_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* IRQ */ #if (ICU_IRQ_EDGE_DETECT == STD_ON) #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Defining a pointer to point to the External */ /* Interrupt status clear registers */ P2VAR(volatile uint8, AUTOMATIC, ICU_CONFIG_DATA) LpEXINTSTCRegs; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_PINChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpPinChannelConfig; /* PRQA S 3432 # JV-01 */ #endif /* End of #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) */ #endif /* End of #if (ICU_IRQ_EDGE_DETECT == STD_ON) */ /* Update the channel configuration pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; /* IRQ */ #if (ICU_IRQ_EDGE_DETECT == STD_ON) if (ICU_HW_EXT_IRQ == LpChannelConfig->ucIcuChannelType) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) LpPinChannelConfig = Icu_GpChannelConfig[LddChannel].pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ #endif #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Clear the IRQ status flag */ LpEXINTSTCRegs = LpPinChannelConfig->pEXINSTCRegsAddress; /* PRQA S 0317, 2814 # JV-01, JV-01 */ *(LpEXINTSTCRegs) = (uint8)(ICU_ONE << (uint8)LpChannelConfig->usChannelMaskValue); /* PRQA S 2814 # JV-01 */ #endif /* End of #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) */ /* Check if the Interrupt register is present for particular channel */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) { /* Enable interrupts */ RH850_SV_CLEAR_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_ENABLE_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ } /* else No action required */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ #endif /* End of ICU_HW_EXT_IRQ == STD_ON */ /* INTP */ #if (ICU_INTP_EDGE_DETECT == STD_ON) #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Set the bit status running of channel is ICU_TRUE*/ Icu_GpChannelRamData[LddChannel].ucChannelRunning = (uint8)ICU_TRUE; /* Check if the Interrupt register is present for particular channel */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Clear the pending interrupts */ RH850_SV_CLEAR_ICR_SYNCP(16, LpChannelConfig->pIntrCntlAddress, ICU_CLEAR_PENDING_INTR_MASK); /* PRQA S 1006, 1281, 2814 # JV-01, JV-01, JV-01 */ #endif /* End of ICU_CLEAR_PENDING_INTERRUPT == STD_ON */ /* Enabling the Interrupt processing */ #if ((ICU_ENABLE_WAKEUP_API == STD_ON) || (ICU_NOTIFY_WAKEUP_INTERRUPT == STD_ON)) if ((ICU_MODE_SLEEP == Icu_GenModuleMode) && ((uint8)ICU_FALSE == Icu_GpChannelRamData[LddChannel].ucWakeupEnable)) { /* No action required */ } else #endif { /* Enable the Interrupt processing */ RH850_SV_CLEAR_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_ENABLE_EIMK_MASK); /* PRQA S 0751, 1006, 2814 # JV-01, JV-01, JV-01 */ } } /* else No action required */ /* End of NULL_PTR != LpChannelConfig->pIntrCntlAddress */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ #endif /* End of ICU_INTP_EDGE_DETECT == STD_ON */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_EDGE_DETECT_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CLEAR_PENDING_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMER_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '&map_Icu_PINChannelConfigType[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pEXINSTCRegsAddress', 'Value': '&map_pEXINSTCRegsAddress[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ICU_HW_EXT_IRQ (E2x)\\nICU_HW_ATU_TIMERA (E2x)\\nICU_HW_ATU_TIMERC (E2x)', 'Name': 'ucIcuChannelType', 'Value': 'ICU_HW_EXT_INTP'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCntlRegs[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEXINSTCRegsAddress[0]', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelMaskValue', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pIntrCntlAddress', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucWakeupEnable', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'ICU_MODE_NORMAL\\nICU_MODE_SLEEP', 'Name': 'Icu_GenModuleMode', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pEXINSTCRegsAddress[0]', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelRunning', 'Value': '-'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_004': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((STD_ON == ICU_IRQ_EDGE_DETECT) || (STD_ON == ICU_INTP_EDGE_DETECT)) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Pin_SetActivation(const Icu_ChannelType LddChannel, const Icu_ActivationType LenActiveEdge) /* PRQA S 1532 # JV-01 */ { #if (ICU_EDGE_DETECT_API == STD_ON) /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* INTP */ #if (STD_ON == ICU_INTP_EDGE_DETECT) /* Defining a pointer to point to the External Interrupt registers */ P2VAR(volatile uint8, AUTOMATIC, ICU_CONFIG_DATA) LpFCLAnCTLAddress; /* PRQA S 3432 # JV-01 */ #endif /* End of U2Ax - INTP */ #endif /* End of (ICU_EDGE_DETECT_API == STD_ON) */ #if (ICU_EDGE_DETECT_API == STD_ON) /* To store Channel Measurement Mode */ Icu_MeasurementModeType LenMeasurementMode; #endif /* E2x - IRQ */ #if ((STD_ON == ICU_IRQ_EDGE_DETECT) && (ICU_EDGE_DETECT_API == STD_ON)) /* Defining a pointer to the PIN timer channel configuration parameters */ P2CONST(Icu_PINChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpPINChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the External Interrupt registers */ P2VAR(volatile uint16, AUTOMATIC, ICU_CONFIG_DATA) LpExtIntpcntRegs; /* PRQA S 3432 # JV-01 */ #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Defining a pointer point to the External Interrupt Status clear Register */ P2VAR(volatile uint8, AUTOMATIC, ICU_CONFIG_DATA) LpEXINTSTCRegs; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_PINChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpPinChannelConfig; /* PRQA S 3432 # JV-01 */ LpPinChannelConfig = Icu_GpChannelConfig[LddChannel].pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ #endif /* End of (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) */ #endif /* End of ((STD_ON == ICU_IRQ_EDGE_DETECT) && (ICU_EDGE_DETECT_API == STD_ON)) */ #if (ICU_EDGE_DETECT_API == STD_ON) /* Update the channel configuration pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; /* Read measurement mode */ LenMeasurementMode = (Icu_MeasurementModeType)(LpChannelConfig->ucIcuMeasurementMode); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ #endif #if (ICU_EDGE_DETECT_API == STD_ON) if (ICU_MODE_SIGNAL_EDGE_DETECT == LenMeasurementMode) { /* IRQ */ #if (STD_ON == ICU_IRQ_EDGE_DETECT) /* Update the PIN Timer channel configuration pointer to point to the current channel */ LpPINChannelUserRegConfig = Icu_GpChannelUserRegConfig[LddChannel].pHWChannelUserRegConfig; /* PRQA S 0317 # JV-01 */ if (ICU_HW_EXT_IRQ == LpChannelConfig->ucIcuChannelType) { /* Read the address of EXINTCTL control register */ LpExtIntpcntRegs = LpChannelConfig->pCntlRegs; /* PRQA S 0317 # JV-01 */ if (ICU_FALLING_EDGE == LenActiveEdge) { /* Set the edge detection bits in the EXINTCTL control register as per mask */ *(LpExtIntpcntRegs) = (uint16)(*(LpExtIntpcntRegs) & (LpPINChannelUserRegConfig->ddChannelModeUserRegSettings)) /* PRQA S 2814 # JV-01 */ | ((uint16)((uint16)ICU_IRQ_FALLING_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO))); /* PRQA S 3383 # JV-01 */ } /* End of (LenActiveEdge == ICU_FALLING_EDGE) */ else if (ICU_RISING_EDGE == LenActiveEdge) /* PRQA S 2004 # JV-01 */ { /* Set the edge detection bits in the EXINTCTL control register as per mask */ *(LpExtIntpcntRegs) = (uint16)(*(LpExtIntpcntRegs) & (LpPINChannelUserRegConfig->ddChannelModeUserRegSettings)) | ((uint16)((uint16)ICU_IRQ_RISING_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO))); /* PRQA S 3383 # JV-01 */ } /* else No action required */ /* End of (LenActiveEdge == ICU_RISING_EDGE) */ #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Clear the IRQ status flag */ LpEXINTSTCRegs = LpPinChannelConfig->pEXINSTCRegsAddress; /* PRQA S 0317, 2814 # JV-01, JV-01 */ *(LpEXINTSTCRegs) = (uint8)(ICU_ONE << (uint8)LpChannelConfig->usChannelMaskValue); /* PRQA S 2814 # JV-01 */ #endif /* End of (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) */ } /* else No action required */ /* End of (ICU_HW_EXT_IRQ == LpChannelConfig->ucIcuChannelType) */ #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Check if the Interrupt register is present for particular channel */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) { /* Clear the pending interrupts */ RH850_SV_CLEAR_ICR_SYNCP(16, LpChannelConfig->pIntrCntlAddress, (uint16)ICU_CLEAR_PENDING_INTR_MASK); /* PRQA S 1281, 2814 # JV-01, JV-01 */ } /* else No action required */ /* End of LpChannelConfig->pIntrCntlAddress != NULL_PTR */ #endif /* End of #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) */ #endif /* End of STD_ON == ICU_IRQ_EDGE_DETECT */ /* INTP */ #if (STD_ON == ICU_INTP_EDGE_DETECT) /* Updating the channel config parameter to the current channel */ /* Read the address of filter control register */ LpFCLAnCTLAddress = LpChannelConfig->pCntlRegs; /* PRQA S 0317 # JV-01 */ /* Mask the bypass bits of filter control register */ *(LpFCLAnCTLAddress) = (*(LpFCLAnCTLAddress) & ICU_BYPASS_MASK); /* PRQA S 2814 # JV-01 */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(8, LpFCLAnCTLAddress); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ if (ICU_BOTH_EDGES == LenActiveEdge) { /* Set the edge detection bits in the filter control register as per mask */ *(LpFCLAnCTLAddress) = (*(LpFCLAnCTLAddress) | ICU_BOTH_EDGES_MASK); /* PRQA S 2814 # JV-01 */ } /* End of ICU_BOTH_EDGES == LenActiveEdge */ else if (ICU_FALLING_EDGE == LenActiveEdge) { /* Set the edge detection bits in the filter control register as per mask */ *(LpFCLAnCTLAddress) = (*(LpFCLAnCTLAddress) | ICU_FALLING_EDGE_MASK); } /* End of ICU_FALLING_EDGE == LenActiveEdge */ else /* (ICU_RISING_EDGE == LenActiveEdge) */ { /* Set the edge detection bits in the filter control register as per mask */ *(LpFCLAnCTLAddress) = (*(LpFCLAnCTLAddress) | ICU_RISING_EDGE_MASK); } /* End of ICU_RISING_EDGE == LenActiveEdge */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(8, LpFCLAnCTLAddress); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #endif /* End of STD_ON == ICU_INTP_EDGE_DETECT */ } /* else No action required */ /* End of ICU_MODE_SIGNAL_EDGE_DETECT == LenMeasurementMode */ #endif /* End of (ICU_EDGE_DETECT_API == STD_ON) */ /* Initialize channel status as idle */ Icu_GpChannelRamData[LddChannel].ucChannelStatus = (uint8)ICU_IDLE; #if (ICU_EDGE_DETECT_API == STD_ON) #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Check if the Interrupt register is present for particular channel */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Clear the pending interrupts */ RH850_SV_CLEAR_ICR_SYNCP(16, LpChannelConfig->pIntrCntlAddress, ICU_CLEAR_PENDING_INTR_MASK); /* PRQA S 1006, 1281, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ /* End of NULL_PTR != LpChannelConfig->pIntrCntlAddress */ #endif /* End of ICU_CLEAR_PENDING_INTERRUPT == STD_ON */ #endif /* End of (ICU_EDGE_DETECT_API == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_EDGE_DETECT_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CLEAR_PENDING_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMER_UNIT_USED', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_005': ['Type': 'Argument', 'Range': '  ICU_FALLING_EDGE\\n  ICU_RISING_EDGE\\n  ICU_BOTH_EDGES', 'Name': 'LenActiveEdge', 'Value': 'ICU_RISING_EDGE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pEXINSTCRegsAddress', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': 'ICU_MODE_SIGNAL_EDGE_DETECT'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'pIntrCntlAddress', 'Value': '[0] = &map_pIntrCntlAddress[0]\\n'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_pIntrCntlAddress[0 to 1]', 'Value': '[0] = 0x0001'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'ICU_HW_EXT_IRQ (E2x)\\nICU_HW_ATU_TIMERA (E2x)\\nICU_HW_ATU_TIMERC (E2x)', 'Name': 'ucIcuChannelType', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pHWChannelUserRegConfig', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ddChannelModeUserRegSettings', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelMaskValue', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '&map_pCntlRegs[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCntlRegs[0]', 'Value': '0x01'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEXINSTCRegsAddress[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_pCntlRegs[0]', 'Value': '0x01'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pEXINSTCRegsAddress[0]', 'Value': '-'], 'Output_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'map_pIntrCntlAddress[0 to 1]', 'Value': '[0] = 0x0001'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((STD_ON == ICU_IRQ_EDGE_DETECT) || (STD_ON == ICU_INTP_EDGE_DETECT)) #if (ICU_SET_MODE_API == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Pin_SetMode(const Icu_ChannelType LucChannelIndex, const Icu_ModeType LenMode) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local variable to store wakeup status */ uint8 LucWakeupStatus; /* Update the channel configuration pointer to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LucChannelIndex]; /* Read the current channel wakeup status */ LucWakeupStatus = (uint8)Icu_GpChannelRamData[LucChannelIndex].ucWakeupEnable; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Check for the current wakeup status of the channel */ if ((ICU_FALSE == LucWakeupStatus) && (NULL_PTR != LpChannelConfig->pIntrCntlAddress)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { if (ICU_MODE_SLEEP == LenMode) { /* Disable Interrupt */ RH850_SV_SET_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_DISABLE_EIMK_MASK); /* PRQA S 0751, 1006, 2814 # JV-01, JV-01, JV-01 */ } /* End of LenMode = ICU_MODE_SLEEP */ else /* LenMode = ICU_MODE_NORMAL */ { #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Check if the Interrupt register is present for particular channel */ /* Clear the pending interrupts */ RH850_SV_CLEAR_ICR_SYNCP(16, LpChannelConfig->pIntrCntlAddress, ICU_CLEAR_PENDING_INTR_MASK); /* PRQA S 1006, 1281 # JV-01, JV-01 */ #endif /* Enable Interrupt for on-going channels */ if ((uint8)ICU_TRUE == Icu_GpChannelRamData[LucChannelIndex].ucChannelRunning) { RH850_SV_CLEAR_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_ENABLE_EIMK_MASK); /* PRQA S 0751, 1006, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ } /* End of LenMode = ICU_MODE_NORMAL */ } /* End of ICU_FALSE == LucWakeupStatus && NULL_PTR != LpChannelConfig->pIntrCntlAddress */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_SET_MODE_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CLEAR_PENDING_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannelIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Argument', 'Range': '  ICU_MODE_NORMAL\\n  ICU_MODE_SLEEP', 'Name': 'LenMode', 'Value': 'ICU_MODE_NORMAL'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pIntrCntlAddress', 'Value': '&map_pIntrCntlAddress[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '0x0001'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucWakeupEnable', 'Value': 'ICU_FALSE'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucChannelRunning', 'Value': 'ICU_FALSE']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '0x0001'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUD_UNIT_USED == STD_ON) #if (ICU_TIMESTAMP_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_CODE_FAST) Icu_HW_Taud_ServiceTimestamp(const Icu_ChannelType LddChannel, const uint32 LulCapturedTimestampVal) /* PRQA S 1505 # JV-01 */ { #if (ICU_NOTIFICATION_CONFIG == STD_ON) /* Defining a pointer to point to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ #endif /* if (ICU_NOTIFICATION_CONFIG == STD_ON) */ /* Defining a pointer to point to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ P2VAR(Icu_TimeStampChannelRamDataType, AUTOMATIC, ICU_CONFIG_DATA) LpTimestampdata; /* PRQA S 3432 # JV-01 */ /* Local variable used to store the ram index of the channel */ uint8 LucRamIndex; #if (ICU_NOTIFICATION_CONFIG == STD_ON) /* Update the channel pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; #endif /* if (ICU_NOTIFICATION_CONFIG == STD_ON) */ /* Load timer channel configuration pointer and channel properties */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[LddChannel]; /* Read channel ram index */ LucRamIndex = LpChannelUserRegConfig->ucRamDataIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Read the Timestamp channel data pointer */ LpTimestampdata = &Icu_GpTimeStampData[LucRamIndex]; /* Check if timestamp capturing reached end of the buffer */ if ((LpTimestampdata->usTimestampIndex) < (LpTimestampdata->usBufferSize)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Update the buffer pointer with current timestamp */ *(LpTimestampdata->pBufferPointer) = LulCapturedTimestampVal; (LpTimestampdata->usTimestampIndex)++; (LpTimestampdata->pBufferPointer)++; /* PRQA S 2824 # JV-01 */ /* Check whether the timestamp index has reached the end of buffer */ if ((LpTimestampdata->usTimestampIndex) >= (LpTimestampdata->usBufferSize)) { /* Check if buffer is configured as circular */ if (ICU_TS_CIRCULAR_BUFFER_MASK == (uint8)(LpChannelUserRegConfig->ucChannelProperties & ICU_TS_CIRCULAR_BUFFER_MASK)) { /* Reset buffer pointer and index */ LpTimestampdata->usTimestampIndex = (uint16)ICU_BUFFER_IDX_INIT_VAL; LpTimestampdata->pBufferPointer = LpTimestampdata->pBufferPointer - LpTimestampdata->usBufferSize; /* PRQA S 0488 # JV-01 */ } /* else No action required */ } /* else No action required */ /* Notify if the configured number of timestamps are captured and notification is enabled */ #if (ICU_NOTIFICATION_CONFIG == STD_ON) if ((uint8)ICU_TRUE == Icu_GpChannelRamData[LddChannel].ucNotificationEnable) { (LpTimestampdata->usTimestampsCounter)++; /* PRQA S 3383 # JV-01 */ if ((LpTimestampdata->usTimestampsCounter) == (LpTimestampdata->usNotifyInterval)) { /* Reset the number of timestamp captured counter */ LpTimestampdata->usTimestampsCounter = (uint16)ICU_TIMESTAMP_RESET_CNT_VAL; /* Check if the function pointer address is present for particular channel */ if (NULL_PTR != LpChannelConfig->pIcuNotificationPointer) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* callback notification */ LpChannelConfig->pIcuNotificationPointer(); } /* else No action required */ } /* else No action required */ } /* else No action required */ #endif /* if (ICU_NOTIFICATION_CONFIG == STD_ON) */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_NOTIFICATION_CONFIG', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAUD_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMESTAMP_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'LulCapturedTimestampVal', 'Value': '0x00000001'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTimeStampData', 'Value': '&map_Icu_GpTimeStampData[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pIcuNotificationPointer', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'usTimestampIndex', 'Value': '0x00'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'usBufferSize', 'Value': '0x03'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'usTimestampsCounter', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'usNotifyInterval', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pBufferPointer', 'Value': '&map_pBufferPointer[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucNotificationEnable', 'Value': 'ICU_FALSE']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'map_pBufferPointer[0 to 2]', 'Value': '[0] = 0x00000001'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'usTimestampIndex', 'Value': '0x01'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pBufferPointer', 'Value': '&map_pBufferPointer[1]'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'usTimestampsCounter', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUD_UNIT_USED == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_CODE_FAST) Icu_HW_Taud_TimerIsr(const Icu_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to point to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) /* Define a pointer to point to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ #endif #if (ICU_TIMESTAMP_API == STD_ON) /* Defining a pointer to point to the TAUD registers */ P2VAR(volatile Icu_TAUDChannelUserRegs, AUTOMATIC, REGSPACE) LpTAUDChannelReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif Icu_MeasurementModeType LenMeasurementMode; #if (ICU_TIMESTAMP_API == STD_ON) uint32 LulCapturedTimestampVal; #endif #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) uint8 LucIndex; uint8 LucMeasureProperty; uint8 LucPeriodMeasurementStatus; /* Update the timer channel pointer to point to the current channel */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[LddChannel]; /* Read the edge count RAM index */ LucIndex = LpChannelUserRegConfig->ucRamDataIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #endif /* End of #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) */ /* Update the channel pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; /* Read the channel's measurement property */ LenMeasurementMode = (Icu_MeasurementModeType)(LpChannelConfig->ucIcuMeasurementMode); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ #if (ICU_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((uint16)ICU_ZERO != (uint16)(*LpChannelConfig->pIntrCntlAddress & ICU_EIC_EIMK_MASK)) /* PRQA S 2814 # JV-01 */ { #if (ICU_E_INT_INCONSISTENT_CONFIGURED == STD_ON) ICU_DEM_REPORT_ERROR(ICU_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); #endif } else #endif { /* Check whether the channel is configured for Signal Measurement */ if (ICU_MODE_SIGNAL_MEASUREMENT == LenMeasurementMode) { #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) /* Process Signal Measurement */ Icu_HW_Taud_ServiceSignalMeasurement(LddChannel); /* Read channel measurement property */ LucMeasureProperty = LpChannelUserRegConfig->ucChannelProperties; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Check measurement property is period */ if (ICU_PERIOD_CHANNEL_ENABLED_MASK == (uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK)) { LucPeriodMeasurementStatus = Icu_GpSignalMeasurementData[LucIndex].ucPeriodMeasurementStatus; /* PRQA S 2824 # JV-01 */ if ((uint8)ICU_PERIOD_IDLE == LucPeriodMeasurementStatus) { /* Set period measurement status as ongoing */ Icu_GpSignalMeasurementData[LucIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_ONGOING; } else /* if ((uint8)ICU_PERIOD_ONGOING == LucPeriodMeasurementStatus) */ { /* Set channel input status as active */ Icu_GpChannelRamData[LddChannel].ucChannelStatus = (uint8)ICU_ACTIVE; /* Set channel result status as avaible */ Icu_GpChannelRamData[LddChannel].blResultComplete = (uint8)ICU_TRUE; } } else /* (LucMeasureProperty != (ICU_PERIOD_TIME)) */ { /* Set channel input status as active */ Icu_GpChannelRamData[LddChannel].ucChannelStatus = (uint8)ICU_ACTIVE; /* Set channel result status as avaible */ Icu_GpChannelRamData[LddChannel].blResultComplete = (uint8)ICU_TRUE; } #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ #endif /* End of #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) */ } /* Check whether the channel is configured for Edge Detection */ else if (ICU_MODE_SIGNAL_EDGE_DETECT == LenMeasurementMode) { /* Set channel input status as active */ Icu_GpChannelRamData[LddChannel].ucChannelStatus = (uint8)ICU_ACTIVE; #if (ICU_NOTIFICATION_CONFIG == STD_ON) /* Check if notification is enabled */ if ((uint8)ICU_TRUE == (Icu_GpChannelRamData[LddChannel].ucNotificationEnable)) { /* Check if the function pointer address is present for particular channel */ if (NULL_PTR != LpChannelConfig->pIcuNotificationPointer) { /* callback notification */ LpChannelConfig->pIcuNotificationPointer(); } /* else No action required */ } /* else No action required */ #endif /* End of (ICU_NOTIFICATION_CONFIG == STD_ON) */ } /* Check whether the channel is configured for Timestamp */ else if (ICU_MODE_TIMESTAMP == LenMeasurementMode) { #if (ICU_TIMESTAMP_API == STD_ON) if ((uint8)ICU_ACTIVE == Icu_GpChannelRamData[LddChannel].ucChannelStatus) { /* Initialize pointer to the base address of the current channel */ LpTAUDChannelReg = (P2VAR(volatile Icu_TAUDChannelUserRegs, AUTOMATIC, REGSPACE)) LpChannelConfig->pCntlRegs; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Calculate captured value */ LulCapturedTimestampVal = (uint32)(LpTAUDChannelReg->usTAUDnCDRm + (uint32)ICU_ONE); /* PRQA S 2814, 3383 # JV-01, JV-01 */ /* Process Timestamp */ Icu_HW_Taud_ServiceTimestamp(LddChannel, LulCapturedTimestampVal); } /* else No action required */ #endif /* End of (ICU_TIMESTAMP_API == STD_ON) */ } else /* if (ICU_MODE_EDGE_COUNTER == LenMeasurementMode) */ { if ((uint8)ICU_ACTIVE == Icu_GpChannelRamData[LddChannel].ucChannelStatus) { #if (ICU_NOTIFICATION_CONFIG == STD_ON) /* Check if the function pointer address is present for particular channel */ if (NULL_PTR != LpChannelConfig->pIcuNotificationPointer) { /* callback notification */ LpChannelConfig->pIcuNotificationPointer(); } /* else No action required */ #endif /* End of (ICU_NOTIFICATION_CONFIG == STD_ON) */ } /* else No action required */ } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAUD_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMER_CH_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_E_INT_INCONSISTENT_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_NOTIFICATION_CONFIG', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMESTAMP_API', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'ICU_ACTIVE / ICU_IDLE', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pIntrCntlAddress', 'Value': '&map_pIntrCntlAddress[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '0x0001'], 'Input_Param_015': ['Type': 'Variable', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': 'ICU_MODE_EDGE_COUNTER'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pIcuNotificationPointer', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '0'], 'Input_Param_019': ['Type': 'Variable', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '  ICU_PERIOD_IDLE\\n  ICU_PERIOD_ONGOING', 'Name': 'ucPeriodMeasurementStatus', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucNotificationEnable', 'Value': '-'], 'Input_Param_022': ['Type': 'Register', 'Range': '', 'Name': 'usTAUDnCDRm', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'blResultComplete ', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucPeriodMeasurementStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_006': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_007': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCapturedTimestampVal', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUD_UNIT_USED == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Taud_UnitInit(P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { /* Defining a pointer to the TAU configuration parameters */ P2CONST(Icu_TAUUnitConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpTAUUnitConfig; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Unit Type */ uint8 LucUnitType; /* Local variable to hold the channel number */ uint8 LucCount; #if (ICU_PRESCALER_CONFIGURED == STD_ON) /* Pointer pointing to the TAUD Unit control registers */ P2VAR(volatile Icu_TAUDUnitOsRegs, AUTOMATIC, REGSPACE) LpTAUDUnitOsReg; /* PRQA S 3432 # JV-01 */ P2VAR(volatile Icu_TAUDUnitUserRegs, AUTOMATIC, REGSPACE) LpTAUDUnitUserReg; /* PRQA S 3432 # JV-01 */ #endif /* Update the global pointer with the first channel's address of Signal Measurement mode type channel's RAM data */ #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) Icu_GpSignalMeasurementData = (P2VAR(volatile Icu_SignalMeasurementModeRamDataType, ICU_VAR_NO_INIT, /* PRQA S 0316, 3432 # JV-01, JV-01 */ ICU_APPL_CONST))ConfigPtr->pSignalMeasureAddress; /* PRQA S 2814 # JV-01 */ #endif /* Store the global pointer to first Unit Configuration */ Icu_GpTAUUnitConfig = ConfigPtr->pTAUUnitConfig; /* PRQA S 0317 # JV-01 */ /* Update the Timer channel configuration pointer to point to the current channel */ /* Update the TAU configuration pointer to point to the current TAU */ LpTAUUnitConfig = Icu_GpTAUUnitConfig; for (LucCount = (uint8)ICU_ZERO; LucCount < (uint8)ICU_TOTAL_TAU_UNITS_CONFIGURED; LucCount++) { /* Read the Unit Type for given unit */ LucUnitType = LpTAUUnitConfig->ucIcuUnitType; /* PRQA S 2814 # JV-01 */ /* Invoke low level driver for initializing the hardware */ if(ICU_HW_TAUD == LucUnitType) { LpTAUUnitConfig = &Icu_GpTAUUnitConfig[LucCount]; /* PRQA S 2824 # JV-01 */ /* Initialize pointer to the base address of the current timer unit */ #if (ICU_PRESCALER_CONFIGURED == STD_ON) LpTAUDUnitOsReg = (P2VAR(volatile Icu_TAUDUnitOsRegs, AUTOMATIC, REGSPACE))LpTAUUnitConfig->pTAUnitOsCntlRegs; /* PRQA S 0310, 2814, 3305, 3432 # JV-01, JV-01, JV-01, JV-01 */ LpTAUDUnitUserReg = (P2VAR(volatile Icu_TAUDUnitUserRegs, AUTOMATIC, /* PRQA S 0310, 3305, 3432 # JV-01, JV-01, JV-01 */ REGSPACE))LpTAUUnitConfig->pTAUnitUserCntlRegs; /* Set the values of baud rate to BRS registers respectively */ if ((uint8)ICU_TRUE == LpTAUUnitConfig->ucConfigurePrescaler) { /* Set the bit corresponding to the channel number in TAUDnTT register */ LpTAUDUnitUserReg->usTAUDnTT = ICU_TAUD_TIMER_RESET_VAL; /* PRQA S 1281, 2814 # JV-01, JV-01 */ /* Write the configured prescaler value to TAUDnTPS register */ LpTAUDUnitOsReg->usTAUDnTPS = LpTAUUnitConfig->usPrescaler; /* PRQA S 2814 # JV-01 */ #if (ICU_TAUD_UNIT_CONFIG == STD_ON) /* Write the configured baudrate value to BRS register */ LpTAUDUnitOsReg->ucTAUDnBRS = LpTAUUnitConfig->ucBaudRate; #endif /* End of (ICU_TAUD_UNIT_CONFIG == STD_ON) */ } /* End of ICU_TRUE == LpTAUUnitConfig->ucConfigurePrescaler */ else { /* Set the bit corresponding to the channel number in TAUDnTT register */ LpTAUDUnitUserReg->usTAUDnTT = LpTAUUnitConfig->usTAUChannelMaskValue; } #endif /* End of (ICU_PRESCALER_CONFIGURED == STD_ON) */ } /* else No action required */ /* End of (ICU_HW_TAUD == LucUnitType) */ /* Increment the pointer to the next unit */ LpTAUUnitConfig++; /* PRQA S 2824 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_PRESCALER_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAUD_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAUD_UNIT_CONFIG', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_SIGNAL_MEASUREMENT_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMER_CH_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': '0x07', 'Name': 'ICU_TOTAL_TAU_UNITS_CONFIGURED', 'Value': '0x07'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pSignalMeasureAddress', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pTAUUnitConfig', 'Value': '&map_Icu_GpTAUUnitConfig[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuUnitType', 'Value': '[0 to 3] = ICU_HW_TAUD'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pTAUnitOsCntlRegs', 'Value': '[0] = &map_pTAUnitOsCntlRegs[0]\\n[1] = &map_pTAUnitOsCntlRegs[1]\\n[2] = &map_pTAUnitOsCntlRegs[2]\\n[3] = &map_pTAUnitOsCntlRegs[3]\\n'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'pTAUnitUserCntlRegs', 'Value': '[0] = &map_pTAUnitUserCntlRegs[0]\\n[1] = &map_pTAUnitUserCntlRegs[1]\\n[2] = &map_pTAUnitUserCntlRegs[2]\\n[3] = &map_pTAUnitUserCntlRegs[3]\\n'], 'Input_Param_012': ['Type': 'Array', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucConfigurePrescaler', 'Value': '[0 to 3] = ICU_FALSE'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'usPrescaler', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ucBaudRate', 'Value': '-'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'usTAUChannelMaskValue', 'Value': '[0 to 6] = 0x0001']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'usTAUDnTT', 'Value': '[0 to 3] = 0x0001'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'usTAUDnTPS', 'Value': '-'], 'Output_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'ucTAUDnBRS', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTAUUnitConfig', 'Value': '&map_Icu_GpTAUUnitConfig[0]'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUJ_UNIT_USED == STD_ON) #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_CODE_FAST) Icu_HW_Tauj_ServiceSignalMeasurement(const Icu_ChannelType LddChannel) /* PRQA S 1505 # JV-01 */ { /* Defining a pointer to point to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Define a pointer to point to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the TAUJ registers */ P2VAR(volatile Icu_TAUJChannelUserRegs, AUTOMATIC, REGSPACE) LpTAUJChannelReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint8 LucMeasureProperty; uint8 LucRamIndex; /* Read channel configuration pointer */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; /* Read timer channel configuration pointer */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[LddChannel]; /* Read the channel ram index */ LucRamIndex = LpChannelUserRegConfig->ucRamDataIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Read channel measurement property */ LucMeasureProperty = LpChannelUserRegConfig->ucChannelProperties; /* Initialize pointer to the base address of the current channel */ LpTAUJChannelReg = (P2VAR(volatile Icu_TAUJChannelUserRegs, AUTOMATIC, REGSPACE)) LpChannelConfig->pCntlRegs; /* PRQA S 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01 */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ if ((ICU_HIGH_TIME_MASK == (uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK)) || (ICU_LOW_TIME_MASK == (uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK))) /* Calculate Active time */ { Icu_GpSignalMeasurementData[LucRamIndex].ulSignalActiveTime = /* PRQA S 2824 # JV-01 */ (uint32)((LpTAUJChannelReg->ulTAUJnCDRm) + (uint32)ICU_ONE); /* PRQA S 2814, 3383 # JV-01, JV-01 */ } else /* (LucMeasureProperty == (ICU_PERIOD_TIME)) */ { Icu_GpSignalMeasurementData[LucRamIndex].ulPrevSignalActiveTime = Icu_GpSignalMeasurementData[LucRamIndex].ulSignalActiveTime; /* Calculate Period time */ Icu_GpSignalMeasurementData[LucRamIndex].ulSignalPeriodTime = (uint32)(LpTAUJChannelReg->ulTAUJnCDRm + (uint32)ICU_ONE); /* PRQA S 3383 # JV-01 */ } #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAUJ_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMER_CH_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '&map_pCntlRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulTAUJnCDRm', 'Value': '0x02'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '0x07'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalActiveTime', 'Value': '0x02']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalActiveTime', 'Value': '0x02'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulPrevSignalActiveTime', 'Value': '0x02'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalPeriodTime', 'Value': '0x03'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUJ_UNIT_USED == STD_ON) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Tauj_SetActivation(const Icu_ChannelType LddChannel, const Icu_ActivationType LenActiveEdge) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to point to the TAUJ registers */ P2VAR(volatile Icu_TAUJChannelUserRegs, AUTOMATIC, REGSPACE) LpTAUJChannelReg; /* PRQA S 3432 # JV-01 */ /* To store Channel Measurement Mode */ Icu_MeasurementModeType LenMeasurementMode; /* Update the channel configuration pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; /* Read measurement mode */ LenMeasurementMode = (Icu_MeasurementModeType)(LpChannelConfig->ucIcuMeasurementMode); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ /* TAUJ doesn't support edge counter mode. so, set the active edge for timestamp mode only */ if (ICU_MODE_TIMESTAMP == LenMeasurementMode) { /* Initialize pointer to the base address of the current channel */ LpTAUJChannelReg = (P2VAR(volatile Icu_TAUJChannelUserRegs, AUTOMATIC, REGSPACE)) LpChannelConfig->pCntlRegs; /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpTAUJChannelReg->ucTAUJnCMURm = (uint8)LenActiveEdge; /* PRQA S 2814 # JV-01 */ } /* else No action required */ #if (ICU_CLEAR_PENDING_INTERRUPT == STD_ON) /* Check if the Interrupt register is present for particular channel */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) { /* Clear the pending interrupts */ RH850_SV_CLEAR_ICR_SYNCP(16, LpChannelConfig->pIntrCntlAddress, ICU_CLEAR_PENDING_INTR_MASK); /* PRQA S 1006, 1281, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ /* End of NULL_PTR != LpChannelConfig->pIntrCntlAddress */ #endif /* End of ICU_CLEAR_PENDING_INTERRUPT == STD_ON */ /* Initialize channel status as idle */ Icu_GpChannelRamData[LddChannel].ucChannelStatus = (uint8)ICU_IDLE; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAUJ_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_002': ['Type': 'Argument', 'Range': '  ICU_FALLING_EDGE\\n  ICU_RISING_EDGE\\n  ICU_BOTH_EDGES', 'Name': 'LenActiveEdge', 'Value': 'ICU_FALLING_EDGE'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': 'ICU_MODE_SIGNAL_MEASUREMENT'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '&map_pCntlRegs[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'Address/NULL_PTR', 'Name': 'pIntrCntlAddress', 'Value': 'NULL_PTR'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ucTAUJnCMURm', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '-'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUJ_UNIT_USED == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_CODE_FAST) Icu_HW_Tauj_TimerIsr(const Icu_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to point to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) /* Define a pointer to point to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ #endif #if (ICU_TIMESTAMP_API == STD_ON) /* Defining a pointer to point to the TAUJ registers */ P2VAR(volatile Icu_TAUJChannelUserRegs, AUTOMATIC, REGSPACE) LpTAUJChannelReg; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif Icu_MeasurementModeType LenMeasurementMode; #if (ICU_TIMESTAMP_API == STD_ON) uint32 LulCapturedTimestampVal; #endif #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) uint8 LucIndex; uint8 LucMeasureProperty; uint8 LucPeriodMeasurementStatus; /* Update the timer channel pointer to point to the current channel */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[LddChannel]; /* Read the edge count RAM index */ LucIndex = LpChannelUserRegConfig->ucRamDataIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #endif /* End of #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON)*/ /* Update the channel pointer to point to the current channel */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; /* Read the channel's measurement property */ LenMeasurementMode = (Icu_MeasurementModeType)(LpChannelConfig->ucIcuMeasurementMode); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ #if (ICU_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if ((uint16)ICU_ZERO != (uint16)(*LpChannelConfig->pIntrCntlAddress & ICU_EIC_EIMK_MASK)) /* PRQA S 2814 # JV-01 */ { #if (ICU_E_INT_INCONSISTENT_CONFIGURED == STD_ON) ICU_DEM_REPORT_ERROR(ICU_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); #endif } else #endif { /* Check whether the channel is configured for Signal Measurement */ if (ICU_MODE_SIGNAL_MEASUREMENT == LenMeasurementMode) { #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) /* Process Signal Measurement */ Icu_HW_Tauj_ServiceSignalMeasurement(LddChannel); /* Read channel measurement property */ LucMeasureProperty = LpChannelUserRegConfig->ucChannelProperties; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ /* Check measurement property is period */ if (ICU_PERIOD_CHANNEL_ENABLED_MASK == (uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK)) { LucPeriodMeasurementStatus = Icu_GpSignalMeasurementData[LucIndex].ucPeriodMeasurementStatus; /* PRQA S 2824 # JV-01 */ if ((uint8)ICU_PERIOD_IDLE == LucPeriodMeasurementStatus) { /* Set period measurement status as ongoing */ Icu_GpSignalMeasurementData[LucIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_ONGOING; } else /* if ((uint8)ICU_PERIOD_ONGOING == LucPeriodMeasurementStatus) */ { /* Set channel input status as active */ Icu_GpChannelRamData[LddChannel].ucChannelStatus = (uint8)ICU_ACTIVE; /* Set channel result status as avaible */ Icu_GpChannelRamData[LddChannel].blResultComplete = (uint8)ICU_TRUE; } } else /* (LucMeasureProperty != (ICU_PERIOD_TIME)) */ { /* Set channel input status as active */ Icu_GpChannelRamData[LddChannel].ucChannelStatus = (uint8)ICU_ACTIVE; /* Set channel result status as avaible */ Icu_GpChannelRamData[LddChannel].blResultComplete = (uint8)ICU_TRUE; } #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_RAM_DATA_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ #endif /* End of (ICU_SIGNAL_MEASUREMENT_API == STD_ON) */ } /* Check whether the channel is configured for Timestamp */ else if (ICU_MODE_TIMESTAMP == LenMeasurementMode) /* PRQA S 2004 # JV-01 */ { #if (ICU_TIMESTAMP_API == STD_ON) if ((uint8)ICU_ACTIVE == Icu_GpChannelRamData[LddChannel].ucChannelStatus) { /* Initialize pointer to the base address of the current channel */ LpTAUJChannelReg = (P2VAR(volatile Icu_TAUJChannelUserRegs, AUTOMATIC, REGSPACE)) LpChannelConfig->pCntlRegs; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Calculate captured value */ LulCapturedTimestampVal = (uint32)(LpTAUJChannelReg->ulTAUJnCDRm + (uint32)ICU_ONE); /* PRQA S 2814, 3383 # JV-01, JV-01 */ /* Process Timestamp */ Icu_HW_Tauj_ServiceTimestamp(LddChannel, LulCapturedTimestampVal); } /* else No action required */ #endif /* End of (ICU_TIMESTAMP_API == STD_ON) */ } /* else No action required */ /* End of (ICU_MODE_SIGNAL_MEASUREMENT == LenMeasurementMode) */ #if (ICU_REPORT_WAKEUP_SOURCE == STD_ON) /* If Module was in SLEEP mode and reporting wakeup is enabled */ if ((ICU_MODE_SLEEP == Icu_GenModuleMode) && ((uint8)ICU_FALSE == LpChannelConfig->ucIcuDisableEcumWakeupNotification) && (ICU_NOWAKEUP != LpChannelConfig->ucEcuMChannelWakeupInfo)) { /* Set the wakeup status to true */ Icu_GpChannelRamData[LddChannel].ucWakeupOccurrence = (uint8)ICU_TRUE; /* Report Wakeup Event to EcuM */ EcuM_CheckWakeup((EcuM_WakeupSourceType)(ICU_DOUBLE_ONE << (LpChannelConfig->ucEcuMChannelWakeupInfo))); } /* else No action required */ #endif /* End of (ICU_REPORT_WAKEUP_SOURCE == STD_ON) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TAUJ_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMER_CH_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_E_INT_INCONSISTENT_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_REPORT_WAKEUP_SOURCE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMESTAMP_API', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pIntrCntlAddress', 'Value': '&map_pIntrCntlAddress[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIntrCntlAddress[0]', 'Value': '0x0001'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'ICU_ACTIVE / ICU_IDLE', 'Name': 'ucChannelStatus', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': 'ICU_MODE_SIGNAL_MEASUREMENT'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': 'ICU_TRUE/ICU_FALSE', 'Name': 'ucIcuDisableEcumWakeupNotification', 'Value': 'ICU_FALSE'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucEcuMChannelWakeupInfo', 'Value': 'ICU_NOWAKEUP'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '0'], 'Input_Param_020': ['Type': 'Variable', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '0x06'], 'Input_Param_021': ['Type': 'Variable', 'Range': '  ICU_PERIOD_IDLE\\n  ICU_PERIOD_ONGOING', 'Name': 'ucPeriodMeasurementStatus', 'Value': 'ICU_PERIOD_ONGOING'], 'Input_Param_022': ['Type': 'Variable', 'Range': '  ICU_MODE_NORMAL\\n  ICU_MODE_SLEEP', 'Name': 'Icu_GenModuleMode', 'Value': 'ICU_MODE_SLEEP'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulTAUJnCDRm', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_ACTIVE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'blResultComplete ', 'Value': 'ICU_TRUE'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucWakeupOccurrence', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucPeriodMeasurementStatus', 'Value': 'ICU_PERIOD_ONGOING'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '0'], 'Output_Param_007': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_008': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulCapturedTimestampVal', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'wakeupSource', 'Value': '-'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAU_UNIT_USED == STD_ON) #if ((ICU_TIMESTAMP_API == STD_ON) || (ICU_EDGE_COUNT_API == STD_ON) || (ICU_SIGNAL_MEASUREMENT_API == STD_ON) || \\ (ICU_EDGE_DETECT_API == STD_ON)) #define ICU_START_SEC_PRIVATE_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PRIVATE_CODE) Icu_HW_Tau_StopCountMeasurement(const Icu_ChannelType LddChannel) /* PRQA S 1532 # JV-01 */ { /* Defining a pointer to the timer channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Local variable to store the measurement mode of a channel */ Icu_MeasurementModeType LenMeasurementMode; /* Read channel configuration pointer */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; /* Read timer channel configuration pointer */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[LddChannel]; #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Disabling the Interrupt processing */ RH850_SV_SET_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_DISABLE_EIMK_MASK); /* PRQA S 0751, 1006, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ /* Read the channel's measurement mode */ LenMeasurementMode = (Icu_MeasurementModeType)(LpChannelConfig->ucIcuMeasurementMode); /* PRQA S 2814, 2844, 4342 # JV-01, JV-01, JV-01 */ if (ICU_MODE_SIGNAL_MEASUREMENT == LenMeasurementMode) { /* If the channel is duty cycle channel, then disable interrupt for the next channel also */ if (ICU_DUTY_PERIOD_ENABLED_MASK == (uint8)(LpChannelUserRegConfig->ucChannelProperties & /* PRQA S 2814, 2844 # JV-01, JV-01 */ ICU_DUTY_PERIOD_ENABLED_MASK)) { /* Read channel configuration pointer */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel + (uint32)ICU_ONE]; /* PRQA S 3383 # JV-01 */ if (NULL_PTR != LpChannelConfig->pIntrCntlAddress) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Disabling the Interrupt processing */ RH850_SV_SET_ICR_SYNCP(8, (LpChannelConfig->pIntrCntlAddress), ICU_DISABLE_EIMK_MASK); /* PRQA S 0751, 1006, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ } /* else No action required */ } /* else No action required */ /* End of (ICU_MODE_SIGNAL_MEASUREMENT == LenMeasurementMode) */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMER_CH_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CLEAR_PENDING_INTERRUPT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': 'Address/NULL_PTR', 'Name': 'pIntrCntlAddress', 'Value': '[0] = &map_pIntrCntlAddress[0]\\n[1] = NULL_PTR'], 'Input_Param_007': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[0] = ICU_MODE_SIGNAL_MEASUREMENT'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '0x07'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_pIntrCntlAddress[0 to 1]', 'Value': '[0] = 0x0001\\n']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'map_pIntrCntlAddress[0 to 1]', 'Value': '[0] = 0x0081\\n'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_Init(P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr) /* PRQA S 1503, 3432 # JV-01, JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the channel timer config parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpTimerChannel; /* PRQA S 3432 # JV-01 */ /* Local variable to store Measurement Mode */ Icu_MeasurementModeType LddMeasurementMode; /* Local variable to store RAM index */ uint8 LucIndex; /* Local variable to hold the channel number */ volatile uint8 LucChannelNo; /* Local variable to hold the channel number */ volatile uint8 LucUnitNo; /* Index of HW IP Type */ volatile VAR(uint8, AUTOMATIC) LucHWIPType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Initialize the DET return value */ LucReturnValue = E_OK; #if (ICU_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if the ICU Driver is already initialized */ if (ICU_INITIALIZED == Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_INIT_SID, ICU_E_ALREADY_INITIALIZED); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of (ICU_ALREADY_INIT_DET_CHECK == STD_ON) */ /* Check if the Configuration pointer is NULL */ if (NULL_PTR == ConfigPtr) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_INIT_SID, ICU_E_INIT_FAILED); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Check if the database is flashed on the target device */ if (ICU_DBTOC_VALUE == (ConfigPtr->ulStartOfDbToc)) /* PRQA S 2814 # JV-01 */ { /* Update the global pointer with the first channel's configuration database address */ Icu_GpChannelConfig = (P2CONST(Icu_ChannelConfigType, ICU_VAR_NO_INIT, ICU_APPL_CONST))ConfigPtr->pChannelConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Update the global pointer with the first Timer channel's configuration database address */ Icu_GpChannelUserRegConfig = (P2CONST(Icu_ChannelUserRegConfigType, ICU_VAR_NO_INIT, ICU_APPL_CONST))ConfigPtr->pChannelUserRegConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Update the global pointer with the first channel's ram address */ Icu_GpChannelRamData = (P2VAR(Icu_ChannelRamDataType, ICU_VAR_NO_INIT, ICU_CONFIG_DATA)) ConfigPtr->pRamAddress; /* PRQA S 0312, 0316, 3432 # JV-01, JV-01, JV-01 */ #if ((ICU_EDGE_COUNT_API == STD_ON) && ((ICU_ATU_TIMER_UNIT_USED == STD_ON) || (ICU_TAUD_UNIT_CONFIG == STD_ON))) Icu_GpEdgeCountData = (P2VAR(Icu_EdgeCountModeRamDatatype, ICU_VAR_NO_INIT, /* PRQA S 0312, 0316, 3432 # JV-01, JV-01, JV-01 */ ICU_CONFIG_DATA))ConfigPtr->pEdgeCountRamAddress; #endif /* Update the global pointer with the first channel's address of Timestamp mode type channel's RAM data */ #if ((ICU_TIMESTAMP_API == STD_ON) && ((ICU_ATU_TIMER_UNIT_USED == STD_ON) || (ICU_TAU_UNIT_USED == STD_ON))) Icu_GpTimeStampData = (P2VAR(Icu_TimeStampChannelRamDataType, ICU_VAR_NO_INIT, /* PRQA S 0312, 0316, 3432 # JV-01, JV-01, JV-01 */ ICU_APPL_CONST))ConfigPtr->pTimeStampAddress; #endif /* End of (ICU_TIMESTAMP_API == STD_ON) */ for (LucChannelNo = ICU_ZERO; LucChannelNo < ICU_MAX_CHANNEL; LucChannelNo++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Load the channel pointer */ LpChannel = &Icu_GpChannelConfig[LucChannelNo]; /* PRQA S 0404 # JV-01 */ if ((ICU_HW_EXT_INTP != LpChannel->ucIcuChannelType) && (ICU_HW_EXT_IRQ != LpChannel->ucIcuChannelType)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Load the timer channel pointer */ LpTimerChannel = &Icu_GpChannelUserRegConfig[LucChannelNo]; /* PRQA S 0404 # JV-01 */ /* Read the Measurement mode of the channel */ LddMeasurementMode = (Icu_MeasurementModeType)LpChannel->ucIcuMeasurementMode; /* PRQA S 4342 # JV-01 */ /* Check whether measurement mode is timestamp */ if (ICU_MODE_TIMESTAMP == LddMeasurementMode) { /* Read the current activation edge from RAM */ LucIndex = LpTimerChannel->ucRamDataIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Reset the flag to indicate that the timestamping is not started */ Icu_GpTimeStampData[LucIndex].blTimestampingStarted = ICU_FALSE; } /* else No action required */ /* End of (LddMeasurementMode == ICU_MODE_TIMESTAMP) */ } /* else No action required */ } /* Invoke low level driver for Initializing the hardware */ for (LucUnitNo = ICU_ZERO; LucUnitNo < ICU_TOTAL_HW_IP_CONFIG; LucUnitNo++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the HWIP Type for given channel */ LucHWIPType = Icu_GaaHWIPConfig[LucUnitNo].ucIndex; if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pUnitInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Deinitializing the hardware */ Icu_GaaHwDepFunc[LucHWIPType]->pUnitInit(ConfigPtr); } /* else No action required */ } for (LucChannelNo = (uint8)ICU_ZERO; LucChannelNo < (uint8)ICU_MAX_CHANNEL; LucChannelNo++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the HWIP Type for given channel */ LucHWIPType = Icu_GpChannelConfig[LucChannelNo].ucIcuChannelType; if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pChannelInit) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucHWIPType]->pChannelInit(LucChannelNo); } /* else No action required */ } /* Set Icu Driver Mode as normal */ Icu_GenModuleMode = ICU_MODE_NORMAL; #if (ICU_REPORT_WAKEUP_SOURCE == STD_ON) /* Set the wakeup source information as Zero*/ Icu_GulWakeupSource = ICU_WAKEUP_INFO_INIT_VAL; #endif #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Set Icu Driver status as initialized */ Icu_SetDriverStatus(ICU_INITIALIZED); #endif } else /* If there is no valid database is present */ { #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_INIT_SID, ICU_E_INVALID_DATABASE); #endif } /* End of (ConfigPtr->ulStartOfDbToc) == ICU_DBTOC_VALUE */ } /* else No action required */ /* End of LucReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ALREADY_INIT_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMESTAMP_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_EDGE_COUNT_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_SET_MODE_API', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_REPORT_WAKEUP_SOURCE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'Address/NULL', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_UNINITIALIZED'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0x00/ICU_DBTOC_VALUE', 'Name': 'ulStartOfDbToc', 'Value': 'ICU_DBTOC_VALUE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pTimeStampAddress', 'Value': '&map_Icu_GpTimeStampData[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pEdgeCountRamAddress', 'Value': '&map_Icu_GpEdgeCountData[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pRamAddress', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuMeasurementMode', 'Value': '-'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '-'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[0 to 103] = ICU_HW_EXT_INTP '], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pChannelInit', 'Value': '[0] = &ISOLATE_void_func_ptr_Icu_ChannelType'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pUnitInit', 'Value': '[0] = &ISOLATE_void_func_ptr_const_Icu_ConfigType_p\\n[1] = NULL_PTR\\n[2] =  NULL_PTR\\n[3] = NULL_PTR\\n[4] = NULL_PTR\\n[5] = NULL_PTR'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Icu_GaaHWIPConfig', 'Value': '&Icu_GaaHWIPConfig[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = ICU_HW_EXT_INTP\\n[1] = ICU_HW_TAUD\\n[2] = ICU_HW_TAUJ']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTimeStampData', 'Value': '&map_Icu_GpTimeStampData[0]'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpEdgeCountData', 'Value': '&map_Icu_GpEdgeCountData[0]'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'blTimestampingStarted', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GenModuleMode', 'Value': 'ICU_MODE_NORMAL'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GulWakeupSource', 'Value': 'ICU_WAKEUP_INFO_INIT_VAL '], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelNo', 'Value': '[1]=0\\n[2]=1\\n[3]=2\\n[4]=3\\n[5]=4\\n[6]=5\\n[7]=6\\n[8]=7\\n[9]=8\\n[10]=9\\n[11]=10\\n[12]=11\\n[13]=12\\n[14]=13\\n[15]=14\\n[16]=15\\n[17]=16\\n[18]=17\\n[19]=18\\n[20]=19\\n[21]=20\\n[22]=21\\n[23]=22\\n[24]=23\\n[25]=24\\n[26]=25\\n[27]=26\\n[28]=27\\n[29]=28\\n[30]=29\\n[31]=30\\n[32]=31\\n[33]=32\\n[34]=33\\n[35]=34\\n[36]=35\\n[37]=36\\n[38]=37\\n[39]=38\\n[40]=39\\n[41]=40\\n[42]=41\\n[43]=42\\n[44]=43\\n[45]=44\\n[46]=45\\n[47]=46\\n[48]=47\\n[49]=48\\n[50]=49\\n[51]=50\\n[52]=51\\n[53]=52\\n[54]=53\\n[55]=54\\n[56]=55\\n[57]=56\\n[58]=57\\n[59]=58\\n[60]=59\\n[61]=60\\n[62]=61\\n[63]=62\\n[64]=63\\n[65]=64\\n[66]=65\\n[67]=66\\n[68]=67\\n[69]=68\\n[70]=69\\n[71]=70\\n[72]=71\\n[73]=72\\n[74]=73\\n[75]=74\\n[76]=75\\n[77]=76\\n[78]=77\\n[79]=78\\n[80]=79\\n[81]=80\\n[82]=81\\n[83]=82\\n[84]=83\\n[85]=84\\n[86]=85\\n[87]=86\\n[88]=87\\n[89]=88\\n[90]=89\\n[91]=90\\n[92]=91\\n[93]=92\\n[94]=93\\n[95]=94\\n[96]=95\\n[97]=96\\n[98]=97\\n[99]=98\\n[100]=99\\n[101]=100\\n[102]=101\\n[103]=102\\n[104]=103'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatus', 'Value': 'ICU_INITIALIZED'], 'Output_Param_023': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_Init(P2CONST(Icu_ConfigType, AUTOMATIC, ICU_APPL_CONST) ConfigPtr) /* PRQA S 1503, 3432 # JV-01, JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the channel timer config parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpTimerChannel; /* PRQA S 3432 # JV-01 */ /* Local variable to store Measurement Mode */ Icu_MeasurementModeType LddMeasurementMode; /* Local variable to store RAM index */ uint8 LucIndex; /* Local variable to hold the channel number */ volatile uint8 LucChannelNo; /* Local variable to hold the channel number */ volatile uint8 LucUnitNo; /* Index of HW IP Type */ volatile VAR(uint8, AUTOMATIC) LucHWIPType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Initialize the DET return value */ LucReturnValue = E_OK; #if (ICU_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if the ICU Driver is already initialized */ if (ICU_INITIALIZED == Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_INIT_SID, ICU_E_ALREADY_INITIALIZED); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ #endif /* End of (ICU_ALREADY_INIT_DET_CHECK == STD_ON) */ /* Check if the Configuration pointer is NULL */ if (NULL_PTR == ConfigPtr) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_INIT_SID, ICU_E_INIT_FAILED); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Check if the database is flashed on the target device */ if (ICU_DBTOC_VALUE == (ConfigPtr->ulStartOfDbToc)) /* PRQA S 2814 # JV-01 */ { /* Update the global pointer with the first channel's configuration database address */ Icu_GpChannelConfig = (P2CONST(Icu_ChannelConfigType, ICU_VAR_NO_INIT, ICU_APPL_CONST))ConfigPtr->pChannelConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Update the global pointer with the first Timer channel's configuration database address */ Icu_GpChannelUserRegConfig = (P2CONST(Icu_ChannelUserRegConfigType, ICU_VAR_NO_INIT, ICU_APPL_CONST))ConfigPtr->pChannelUserRegConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Update the global pointer with the first channel's ram address */ Icu_GpChannelRamData = (P2VAR(Icu_ChannelRamDataType, ICU_VAR_NO_INIT, ICU_CONFIG_DATA)) ConfigPtr->pRamAddress; /* PRQA S 0312, 0316, 3432 # JV-01, JV-01, JV-01 */ #if ((ICU_EDGE_COUNT_API == STD_ON) && ((ICU_ATU_TIMER_UNIT_USED == STD_ON) || (ICU_TAUD_UNIT_CONFIG == STD_ON))) Icu_GpEdgeCountData = (P2VAR(Icu_EdgeCountModeRamDatatype, ICU_VAR_NO_INIT, /* PRQA S 0312, 0316, 3432 # JV-01, JV-01, JV-01 */ ICU_CONFIG_DATA))ConfigPtr->pEdgeCountRamAddress; #endif /* Update the global pointer with the first channel's address of Timestamp mode type channel's RAM data */ #if ((ICU_TIMESTAMP_API == STD_ON) && ((ICU_ATU_TIMER_UNIT_USED == STD_ON) || (ICU_TAU_UNIT_USED == STD_ON))) Icu_GpTimeStampData = (P2VAR(Icu_TimeStampChannelRamDataType, ICU_VAR_NO_INIT, /* PRQA S 0312, 0316, 3432 # JV-01, JV-01, JV-01 */ ICU_APPL_CONST))ConfigPtr->pTimeStampAddress; #endif /* End of (ICU_TIMESTAMP_API == STD_ON) */ for (LucChannelNo = ICU_ZERO; LucChannelNo < ICU_MAX_CHANNEL; LucChannelNo++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Load the channel pointer */ LpChannel = &Icu_GpChannelConfig[LucChannelNo]; /* PRQA S 0404 # JV-01 */ if ((ICU_HW_EXT_INTP != LpChannel->ucIcuChannelType) && (ICU_HW_EXT_IRQ != LpChannel->ucIcuChannelType)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Load the timer channel pointer */ LpTimerChannel = &Icu_GpChannelUserRegConfig[LucChannelNo]; /* PRQA S 0404 # JV-01 */ /* Read the Measurement mode of the channel */ LddMeasurementMode = (Icu_MeasurementModeType)LpChannel->ucIcuMeasurementMode; /* PRQA S 4342 # JV-01 */ /* Check whether measurement mode is timestamp */ if (ICU_MODE_TIMESTAMP == LddMeasurementMode) { /* Read the current activation edge from RAM */ LucIndex = LpTimerChannel->ucRamDataIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Reset the flag to indicate that the timestamping is not started */ Icu_GpTimeStampData[LucIndex].blTimestampingStarted = ICU_FALSE; } /* else No action required */ /* End of (LddMeasurementMode == ICU_MODE_TIMESTAMP) */ } /* else No action required */ } /* Invoke low level driver for Initializing the hardware */ for (LucUnitNo = ICU_ZERO; LucUnitNo < ICU_TOTAL_HW_IP_CONFIG; LucUnitNo++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the HWIP Type for given channel */ LucHWIPType = Icu_GaaHWIPConfig[LucUnitNo].ucIndex; if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pUnitInit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for Deinitializing the hardware */ Icu_GaaHwDepFunc[LucHWIPType]->pUnitInit(ConfigPtr); } /* else No action required */ } for (LucChannelNo = (uint8)ICU_ZERO; LucChannelNo < (uint8)ICU_MAX_CHANNEL; LucChannelNo++) /* PRQA S 3387, 3416 # JV-01, JV-01 */ { /* Read the HWIP Type for given channel */ LucHWIPType = Icu_GpChannelConfig[LucChannelNo].ucIcuChannelType; if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pChannelInit) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucHWIPType]->pChannelInit(LucChannelNo); } /* else No action required */ } /* Set Icu Driver Mode as normal */ Icu_GenModuleMode = ICU_MODE_NORMAL; #if (ICU_REPORT_WAKEUP_SOURCE == STD_ON) /* Set the wakeup source information as Zero*/ Icu_GulWakeupSource = ICU_WAKEUP_INFO_INIT_VAL; #endif #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Set Icu Driver status as initialized */ Icu_SetDriverStatus(ICU_INITIALIZED); #endif } else /* If there is no valid database is present */ { #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_INIT_SID, ICU_E_INVALID_DATABASE); #endif } /* End of (ConfigPtr->ulStartOfDbToc) == ICU_DBTOC_VALUE */ } /* else No action required */ /* End of LucReturnValue == E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ALREADY_INIT_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_TIMESTAMP_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_EDGE_COUNT_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_SET_MODE_API', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_REPORT_WAKEUP_SOURCE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'Address/NULL', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_UNINITIALIZED'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0x00/ICU_DBTOC_VALUE', 'Name': 'ulStartOfDbToc', 'Value': 'ICU_DBTOC_VALUE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pTimeStampAddress', 'Value': '&map_Icu_GpTimeStampData[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pEdgeCountRamAddress', 'Value': '&map_Icu_GpEdgeCountData[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pRamAddress', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuMeasurementMode', 'Value': '[0] = ICU_MODE_SIGNAL_MEASUREMENT\\n[1] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '-'], 'Input_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[0 to 101] = ICU_HW_TAUJ '], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'pChannelInit', 'Value': '[3] = &ISOLATE_void_func_ptr_Icu_ChannelType'], 'Input_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'pUnitInit', 'Value': '[0] = NULL_PTR\\n[1] = NULL_PTR\\n[2] =  NULL_PTR\\n[3] = &ISOLATE_void_func_ptr_const_Icu_ConfigType_p\\n[4] = NULL_PTR\\n[5] = NULL_PTR'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Icu_GaaHWIPConfig', 'Value': '&Icu_GaaHWIPConfig[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = ICU_HW_EXT_INTP\\n[1] = ICU_HW_TAUD\\n[2] = ICU_HW_TAUJ']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Output_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpTimeStampData', 'Value': '&map_Icu_GpTimeStampData[0]'], 'Output_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpEdgeCountData', 'Value': '&map_Icu_GpEdgeCountData[0]'], 'Output_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'blTimestampingStarted', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GenModuleMode', 'Value': 'ICU_MODE_NORMAL'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GulWakeupSource', 'Value': 'ICU_WAKEUP_INFO_INIT_VAL '], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannelNo', 'Value': '[1]=0\\n[2]=1\\n[3]=2\\n[4]=3\\n[5]=4\\n[6]=5\\n[7]=6\\n[8]=7\\n[9]=8\\n[10]=9\\n[11]=10\\n[12]=11\\n[13]=12\\n[14]=13\\n[15]=14\\n[16]=15\\n[17]=16\\n[18]=17\\n[19]=18\\n[20]=19\\n[21]=20\\n[22]=21\\n[23]=22\\n[24]=23\\n[25]=24\\n[26]=25\\n[27]=26\\n[28]=27\\n[29]=28\\n[30]=29\\n[31]=30\\n[32]=31\\n[33]=32\\n[34]=33\\n[35]=34\\n[36]=35\\n[37]=36\\n[38]=37\\n[39]=38\\n[40]=39\\n[41]=40\\n[42]=41\\n[43]=42\\n[44]=43\\n[45]=44\\n[46]=45\\n[47]=46\\n[48]=47\\n[49]=48\\n[50]=49\\n[51]=50\\n[52]=51\\n[53]=52\\n[54]=53\\n[55]=54\\n[56]=55\\n[57]=56\\n[58]=57\\n[59]=58\\n[60]=59\\n[61]=60\\n[62]=61\\n[63]=62\\n[64]=63\\n[65]=64\\n[66]=65\\n[67]=66\\n[68]=67\\n[69]=68\\n[70]=69\\n[71]=70\\n[72]=71\\n[73]=72\\n[74]=73\\n[75]=74\\n[76]=75\\n[77]=76\\n[78]=77\\n[79]=78\\n[80]=79\\n[81]=80\\n[82]=81\\n[83]=82\\n[84]=83\\n[85]=84\\n[86]=85\\n[87]=86\\n[88]=87\\n[89]=88\\n[90]=89\\n[91]=90\\n[92]=91\\n[93]=92\\n[94]=93\\n[95]=94\\n[96]=95\\n[97]=96\\n[98]=97\\n[99]=98\\n[100]=99\\n[101]=100\\n[102]=101'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatus', 'Value': 'ICU_INITIALIZED'], 'Output_Param_023': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_COUNT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_ResetEdgeCount(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_RESET_EDGE_COUNT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_RESET_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge counting */ if ((uint8)(ICU_MODE_EDGE_COUNTER) != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_RESET_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Read the Unit Type for given unit */ /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pResetEdgeCount) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Icu_GaaHwDepFunc[LucTimerType]->pResetEdgeCount(Channel); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '77'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[77] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[77] =ICU_HW_EXT_INTP'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pResetEdgeCount', 'Value': '[0] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '77'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_EDGE_COUNT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_ResetEdgeCount(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_RESET_EDGE_COUNT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_RESET_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Edge counting */ if ((uint8)(ICU_MODE_EDGE_COUNTER) != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_RESET_EDGE_COUNT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Read the Unit Type for given unit */ /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pResetEdgeCount) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Icu_GaaHwDepFunc[LucTimerType]->pResetEdgeCount(Channel); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '59'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[59] = ICU_MODE_EDGE_COUNTER'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[59] = ICU_HW_ATU_TIMERC'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pResetEdgeCount', 'Value': '[5] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '59'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (STD_ON == ICU_ATU_TIMER_UNIT_USED) #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_CODE_FAST) Icu_ServiceSignalMeasurement(const Icu_ChannelType LddChannel) /* PRQA S 1505 # JV-01 */ { /* Defining a pointer to point to the channel configuration parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Define a pointer to point to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Define a pointer to point to the ATU timer channel configuration parameters */ P2CONST(Icu_ATUChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpATUChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the ATU channel configuration parameters */ P2CONST(Icu_ATUChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpATUChannelConfig; /* PRQA S 3432 # JV-01 */ /* Defining a pointer to the channel ram data */ P2VAR(volatile Icu_ChannelRamDataType, AUTOMATIC, ICU_CONFIG_DATA) LpRamData; /* PRQA S 3432 # JV-01 */ #if (ICU_ATU_TIMERA_UNIT_USED == STD_ON) /* Defining a pointer to point to the TimerA registers */ P2VAR(Icu_ATUTimerAChannelUserRegs, AUTOMATIC, ICU_CONFIG_DATA) LpATUTimerAChannelRegs; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Defining a pointer to point to the TimerA registers */ P2VAR(Icu_ATUTimerACommonUserRegs, AUTOMATIC, ICU_CONFIG_DATA) LpATUTimerACommonRegs; /* PRQA S 3432 # JV-01 */ #endif /* End of #if (ICU_ATU_TIMERA_UNIT_USED == STD_ON) */ #if (ICU_ATU_TIMERC_UNIT_USED == STD_ON) /* Defining a pointer to point to the TimerC registers */ P2VAR(Icu_ATUTimerCSubBlkUserRegs, AUTOMATIC, ICU_CONFIG_DATA) LpATUTimerCSubBlkRegs; /* PRQA S 3432 # JV-01 */ P2VAR(Icu_ATUTimerCChannelUserRegs, AUTOMATIC, ICU_CONFIG_DATA) LpATUTimerCChannelRegs; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif /* End of #if (ICU_ATU_TIMERC_UNIT_USED == STD_ON) */ uint8 LucMeasureProperty; uint8 LucRamIndex; uint16 LusCurrentEdgeConfig; /* variable of setting next detect edge */ uint8 LucSetDetectEdge; /* Read channel configuration pointer */ LpChannelConfig = &Icu_GpChannelConfig[LddChannel]; /* Read timer channel configuration pointer */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[LddChannel]; /* Read the channel ram data */ LpRamData = &Icu_GpChannelRamData[LddChannel]; /* Read ATU timer channel configuration pointer */ LpATUChannelUserRegConfig = Icu_GpChannelUserRegConfig[LddChannel].pHWChannelUserRegConfig; /* PRQA S 0317 # JV-01 */ /* Read the channel ram index */ LucRamIndex = LpChannelUserRegConfig->ucRamDataIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LucMeasureProperty = LpChannelUserRegConfig->ucChannelProperties; LpATUChannelConfig = Icu_GpChannelConfig[LddChannel].pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ #if (ICU_ATU_TIMERA_UNIT_USED == STD_ON) if (ICU_HW_ATU_TIMERA == LpChannelConfig->ucIcuChannelType) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Initialize pointer to the base address of the current channel */ LpATUTimerAChannelRegs = (P2VAR(Icu_ATUTimerAChannelUserRegs, AUTOMATIC, ICU_CONFIG_DATA))LpATUChannelConfig->pTimerSubBlkUserRegs; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ LpATUTimerACommonRegs = (P2VAR(Icu_ATUTimerACommonUserRegs, AUTOMATIC, ICU_CONFIG_DATA)) LpChannelConfig->pCntlRegs; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Check channel property as on time and off time */ if (((uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK)) < ICU_PERIOD_CHANNEL_ENABLED_MASK) { /* Capture the value when period measurement status is ongoing. */ if ((uint8)ICU_PERIOD_ONGOING == Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus) /* PRQA S 2824 # JV-01 */ { /* Save input capture register value when end edge */ LpRamData->ulEndEdgeCaptureValue = (LpATUTimerAChannelRegs->ulAtuTimerAICRAm); /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Calculate Active time */ Icu_GpSignalMeasurementData[LucRamIndex].ulSignalActiveTime = /* PRQA S 0404 # JV-01 */ LpRamData->ulEndEdgeCaptureValue - /* PRQA S 3384 # JV-01 */ LpRamData->ulStartEdgeCaptureValue; /* Set channel input status as active */ LpRamData->blResultComplete = ICU_TRUE; /* Set channel input status as active */ LpRamData->ucChannelStatus = (uint8)ICU_ACTIVE; /* Toggle and configure edge detection for ON_TIME ,OFF_TIME * measurement. */ if (((uint8)(LucMeasureProperty & ICU_DUTY_PERIOD_ENABLED_MASK)) != ICU_DUTY_PERIOD_ENABLED_MASK) { /* Mask the edge configured in the register for particular channel */ LpATUTimerACommonRegs->usAtuTimerATIOR1A &= LpATUChannelUserRegConfig->usChannelModeUserRegSettings; /* PRQA S 2814 # JV-01 */ /* Toggle the Edge confiuration */ if ((uint8)ICU_HIGH_TIME == ((uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK))) { /* Set the Edge to be detected for next time */ LpATUTimerACommonRegs->usAtuTimerATIOR1A |= (uint16)((uint16)ICU_ATU_RISING_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO)); /* PRQA S 3383 # JV-01 */ } /* ICU_LOW_TIME == LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK */ else { /* Set the Edge to be detected for next time */ LpATUTimerACommonRegs->usAtuTimerATIOR1A |= (uint16)((uint16)ICU_ATU_FALLING_EDGE_MASK << (LpChannelConfig->usChannelMaskValue * ICU_TWO)); /* PRQA S 3383 # JV-01 */ } /* Change status to idle */ Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_IDLE; } else /* In case of Duty cycle additional channel (both edge) */ { /* Save input capture register value as re-start edge */ LpRamData->ulStartEdgeCaptureValue = (LpATUTimerAChannelRegs->ulAtuTimerAICRAm); } } else /* if (LpSignalMeasureData->ucPeriodMeasurementStatus == ICU_PERIOD_IDLE )*/ { /* Save input capture register value when start edge */ LpRamData->ulStartEdgeCaptureValue = (LpATUTimerAChannelRegs->ulAtuTimerAICRAm); /* Check whether channel configured for duty cycle, then do actions in period time ,else start the timer for signal measurement(on time, off time) and toggle the edge to be detected for next time. */ if (((uint8)(LucMeasureProperty & ICU_DUTY_PERIOD_ENABLED_MASK)) != ICU_DUTY_PERIOD_ENABLED_MASK) { /* Mask and get the current loaded edge configuration from register*/ LusCurrentEdgeConfig = (LpATUTimerACommonRegs->usAtuTimerATIOR1A & (uint16)(~LpATUChannelUserRegConfig->usChannelModeUserRegSettings)); /* get edge configuration for particular channel */ LusCurrentEdgeConfig = (LusCurrentEdgeConfig >> (LpChannelConfig->usChannelMaskValue * (uint16)ICU_TWO)); /* PRQA S 3383 # JV-01 */ /* Clear the current edge setting before setting */ LpATUTimerACommonRegs->usAtuTimerATIOR1A &= LpATUChannelUserRegConfig->usChannelModeUserRegSettings; /* Checking measurement property */ if ((uint8)ICU_HIGH_TIME == (uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK)) { if (ICU_ATU_RISING_EDGE_MASK == (uint8)LusCurrentEdgeConfig) { /* Setting next detect edge to Falling for capture value */ LucSetDetectEdge = ICU_ATU_FALLING_EDGE_MASK; /* Set period measurement status as ongoing. */ Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_ONGOING; } else /* ICU_ATU_FALLING_EDGE_MASK == LusCurrentEdgeConfig case */ { /* Setting next detect edge to Rising for start count */ LucSetDetectEdge = ICU_ATU_RISING_EDGE_MASK; } } else { if (ICU_ATU_FALLING_EDGE_MASK == (uint8)LusCurrentEdgeConfig) { /* Setting next detect edge to Rising for capture value */ LucSetDetectEdge = ICU_ATU_RISING_EDGE_MASK; /* CSet period measurement status as ongoing. */ Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_ONGOING; } else /* ICU_ATU_RISING_EDGE_MASK == LusCurrentEdgeConfig case */ { /* Setting next detect edge to Falling for start count */ LucSetDetectEdge = ICU_ATU_FALLING_EDGE_MASK; } } /* Setting next detect edge */ LpATUTimerACommonRegs->usAtuTimerATIOR1A |= (uint16)((uint16)LucSetDetectEdge << (LpChannelConfig->usChannelMaskValue * ICU_TWO)); /* PRQA S 3383 # JV-01 */ } /* else No action required */ } } else /* (LucMeasureProperty == (ICU_PERIOD_TIME)) */ { /* Set period measurement status as ongoing */ if ((uint8)ICU_PERIOD_ONGOING == Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus) { Icu_GpSignalMeasurementData[LucRamIndex].ulPrevSignalActiveTime = Icu_GpSignalMeasurementData[LucRamIndex].ulSignalActiveTime; /* Save input capture register value when end edge */ LpRamData->ulEndEdgeCaptureValue = (LpATUTimerAChannelRegs->ulAtuTimerAICRAm); /* Calculate Period time */ Icu_GpSignalMeasurementData[LucRamIndex].ulSignalPeriodTime = LpRamData->ulEndEdgeCaptureValue - /* PRQA S 0404, 3384 # JV-01, JV-01 */ LpRamData->ulStartEdgeCaptureValue; /* Save input capture register value as re-start edge */ LpRamData->ulStartEdgeCaptureValue = (LpATUTimerAChannelRegs->ulAtuTimerAICRAm); /* Change status to active since signal measurement values available */ LpRamData->blResultComplete = ICU_TRUE; /* Set channel input status as active */ LpRamData->ucChannelStatus = (uint8)ICU_ACTIVE; } else { /* Save input capture register value when first edge */ LpRamData->ulStartEdgeCaptureValue = (LpATUTimerAChannelRegs->ulAtuTimerAICRAm); /* Set period measurement status as ongoing */ Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_ONGOING; } } } /* else No action required */ /* End of (ICU_HW_ATU_TIMERA == LpChannelConfig->ucIcuChannelType) */ #endif /* End of #if (ICU_ATU_TIMERA_UNIT_USED == STD_ON) */ #if (ICU_ATU_TIMERC_UNIT_USED == STD_ON) if (ICU_HW_ATU_TIMERC == LpChannelConfig->ucIcuChannelType) { LpATUTimerCSubBlkRegs = (P2VAR(Icu_ATUTimerCSubBlkUserRegs, AUTOMATIC, ICU_CONFIG_DATA))LpATUChannelConfig->pTimerSubBlkUserRegs; /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpATUTimerCChannelRegs = (P2VAR(Icu_ATUTimerCChannelUserRegs, AUTOMATIC, ICU_CONFIG_DATA))LpATUChannelConfig->pTimerChannelUserRegs; /* PRQA S 0316, 3432 # JV-01, JV-01 */ if (((uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK)) < ICU_PERIOD_CHANNEL_ENABLED_MASK) { if ((uint8)ICU_PERIOD_ONGOING == Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus) { /* Save input capture register value when end edge */ LpRamData->ulEndEdgeCaptureValue = (LpATUTimerCChannelRegs->ulAtuTimerCGRCmn); /* PRQA S 2814 # JV-01 */ /* Calculate Active time */ Icu_GpSignalMeasurementData[LucRamIndex].ulSignalActiveTime = LpRamData->ulEndEdgeCaptureValue - /* PRQA S 0404, 3384 # JV-01, JV-01 */ LpRamData->ulStartEdgeCaptureValue; /* Set channel input status as active */ LpRamData->blResultComplete = ICU_TRUE; /* Set channel input status as active */ LpRamData->ucChannelStatus = (uint8)ICU_ACTIVE; /* Check whether channel configured for duty cycle,then do actions in period time ,else start the timer for signal measurement(on time, off time) and toggle the edge to be detected for next time. */ if (((uint8)(LucMeasureProperty & ICU_DUTY_PERIOD_ENABLED_MASK)) != ICU_DUTY_PERIOD_ENABLED_MASK) { /* Mask and toggle the edge for next interrupt */ LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm &= LpATUChannelUserRegConfig->usChannelModeUserRegSettings; /* PRQA S 2814 # JV-01 */ if ((uint8)ICU_HIGH_TIME == ((uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK))) { LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm |= (uint16)((uint16)(ICU_SET_INPUT_CAPTURE_MODE | ICU_ATU_RISING_EDGE_MASK) << (LpChannelConfig->usChannelMaskValue * ICU_FOUR)); /* PRQA S 3383 # JV-01 */ } /* ICU_LOW_TIME == LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK */ else { LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm |= (uint16)((uint16)(ICU_SET_INPUT_CAPTURE_MODE | ICU_ATU_FALLING_EDGE_MASK) << (LpChannelConfig->usChannelMaskValue * ICU_FOUR)); /* PRQA S 3383 # JV-01 */ } /* Change status to idle */ Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_IDLE; } else /* In case of Duty cycle additional channel (both edge) */ { /* Save input capture register value when start edge */ LpRamData->ulStartEdgeCaptureValue = (LpATUTimerCChannelRegs->ulAtuTimerCGRCmn); } } else /* if (LpSignalMeasureData->ucPeriodMeasurementStatus == ICU_PERIOD_IDLE )*/ { /* Save input capture register value when start edge */ LpRamData->ulStartEdgeCaptureValue = (LpATUTimerCChannelRegs->ulAtuTimerCGRCmn); if (((uint8)(LucMeasureProperty & ICU_DUTY_PERIOD_ENABLED_MASK)) != ICU_DUTY_PERIOD_ENABLED_MASK) { /* Mask and get the current loaded edge configuration from register*/ LusCurrentEdgeConfig = (LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm & (uint16)(~LpATUChannelUserRegConfig->usChannelModeUserRegSettings)); /* get edge configuration for particular channel */ LusCurrentEdgeConfig = ((uint16)(LusCurrentEdgeConfig >> (LpChannelConfig->usChannelMaskValue * (uint16)ICU_FOUR)) & /* PRQA S 3383 # JV-01 */ (uint16)ICU_ATU_BOTH_EDGE_MASK); /* Clear the current edge setting before setting */ LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm &= LpATUChannelUserRegConfig->usChannelModeUserRegSettings; /* Checking measurement property */ if ((uint8)ICU_HIGH_TIME == (uint8)(LucMeasureProperty & ICU_HIGH_LOW_TIME_MASK)) { if (ICU_ATU_RISING_EDGE_MASK == (uint8)LusCurrentEdgeConfig) { /* Setting next detect edge to Falling for capture value */ LucSetDetectEdge = ICU_ATU_FALLING_EDGE_MASK; /* Set period measurement status as ongoing. */ Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_ONGOING; } else /* ICU_ATU_FALLING_EDGE_MASK == LusCurrentEdgeConfig case */ { /* Setting next detect edge to Rising for start count */ LucSetDetectEdge = ICU_ATU_RISING_EDGE_MASK; } } else { if (ICU_ATU_FALLING_EDGE_MASK == (uint8)LusCurrentEdgeConfig) { /* Setting next detect edge to Rising for capture value */ LucSetDetectEdge = ICU_ATU_RISING_EDGE_MASK; /* Set period measurement status as ongoing. */ Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_ONGOING; } else /* ICU_ATU_RISING_EDGE_MASK == LusCurrentEdgeConfig case */ { /* Setting next detect edge to Falling for start count */ LucSetDetectEdge = ICU_ATU_FALLING_EDGE_MASK; } } /* Setting next detect edge */ LpATUTimerCSubBlkRegs->usAtuTimerCTIORCm |= (uint16)(((uint32)ICU_SET_INPUT_CAPTURE_MODE | (uint32)LucSetDetectEdge) << (LpChannelConfig->usChannelMaskValue * ICU_FOUR)); /* PRQA S 3383 # JV-01 */ } /* else No action required */ } } else /* (LucMeasureProperty == (ICU_PERIOD_TIME)) */ { if ((uint8)ICU_PERIOD_ONGOING == Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus) { /* Store the active time */ Icu_GpSignalMeasurementData[LucRamIndex].ulPrevSignalActiveTime = Icu_GpSignalMeasurementData[LucRamIndex].ulSignalActiveTime; /* Save input capture register value when end edge */ LpRamData->ulEndEdgeCaptureValue = LpATUTimerCChannelRegs->ulAtuTimerCGRCmn; /* Calculate Period time */ Icu_GpSignalMeasurementData[LucRamIndex].ulSignalPeriodTime = LpRamData->ulEndEdgeCaptureValue - /* PRQA S 0404, 3384 # JV-01, JV-01 */ LpRamData->ulStartEdgeCaptureValue; /* Save input capture register value as re-start edge */ LpRamData->ulStartEdgeCaptureValue = LpATUTimerCChannelRegs->ulAtuTimerCGRCmn; LpRamData->blResultComplete = ICU_TRUE; /* Set channel input status as active */ LpRamData->ucChannelStatus = (uint8)ICU_ACTIVE; } else { /* Save input capture register value when first edge */ LpRamData->ulStartEdgeCaptureValue = (LpATUTimerCChannelRegs->ulAtuTimerCGRCmn); Icu_GpSignalMeasurementData[LucRamIndex].ucPeriodMeasurementStatus = (uint8)ICU_PERIOD_ONGOING; } } /* else No action required */ } /* End of (ICU_HW_ATU_TIMERC == LpChannelConfig->ucIcuChannelType) */ #endif /* End of #if (ICU_ATU_TIMERC_UNIT_USED == STD_ON) */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERA_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_ATU_TIMERC_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannel', 'Value': '0x00'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpSignalMeasurementData', 'Value': '&map_Icu_GpSignalMeasurementData[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalActiveTime', 'Value': '0x00000000'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'ICU_PERIOD_ONGOING/ICU_PERIOD_IDLE', 'Name': 'ucPeriodMeasurementStatus', 'Value': 'ICU_PERIOD_IDLE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelRamData', 'Value': '&map_Icu_GpChannelRamData[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blResultComplete ', 'Value': 'ICU_FALSE'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulStartEdgeCaptureValue', 'Value': '0x00000001'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulEndEdgeCaptureValue', 'Value': '0x00000000'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pHWChannelUserRegConfig', 'Value': '&map_Icu_GpATUChannelUserRegConfig[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '0x01'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucRamDataIndex', 'Value': '0x00'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelModeUserRegSettings', 'Value': '0xFFF0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '&map_Icu_GpATUChannelConfig[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pTimerSubBlkUserRegs', 'Value': '&map_Icu_ATUTimerCSubBlkUserRegs[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'usChannelMaskValue', 'Value': '0x0000'], 'Input_Param_020': ['Type': 'Variable', 'Range': 'ICU_HW_ATU_TIMERA\\nICU_HW_ATU_TIMERC\\nICU_HW_EXT_IRQ', 'Name': 'ucIcuChannelType', 'Value': 'ICU_HW_ATU_TIMERC'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pTimerChannelUserRegs', 'Value': '&map_Icu_ATUTimerCChannelUserRegs[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ulAtuTimerAICRAm', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerCTIORCm', 'Value': '0x0005'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerATIOR1A', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'ulAtuTimerCGRCmn', 'Value': '0x00000001']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalActiveTime', 'Value': '0x00000000'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucPeriodMeasurementStatus', 'Value': 'ICU_PERIOD_ONGOING'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulSignalPeriodTime', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulPrevSignalActiveTime', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blResultComplete ', 'Value': 'ICU_FALSE'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelStatus', 'Value': 'ICU_IDLE'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulStartEdgeCaptureValue', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulEndEdgeCaptureValue', 'Value': '0x00000000'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerCTIORCm', 'Value': '0x0006'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'usAtuTimerATIOR1A', 'Value': '-'], 'Output_Param_010': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_011': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_SetActivationCondition(Icu_ChannelType Channel, Icu_ActivationType Activation) /* PRQA S 1503 # JV-01 */ { /* Declare a Local variable to Timer Type */ volatile uint8 LucHWIPType; /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_SET_ACTIVATION_CONDITION_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_SET_ACTIVATION_CONDITION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { if ((uint8)ICU_MODE_SIGNAL_MEASUREMENT == Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_SET_ACTIVATION_CONDITION_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ } } /* Check if the activation edge other than Rising or Falling or Both edges */ if ((ICU_FALLING_EDGE != Activation) && (ICU_RISING_EDGE != Activation) && (ICU_BOTH_EDGES != Activation)) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_SET_ACTIVATION_CONDITION_SID, ICU_E_PARAM_ACTIVATION); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } /* else No action required */ /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Critical Section */ ICU_ENTER_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Unit Type for given unit */ LucHWIPType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Set the activation edge value */ if (NULL_PTR != Icu_GaaHwDepFunc[LucHWIPType]->pSetActivation) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucHWIPType]->pSetActivation(Channel, Activation); } /* else No action required */ #if (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Critical Section */ ICU_EXIT_CRITICAL_SECTION(ICU_INTERRUPT_CONTROL_PROTECTION); #endif /* End of (ICU_CRITICAL_SECTION_PROTECTION == STD_ON) */ } /* else No action required */ /* End of #if (ICU_DEV_ERROR_DETECT == STD_ON) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0...183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '101'], 'Input_Param_003': ['Type': 'Argument', 'Range': '  ICU_FALLING_EDGE\\n  ICU_RISING_EDGE\\n  ICU_BOTH_EDGES', 'Name': 'Activation', 'Value': 'ICU_BOTH_EDGES'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[101] = ICU_MODE_SIGNAL_EDGE_DETECT'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[101] = ICU_HW_EXT_INTP '], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pSetActivation', 'Value': '[0 to 5] = NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'Channel', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'Activation', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_StopSignalMeasurement(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Defining a pointer to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_STOP_SIGNAL_MEASUREMENT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_STOP_SIGNAL_MEASUREMENT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Signal measurement */ if ((uint8)ICU_MODE_SIGNAL_MEASUREMENT != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_STOP_SIGNAL_MEASUREMENT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Read timer channel configuration pointer */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[Channel]; /* Check if the channel is configured for extra duty channel */ if (ICU_FIVE == (uint8)(LpChannelUserRegConfig->ucChannelProperties)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Report Error to Det */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_STOP_SIGNAL_MEASUREMENT_SID, ICU_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } /* else No action required */ } } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Disable Timestamp capturing */ /* Read the Unit Type for given unit */ /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Stop count measurement for the channel */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pStopCountMeasurement) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucTimerType]->pStopCountMeasurement(Channel); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '129'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[129] = ICU_MODE_SIGNAL_MEASUREMENT'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[129] = ICU_HW_EXT_INTP'], 'Input_Param_008': ['Type': 'Array', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '[129] = 0x00'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pStopCountMeasurement', 'Value': '[0 to 5] = NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_SIGNAL_MEASUREMENT_API == STD_ON) #define ICU_START_SEC_PUBLIC_CODE #include \"Icu_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, ICU_PUBLIC_CODE) Icu_StopSignalMeasurement(Icu_ChannelType Channel) /* PRQA S 1503 # JV-01 */ { /* Defining a pointer to the channel config parameters */ P2CONST(Icu_ChannelConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannel; /* PRQA S 3432 # JV-01 */ /* Declare a Local variable to Timer Type */ volatile uint8 LucTimerType; #if (ICU_DEV_ERROR_DETECT == STD_ON) /* Defining a pointer to the timer channel configuration parameters */ P2CONST(Icu_ChannelUserRegConfigType, AUTOMATIC, ICU_CONFIG_DATA) LpChannelUserRegConfig; /* PRQA S 3432 # JV-01 */ /* Declare the variable to store the DET return value */ Std_ReturnType LucReturnValue; /* Set the DET return value */ LucReturnValue = E_OK; /* Check if the Icu Module is not initialized */ if (ICU_INITIALIZED != Icu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_STOP_SIGNAL_MEASUREMENT_SID, ICU_E_UNINIT); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the channel is valid */ if (ICU_MAX_CHANNEL_ID_CONFIGURED < Channel) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_STOP_SIGNAL_MEASUREMENT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Check if the measurement mode is other than Signal measurement */ if ((uint8)ICU_MODE_SIGNAL_MEASUREMENT != Icu_GpChannelConfig[Channel].ucIcuMeasurementMode) { /* Report Error to DET */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_STOP_SIGNAL_MEASUREMENT_SID, ICU_E_PARAM_CHANNEL); /* Set DET return value to E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { /* Read timer channel configuration pointer */ LpChannelUserRegConfig = &Icu_GpChannelUserRegConfig[Channel]; /* Check if the channel is configured for extra duty channel */ if (ICU_FIVE == (uint8)(LpChannelUserRegConfig->ucChannelProperties)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Report Error to Det */ (void)Det_ReportError(ICU_MODULE_ID, ICU_INSTANCE_ID, ICU_STOP_SIGNAL_MEASUREMENT_SID, ICU_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } /* else No action required */ } } } /* Check if any DET was reported */ if (E_OK == LucReturnValue) #endif /* End of (ICU_DEV_ERROR_DETECT == STD_ON) */ { /* Disable Timestamp capturing */ /* Read the Unit Type for given unit */ /* Updating the channel config parameter to the current channel */ LpChannel = &Icu_GpChannelConfig[Channel]; /* Read the Timer Type for given channel */ LucTimerType = LpChannel->ucIcuChannelType; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Stop count measurement for the channel */ if (NULL_PTR != Icu_GaaHwDepFunc[LucTimerType]->pStopCountMeasurement) /* PRQA S 2814 # JV-01 */ { Icu_GaaHwDepFunc[LucTimerType]->pStopCountMeasurement(Channel); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'ICU_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0\u2026103\\n0\u202659\\n0\u202675\\n0\u2026183\\n0\u2026129\\n0\u2026159', 'Name': 'Channel', 'Value': '159'], 'Input_Param_003': ['Type': 'Variable', 'Range': '0/1', 'Name': 'Icu_GblDriverStatus', 'Value': 'ICU_INITIALIZED'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelConfig', 'Value': '&map_Icu_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Icu_GpChannelUserRegConfig', 'Value': '&map_Icu_GpChannelUserRegConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '  ICU_MODE_SIGNAL_EDGE_DETECT\\n  ICU_MODE_SIGNAL_MEASUREMENT\\n  ICU_MODE_TIMESTAMP\\n  ICU_MODE_EDGE_COUNTER', 'Name': 'ucIcuMeasurementMode', 'Value': '[159] = ICU_MODE_SIGNAL_MEASUREMENT'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIcuChannelType', 'Value': '[159] = ICU_HW_TAUJ'], 'Input_Param_008': ['Type': 'Array', 'Range': '0\u20268', 'Name': 'ucChannelProperties', 'Value': '[159] = 0x06'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'Icu_GaaHwDepFunc[0 to 5]', 'Value': '[0] = &map_Icu_GaaHwDepFunc[0]\\n[1] = &map_Icu_GaaHwDepFunc[1]\\n[2] = &map_Icu_GaaHwDepFunc[2]\\n[3] = &map_Icu_GaaHwDepFunc[3]\\n[4] = &map_Icu_GaaHwDepFunc[4]\\n[5] = &map_Icu_GaaHwDepFunc[5]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pStopCountMeasurement', 'Value': '[3] = &ISOLATE_void_func_ptr_Icu_ChannelType']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleID', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '159'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUD0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Taud_TimerIsr(ICU_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '23 = TAUD1_CH07_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '23'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUD0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Taud_TimerIsr(ICU_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '61 = TAUD3_CH13_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '61'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUJ0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUJ0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(TAUJ0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) TAUJ0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Tauj_TimerIsr(ICU_TAUJ0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '0 = TAUJ0_CH00_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '48'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUJ0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUJ0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(TAUJ0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) TAUJ0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Tauj_TimerIsr(ICU_TAUJ0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '10 = TAUJ2_CH02_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '58'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUJ0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUJ0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(TAUJ0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) TAUJ0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Tauj_TimerIsr(ICU_TAUJ0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '12 = TAUJ3_CH00_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '60'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (ICU_TAUJ0_CH00_ISR_API == STD_ON) #define ICU_START_SEC_CODE_FAST #include \"Icu_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUJ0_CH00_CAT2_ISR) || (ICU_ISR_CATEGORY_2 == STD_ON) ISR(TAUJ0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, ICU_CODE_FAST) TAUJ0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Icu_HW_Tauj_TimerIsr(ICU_TAUJ0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '5 = TAUJ3_CH01_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannel', 'Value': '37'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ /* RLIN3n Status Interrupt */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_LIN_CHANNEL0_ERR_CAT2_ISR) || (LIN_ISR_CATEGORY_2 == STD_ON) ISR(LIN_CHANNEL0_ERR_CAT2_ISR) /* PRQA S 3408, 1503 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, LIN_CODE_FAST) LIN_CHANNEL0_ERR_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Lin_ErrIsr(LIN_CHANNEL0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CHANNELn_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_ISR_CATEGORY_2', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Count_Irq', 'Value': '10 =  LIN_CHANNEL10_ERR_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '0x0A'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ /* RLIN3n Successful Reception Interrupt */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_LIN_CHANNEL0_RX_CAT2_ISR) || (LIN_ISR_CATEGORY_2 == STD_ON) ISR(LIN_CHANNEL0_RX_CAT2_ISR) /* PRQA S 3408, 1503 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, LIN_CODE_FAST) LIN_CHANNEL0_RX_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Lin_RxIsr(LIN_CHANNEL0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CHANNELn_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Count_Irq', 'Value': '2 =  LIN_CHANNEL2_RX_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '0x02'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ /* RLIN3n Successful Reception Interrupt */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_LIN_CHANNEL0_RX_CAT2_ISR) || (LIN_ISR_CATEGORY_2 == STD_ON) ISR(LIN_CHANNEL0_RX_CAT2_ISR) /* PRQA S 3408, 1503 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, LIN_CODE_FAST) LIN_CHANNEL0_RX_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Lin_RxIsr(LIN_CHANNEL0); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CHANNELn_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Count_Irq', 'Value': '5 =  LIN_CHANNEL5_RX_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '0x05'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_PUBLIC_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, LIN_PUBLIC_CODE) Lin_CheckWakeup(uint8 Channel) /* PRQA S 1503, 3206 # JV-01, JV-01 */ { #if (LIN_WAKEUP_SUPPORT == STD_ON) volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_PRIVATE_CONST) LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_APPL_DATA) LpRamVars; /* PRQA S 3432 # JV-01 */ #endif /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ #if (LIN_DEV_ERROR_DETECT == STD_ON) boolean LblDetErrFlag; #endif Std_ReturnType LucReturnValue; /* Initialize the return value to E_OK */ LucReturnValue = E_OK; #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Initialize error status flag to LIN_FALSE */ LblDetErrFlag = LIN_FALSE; #endif /* (LIN_DEV_ERROR_DETECT == STD_ON) */ #if (LIN_AR_VERSION == LIN_AR_422_VERSION) #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not Initialized */ if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE and return E_NOT_OK */ LblDetErrFlag = LIN_TRUE; LucReturnValue = E_NOT_OK; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE and return E_NOT_OK*/ LblDetErrFlag = LIN_TRUE; LucReturnValue = E_NOT_OK; } /* else No action required */ } #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ #elif ((LIN_AR_VERSION == LIN_AR_431_VERSION) || (LIN_AR_VERSION == LIN_AR_1911_VERSION)) if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ /* Return E_NOT_OK if error occurs */ LucReturnValue = E_NOT_OK; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ /* Return E_NOT_OK if error occurs */ LucReturnValue = E_NOT_OK; } /* else No action required */ } #endif /* if (LIN_AR_VERSION == LIN_AR_422_VERSION) */ #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Check if DET error occured */ if (LIN_FALSE == LblDetErrFlag) #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ { /* Check if no error occured */ if (E_OK == LucReturnValue) /* PRQA S 2995, 2991 # JV-01, JV-01 */ { #if (LIN_WAKEUP_SUPPORT == STD_ON) /* Get the address of Channel info structure */ LpLinChannelPtr = &Lin_GpChannelConfig[Channel]; /* PRQA S 0404 # JV-01 */ /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[Channel]; /* PRQA S 0404 # JV-01 */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Check if wake-up occurred */ if (LIN_WAKEUP == LpRamVars->ucSlpRqst_RespRdy) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Clear the sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_CLR_SLEEP_REQUEST; /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Invoke the upper layer wakeup notification */ EcuM_SetWakeupEvent((EcuM_WakeupSourceType)LIN_ONE << (LpLinChannelPtr->ucWakeupSourceId)); /* PRQA S 2814, 2844 # JV-03, JV-01 */ /* Invoke the LinIf wakeup notification */ LinIf_WakeupConfirmation((EcuM_WakeupSourceType)LIN_ONE << (LpLinChannelPtr->ucWakeupSourceId)); /* Set RLIN3 to Reset Mode */ LucReturnValue = Lin_HwSetMasterMode(Channel, RLIN3_RESET_MODE, LIN_CHECK_WAKEUP_SID); if (E_OK == LucReturnValue) { /* Set RLIN3 to Operation Mode */ LucReturnValue = Lin_HwSetMasterMode(Channel, RLIN3_OPERATION_MODE, LIN_CHECK_WAKEUP_SID); } /* else No action required */ #if (LIN_SLAVE_MODE_SUPPORT == STD_ON) if (LIN_SLAVE_NODE == LpLinChannelPtr->enNodeType) { if (E_OK == LucReturnValue) { /* SWS_Lin_00272 The LIN driver shall be able to receive a LIN header at any time in LIN_CH_OPERATIONAL state */ Lin_HwSlaveStartHeaderReception(Channel); }/* else No action required */ } else #endif /* (LIN_SLAVE_MODE_SUPPORT == STD_ON) */ { #if (LIN_MASTER_MODE_SUPPORT == STD_ON) /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(Channel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); #endif /* if (LIN_MASTER_MODE_SUPPORT == STD_ON) */ } } else { /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); } #endif /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ } /* else No action required */ } /* else No action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'LIN_AR_1911_VERSION/LIN_AR_422_VERSION/ LIN_AR_431_VERSION', 'Name': 'LIN_AR_VERSION', 'Value': 'LIN_AR_431_VERSION'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_MASTER_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_SLAVE_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Channel', 'Value': '23'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'LIN_UNINIT/ LIN_INIT', 'Name': 'Lin_GblDriverState', 'Value': 'LIN_INIT'], 'Input_Param_008': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'LIN_WAKEUP/ LIN_SET_SLEEP_REQUEST/ LIN_CLR_SLEEP_REQUEST', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_WAKEUP'], 'Input_Param_011': ['Type': 'Variable', 'Range': '5', 'Name': 'ucWakeupSourceId', 'Value': '5'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'LIN_MASTER_NODE/LIN_SLAVE_NODE', 'Name': 'enNodeType', 'Value': 'LIN_MASTER_NODE'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Output_Param_017': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION\\n'], 'Output_Param_018': ['Type': 'Variable', 'Range': 'LIN_WAKEUP/ LIN_SET_SLEEP_REQUEST/ LIN_CLR_SLEEP_REQUEST', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_CLR_SLEEP_REQUEST'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION\\n'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'sources', 'Value': '32'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'wakeupSource', 'Value': '32'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '[1] = 23\\n[2] = 23'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenModeType', 'Value': '[1] = RLIN3_RESET_MODE\\n[2] = RLIN3_OPERATION_MODE'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApiId', 'Value': '[1] = LIN_CHECK_WAKEUP_SID\\n[2] = LIN_CHECK_WAKEUP_SID'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '23'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenInterruptScheduleType', 'Value': 'LIN_INTERRUPT_DIS'], 'Output_Param_029': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_030': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_OK'], 'Output_Param_031': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_PUBLIC_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, LIN_PUBLIC_CODE) Lin_CheckWakeup(uint8 Channel) /* PRQA S 1503, 3206 # JV-01, JV-01 */ { #if (LIN_WAKEUP_SUPPORT == STD_ON) volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_PRIVATE_CONST) LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_APPL_DATA) LpRamVars; /* PRQA S 3432 # JV-01 */ #endif /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ #if (LIN_DEV_ERROR_DETECT == STD_ON) boolean LblDetErrFlag; #endif Std_ReturnType LucReturnValue; /* Initialize the return value to E_OK */ LucReturnValue = E_OK; #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Initialize error status flag to LIN_FALSE */ LblDetErrFlag = LIN_FALSE; #endif /* (LIN_DEV_ERROR_DETECT == STD_ON) */ #if (LIN_AR_VERSION == LIN_AR_422_VERSION) #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not Initialized */ if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE and return E_NOT_OK */ LblDetErrFlag = LIN_TRUE; LucReturnValue = E_NOT_OK; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE and return E_NOT_OK*/ LblDetErrFlag = LIN_TRUE; LucReturnValue = E_NOT_OK; } /* else No action required */ } #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ #elif ((LIN_AR_VERSION == LIN_AR_431_VERSION) || (LIN_AR_VERSION == LIN_AR_1911_VERSION)) if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ /* Return E_NOT_OK if error occurs */ LucReturnValue = E_NOT_OK; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ /* Return E_NOT_OK if error occurs */ LucReturnValue = E_NOT_OK; } /* else No action required */ } #endif /* if (LIN_AR_VERSION == LIN_AR_422_VERSION) */ #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Check if DET error occured */ if (LIN_FALSE == LblDetErrFlag) #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ { /* Check if no error occured */ if (E_OK == LucReturnValue) /* PRQA S 2995, 2991 # JV-01, JV-01 */ { #if (LIN_WAKEUP_SUPPORT == STD_ON) /* Get the address of Channel info structure */ LpLinChannelPtr = &Lin_GpChannelConfig[Channel]; /* PRQA S 0404 # JV-01 */ /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[Channel]; /* PRQA S 0404 # JV-01 */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Check if wake-up occurred */ if (LIN_WAKEUP == LpRamVars->ucSlpRqst_RespRdy) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Clear the sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_CLR_SLEEP_REQUEST; /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Invoke the upper layer wakeup notification */ EcuM_SetWakeupEvent((EcuM_WakeupSourceType)LIN_ONE << (LpLinChannelPtr->ucWakeupSourceId)); /* PRQA S 2814, 2844 # JV-03, JV-01 */ /* Invoke the LinIf wakeup notification */ LinIf_WakeupConfirmation((EcuM_WakeupSourceType)LIN_ONE << (LpLinChannelPtr->ucWakeupSourceId)); /* Set RLIN3 to Reset Mode */ LucReturnValue = Lin_HwSetMasterMode(Channel, RLIN3_RESET_MODE, LIN_CHECK_WAKEUP_SID); if (E_OK == LucReturnValue) { /* Set RLIN3 to Operation Mode */ LucReturnValue = Lin_HwSetMasterMode(Channel, RLIN3_OPERATION_MODE, LIN_CHECK_WAKEUP_SID); } /* else No action required */ #if (LIN_SLAVE_MODE_SUPPORT == STD_ON) if (LIN_SLAVE_NODE == LpLinChannelPtr->enNodeType) { if (E_OK == LucReturnValue) { /* SWS_Lin_00272 The LIN driver shall be able to receive a LIN header at any time in LIN_CH_OPERATIONAL state */ Lin_HwSlaveStartHeaderReception(Channel); }/* else No action required */ } else #endif /* (LIN_SLAVE_MODE_SUPPORT == STD_ON) */ { #if (LIN_MASTER_MODE_SUPPORT == STD_ON) /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(Channel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); #endif /* if (LIN_MASTER_MODE_SUPPORT == STD_ON) */ } } else { /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); } #endif /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ } /* else No action required */ } /* else No action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'LIN_AR_1911_VERSION/LIN_AR_422_VERSION/ LIN_AR_431_VERSION', 'Name': 'LIN_AR_VERSION', 'Value': 'LIN_AR_431_VERSION'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_MASTER_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_SLAVE_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Channel', 'Value': '23'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'LIN_UNINIT/ LIN_INIT', 'Name': 'Lin_GblDriverState', 'Value': 'LIN_INIT'], 'Input_Param_008': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'LIN_WAKEUP/ LIN_SET_SLEEP_REQUEST/ LIN_CLR_SLEEP_REQUEST', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_WAKEUP'], 'Input_Param_011': ['Type': 'Variable', 'Range': '5', 'Name': 'ucWakeupSourceId', 'Value': '5'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'LIN_MASTER_NODE/LIN_SLAVE_NODE', 'Name': 'enNodeType', 'Value': 'LIN_MASTER_NODE'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Output_Param_017': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION'], 'Output_Param_018': ['Type': 'Variable', 'Range': 'LIN_WAKEUP/ LIN_SET_SLEEP_REQUEST/ LIN_CLR_SLEEP_REQUEST', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_CLR_SLEEP_REQUEST'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION\\n'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'sources', 'Value': '32'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'wakeupSource', 'Value': '32'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '23'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenModeType', 'Value': 'RLIN3_RESET_MODE'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApiId', 'Value': 'LIN_CHECK_WAKEUP_SID'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '23'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenInterruptScheduleType', 'Value': 'LIN_INTERRUPT_DIS'], 'Output_Param_029': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_030': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_031': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_PUBLIC_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, LIN_PUBLIC_CODE) Lin_CheckWakeup(uint8 Channel) /* PRQA S 1503, 3206 # JV-01, JV-01 */ { #if (LIN_WAKEUP_SUPPORT == STD_ON) volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_PRIVATE_CONST) LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_APPL_DATA) LpRamVars; /* PRQA S 3432 # JV-01 */ #endif /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ #if (LIN_DEV_ERROR_DETECT == STD_ON) boolean LblDetErrFlag; #endif Std_ReturnType LucReturnValue; /* Initialize the return value to E_OK */ LucReturnValue = E_OK; #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Initialize error status flag to LIN_FALSE */ LblDetErrFlag = LIN_FALSE; #endif /* (LIN_DEV_ERROR_DETECT == STD_ON) */ #if (LIN_AR_VERSION == LIN_AR_422_VERSION) #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not Initialized */ if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE and return E_NOT_OK */ LblDetErrFlag = LIN_TRUE; LucReturnValue = E_NOT_OK; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE and return E_NOT_OK*/ LblDetErrFlag = LIN_TRUE; LucReturnValue = E_NOT_OK; } /* else No action required */ } #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ #elif ((LIN_AR_VERSION == LIN_AR_431_VERSION) || (LIN_AR_VERSION == LIN_AR_1911_VERSION)) if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ /* Return E_NOT_OK if error occurs */ LucReturnValue = E_NOT_OK; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_CHECK_WAKEUP_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ /* Return E_NOT_OK if error occurs */ LucReturnValue = E_NOT_OK; } /* else No action required */ } #endif /* if (LIN_AR_VERSION == LIN_AR_422_VERSION) */ #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Check if DET error occured */ if (LIN_FALSE == LblDetErrFlag) #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ { /* Check if no error occured */ if (E_OK == LucReturnValue) /* PRQA S 2995, 2991 # JV-01, JV-01 */ { #if (LIN_WAKEUP_SUPPORT == STD_ON) /* Get the address of Channel info structure */ LpLinChannelPtr = &Lin_GpChannelConfig[Channel]; /* PRQA S 0404 # JV-01 */ /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[Channel]; /* PRQA S 0404 # JV-01 */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Check if wake-up occurred */ if (LIN_WAKEUP == LpRamVars->ucSlpRqst_RespRdy) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Clear the sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_CLR_SLEEP_REQUEST; /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Invoke the upper layer wakeup notification */ EcuM_SetWakeupEvent((EcuM_WakeupSourceType)LIN_ONE << (LpLinChannelPtr->ucWakeupSourceId)); /* PRQA S 2814, 2844 # JV-03, JV-01 */ /* Invoke the LinIf wakeup notification */ LinIf_WakeupConfirmation((EcuM_WakeupSourceType)LIN_ONE << (LpLinChannelPtr->ucWakeupSourceId)); /* Set RLIN3 to Reset Mode */ LucReturnValue = Lin_HwSetMasterMode(Channel, RLIN3_RESET_MODE, LIN_CHECK_WAKEUP_SID); if (E_OK == LucReturnValue) { /* Set RLIN3 to Operation Mode */ LucReturnValue = Lin_HwSetMasterMode(Channel, RLIN3_OPERATION_MODE, LIN_CHECK_WAKEUP_SID); } /* else No action required */ #if (LIN_SLAVE_MODE_SUPPORT == STD_ON) if (LIN_SLAVE_NODE == LpLinChannelPtr->enNodeType) { if (E_OK == LucReturnValue) { /* SWS_Lin_00272 The LIN driver shall be able to receive a LIN header at any time in LIN_CH_OPERATIONAL state */ Lin_HwSlaveStartHeaderReception(Channel); }/* else No action required */ } else #endif /* (LIN_SLAVE_MODE_SUPPORT == STD_ON) */ { #if (LIN_MASTER_MODE_SUPPORT == STD_ON) /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(Channel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); #endif /* if (LIN_MASTER_MODE_SUPPORT == STD_ON) */ } } else { /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); } #endif /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ } /* else No action required */ } /* else No action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'LIN_AR_1911_VERSION/LIN_AR_422_VERSION/ LIN_AR_431_VERSION', 'Name': 'LIN_AR_VERSION', 'Value': 'LIN_AR_431_VERSION'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_MASTER_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_SLAVE_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Channel', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'LIN_UNINIT/ LIN_INIT', 'Name': 'Lin_GblDriverState', 'Value': 'LIN_INIT'], 'Input_Param_008': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'LIN_WAKEUP/ LIN_SET_SLEEP_REQUEST/ LIN_CLR_SLEEP_REQUEST', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_SET_SLEEP_REQUEST'], 'Input_Param_011': ['Type': 'Variable', 'Range': '5', 'Name': 'ucWakeupSourceId', 'Value': '5'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'LIN_MASTER_NODE/LIN_SLAVE_NODE', 'Name': 'enNodeType', 'Value': '-'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Output_Param_017': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION\\n'], 'Output_Param_018': ['Type': 'Variable', 'Range': 'LIN_WAKEUP/ LIN_SET_SLEEP_REQUEST/ LIN_CLR_SLEEP_REQUEST', 'Name': 'ucSlpRqst_RespRdy', 'Value': '-'], 'Output_Param_019': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION\\n'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'sources', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'wakeupSource', 'Value': '-'], 'Output_Param_022': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenModeType', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApiId', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenInterruptScheduleType', 'Value': '-'], 'Output_Param_029': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': '-'], 'Output_Param_030': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_OK'], 'Output_Param_031': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_CODE_FAST #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, LIN_CODE_FAST) Lin_ErrIsr(const uint8 LucChannel) /* PRQA S 1532 # JV-01 */ { #if (LIN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) /* Check if the EIMK bit of the EIC register is set */ if (LIN_EIC_EIMK_MASK == (uint16)((*(Lin_GpRLIN3Properties[LucChannel].pLin3IntStEicReg)) & (uint16)LIN_EIC_EIMK_MASK)) { #ifdef LIN_E_INT_INCONSISTENT /* Reporting to DEM that interrupt from unknown source */ LIN_DEM_REPORT_ERROR(LIN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); #endif /* #ifdef LIN_E_INT_INCONSISTENT */ } else #endif /* (LIN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) */ { #if (LIN_SLAVE_MODE_SUPPORT == STD_ON) if (LIN_SLAVE_NODE == Lin_GpChannelConfig[LucChannel].enNodeType) { /* Calling error processing API for error check */ Lin_HwSlaveErrorProcessing(LucChannel); } else #endif /* (LIN_SLAVE_MODE_SUPPORT == STD_ON) */ { #if (LIN_MASTER_MODE_SUPPORT == STD_ON) /* Calling error processing API for error check */ Lin_HwErrorProcessing(LucChannel); #endif /* #if (LIN_MASTER_MODE_SUPPORT == STD_ON) */ } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON / STD_OFF', 'Name': 'LIN_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannel', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '&map_Lin_GaaRLIN3Properties[0]', 'Name': 'Lin_GpRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pLin3IntStEicReg', 'Value': '&map_pLin3IntStEicReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0x0000..0xFFFF', 'Name': 'map_pLin3IntStEicReg[0]', 'Value': '0x0080'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'LIN_MASTER_NODE/LIN_SLAVE_NODE', 'Name': 'enNodeType', 'Value': 'LIN_MASTER_NODE']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'LIN_E_INT_INCONSISTENT'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ /* SWS_Lin_00289 */ #if (LIN_MASTER_MODE_SUPPORT == STD_ON) #define LIN_START_SEC_PUBLIC_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Lin_StatusType, LIN_PUBLIC_CODE) Lin_GetStatus(uint8 Channel, P2VAR(P2VAR(uint8, AUTOMATIC, LIN_APPL_DATA), AUTOMATIC, LIN_APPL_DATA) Lin_SduPtr) /* PRQA S 1503, 3432 # JV-01, JV-01 */ { volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_APPL_DATA) LpRamVars; /* PRQA S 3432 # JV-01 */ #if (LIN_DEV_ERROR_DETECT == STD_ON) boolean LblDetErrFlag; #endif boolean LblSleepPending; Lin_StatusType LenReturnValue; #if (LIN_DEV_ERROR_DETECT == STD_ON ) P2VAR(P2VAR(uint8, AUTOMATIC, LIN_APPL_DATA), AUTOMATIC, LIN_APPL_DATA) LpLinSduPtr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #elif ((LIN_DEV_ERROR_DETECT == STD_OFF ) && ((LIN_AR_VERSION == LIN_AR_431_VERSION) || \\ (LIN_AR_VERSION == LIN_AR_1911_VERSION))) P2VAR(P2VAR(uint8, AUTOMATIC, LIN_APPL_DATA), AUTOMATIC, LIN_APPL_DATA) LpLinSduPtr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ #endif #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Initialize error status flag to LIN_FALSE */ LblDetErrFlag = LIN_FALSE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ #if (LIN_AR_VERSION == LIN_AR_422_VERSION) /* Initialize the return value */ LenReturnValue = LIN_NOT_OK; /* PRQA S 2982 # JV-01 */ #elif ((LIN_AR_VERSION == LIN_AR_431_VERSION) || (LIN_AR_VERSION == LIN_AR_1911_VERSION)) /* Initialize the return value */ LenReturnValue = LIN_CH_SLEEP; /* PRQA S 2982 # JV-01 */ #endif /* #if (LIN_AR_VERSION == LIN_AR_422_VERSION) */ #if (LIN_AR_VERSION == LIN_AR_422_VERSION) #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not initialized */ if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GET_STATUS_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GET_STATUS_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } /* else No action required */ /* Get the pointer to data buffer */ LpLinSduPtr = Lin_SduPtr; /* Report to DET if Lin_SduPtr pointer is a NULL pointer */ if (NULL_PTR == LpLinSduPtr) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GET_STATUS_SID, LIN_E_PARAM_POINTER); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } /* else No action required */ } #endif /* if (LIN_DEV_ERROR_DETECT == STD_ON) */ #elif ((LIN_AR_VERSION == LIN_AR_431_VERSION) || \\ (LIN_AR_VERSION == LIN_AR_1911_VERSION)) if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not initialized */ /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GET_STATUS_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ LenReturnValue = LIN_NOT_OK; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GET_STATUS_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ LenReturnValue = LIN_NOT_OK; } else { #if (LIN_SLAVE_MODE_SUPPORT == STD_ON) /* [AR19-11] Support Slave mode: SWS_Lin_00264 Lin_GetStatus is only applicable for LIN master nodes */ if (LIN_SLAVE_NODE == Lin_GpChannelConfig[Channel].enNodeType) { #if (LIN_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GET_STATUS_SID, LIN_E_INVALID_NODE_TYPE); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ LenReturnValue = LIN_NOT_OK; }/* else No action required */ #endif /* (LIN_SLAVE_MODE_SUPPORT == STD_ON) */ } /* Get the pointer to data buffer */ LpLinSduPtr = Lin_SduPtr; /* Report to DET if Lin_SduPtr pointer is a NULL pointer */ if (NULL_PTR == LpLinSduPtr) { #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GET_STATUS_SID, LIN_E_PARAM_POINTER); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ LenReturnValue = LIN_NOT_OK; } /* else No action required */ } #endif /* #if (LIN_AR_VERSION == LIN_AR_422_VERSION) */ #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Check whether any development error occurred */ if (LIN_FALSE == LblDetErrFlag) #elif (LIN_DEV_ERROR_DETECT == STD_OFF) #if ((LIN_AR_VERSION == LIN_AR_431_VERSION) || \\ (LIN_AR_VERSION == LIN_AR_1911_VERSION)) if (LIN_NOT_OK != LenReturnValue) #endif /* #if ((LIN_AR_VERSION == LIN_AR_431_VERSION) || \\ (LIN_AR_VERSION == LIN_AR_1911_VERSION)) */ #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ { /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[Channel]; /* PRQA S 0404 # JV-01 */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Update the return value of the requested channel */ LenReturnValue = LpRamVars->enChannelStatus; /* PRQA S 2844, 2814 # JV-01, JV-03 */ /* Get current sleep pending status */ LblSleepPending = LpRamVars->blSleepPending; /* When Lin_GetStatus is called, the LIN driver shall directly enter the LIN_CH_SLEEP state */ if (LIN_TRUE == LblSleepPending) { /* Change Channel status to Sleep */ LpRamVars->enChannelStatus = LIN_CH_SLEEP; /* Clear sleep pending status */ LpRamVars->blSleepPending = LIN_FALSE; LenReturnValue = LIN_CH_SLEEP; } /* else No action required */ /* Check if the reception is successful */ if (LIN_RX_OK == LenReturnValue) { *Lin_SduPtr = (uint8 *)&(LpRamVars->aaFrameData[(uint32)LIN_ZERO]); /* PRQA S 0312, 2814 # JV-01, JV-02 */ } /* else No action required */ /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); } /* No DET errors occurred */ #if (LIN_DEV_ERROR_DETECT == STD_OFF) #if ((LIN_AR_VERSION == LIN_AR_431_VERSION) || \\ (LIN_AR_VERSION == LIN_AR_1911_VERSION)) else { /* No action required */ } #endif /* #if ((LIN_AR_VERSION == LIN_AR_431_VERSION) || \\ (LIN_AR_VERSION == LIN_AR_1911_VERSION)) */ #else /* LIN_DEV_ERROR_DETECT == STD_ON */ else { /* No action is required */ } #endif /* #if (LIN_DEV_ERROR_DETECT == STD_OFF) */ return(LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'LIN_AR_1911_VERSION/\\nLIN_AR_422_VERSION/\\nLIN_AR_431_VERSION', 'Name': 'LIN_AR_VERSION', 'Value': 'LIN_AR_431_VERSION'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_MASTER_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_SLAVE_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Channel', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'LIN_UNINIT/LIN_INIT', 'Name': 'Lin_GblDriverState', 'Value': 'LIN_INIT'], 'Input_Param_007': ['Type': 'Argument', 'Range': 'NULL_PTR\\n/Address', 'Name': 'Lin_SduPtr', 'Value': '&Lin_SduPtr'], 'Input_Param_008': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '  LIN_NOT_OK           \\n  LIN_TX_OK        \\n  LIN_TX_BUSY\\n  LIN_TX_HEADER_ERROR  \\n  LIN_TX_ERROR        \\n  LIN_RX_OK           \\n  LIN_RX_BUSY          \\n  LIN_RX_ERROR         \\n  LIN_RX_NO_RESPONSE   \\n  LIN_OPERATIONAL     \\n  LIN_CH_SLEEP    ', 'Name': 'enChannelStatus', 'Value': 'LIN_RX_ERROR'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'LIN_TRUE\\nLIN_FALSE', 'Name': 'blSleepPending', 'Value': 'LIN_FALSE'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'LIN_MASTER_NODE/LIN_SLAVE_NODE', 'Name': 'enNodeType', 'Value': 'LIN_MASTER_NODE'], 'Input_Param_013': ['Type': 'Array', 'Range': '0x00..0xFF', 'Name': 'aaFrameData[0 to 7]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_020': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_021': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_022': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_023': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_024': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_025': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_026': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_027': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_028': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': '-'], 'Output_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelStatus', 'Value': 'LIN_RX_ERROR'], 'Output_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'blSleepPending', 'Value': 'LIN_FALSE'], 'Output_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'Lin_SduPtr', 'Value': '-'], 'Output_Param_032': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': '-'], 'Output_Param_033': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': ' LIN_RX_ERROR'], 'Output_Param_034': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_PUBLIC_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, LIN_PUBLIC_CODE) Lin_GoToSleepInternal(uint8 Channel) /* PRQA S 1503 # JV-01 */ { #if (LIN_WAKEUP_SUPPORT == STD_ON) volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_PRIVATE_CONST) LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ #endif volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_APPL_DATA) LpRamVars; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; #if (LIN_DEV_ERROR_DETECT == STD_ON) boolean LblDetErrFlag; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_NOT_OK; /* PRQA S 2982 # JV-01 */ #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Initialize error status flag to LIN_FALSE */ LblDetErrFlag = LIN_FALSE; /* Report to DET, if module is not initialized */ if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GO_TO_SLEEP_INTERNAL_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GO_TO_SLEEP_INTERNAL_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } /* else No action required */ } /* Check whether any development error occurred */ if (LIN_FALSE == LblDetErrFlag) #endif /* LIN_DEV_ERROR_DETECT */ { /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[Channel]; /* PRQA S 0404 # JV-01 */ /* Check if current status is already in LIN_CH_SLEEP */ if ((LIN_CH_SLEEP == LpRamVars->enChannelStatus) && /* PRQA S 2814, 2844 # JV-03, JV-01 */ ( LIN_FALSE == LpRamVars->blSleepPending)) { /* Update the return value */ LucReturnValue = E_OK; } else { /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Change Channel status to Sleep */ LpRamVars->enChannelStatus = LIN_CH_SLEEP; /* Clear sleep pending status */ LpRamVars->blSleepPending = LIN_FALSE; /* Clear the sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_CLR_SLEEP_REQUEST; /* Reset the LinIf wake-up flag */ LpRamVars->blWakeupCalled = LIN_FALSE; /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Check if global wake-up support is enabled */ #if (LIN_WAKEUP_SUPPORT == STD_ON) /* Get the address of LIN Channel structure */ LpLinChannelPtr = &Lin_GpChannelConfig[Channel]; /* PRQA S 0404 # JV-01 */ /* Check if channel specific wake-up support is enabled */ if (LIN_TRUE == LpLinChannelPtr->blWakeupSupport) /* PRQA S 2844, 2814 # JV-01, JV-03 */ { /* Set RLIN3 to Slave Wake-up */ LucReturnValue = Lin_HwHandleWakeupRequest(Channel, LIN_SLAVE_ISSUE, LIN_GO_TO_SLEEP_INTERNAL_SID); } else { LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(Channel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Update the return value */ LucReturnValue = E_OK; } #else /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(Channel, LIN_INTERRUPT_DIS); /* Update the return value */ /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); LucReturnValue = E_OK; #endif } } /* No development errors occurred */ /* else No action required */ return(LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Channel', 'Value': '8'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'LIN_UNINIT/LIN_INIT', 'Name': 'Lin_GblDriverState', 'Value': 'LIN_INIT'], 'Input_Param_005': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '  LIN_NOT_OK           \\n  LIN_TX_OK        \\n  LIN_TX_BUSY          LIN_TX_HEADER_ERROR  \\n  LIN_TX_ERROR        \\n  LIN_RX_OK           \\n  LIN_RX_BUSY          \\n  LIN_RX_ERROR         \\n LIN_RX_NO_RESPONSE   \\n  LIN_OPERATIONAL     \\n  LIN_CH_SLEEP    ', 'Name': 'enChannelStatus', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'LIN_TRUE\\nLIN_FALSE', 'Name': 'blWakeupSupport', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'LIN_TRUE\\nLIN_FALSE', 'Name': 'blSleepPending', 'Value': '-'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'LIN_MODULE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'LIN_INSTANCE_ID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'LIN_GO_TO_SLEEP_INTERNAL_SID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'LIN_E_INVALID_CHANNEL'], 'Output_Param_008': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': '-'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelStatus', 'Value': '-'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSlpRqst_RespRdy', 'Value': '-'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupCalled', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'blSleepPending', 'Value': '-'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenWakeupType', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApiId', 'Value': '-'], 'Output_Param_017': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenInterruptScheduleType', 'Value': '-'], 'Output_Param_020': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': '-'], 'Output_Param_021': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_022': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_PUBLIC_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, LIN_PUBLIC_CODE) Lin_GoToSleepInternal(uint8 Channel) /* PRQA S 1503 # JV-01 */ { #if (LIN_WAKEUP_SUPPORT == STD_ON) volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_PRIVATE_CONST) LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ #endif volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_APPL_DATA) LpRamVars; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; #if (LIN_DEV_ERROR_DETECT == STD_ON) boolean LblDetErrFlag; #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ /* Initialize the return value */ LucReturnValue = E_NOT_OK; /* PRQA S 2982 # JV-01 */ #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Initialize error status flag to LIN_FALSE */ LblDetErrFlag = LIN_FALSE; /* Report to DET, if module is not initialized */ if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GO_TO_SLEEP_INTERNAL_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_GO_TO_SLEEP_INTERNAL_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } /* else No action required */ } /* Check whether any development error occurred */ if (LIN_FALSE == LblDetErrFlag) #endif /* LIN_DEV_ERROR_DETECT */ { /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[Channel]; /* PRQA S 0404 # JV-01 */ /* Check if current status is already in LIN_CH_SLEEP */ if ((LIN_CH_SLEEP == LpRamVars->enChannelStatus) && /* PRQA S 2814, 2844 # JV-03, JV-01 */ ( LIN_FALSE == LpRamVars->blSleepPending)) { /* Update the return value */ LucReturnValue = E_OK; } else { /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Change Channel status to Sleep */ LpRamVars->enChannelStatus = LIN_CH_SLEEP; /* Clear sleep pending status */ LpRamVars->blSleepPending = LIN_FALSE; /* Clear the sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_CLR_SLEEP_REQUEST; /* Reset the LinIf wake-up flag */ LpRamVars->blWakeupCalled = LIN_FALSE; /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Check if global wake-up support is enabled */ #if (LIN_WAKEUP_SUPPORT == STD_ON) /* Get the address of LIN Channel structure */ LpLinChannelPtr = &Lin_GpChannelConfig[Channel]; /* PRQA S 0404 # JV-01 */ /* Check if channel specific wake-up support is enabled */ if (LIN_TRUE == LpLinChannelPtr->blWakeupSupport) /* PRQA S 2844, 2814 # JV-01, JV-03 */ { /* Set RLIN3 to Slave Wake-up */ LucReturnValue = Lin_HwHandleWakeupRequest(Channel, LIN_SLAVE_ISSUE, LIN_GO_TO_SLEEP_INTERNAL_SID); } else { LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(Channel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Update the return value */ LucReturnValue = E_OK; } #else /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(Channel, LIN_INTERRUPT_DIS); /* Update the return value */ /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); LucReturnValue = E_OK; #endif } } /* No development errors occurred */ /* else No action required */ return(LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Channel', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'LIN_UNINIT/LIN_INIT', 'Name': 'Lin_GblDriverState', 'Value': 'LIN_INIT'], 'Input_Param_005': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '  LIN_NOT_OK           \\n  LIN_TX_OK        \\n  LIN_TX_BUSY          LIN_TX_HEADER_ERROR  \\n  LIN_TX_ERROR        \\n  LIN_RX_OK           \\n  LIN_RX_BUSY          \\n  LIN_RX_ERROR         \\n LIN_RX_NO_RESPONSE   \\n  LIN_OPERATIONAL     \\n  LIN_CH_SLEEP    ', 'Name': 'enChannelStatus', 'Value': 'LIN_CH_SLEEP'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'LIN_TRUE\\nLIN_FALSE', 'Name': 'blWakeupSupport', 'Value': 'LIN_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'LIN_TRUE\\nLIN_FALSE', 'Name': 'blSleepPending', 'Value': 'LIN_TRUE'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION\\n'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelStatus', 'Value': 'LIN_CH_SLEEP'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_CLR_SLEEP_REQUEST'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupCalled', 'Value': 'LIN_FALSE'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'blSleepPending', 'Value': 'LIN_FALSE'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION\\n'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenWakeupType', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApiId', 'Value': '-'], 'Output_Param_017': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '0'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenInterruptScheduleType', 'Value': 'LIN_INTERRUPT_DIS'], 'Output_Param_020': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_021': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_OK'], 'Output_Param_022': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (LIN_MASTER_MODE_SUPPORT == STD_ON) #define LIN_START_SEC_CODE_FAST #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, LIN_CODE_FAST) Lin_HwErrorProcessing(const uint8 LucChannel) { volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_CONST)LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2CONST(Lin3_ChannelConfigType, AUTOMATIC, LIN_CONST) LpLin3ChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2VAR(RLin3_UartRegs, AUTOMATIC, REGSPACE) LpLN3ChannelRegs; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_VAR_FAST_NO_INIT) LpRamVars; /* PRQA S 3432 # JV-01 */ Lin_FrameResponseType LenFrameType; /* Get the pointer to requested channel configuration */ LpLinChannelPtr = &Lin_GpChannelConfig[LucChannel]; /* PRQA S 0404 # JV-01 */ /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[LucChannel]; /* PRQA S 0404 # JV-01 */ /* Get the channel index */ LpLin3ChannelPtr = &Lin_GpRLIN3Properties[LpLinChannelPtr->ucPropertiesIndex]; /* PRQA S 0404, 2844, 2814 # JV-01, JV-01, JV-02 */ /* Get the RLIN3 Channel Base Address */ LpLN3ChannelRegs = LpLin3ChannelPtr->pLn3ChanlBaseAddress; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Get frame type */ LenFrameType = LpRamVars->enFrameType; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Check for any error occurred */ if (LIN_ERROR_OCCURED == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_ERROR_OCCURED)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Check if the transmitted frame is for go-to-sleep command */ if (LIN_SET_SLEEP_REQUEST == LpRamVars->ucSlpRqst_RespRdy) { /* LIN_CH_SLEEP: */ /* Lin_GetStatus() has already been called after calling Lin_GoToSleep */ /* or */ /* LIN_CH_SLEEP_PENDING: */ /* Lin_GetStatus() has not been called yet after calling Lin_GoToSleep */ /* The status of channel must not be changed while issuing the */ /* go-to-sleep command even if some errors have occured. */ if ((LIN_CH_SLEEP == LpRamVars->enChannelStatus) || (LIN_TRUE == LpRamVars->blSleepPending)) { /* Clear the sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_CLR_SLEEP_REQUEST; if (LIN_HEADER_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_COMPLETE)) { /* Clear the header interrupt */ LpLN3ChannelRegs->ucRLN3nLST = (LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_DONE); } /* else No action required */ /* Clear all error flags and the ERR bit of the RLN3nLST register is automatically cleared */ LpLN3ChannelRegs->ucRLN3nLEST = LIN_RESET_VALUE; #if (LIN_WAKEUP_SUPPORT == STD_ON) /* Check if channel specific wake-up support is enabled */ if (LIN_TRUE == LpLinChannelPtr->blWakeupSupport) { /* Set RLIN3 to Slave Wake-up */ (void)Lin_HwHandleWakeupRequest(LucChannel, LIN_SLAVE_ISSUE, LIN_GO_TO_SLEEP_SID); } else #endif /* #if (LIN_WAKEUP_SUPPORT == STD_ON) */ { /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(LucChannel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); } } /* else No action required */ } /* Check if an error was occurred in Lin_Wakeup() */ else if (LIN_TRUE == LpRamVars->blWakeupCalled) { /* Reset the LinIf wake-up flag */ LpRamVars->blWakeupCalled = LIN_FALSE; /* Check for Bit error */ if (LIN_BIT_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_BIT_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; /* Clear BER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_BIT_CLEAR); } /* else No action required */ /* Check for Header Transmission error */ if (LIN_PBUS_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_PBUS_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; /* Clear PBER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_PBUS_CLEAR); } /* else No action required */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(LucChannel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); } /* Other than go-to-sleep command and Lin_Wakeup(), Lin_SendFrame() with LIN_FRAMERESPONSE_IGNORE (for AR19-11) instead of LIN_SLAVE_TO_SLAVE */ #if (LIN_AR_VERSION == LIN_AR_1911_VERSION) else if (LIN_FRAMERESPONSE_IGNORE == LenFrameType) { /* An error was occurred in response part */ if (LIN_HEADER_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_COMPLETE)) { /* Clear the header interrupt */ LpLN3ChannelRegs->ucRLN3nLST = (LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_DONE); /* Set the channel status to LIN_TX_OK */ LpRamVars->enChannelStatus = LIN_TX_OK; /* Clear all error flags and the ERR bit of the RLN3nLST register is automatically cleared */ LpLN3ChannelRegs->ucRLN3nLEST = LIN_RESET_VALUE; } /* an error was occurred in header part */ else { /* Check for Bit error */ if (LIN_BIT_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_BIT_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; /* Clear BER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_BIT_CLEAR); } /* else No action required */ /* Check for Header Transmission error */ if (LIN_PBUS_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_PBUS_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; /* Clear PBER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_PBUS_CLEAR); } /* else No action required */ /* Check for any Time out error */ if (LIN_TIMEOUT_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_TIMEOUT_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; #ifdef LIN_E_TIMEOUT_FAILURE /* Report Error to DEM */ LIN_DEM_REPORT_ERROR(LIN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif /* #ifdef LIN_E_TIMEOUT_FAILURE */ /* Clear FTER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_TIMEOUT_CLEAR); } else { /* No action required */ } } /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(LucChannel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); } #else /* Other than go-to-sleep command and Lin_Wakeup(), Lin_SendFrame() with LIN_SLAVE_TO_SLAVE (for AR4.3.1 and AR4,2,2) */ else if (LIN_SLAVE_TO_SLAVE == LenFrameType) { /* an error was occurred in response part */ if (LIN_HEADER_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_COMPLETE)) { /* Clear the header interrupt */ LpLN3ChannelRegs->ucRLN3nLST = (LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_DONE); /* Set the channel status to LIN_TX_OK */ LpRamVars->enChannelStatus = LIN_TX_OK; /* Clear all error flags and the ERR bit of the RLN3nLST register is automatically cleared */ LpLN3ChannelRegs->ucRLN3nLEST = LIN_RESET_VALUE; } /* an error was occurred in header part */ else { /* Check for Bit error */ if (LIN_BIT_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_BIT_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; /* Clear BER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_BIT_CLEAR); } else { /* No action required */ } /* Check for Header Transmission error */ if (LIN_PBUS_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_PBUS_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; /* Clear PBER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_PBUS_CLEAR); } else { /* No action is required */ } /* Check for any Time out error */ if (LIN_TIMEOUT_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_TIMEOUT_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; #ifdef LIN_E_TIMEOUT_FAILURE /* Report Error to DEM */ LIN_DEM_REPORT_ERROR(LIN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif /* #ifdef LIN_E_TIMEOUT_FAILURE */ /* Clear FTER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_TIMEOUT_CLEAR); } else { /* No action required */ } } /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(LucChannel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); } /* Lin_SendFrame() with LIN_FRAMERESPONSE_TX and LIN_FRAMERESPONSE_RX (for AR19-11) or LIN_MASTER_RESPONSE and LIN_SLAVE_RESPONSE (for AR4.3.1 and AR4.2.2) */ #endif /* #if (LIN_AR_VERSION == LIN_AR_1911_VERSION) */ else { /* Check for any checksum field error */ if (LIN_CHECKSUM_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_CHECKSUM_ERROR)) { /* Update channel status to LIN_RX_ERROR */ LpRamVars->enChannelStatus = LIN_RX_ERROR; /* Clear CKE bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_CHECKSUM_CLEAR); } /* else No action required */ /* Check for any Time out error */ if (LIN_TIMEOUT_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_TIMEOUT_ERROR)) { /* Check if header frame transmit successfully */ if (LIN_HEADER_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_COMPLETE)) { #if (LIN_AR_VERSION == LIN_AR_1911_VERSION) /* AR19-11 use LIN_FRAMERESPONSE_TX instead of LIN_MASTER_RESPONSE */ if (LIN_FRAMERESPONSE_TX == LenFrameType) { /* an error was occurred in response transmission part */ /* Update channel status to LIN_TX_ERROR */ LpRamVars->enChannelStatus = LIN_TX_ERROR; } /* frame type is of LIN_FRAMERESPONSE_RX (for AR19-11) */ else { /* an error was occurred in response reception part */ /* Check if at least 1 response byte has been received */ if (LIN_DATA1RX_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_DATA1RX_COMPLETE)) { /* Update channel status to LIN_RX_ERROR */ LpRamVars->enChannelStatus = LIN_RX_ERROR; } /* if no response byte has been received */ else { /* Update channel status to LIN_RX_NO_RESPONSE */ LpRamVars->enChannelStatus = LIN_RX_NO_RESPONSE; } } #else if (LIN_MASTER_RESPONSE == LenFrameType) { /* An error was occurred in response transmission part */ /* Update channel status to LIN_TX_ERROR */ LpRamVars->enChannelStatus = LIN_TX_ERROR; } /* frame type is of LIN_SLAVE_RESPONSE (for AR4.3.1 and AR4.2.2) */ else { /* An error was occurred in response reception part */ /* Check if at least 1 response byte has been received */ if (LIN_DATA1RX_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_DATA1RX_COMPLETE)) { /* Update channel status to LIN_RX_ERROR */ LpRamVars->enChannelStatus = LIN_RX_ERROR; } /* If no response byte has been received */ else { /* Update channel status to LIN_RX_NO_RESPONSE */ LpRamVars->enChannelStatus = LIN_RX_NO_RESPONSE; } } #endif /* #if (LIN_AR_VERSION == LIN_AR_1911_VERSION) */ } /* An error was occurred in header part */ else { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; } #ifdef LIN_E_TIMEOUT_FAILURE /* Report Error to DEM */ LIN_DEM_REPORT_ERROR(LIN_E_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif /* #ifdef LIN_E_TIMEOUT_FAILURE */ /* Clear FTER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_TIMEOUT_CLEAR); } /* else No action required */ /* Check for Bit error */ if (LIN_BIT_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_BIT_ERROR)) { /* Check if header frame transmit successfully */ if (LIN_HEADER_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_COMPLETE)) { /* Update channel status to LIN_TX_ERROR */ LpRamVars->enChannelStatus = LIN_TX_ERROR; } /* Check if header frame transmit not successful */ else { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; } /* Clear BER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_BIT_CLEAR); } /* else No action required */ /* Check for Header Transmission error */ if (LIN_PBUS_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_PBUS_ERROR)) { /* Update channel status to LIN_TX_HEADER_ERROR */ LpRamVars->enChannelStatus = LIN_TX_HEADER_ERROR; /* Clear PBER bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_PBUS_CLEAR); } /* else No action required */ /* Check for any framing error */ if (LIN_FRAMING_ERROR == (uint8)(LpLN3ChannelRegs->ucRLN3nLEST & LIN_FRAMING_ERROR)) { /* Update channel status to LIN_RX_ERROR */ LpRamVars->enChannelStatus = LIN_RX_ERROR; /* Clear CKE bit */ LpLN3ChannelRegs->ucRLN3nLEST = (LpLN3ChannelRegs->ucRLN3nLEST & LIN_FRAMING_CLEAR); } /* else No action required */ if (LIN_HEADER_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_COMPLETE)) { /* Clear the header interrupt */ LpLN3ChannelRegs->ucRLN3nLST = (LpLN3ChannelRegs->ucRLN3nLST & LIN_HEADER_DONE); } /* else No action required */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Disable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(LucChannel, LIN_INTERRUPT_DIS); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); } } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannel', 'Value': '0x00'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_MASTER_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Lin_GpRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucPropertiesIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pLn3ChanlBaseAddress', 'Value': '&map_pLn3ChanlBaseAddress[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0x00..0xFF', 'Name': 'ucRLN3nLST', 'Value': '0x08'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'LIN_SET_SLEEP_REQUEST/LIN_CLR_SLEEP_REQUEST', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_CLR_SLEEP_REQUEST'], 'Input_Param_009': ['Type': 'Variable', 'Range': '  LIN_NOT_OK           \\n  LIN_TX_OK        \\n  LIN_TX_BUSY          LIN_TX_HEADER_ERROR  \\n  LIN_TX_ERROR        \\n  LIN_RX_OK           \\n  LIN_RX_BUSY          \\n  LIN_RX_ERROR         \\n  LIN_RX_NO_RESPONSE   \\n  LIN_OPERATIONAL     \\n  LIN_CH_SLEEP    ', 'Name': 'enChannelStatus', 'Value': 'LIN_OPERATIONAL'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'LIN_TRUE/LIN_FALSE', 'Name': 'blSleepPending', 'Value': ' LIN_FALSE'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'LIN_TRUE/LIN_FALSE', 'Name': 'blWakeupCalled', 'Value': 'LIN_FALSE'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0x00..0xFF', 'Name': 'ucRLN3nLEST', 'Value': '0x08'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'LIN_MASTER_RESPONSE \\n  LIN_SLAVE_RESPONSE \\n  LIN_SLAVE_TO_SLAVE ', 'Name': 'enFrameType', 'Value': 'LIN_SLAVE_RESPONSE'], 'Input_Param_014': ['Type': 'Macro', 'Range': '', 'Name': 'LIN_E_TIMEOUT_FAILURE', 'Value': '<defined>'], 'Input_Param_015': ['Type': 'Macro', 'Range': 'STD_ON / STD_OFF', 'Name': 'LIN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_016': ['Type': 'Variable', 'Range': 'LIN_TRUE/LIN_FALSE', 'Name': 'blWakeupSupport', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucSlpRqst_RespRdy', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ucRLN3nLST', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ucRLN3nLEST', 'Value': '0x00'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupCalled', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelStatus', 'Value': 'LIN_RX_ERROR'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenWakeupType', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApiId', 'Value': '-'], 'Output_Param_012': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '0x00'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenInterruptScheduleType', 'Value': 'LIN_INTERRUPT_DIS'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_016': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_PRIVATE_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, LIN_PRIVATE_CODE) Lin_HwLoadTxBuffer(const uint8 LucChannel) { volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_PRIVATE_CONST) LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2CONST(Lin3_ChannelConfigType, AUTOMATIC, LIN_PRIVATE_CONST) LpLin3ChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2VAR(RLin3_UartRegs, AUTOMATIC, REGSPACE) LpLN3ChannelRegs; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_VAR_FAST_NO_INIT) LpRamVars; /* PRQA S 3432, 3678 # JV-01, JV-01 */ volatile P2VAR(uint8, AUTOMATIC, LIN_VAR_FAST_NO_INIT) volatile LpStartDataBuffer; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint8 LucIncrement; uint8 LucDataLength; /* Get the pointer to frame data */ LpRamVars = &Lin_GpChannelRamData[LucChannel]; /* PRQA S 0404 # JV-01 */ /* Copy the data length to local variable */ LucDataLength = LpRamVars->ucFrameLength; /* PRQA S 2814, 2844 # JV-02, JV-01 */ LpStartDataBuffer = &LpRamVars->aaFrameData[(uint32)LIN_ZERO]; /* Get the address of LIN Channel structure */ LpLinChannelPtr = &Lin_GpChannelConfig[LucChannel]; /* PRQA S 0404 # JV-01 */ LpLin3ChannelPtr = &Lin_GpRLIN3Properties[LpLinChannelPtr->ucPropertiesIndex]; /* PRQA S 0404, 2814, 2844 # JV-01, JV-02, JV-01 */ /* Get the RLIN3 Channel Base Address */ LpLN3ChannelRegs = LpLin3ChannelPtr->pLn3ChanlBaseAddress; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Copy data to Tx Buffer */ for (LucIncrement = LIN_ZERO; LucDataLength > LucIncrement; LucIncrement++) { LpLN3ChannelRegs->ucRLN3nLDBR[LucIncrement] = *LpStartDataBuffer; /* PRQA S 0404, 2814, 2844 # JV-01, JV-01, JV-01 */ LpStartDataBuffer++; /* PRQA S 3387 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_001': ['Type': 'Variable', 'Range': '&map_Lin_GaaRLIN3Properties[0]', 'Name': 'Lin_GpRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucPropertiesIndex', 'Value': '15'], 'Input_Param_004': ['Type': 'Variable', 'Range': '&map_pLn3ChanlBaseAddress[0]', 'Name': 'pLn3ChanlBaseAddress', 'Value': '&map_pLn3ChanlBaseAddress[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '0x00..0xFF', 'Name': 'aaFrameData[0 to 7]', 'Value': '[0] = 0x55\\n[1] = 0x00\\n[2] = 0xFF\\n[3] = 0x55\\n[4] = 0x00\\n[5] = 0xFF\\n[6] = 0x55\\n[7] = 0x00'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0x00..0xFF', 'Name': 'ucFrameLength', 'Value': '0x08'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannel', 'Value': '15']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'ucRLN3nLDBR[0 to 7]', 'Value': '[0] = 0x55\\n[1] = 0x00\\n[2] = 0xFF\\n[3] = 0x55\\n[4] = 0x00\\n[5] = 0xFF\\n[6] = 0x55\\n[7] = 0x00'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (LIN_MASTER_MODE_SUPPORT ==STD_ON) #define LIN_START_SEC_PRIVATE_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, LIN_PRIVATE_CODE) Lin_HwSendHeaderInternal(const uint8 LucChannel, CONSTP2CONST(Lin_PduType, AUTOMATIC, LIN_PRIVATE_CONST) LpPduInfoPtr, /* PRQA S 1532 # JV-01 */ const uint8 LucApiId) { volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_PRIVATE_CONST) LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2CONST(Lin3_ChannelConfigType, AUTOMATIC, LIN_PRIVATE_CONST) LpLin3ChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2VAR(RLin3_UartRegs, AUTOMATIC, REGSPACE) LpLN3ChannelRegs; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_VAR_FAST_NO_INIT) LpRamVars; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; Lin_FrameResponseType LenFrameType; /* Initialize the return value */ LucReturnValue = E_NOT_OK; /* PRQA S 2982 # JV-01 */ /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[LucChannel]; /* PRQA S 0404 # JV-01 */ /* Copy the frame Id to frame data structure */ LpRamVars->ucFrameId = LpPduInfoPtr->Pid; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Copy the checksum model to frame data structure */ LpRamVars->enCheckSumModel = LpPduInfoPtr->Cs; /* Copy the data length to frame data structure */ LpRamVars->ucFrameLength = LpPduInfoPtr->Dl; /* Copy the frame type to frame data structure */ LpRamVars->enFrameType = LpPduInfoPtr->Drc; /* Get the address of LIN Channel structure */ LpLinChannelPtr = &Lin_GpChannelConfig[LucChannel]; /* PRQA S 0404 # JV-01 */ LpLin3ChannelPtr = &Lin_GpRLIN3Properties[LpLinChannelPtr->ucPropertiesIndex]; /* PRQA S 0404, 2844, 2814 # JV-01, JV-01, JV-02 */ /* Get the RLIN3 Channel Base Address */ LpLN3ChannelRegs = LpLin3ChannelPtr->pLn3ChanlBaseAddress; /* PRQA S 2844, 2814 # JV-01, JV-02 */ /* Get frame type */ LenFrameType = LpRamVars->enFrameType; if (LIN_TRUE == LpRamVars->blWakeupCalled) { /* Reset the LinIf wake-up flag */ LpRamVars->blWakeupCalled = LIN_FALSE; } /* else No action required */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Set RLIN3 to Reset Mode */ LucReturnValue = Lin_HwSetMasterMode(LucChannel, RLIN3_RESET_MODE, LucApiId); if (E_OK == LucReturnValue) { /* Set RLIN3 to Operation Mode */ LucReturnValue = Lin_HwSetMasterMode(LucChannel, RLIN3_OPERATION_MODE, LucApiId); } /* else No action required */ /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); if (E_OK == LucReturnValue) { /* Set the frame Id */ LpLN3ChannelRegs->ucRLN3nLIDB = LpRamVars->ucFrameId; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Reset of LIN data Field Configuration Register */ LpLN3ChannelRegs->ucRLN3nLDFC = LIN_RESET_VALUE; /* If checksum model is of type CLASSIC */ if (LIN_CLASSIC_CS == LpRamVars->enCheckSumModel) { /* Set the checksum model to CLASSIC */ LpLN3ChannelRegs->ucRLN3nLDFC = (LpLN3ChannelRegs->ucRLN3nLDFC & LIN_SET_CLS_CHKSUM); } /* If checksum model is of type ENHANCED */ else { /* Set the checksum model to ENHANCED */ LpLN3ChannelRegs->ucRLN3nLDFC = (LpLN3ChannelRegs->ucRLN3nLDFC | LIN_SET_ENH_CHKSUM); } /* Set length of total bytes in a RLIN3 Frame(Response data + Checksum) */ LpLN3ChannelRegs->ucRLN3nLDFC = (LpLN3ChannelRegs->ucRLN3nLDFC | LpPduInfoPtr->Dl); #if (LIN_AR_VERSION == LIN_AR_1911_VERSION) /* AR19-11 use LIN_FRAMERESPONSE_TX instead of LIN_MASTER_RESPONSE */ if (LIN_FRAMERESPONSE_TX == LenFrameType) { /* To Set the Transmit Data */ /*Call the internal function to load Tx Buffer and start the frame transmission */ Lin_HwLoadTxBuffer(LucChannel); /* Set Response direction for Transmit */ LpLN3ChannelRegs->ucRLN3nLDFC = (LpLN3ChannelRegs->ucRLN3nLDFC | LIN_TRANSMISSION_DIRECTION); } else { /* Set Response direction for Receive */ LpLN3ChannelRegs->ucRLN3nLDFC = (LpLN3ChannelRegs->ucRLN3nLDFC & LIN_RECEPTION_DIRECTION); } #else if (LIN_MASTER_RESPONSE == LenFrameType) { /* To Set the Transmit Data */ /*Call the internal function to load Tx Buffer and start the frame transmission */ Lin_HwLoadTxBuffer(LucChannel); /* Set Response direction for Transmit */ LpLN3ChannelRegs->ucRLN3nLDFC = (LpLN3ChannelRegs->ucRLN3nLDFC | LIN_TRANSMISSION_DIRECTION); } else { /* Set Response direction for Receive */ LpLN3ChannelRegs->ucRLN3nLDFC = (LpLN3ChannelRegs->ucRLN3nLDFC & LIN_RECEPTION_DIRECTION); } #endif /* #if (LIN_AR_VERSION == LIN_AR_1911_VERSION) */ /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Enable RLIN3 Interrupt */ Lin_HwScheduleInterrupt(LucChannel, LIN_INTERRUPT_EN); /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); #if (LIN_AR_VERSION == LIN_AR_1911_VERSION) switch (LenFrameType) { /* AR19-11 use LIN_FRAMERESPONSE_TX instead of LIN_MASTER_RESPONSE */ case LIN_FRAMERESPONSE_TX: /* Check if the transmitted frame is for go-to-sleep command */ if (LIN_SET_SLEEP_REQUEST == LpRamVars->ucSlpRqst_RespRdy) { /* No action required, keep LpRamVars->blSleepPending as LIN_TRUE */ } else { /* Set the Channel Status */ LpRamVars->enChannelStatus = LIN_TX_BUSY; } break; /* AR19-11 use LIN_FRAMERESPONSE_IGNORE instead of LIN_SLAVE_TO_SLAVE */ case LIN_FRAMERESPONSE_IGNORE: /* Set the Channel Status */ LpRamVars->enChannelStatus = LIN_TX_BUSY; break; /* AR19-11 use LIN_FRAMERESPONSE_RX instead of LIN_SLAVE_RESPONSE */ case LIN_FRAMERESPONSE_RX: /* Set the Channel Status */ LpRamVars->enChannelStatus = LIN_RX_BUSY; break; default: /* No action required */ break; } #else switch (LenFrameType) { case LIN_MASTER_RESPONSE: /* Check if the transmitted frame is for go-to-sleep command */ if (LIN_SET_SLEEP_REQUEST == LpRamVars->ucSlpRqst_RespRdy) { /* No action required, keep LpRamVars->blSleepPending as LIN_TRUE */ } else { /* Set the Channel Status */ LpRamVars->enChannelStatus = LIN_TX_BUSY; } break; case LIN_SLAVE_TO_SLAVE: /* Set the Channel Status */ LpRamVars->enChannelStatus = LIN_TX_BUSY; break; case LIN_SLAVE_RESPONSE: /* Set the Channel Status */ LpRamVars->enChannelStatus = LIN_RX_BUSY; break; default: /* No action required */ break; } #endif /* #if (LIN_AR_VERSION == LIN_AR_1911_VERSION) */ /* Initiate Transmission */ LpLN3ChannelRegs->ucRLN3nLTRC = (LpLN3ChannelRegs->ucRLN3nLTRC | LIN_START_TRANSMIT); } /* End of if (E_OK == LucReturnValue) */ /* else No action required */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'LIN_AR_1911_VERSION/LIN_AR_431_VERSION/LIN_AR_422_VERSION', 'Name': 'LIN_AR_VERSION', 'Value': 'LIN_AR_1911_VERSION'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_MASTER_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannel', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': '&map_GddPduInfo[0]', 'Name': 'LpPduInfoPtr', 'Value': '&map_GddPduInfo[0]'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0x00..0xFF', 'Name': 'LucApiId', 'Value': '0xFF'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0x00..0xFF', 'Name': 'Pid', 'Value': '0xFE'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'LIN_ENHANCED_CS/LIN_CLASSIC_CS', 'Name': 'Cs', 'Value': 'LIN_ENHANCED_CS'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0x00..0xFF', 'Name': 'Dl', 'Value': '0x08'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'LIN_MASTER_RESPONSE \\nLIN_SLAVE_RESPONSE \\nLIN_SLAVE_TO_SLAVE ', 'Name': 'Drc', 'Value': 'LIN_FRAMERESPONSE_IGNORE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '&map_Lin_GaaRLIN3Properties[0]', 'Name': 'Lin_GpRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'LIN_TRUE/LIN_FALSE', 'Name': 'blWakeupCalled', 'Value': 'LIN_FALSE'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'LIN_ENHANCED_CS/LIN_CLASSIC_CS', 'Name': 'enCheckSumModel', 'Value': 'LIN_ENHANCED_CS'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'LIN_SET_SLEEP_REQUEST/LIN_CLR_SLEEP_REQUEST', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_SET_SLEEP_REQUEST'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0x00..0xFF', 'Name': 'ucPropertiesIndex', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pLn3ChanlBaseAddress', 'Value': '&map_pLn3ChanlBaseAddress[0]'], 'Input_Param_017': ['Type': 'Register', 'Range': '0x00..0xFF', 'Name': 'ucRLN3nLIDB', 'Value': '0x00'], 'Input_Param_018': ['Type': 'Register', 'Range': '0x00..0xFF', 'Name': 'ucRLN3nLDFC', 'Value': '0x00'], 'Input_Param_019': ['Type': 'Register', 'Range': '0x00..0xFF', 'Name': 'ucRLN3nLTRC', 'Value': '0x00'], 'Input_Param_020': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucFrameId', 'Value': '0xFE'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enCheckSumModel', 'Value': 'LIN_ENHANCED_CS'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucFrameLength', 'Value': '0x08'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enFrameType', 'Value': 'LIN_FRAMERESPONSE_IGNORE'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupCalled', 'Value': 'LIN_FALSE'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelStatus', 'Value': 'LIN_TX_BUSY'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '[1] = 0x00\\n[2] = 0x00'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenModeType', 'Value': '[1] = RLIN3_RESET_MODE\\n[2] = RLIN3_OPERATION_MODE'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApiId', 'Value': '[1] = 0xFF\\n[2] = 0xFF'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ucRLN3nLIDB', 'Value': '0xFE'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'ucRLN3nLDFC', 'Value': '0x28'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'ucRLN3nLTRC', 'Value': '0x01'], 'Output_Param_013': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '0x00'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenInterruptScheduleType', 'Value': 'LIN_INTERRUPT_EN'], 'Output_Param_018': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'Std_ReturnType', 'Value': 'E_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (LIN_WAKEUP_SUPPORT == STD_ON) #define LIN_START_SEC_CODE_FAST #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, LIN_CODE_FAST) Lin_HwWakeUpFromBus(const uint8 LucChannel) { volatile P2CONST(Lin_ChannelInfo, AUTOMATIC, LIN_CONST)LpLinChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2CONST(Lin3_ChannelConfigType, AUTOMATIC, LIN_CONST) LpLin3ChannelPtr; /* PRQA S 3432 # JV-01 */ volatile P2VAR(RLin3_UartRegs, AUTOMATIC, REGSPACE) LpLN3ChannelRegs; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_VAR_FAST_NO_INIT) LpRamVars; /* PRQA S 3432 # JV-01 */ /* Get the address of LIN Channel structure */ LpLinChannelPtr = &Lin_GpChannelConfig[LucChannel]; /* PRQA S 0404 # JV-01 */ /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[LucChannel]; /* PRQA S 0404 # JV-01 */ /* Check if channel specific wake-up is enabled */ if (LIN_TRUE == LpLinChannelPtr->blWakeupSupport) /* PRQA S 2844, 2814 # JV-01, JV-02 */ { LpLin3ChannelPtr = &Lin_GpRLIN3Properties[LpLinChannelPtr->ucPropertiesIndex]; /* PRQA S 0404 # JV-01 */ /* Get the RLIN3 Channel Base Address */ LpLN3ChannelRegs = LpLin3ChannelPtr->pLn3ChanlBaseAddress; /* PRQA S 2844, 2814 # JV-01, JV-02 */ if (LIN_RECEPTION_COMPLETE == (uint8)(LpLN3ChannelRegs->ucRLN3nLST & LIN_RECEPTION_COMPLETE)) /* PRQA S 2844, 2814 # JV-01, JV-01 */ { /* Clear sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_WAKEUP; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Clear the reception interrupt */ LpLN3ChannelRegs->ucRLN3nLST = (LpLN3ChannelRegs->ucRLN3nLST & LIN_RECEPTION_DONE); } /* else No action required */ /* Invoke the upper layer wakeup notification */ EcuM_CheckWakeup((EcuM_WakeupSourceType)LIN_ONE << (LpLinChannelPtr->ucWakeupSourceId)); } /* Channel specific wakeup is enabled */ /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_001': ['Type': 'Variable', 'Range': '&map_Lin_GaaRLIN3Properties[0]', 'Name': 'Lin_GpRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucPropertiesIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pLn3ChanlBaseAddress', 'Value': '&map_pLn3ChanlBaseAddress[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'LIN_TRUE/LIN_FALSE', 'Name': 'blWakeupSupport', 'Value': 'LIN_TRUE'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0x00..0xFF', 'Name': 'ucRLN3nLST', 'Value': '0xFD'], 'Input_Param_007': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannel', 'Value': '0'], 'Input_Param_008': ['Type': 'Macro', 'Range': 'STD_ON / STD_OFF', 'Name': 'LIN_WAKEUP_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0x00..0xFF', 'Name': 'ucWakeupSourceId', 'Value': '5']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucSlpRqst_RespRdy', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ucRLN3nLST', 'Value': '0xFD'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'wakeupSource', 'Value': '0x20'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_PUBLIC_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, LIN_PUBLIC_CODE) Lin_Init(P2CONST(Lin_ConfigType, AUTOMATIC, LIN_APPL_CONST) Config) /* PRQA S 1503, 3432 # JV-01, JV-01 */ { volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_APPL_DATA) LpRamVars; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; uint8 LucNoOfLinChannels; #if (LIN_DEV_ERROR_DETECT == STD_ON) boolean LblDetErrFlag; /* Initialize error status flag to LIN_FALSE */ LblDetErrFlag = LIN_FALSE; #if (LIN_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if Lin is not in UNINIT state */ if (LIN_UNINIT != Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_INIT_SID, LIN_E_STATE_TRANSITION); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } /* else No action required */ #endif /* #if (LIN_ALREADY_INIT_DET_CHECK == STD_ON) */ /* Check if Lin configuration pointer is a NULL Pointer */ if (NULL_PTR == Config) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_INIT_SID, LIN_E_INVALID_POINTER); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } else if ((uint32)LIN_DBTOC_VALUE != (Config->ulStartOfDbToc)) /* PRQA S 2004 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_INIT_SID, LIN_E_INVALID_DATABASE); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } /* else No action required */ /* Check if no DET error is occurred */ if (LIN_FALSE == LblDetErrFlag) #endif /* #if (LIN_DEV_ERROR_DETECT == STD_ON) */ { /* Initializes the global pointer of LIN first channel config structure */ Lin_GpChannelConfig = (volatile P2CONST(Lin_ChannelInfo, LIN_VAR_NO_INIT, LIN_APPL_CONST))(Config->pFirstChannel); /* PRQA S 0316, 2814, 3432 # JV-01, JV-03, JV-01 */ /* Initializes the global pointer of LIN first channel RAM data structure */ Lin_GpChannelRamData = (volatile P2VAR(Lin_RamData, LIN_VAR_NO_INIT, LIN_APPL_DATA))(Config->pFrameVariables); /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Initializes the global pointer to RLIN3 first channel structure */ Lin_GpRLIN3Properties = (volatile P2CONST(Lin3_ChannelConfigType, LIN_VAR_NO_INIT, LIN_APPL_CONST))(Config->pRLIN3Properties); /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Initializes RLIN3 HW for configured channels */ LucNoOfLinChannels = LIN_ZERO; /* Initialize the return value */ LucReturnValue = E_NOT_OK; /* PRQA S 2982 # JV-01 */ do { /* Initializes the LIN HW channel */ LucReturnValue = Lin_HwInit(LucNoOfLinChannels); /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[LucNoOfLinChannels]; /* PRQA S 0404 # JV-01 */ /* Initialize the sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_CLR_SLEEP_REQUEST; /* PRQA S 2844, 2814 # JV-01, JV-01 */ #if (LIN_AR_VERSION == LIN_AR_422_VERSION) /* Initialize channel status */ LpRamVars->enChannelStatus = LIN_OPERATIONAL; #elif ((LIN_AR_VERSION == LIN_AR_431_VERSION) || \\ (LIN_AR_VERSION == LIN_AR_1911_VERSION)) /* Initialize channel status */ LpRamVars->enChannelStatus = LIN_CH_SLEEP; #endif /* #if (LIN_AR_VERSION == LIN_AR_422_VERSION) */ /* Initialize the LinIf wake-up flag */ LpRamVars->blWakeupCalled = LIN_FALSE; /* Initialize the frame identifier */ LpRamVars->ucFrameId = LIN_ZERO; /* Initialize the frame length */ LpRamVars->ucFrameLength = LIN_ONE; /* Initialize the sleep pending status */ LpRamVars->blSleepPending = LIN_FALSE; LucNoOfLinChannels++; /* PRQA S 3383 # JV-01 */ }while ((LIN_NO_OF_CHANNELS > LucNoOfLinChannels) && (E_OK == LucReturnValue)); /* PRQA S 2996, 2993 # JV-01, JV-01 */ if (E_OK == LucReturnValue) { /* Set the status of LIN driver(Lin_GblDriverState) to LIN_INIT */ Lin_SetStatus(LIN_INIT); } /* else No action required */ } /* if (LblDetErrFlag == LIN_FALSE) */ /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'LIN_AR_1911_VERSION/LIN_AR_422_VERSION/ LIN_AR_431_VERSION', 'Name': 'LIN_AR_VERSION', 'Value': 'LIN_AR_1911_VERSION'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_MASTER_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_SLAVE_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_ALREADY_INIT_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': '1..total number of LIN configured', 'Name': 'LIN_NO_OF_CHANNELS', 'Value': '0x10'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'Address/NULL', 'Name': 'Config', 'Value': '&map_Lin_GaaConfiguration[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'LIN_UNINIT/ LIN_INIT', 'Name': 'Lin_GblDriverState', 'Value': 'LIN_INIT'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0x00/ LIN_DBTOC_VALUE', 'Name': 'ulStartOfDbToc', 'Value': 'LIN_DBTOC_VALUE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'pFrameVariables', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'pFirstChannel', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '&map_Lin_GaaRLIN3Properties[0]', 'Name': 'pRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '-', 'Name': 'return ', 'Value': '[1 to 16] = E_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Output_Param_013': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Output_Param_014': ['Type': 'Variable', 'Range': '&map_Lin_GaaRLIN3Properties[0]', 'Name': 'Lin_GpRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Output_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucSlpRqst_RespRdy', 'Value': '[0 to 15] = LIN_CLR_SLEEP_REQUEST'], 'Output_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'enChannelStatus', 'Value': '[0 to 15] = LIN_CH_SLEEP'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'blWakeupCalled', 'Value': '[0 to 15] = LIN_FALSE'], 'Output_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'ucFrameId', 'Value': '[0 to 15] = LIN_ZERO'], 'Output_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'ucFrameLength', 'Value': '[0 to 15] = LIN_ONE'], 'Output_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'blSleepPending', 'Value': '[0 to 15] = LIN_FALSE'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucNoOfLinChannels', 'Value': '[1 to 16] = 1'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatus', 'Value': 'LIN_INIT'], 'Output_Param_023': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_CODE_FAST #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, LIN_CODE_FAST) Lin_TxIsr(const uint8 LucChannel) /* PRQA S 1532 # JV-01 */ { #if (LIN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) /* Check if the EIMK bit of the EIC register is set */ if (LIN_EIC_EIMK_MASK == (uint16)((*(Lin_GpRLIN3Properties[LucChannel].pLin3IntTxEicReg)) & (uint16)LIN_EIC_EIMK_MASK)) { #ifdef LIN_E_INT_INCONSISTENT /* Reporting to DEM that interrupt from unknown source */ LIN_DEM_REPORT_ERROR(LIN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); #endif /* #ifdef LIN_E_INT_INCONSISTENT */ } else #endif /* (LIN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) */ { if (LIN_TRUE == Lin_GpChannelRamData[LucChannel].blWakeupCalled) { Lin_HwWakeupOnGoing(LucChannel); } else { #if (LIN_SLAVE_MODE_SUPPORT == STD_ON) if (LIN_SLAVE_NODE == Lin_GpChannelConfig[LucChannel].enNodeType) { /* Invoke Lin_HwSlaveProcessData to deal with the Tx Interrupt */ Lin_HwSlaveProcessData(LucChannel); } else #endif /* (LIN_SLAVE_MODE_SUPPORT == STD_ON) */ { #if (LIN_MASTER_MODE_SUPPORT == STD_ON) /* Invoke Lin_HwProcessData to deal with the Tx Interrupt */ Lin_HwProcessData(LucChannel); #endif /* #if (LIN_MASTER_MODE_SUPPORT == STD_ON) */ } } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON / STD_OFF', 'Name': 'LIN_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannel', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '&map_Lin_GaaRLIN3Properties[0]', 'Name': 'Lin_GpRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pLin3IntTxEicReg', 'Value': '&map_pLin3IntTxEicReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0x0000..0xFFFF', 'Name': 'map_pLin3IntTxEicReg[0]', 'Value': '0x0080'], 'Input_Param_006': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'LIN_MASTER_NODE/LIN_SLAVE_NODE', 'Name': 'enNodeType', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'LIN_TRUE / LIN_FALSE', 'Name': 'blWakeupCalled', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'LIN_E_INT_INCONSISTENT'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_CODE_FAST #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, LIN_CODE_FAST) Lin_TxIsr(const uint8 LucChannel) /* PRQA S 1532 # JV-01 */ { #if (LIN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) /* Check if the EIMK bit of the EIC register is set */ if (LIN_EIC_EIMK_MASK == (uint16)((*(Lin_GpRLIN3Properties[LucChannel].pLin3IntTxEicReg)) & (uint16)LIN_EIC_EIMK_MASK)) { #ifdef LIN_E_INT_INCONSISTENT /* Reporting to DEM that interrupt from unknown source */ LIN_DEM_REPORT_ERROR(LIN_E_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); #endif /* #ifdef LIN_E_INT_INCONSISTENT */ } else #endif /* (LIN_INTERRUPT_CONSISTENCY_CHECK == STD_ON) */ { if (LIN_TRUE == Lin_GpChannelRamData[LucChannel].blWakeupCalled) { Lin_HwWakeupOnGoing(LucChannel); } else { #if (LIN_SLAVE_MODE_SUPPORT == STD_ON) if (LIN_SLAVE_NODE == Lin_GpChannelConfig[LucChannel].enNodeType) { /* Invoke Lin_HwSlaveProcessData to deal with the Tx Interrupt */ Lin_HwSlaveProcessData(LucChannel); } else #endif /* (LIN_SLAVE_MODE_SUPPORT == STD_ON) */ { #if (LIN_MASTER_MODE_SUPPORT == STD_ON) /* Invoke Lin_HwProcessData to deal with the Tx Interrupt */ Lin_HwProcessData(LucChannel); #endif /* #if (LIN_MASTER_MODE_SUPPORT == STD_ON) */ } } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON / STD_OFF', 'Name': 'LIN_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LucChannel', 'Value': '5'], 'Input_Param_002': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '&map_Lin_GaaRLIN3Properties[0]', 'Name': 'Lin_GpRLIN3Properties', 'Value': '&map_Lin_GaaRLIN3Properties[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pLin3IntTxEicReg', 'Value': '&map_pLin3IntTxEicReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0x0000..0xFFFF', 'Name': 'map_pLin3IntTxEicReg[0]', 'Value': '0xFF7F'], 'Input_Param_006': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'LIN_MASTER_NODE/LIN_SLAVE_NODE', 'Name': 'enNodeType', 'Value': 'LIN_SLAVE_NODE'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'LIN_TRUE / LIN_FALSE', 'Name': 'blWakeupCalled', 'Value': ' LIN_FALSE']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '0x05'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define LIN_START_SEC_PUBLIC_CODE #include \"Lin_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, LIN_PUBLIC_CODE) Lin_WakeupInternal(uint8 Channel) /* PRQA S 1503 # JV-01 */ { volatile P2VAR(Lin_RamData, AUTOMATIC, LIN_APPL_DATA) LpRamVars; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; #if (LIN_DEV_ERROR_DETECT == STD_ON) Lin_StatusType LenChannelStatus; boolean LblDetErrFlag; #endif /* Initialize the return value */ LucReturnValue = E_NOT_OK; /* PRQA S 2982 # JV-01 */ #if (LIN_DEV_ERROR_DETECT == STD_ON) /* Initialize error status flag to LIN_FALSE */ LblDetErrFlag = LIN_FALSE; /* Report to DET, if module is not Initialized */ if (LIN_UNINIT == Lin_GblDriverState) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_WAKEUP_INTERNAL_SID, LIN_E_UNINIT); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } else { /* Report to DET, if Channel is out of range */ if (LIN_MAX_CHANNEL_ID < Channel) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_WAKEUP_INTERNAL_SID, LIN_E_INVALID_CHANNEL); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } else { /* Get the address of LIN Channel structure */ LenChannelStatus = Lin_GpChannelRamData[Channel].enChannelStatus; if (LIN_CH_SLEEP != LenChannelStatus) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_WAKEUP_INTERNAL_SID, LIN_E_STATE_TRANSITION); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } else { if (LIN_TRUE == Lin_GpChannelRamData[Channel].blWakeupCalled) { /* Report to DET */ (void)Det_ReportError(LIN_MODULE_ID, LIN_INSTANCE_ID, LIN_WAKEUP_INTERNAL_SID, LIN_E_STATE_TRANSITION); /* Set the error status flag to LIN_TRUE */ LblDetErrFlag = LIN_TRUE; } /* else No action required */ } } } /* Check whether any development error occurred */ if (LIN_FALSE == LblDetErrFlag) #endif /* LIN_DEV_ERROR_DETECT */ { /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); /* Set RLIN3 to Reset Mode */ LucReturnValue = Lin_HwSetMasterMode(Channel, RLIN3_RESET_MODE, LIN_WAKEUP_INTERNAL_SID); if (E_OK == LucReturnValue) { /* Set RLIN3 to Operation Mode */ LucReturnValue = Lin_HwSetMasterMode(Channel, RLIN3_OPERATION_MODE, LIN_WAKEUP_INTERNAL_SID); } /* else No action required */ /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_INTERRUPT_CONTROL_PROTECTION); if (E_OK == LucReturnValue) { /* Enter the protection area */ LIN_ENTER_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); /* Get the pointer to channel RAM data */ LpRamVars = &Lin_GpChannelRamData[Channel]; /* PRQA S 0404 # JV-01 */ /* Set the channel status */ LpRamVars->enChannelStatus = LIN_OPERATIONAL; /* PRQA S 2814, 2844 # JV-03, JV-01 */ /* Clear the sleep requested bit */ LpRamVars->ucSlpRqst_RespRdy = LIN_CLR_SLEEP_REQUEST; /* Exit the protection area */ LIN_EXIT_CRITICAL_SECTION(LIN_RAM_DATA_PROTECTION); #if (LIN_SLAVE_MODE_SUPPORT == STD_ON) if (LIN_SLAVE_NODE == Lin_GpChannelConfig[Channel].enNodeType) { /* SWS_Lin_00272 The LIN driver shall be able to receive a LIN header at any time in LIN_CH_OPERATIONAL state */ Lin_HwSlaveStartHeaderReception(Channel); }/* else No action required */ #endif /* (LIN_SLAVE_MODE_SUPPORT == STD_ON) */ }/* else No action required */ } /* if (LblDetErrFlag == LIN_FALSE) */ /* else No action required */ return(LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_MASTER_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON/STD_OFF', 'Name': 'LIN_SLAVE_MODE_SUPPORT', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..LIN_MAX_CHANNEL_ID', 'Name': 'Channel', 'Value': '10'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'LIN_UNINIT/LIN_INIT', 'Name': 'Lin_GblDriverState', 'Value': 'LIN_INIT'], 'Input_Param_006': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelConfig[0]', 'Name': 'Lin_GpChannelConfig', 'Value': '&map_Lin_GaaChannelConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '&map_Lin_GaaChannelRamData[0]', 'Name': 'Lin_GpChannelRamData', 'Value': '&map_Lin_GaaChannelRamData[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '  LIN_NOT_OK           \\n  LIN_TX_OK        \\n  LIN_TX_BUSY          LIN_TX_HEADER_ERROR  \\n  LIN_TX_ERROR        \\n  LIN_RX_OK           \\n  LIN_RX_BUSY          \\n  LIN_RX_ERROR         \\n  LIN_RX_NO_RESPONSE   \\n  LIN_OPERATIONAL     \\n  LIN_CH_SLEEP    ', 'Name': 'enChannelStatus', 'Value': 'LIN_CH_SLEEP'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'LIN_TRUE\\nLIN_FALSE', 'Name': 'blWakeupCalled', 'Value': 'LIN_FALSE'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'LIN_MASTER_NODE/LIN_SLAVE_NODE', 'Name': 'enNodeType', 'Value': 'LIN_MASTER_NODE'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK\\n[2] = E_OK']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_016': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '[1] = 10\\n[2] = 10'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenModeType', 'Value': '[1] = RLIN3_RESET_MODE\\n[2] = RLIN3_OPERATION_MODE'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApiId', 'Value': '[1] = LIN_WAKEUP_INTERNAL_SID\\n[2] = LIN_WAKEUP_INTERNAL_SID'], 'Output_Param_020': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_021': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelStatus', 'Value': 'LIN_OPERATIONAL'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucSlpRqst_RespRdy', 'Value': 'LIN_CLR_SLEEP_REQUEST'], 'Output_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'blWakeupCalled', 'Value': 'LIN_TRUE'], 'Output_Param_025': ['Type': 'Critical_Section', 'Range': '', 'Name': 'Exclusive_Area', 'Value': 'LIN_RAM_DATA_PROTECTION'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucChannel', 'Value': '-'], 'Output_Param_027': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_OK'], 'Output_Param_028': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if (MCU_INIT_CLOCK == STD_ON) #define MCU_START_SEC_PRIVATE_CODE #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Std_ReturnType, MCU_PRIVATE_CODE) Mcu_CLKInitClock(void) /* PRQA S 1532 # JV-01 */ { Std_ReturnType LucReturnValue; Std_ReturnType LucPllStatus; Std_ReturnType LucMainOscStatus; LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Check if HS IntOSC is stable */ LucReturnValue = Mcu_CLKValidateSR( Mcu_GpClockHwInfo->pHSOscSReg, /* PRQA S 2814 # JV-01 */ MCU_HSOSC_CLK_STABLE, MCU_HSOSC_CLK_STABLE, MCU_ZERO); /* * Check if Main Osc is used for the current clock setting */ if ((E_OK == LucReturnValue) && (MCU_TRUE == Mcu_GpClockSetting->blMainOscUsed)) /* PRQA S 2814 # JV-01 */ { /* Confirm that the Main OSC is stopped (MOSCS.MOSCEN = 0 & MOSCS.MOSCSTAB = 0) */ LucMainOscStatus = Mcu_CLKValidateSR( Mcu_GpClockHwInfo->pMainOscSReg, /* PRQA S 2814 # JV-01 */ MCU_MOSCS_STOPPED, MCU_CKSC_ALLMASK, MCU_ZERO); if (E_OK == LucMainOscStatus) { /* Start the Main OSC (MOSCE.MOSCENTRG = 1) */ LucReturnValue = Mcu_CLKWriteCR( /* PRQA S 0404 # JV-01 */ Mcu_GpClockHwInfo->pMainOscEReg, /* PRQA S 2814 # JV-01 */ Mcu_GpClockHwInfo->pMainOscSReg, MCU_MOSCE_ENABLE_TRIGGER, MCU_MOSCS_STABLE, MCU_MOSCS_STABLE); } } if (E_OK == LucReturnValue) { /* Confirm that the PLL is stopped (PLLS.PLLCLKEN = 0 & PLLS.PLLCLKSTAB = 0) */ LucPllStatus = Mcu_CLKValidateSR( Mcu_GpClockHwInfo->pPllSReg, /* PRQA S 2814 # JV-01 */ MCU_PLLS_CLK_STOPPED, MCU_CKSC_ALLMASK, MCU_ZERO); /* Check if the PLL is stopped and the system clock is selected as PLL0 */ if ((E_OK == LucPllStatus) && (MCU_CKSC_CPU_CLK_PLLO == Mcu_GpClockSetting->ulCKSCCPUC)) /* PRQA S 2814 # JV-01 */ { /* Enable PLL */ LucReturnValue = Mcu_CLKWriteCR( /* PRQA S 0404 # JV-01 */ Mcu_GpClockHwInfo->pPllEReg, /* PRQA S 2814 # JV-01 */ Mcu_GpClockHwInfo->pPllSReg, MCU_PLLE_ENABLE_TRIGGER, MCU_PLLS_CLK_STABLE, MCU_PLLS_CLK_STABLE); } else if (MCU_CKSC_CPU_CLK_PLLO != Mcu_GpClockSetting->ulCKSCCPUC) /* PRQA S 2004 # JV-01 */ { /* Distribute module clocks in Mcu_Init() since PLL is not used */ LucReturnValue = Mcu_CLKDistributeClocks(); /* And stop PLL if PLL is ON */ if ((E_OK == LucReturnValue) && (E_NOT_OK == LucPllStatus)) { LucReturnValue = Mcu_CLKWriteCR( /* PRQA S 0404 # JV-01 */ Mcu_GpClockHwInfo->pPllEReg, /* PRQA S 2814 # JV-01 */ Mcu_GpClockHwInfo->pPllSReg, MCU_PLLE_DISABLE_TRIGGER, MCU_PLLS_CLK_STOPPED, MCU_CKSC_ALLMASK); } } } /* Check if Main OSC is not selected as clock source for any clock domain */ if ((E_OK == LucReturnValue) && (MCU_FALSE == Mcu_GpClockSetting->blMainOscUsed)) /* PRQA S 2814 # JV-01 */ { /* Confirm that the Main OSC is stable */ LucMainOscStatus = Mcu_CLKValidateSR( /* PRQA S 0404 # JV-01 */ Mcu_GpClockHwInfo->pMainOscSReg, /* PRQA S 2814 # JV-01 */ MCU_MOSCS_STABLE, MCU_MOSCS_STABLE, Mcu_GpClockSetting->ulClkStbCount); if (E_OK == LucMainOscStatus) { /* Disable Main OSC */ LucReturnValue = Mcu_CLKWriteCR( /* PRQA S 0404 # JV-01 */ Mcu_GpClockHwInfo->pMainOscEReg, /* PRQA S 2814 # JV-01 */ Mcu_GpClockHwInfo->pMainOscSReg, MCU_MOSCE_DISABLE_TRIGGER, MCU_MOSCS_STOPPED, MCU_CKSC_ALLMASK); } } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpClockHwInfo', 'Value': '&map_Mcu_GpClockHwInfo[0]'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'pHSOscSReg', 'Value': '&map_pHSOscSReg[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pMainOscSReg', 'Value': '&map_pMainOscSReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pMainOscEReg', 'Value': '&map_pMainOscEReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pPllSReg', 'Value': '&map_pPllSReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pPllEReg', 'Value': '&map_pPllEReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_pHSOscSReg[0]', 'Value': '0x00000000'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pMainOscSReg[0]', 'Value': '0x00000000'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pMainOscEReg[0]', 'Value': '0x00000000'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPllSReg[0]', 'Value': '0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPllEReg[0]', 'Value': '0x00000000'], 'Input_Param_011': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1 to 3] = E_OK'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[1] = E_OK'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpClockSetting', 'Value': '&map_Mcu_GpClockSetting[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'blMainOscUsed', 'Value': 'MCU_FALSE'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulCKSCCPUC', 'Value': 'MCU_CKSC_CPU_CLK_IOSC'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulClkStbCount', 'Value': '0xFFFF'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_OK'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pMainOscEReg[0]', 'Value': '0x00000000'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_pPllEReg[0]', 'Value': '0x00000000'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '[1] = &map_pHSOscSReg[0]'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegValue', 'Value': '[1] = MCU_HSOSC_CLK_STABLE'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegMask', 'Value': '[1] = MCU_HSOSC_CLK_STABLE'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMaxCount', 'Value': '[1] = MCU_ZERO'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegValue', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegMask', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMaxCount', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKCReg', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCRVal', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRVal', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRMask', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '[2] = &map_pPllSReg[0]'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegValue', 'Value': '[2] = MCU_PLLS_CLK_STOPPED'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegMask', 'Value': '[2] = MCU_CKSC_ALLMASK'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMaxCount', 'Value': '[2] = MCU_ZERO'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKCReg', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCRVal', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRVal', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRMask', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKCReg', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCRVal', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRVal', 'Value': '-'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRMask', 'Value': '-'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '[3] = &map_pMainOscSReg[0]'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegValue', 'Value': '[3] = MCU_MOSCS_STABLE'], 'Output_Param_033': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulRegMask', 'Value': '[3] = MCU_MOSCS_STABLE'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMaxCount', 'Value': '[3] = 0xFFFF'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKCReg', 'Value': '[1] = &map_pMainOscEReg[0]'], 'Output_Param_036': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '[1] = &map_pMainOscSReg[0]'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCRVal', 'Value': '[1] = MCU_MOSCE_DISABLE_TRIGGER'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRVal', 'Value': '[1] = MCU_MOSCS_STOPPED'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRMask', 'Value': '[1] = MCU_CKSC_ALLMASK'], 'Output_Param_040': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if (MCU_INIT_CLOCK == STD_ON) #define MCU_START_SEC_PRIVATE_CODE #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(Std_ReturnType, MCU_PRIVATE_CODE) Mcu_CLKShiftCpuSys(boolean LblGearUp) { Std_ReturnType LucReturnValue; LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Write CLKD_PLLC as divided by 2 */ LucReturnValue = Mcu_CLKWriteCR( /* PRQA S 0404 # JV-01 */ Mcu_GpClockHwInfo->pCLKDPLLCReg, /* PRQA S 2814 # JV-01 */ Mcu_GpClockHwInfo->pCLKDPLLSReg, MCU_PLL_PLLCLKDCSID_DIV2, MCU_PLL_PLLCLKDSYNC_OK, MCU_PLL_PLLCLKDSYNC_OK); if (E_OK == LucReturnValue) { /* Update the system clock selection as the setting value */ LucReturnValue = Mcu_CLKWriteCR( /* PRQA S 0404 # JV-01 */ Mcu_GpClockHwInfo->pCKSCCPUCReg, /* PRQA S 2814 # JV-01 */ Mcu_GpClockHwInfo->pCKSCCPUSReg, Mcu_GpClockSetting->ulCKSCCPUC, /* PRQA S 2814 # JV-01 */ Mcu_GpClockSetting->ulCKSCCPUC, MCU_CKSC_ALLMASK); if ((E_OK == LucReturnValue) && (MCU_TRUE == LblGearUp)) { /* Write CLKD_PLLC as divided by 1 */ LucReturnValue = Mcu_CLKWriteCR( /* PRQA S 0404 # JV-01 */ Mcu_GpClockHwInfo->pCLKDPLLCReg, /* PRQA S 2814 # JV-01 */ Mcu_GpClockHwInfo->pCLKDPLLSReg, MCU_PLL_PLLCLKDCSID_DIV1, MCU_PLL_PLLCLKDSYNC_OK, MCU_PLL_PLLCLKDSYNC_OK); } } /* Return shift clock result */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LblGearUp', 'Value': 'MCU_TRUE'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpClockHwInfo', 'Value': '&map_Mcu_GpClockHwInfo[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pCLKDPLLCReg', 'Value': '&map_pCLKDPLLCReg[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pCLKDPLLSReg', 'Value': '&map_pCLKDPLLSReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pCKSCCPUCReg', 'Value': '&map_pCKSCCPUCReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pCKSCCPUSReg', 'Value': '&map_pCKSCCPUSReg[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpClockSetting', 'Value': '&map_Mcu_GpClockSetting[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulCKSCCPUC', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCLKDPLLCReg[0]', 'Value': '0x00000000'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCLKDPLLSReg[0]', 'Value': '0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCKSCCPUCReg[0]', 'Value': '0x00000000'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pCKSCCPUSReg[0]', 'Value': '0x00000000'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[3] = E_NOT_OK']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pCLKDPLLCReg[0]', 'Value': '0x00000000'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_pCKSCCPUCReg[0]', 'Value': '0x00000000'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKCReg', 'Value': '[1] = &map_pCLKDPLLCReg[0]'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '[1] = &map_pCLKDPLLSReg[0]'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCRVal', 'Value': '[1] = MCU_PLL_PLLCLKDCSID_DIV2'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRVal', 'Value': '[1] = MCU_PLL_PLLCLKDSYNC_OK'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRMask', 'Value': '[1] = MCU_PLL_PLLCLKDSYNC_OK'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKCReg', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCRVal', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRVal', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRMask', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKCReg', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulCRVal', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRVal', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'ulSRMask', 'Value': '-'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if (MCU_INIT_CLOCK == STD_ON) #define MCU_START_SEC_PRIVATE_CODE #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(Std_ReturnType, MCU_PRIVATE_CODE) Mcu_CLKValidateSR( volatile P2CONST(uint32, TYPEDEF, REGSPACE) LpCLKSReg, /* PRQA S 3432 # JV-01 */ const uint32 LulRegValue, const uint32 LulRegMask, const uint32 LulMaxCount) { Std_ReturnType LucReturnValue; volatile uint32 LulCount; LucReturnValue = E_OK; /* Setting clock stable wait time */ LulCount = LulMaxCount; /* Process to check status of target clock */ while ((((*LpCLKSReg) & LulRegMask) != LulRegValue) && (LulCount > MCU_ZERO)) /* PRQA S 2814, 3415, 3416 # JV-01, JV-01, JV-01 */ { LulCount--; /* PRQA S 3384, 3387 # JV-01, JV-01 */ EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ } if (((*LpCLKSReg) & LulRegMask) != LulRegValue) /* PRQA S 2814 # JV-01 */ { LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LpCLKSReg', 'Value': '&map_LpCLKSReg[0]'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0x00000000 \u2026 0xFFFFFFFF', 'Name': 'LulRegValue', 'Value': '0x00000001'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x00000000 \u2026 0xFFFFFFFF', 'Name': 'LulRegMask', 'Value': '0x00000001'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x00000000 \u2026 0xFFFFFFFF', 'Name': 'LulMaxCount', 'Value': '0x00000001'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpCLKSReg[0]', 'Value': '0x00000001']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_OK'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if (MCU_DMON_DIAG_OPERATION == STD_ON) #if (MCU_CLMA_OPERATION == STD_ON) #define MCU_START_SEC_PRIVATE_CODE #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(Std_ReturnType, MCU_PRIVATE_CODE) Mcu_CLMStartMainOsc(void) { Std_ReturnType LucReturnValue; P2CONST(Mcu_ClockSettingType, MCU_CONST, MCU_CONFIG_DATA) LpClockSetting; LpClockSetting = (P2CONST(Mcu_ClockSettingType, MCU_VAR_NO_INIT, MCU_CONFIG_DATA))Mcu_GpConfigPtr->pClockSetting; LucReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ /* Release Register Access protection */ *Mcu_GpClockHwInfo->pPReg = MCU_CKSC_DISABLE_REG_PROTECT_VALUE; /* PRQA S 2814 # JV-01 */ /* Start the MainOSC (MOSCE.MOSCENTRG = 1) */ *Mcu_GpClockHwInfo->pMainOscEReg = MCU_MOSCE_ENABLE_TRIGGER; /* Hold Register Access protection */ *Mcu_GpClockHwInfo->pPReg = MCU_CKSC_ENABLE_REG_PROTECT_VALUE; /* Check stability of MainOSC */ LucReturnValue = Mcu_CLMValidateCR(Mcu_GpClockHwInfo->pMainOscSReg, /* PRQA S 0404 # JV-01 */ MCU_MOSCS_CLK_STABLE, LpClockSetting->ulClkStbCount); /* PRQA S 2814 # JV-01 */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_DMON_DIAG_OPERATION', 'Value': ''], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpClockHwInfo', 'Value': ''], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pPReg', 'Value': ''], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pMainOscEReg', 'Value': ''], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pMainOscSReg', 'Value': ''], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pMainOscSReg[0]', 'Value': ''], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpConfigPtr', 'Value': ''], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pClockSetting', 'Value': ''], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulClkStbCount', 'Value': '']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': ''], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pPReg[0]', 'Value': ''], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_pMainOscEReg[0]', 'Value': ''], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpValidatedRegAdress', 'Value': ''], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulClockExpectedValue', 'Value': ''], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulWaitStableTime', 'Value': ''], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (MCU_DMON_DIAG_OPERATION == STD_ON) #if (MCU_CLMA_OPERATION == STD_ON) #define MCU_START_SEC_PRIVATE_CODE #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(Std_ReturnType, MCU_PRIVATE_CODE) Mcu_CLMValidateCR( P2CONST(volatile uint32, AUTOMATIC, MCU_CONFIG_CONST) LpValidatedRegAdress, /* PRQA S 3432 # JV-01 */ const uint32 LulClockExpectedValue, const uint32 LulWaitStableTime) { Std_ReturnType LucReturnValue; uint16 LusCount; LucReturnValue = E_OK; /* Setting clock stable wait time */ LusCount = (uint32)LulWaitStableTime; /* PRQA S 4461 # JV-01 */ /* Process to check status of target clock */ while ((((*LpValidatedRegAdress) & MCU_CKSC_ALLMASK) != LulClockExpectedValue) && /* PRQA S 2814 # JV-01 */ (LusCount > (uint32)MCU_ZERO)) { LusCount--; EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ } if (((*LpValidatedRegAdress) & MCU_CKSC_ALLMASK) != LulClockExpectedValue) /* PRQA S 2814 # JV-01 */ { LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_DMON_DIAG_OPERATION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpValidatedRegAdress', 'Value': '&map_LpValidatedRegAdress[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x00000000 \u2026 0xFFFFFFFF', 'Name': 'LulClockExpectedValue', 'Value': '0x0000FFFF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x00000000 \u2026 0xFFFFFFFF', 'Name': 'LulWaitStableTime', 'Value': '0xFFFF'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_LpValidatedRegAdress[0]', 'Value': '0x0000FFFF']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_OK'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define MCU_START_SEC_PRIVATE_CODE #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(Std_ReturnType, MCU_PRIVATE_CODE) Mcu_ECMClearErrorOut(void) { Std_ReturnType LucReturnValue; P2VAR(volatile uint32, AUTOMATIC, MCU_CONFIG_DATA) LpEcmRegAddress; /* PRQA S 3432 # JV-01 */ uint8 LucCount; volatile uint32 LulEcmRegValue; volatile uint32 LulEcmMasterRegValue; #if (MCU_ECM_ERROROUTC_CLEAR_VERIFY == STD_ON) volatile uint32 LulECMheckerRegValue; #endif /*(Mcu_ECM_ERROROUTC_CLEAR_VERIFY == STD_ON)*/ uint8 LucLoopCount; P2VAR(volatile uint32, AUTOMATIC, MCU_CONFIG_DATA) LpBackupRegAddress; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Mcu_EcmHwInfoType, AUTOMATIC, MCU_CONFIG_DATA) LpEcmHwInfo; /* PRQA S 3432 # JV-01 */ /* Get the address to ECM configuration structure */ LpEcmHwInfo = (P2CONST(Mcu_EcmHwInfoType, MCU_CONST, MCU_CONFIG_DATA))Mcu_GpConfigPtr->pEcmHwInfo; /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* Initialize the following variables */ LucReturnValue = E_OK; /* Release Register Access Protection */ *LpEcmHwInfo->pECMKCPROTReg = MCU_ECM_DISABLE_REG_PROTECT_VALUE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Check if ECMEOCCFG register is not set */ if (MCU_ECM_EOCCFG_COUNTER_UPDATING != /* PRQA S 0404 # JV-01 */ (*LpEcmHwInfo->pECMEOCCFGReg & MCU_ECM_EOCCFG_COUNTER_CMPW_MASK)) { /* Set ECMEOCCFG register to all 0 */ *LpEcmHwInfo->pECMEOCCFGReg = MCU_LONG_WORD_ZERO; } else { /* ECMEOUTCLRT update is in progress */ LucReturnValue = E_NOT_OK; } if ( E_OK == LucReturnValue) { LpEcmRegAddress = LpEcmHwInfo->pECMETCCFG0Reg; for(LucCount = MCU_ZERO; (LucCount < MCU_ECM_ERROUTZ_NUM) && (LucReturnValue == E_OK); LucCount++) { /* Check if ECMETCCFGn register is not set */ if (MCU_ECM_ETCCFG_COUNTER_UPDATING != ((*LpEcmRegAddress) & MCU_ECM_ETCCFG_COUNTER_CMPW_MASK)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Clear ECMETCCFGn register to all 0 */ *LpEcmRegAddress = MCU_LONG_WORD_ZERO; LpEcmRegAddress++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } else { /* ECMETRGCLRT update is in progress */ LucReturnValue = E_NOT_OK; } } } if (E_OK == LucReturnValue) { /* ECMPEM register set to masked */ *LpEcmHwInfo->pECMPEMReg = MCU_ECM_ECMPEM_ERROR_MASK_VALUE; /* Disable error output signal mask for ECM compare error */ /* error output signal mask setting 0..11 */ LpEcmRegAddress = LpEcmHwInfo->pECMEMK0Reg; for (LucCount = MCU_ZERO; LucCount < MCU_ECM_COMMON_REG_NUM; LucCount++) { if (LucCount == MCU_ZERO) { *LpEcmRegAddress = MCU_ECM_ECMEMK0_MASK; /* PRQA S 2814, 2844 # JV-01, JV-01 */ } else { *LpEcmRegAddress = MCU_ECM_ECMEMK_ALL_MASK; } /* next ECMEMKx register */ LpEcmRegAddress++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } } if (E_OK == LucReturnValue) { /* error trigger x mask setting 0..11 */ LpEcmRegAddress = LpEcmHwInfo->pECMETMK00Reg; for (LucCount = MCU_ZERO; LucCount < MCU_ECM_ERROUTZ_NUM; LucCount++) { /* need to backup old error trigger register address */ LpBackupRegAddress = LpEcmRegAddress; for (LucLoopCount = MCU_ZERO; LucLoopCount < MCU_ECM_COMMON_REG_NUM; LucLoopCount++) { *LpEcmRegAddress = MCU_ECM_ECMETMK_ALL_MASK; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* next ECMETMKx register */ LpEcmRegAddress++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } /* next error trigrt x */ LpEcmRegAddress = (volatile uint32 *)(LpBackupRegAddress + MCU_ECMETMK_OFFSET); /* PRQA S 0488, 2824, 2934 # JV-01, JV-01, JV-01 */ } } if (E_OK == LucReturnValue) { /* Disable interrupt generate for ECM compare error */ LpEcmRegAddress = LpEcmHwInfo->pECMINCFG00Reg; for (LucCount = MCU_ZERO; LucCount < MCU_ECM_CORE_NUM; LucCount++) { *LpEcmRegAddress &= ~MCU_ECM_ECMINCFG_ECM_COMPERR_MASK; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* next ECMINCFGx for each core */ LpEcmRegAddress = (volatile uint32 *)(LpEcmRegAddress + MCU_ECMINCFG_OFFSET); /* PRQA S 0488, 2824, 2934 # JV-01, JV-01, JV-01 */ } /* Disable internal reset generate for ECM compare error */ *LpEcmHwInfo->pECMIRCFG0Reg &= ~MCU_ECM_ECMIRCFG_ECM_COMPERR_MASK; /* ERROR OUT Clear (ECM master/checker error clear trigger register) */ *LpEcmHwInfo->pECMMECLRReg = MCU_ECM_ECLR_ERRCLR_VALUE; LpEcmRegAddress = LpEcmHwInfo->pECMMECLR0Reg; for (LucCount = MCU_ZERO; LucCount < MCU_ECM_ERROUTZ_NUM; LucCount++) { *LpEcmRegAddress = MCU_ECM_ECLR_ERRCLR_VALUE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* next ECMMECLRx register */ LpEcmRegAddress = LpEcmRegAddress + MCU_LONG_WORD_TWO; /* PRQA S 0488, 2824, 2934 # JV-01, JV-01, JV-01 */ } *LpEcmHwInfo->pECMCECLRReg = MCU_ECM_ECLR_ERRCLR_VALUE; LpEcmRegAddress = LpEcmHwInfo->pECMCECLR0Reg; for (LucCount = MCU_ZERO; LucCount < MCU_ECM_ERROUTZ_NUM; LucCount++) { *LpEcmRegAddress = MCU_ECM_ECLR_ERRCLR_VALUE; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* next ECMECLRx register */ LpEcmRegAddress = LpEcmRegAddress + MCU_LONG_WORD_TWO; /* PRQA S 0488, 2824, 2934 # JV-01, JV-01, JV-01 */ } /* Hold Register Access protection */ *LpEcmHwInfo->pECMKCPROTReg = MCU_ECM_ENABLE_REG_PROTECT_VALUE; /* read 5 times ECM status register */ for (LucCount = MCU_ZERO; LucCount < MCU_ECM_ESSTR_COUNT; LucCount++) { LulEcmMasterRegValue = *LpEcmHwInfo->pECMMESSTR0Reg; /* PRQA S 0404 # JV-01 */ #if (MCU_ECM_ERROROUTC_CLEAR_VERIFY == STD_ON) LulECMheckerRegValue = *LpEcmHwInfo->pECMCESSTR0Reg; /* PRQA S 0404 # JV-01 */ #endif } /* Check ERROROUT status */ LulEcmMasterRegValue = *LpEcmHwInfo->pECMMESSTR0Reg; /* PRQA S 0404 # JV-01 */ #if (MCU_ECM_ERROROUTC_CLEAR_VERIFY == STD_ON) if ((MCU_ECM_ESSTR_ERROUT_MASK != (MCU_ECM_ESSTR_ERROUT_MASK & LulEcmMasterRegValue)) || (MCU_ECM_ESSTR_ERROUT_MASK != (MCU_ECM_ESSTR_ERROUT_MASK & LulECMheckerRegValue))) #else if ((MCU_ECM_ESSTR_ERROUT_MASK != (MCU_ECM_ESSTR_ERROUT_MASK & LulEcmMasterRegValue))) #endif { /* ERROROUT not cleared */ LucReturnValue = E_NOT_OK; } /* Set MSKM bit and MSKC bit of the ECMPEM register */ /* ECMPEM register set to masked */ LulEcmRegValue = (uint32)MCU_ZERO; *LpEcmHwInfo->pECMPEMReg = LulEcmRegValue; /* PRQA S 0404 # JV-01 */ } /* Return the value of ECM ERROROUT Clear result */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_ECM_OPERATION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_ECM_ERROROUTC_CLEAR_VERIFY', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpConfigPtr', 'Value': '&map_Mcu_GpConfigPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmHwInfo', 'Value': '&map_pEcmHwInfo[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pECMKCPROTReg', 'Value': '&map_pECMKCPROTReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMKCPROTReg[0]', 'Value': '0x00000000'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pECMEOCCFGReg', 'Value': '&map_pECMEOCCFGReg[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMEOCCFGReg[0]', 'Value': '0x00000000'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pECMETCCFG0Reg', 'Value': '&map_pECMETCCFG0Reg[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMETCCFG0Reg[0 to 1]', 'Value': '[0]=0x00000000\\n[1]=0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pECMPEMReg', 'Value': '&map_pECMPEMReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMPEMReg[0]', 'Value': '0x00000000'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pECMEMK0Reg', 'Value': '&map_pECMEMK0Reg[0]'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMEMK0Reg[0 to 11]', 'Value': '[0 to 11]=0x00000000'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pECMETMK00Reg', 'Value': '&map_pECMETMK00Reg[0]'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMETMK00Reg[0 to 255]', 'Value': '[0 to 255]=0x00000000'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pECMINCFG00Reg', 'Value': '&map_pECMINCFG00Reg[0]'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMINCFG00Reg[0 to 1]', 'Value': '[0 to 1]=0x00000000'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pECMIRCFG0Reg', 'Value': '&map_pECMIRCFG0Reg[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMIRCFG0Reg[0]', 'Value': '0x00000000'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'pECMMECLRReg', 'Value': '&map_pECMMECLRReg[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pECMMECLR0Reg', 'Value': '&map_pECMMECLR0Reg[0]'], 'Input_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMMECLR0Reg[0 to 3]', 'Value': '[0 to 3]=0x00000000'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'pECMCECLRReg', 'Value': '&map_pECMCECLRReg[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'pECMCECLR0Reg', 'Value': '&map_pECMCECLR0Reg[0]'], 'Input_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMCECLR0Reg[0 to 3]', 'Value': '[0 to 3]=0x00000000'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pECMMESSTR0Reg', 'Value': '&map_pECMMESSTR0Reg[0]'], 'Input_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMMESSTR0Reg[0 to 4]', 'Value': '[0 to 4]=0x00000000'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'pECMCESSTR0Reg', 'Value': '&map_pECMCESSTR0Reg[0]'], 'Input_Param_029': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMCESSTR0Reg[0 to 4]', 'Value': '[0 to 4]=0x00000001']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMKCPROTReg[0]', 'Value': 'MCU_ECM_ENABLE_REG_PROTECT_VALUE'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMEOCCFGReg[0]', 'Value': 'MCU_LONG_WORD_ZERO'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMETCCFG0Reg[0 to 1]', 'Value': '[0 to 1]=0x00000000'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMPEMReg[0]', 'Value': '(uint32)MCU_ZERO'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMEMK0Reg[0 to 11]', 'Value': '[0]=MCU_ECM_ECMEMK0_MASK\\n[1 to 11]=MCU_ECM_ECMEMK_ALL_MASK'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMETMK00Reg[0 to 255]', 'Value': '[0 to 11]=MCU_ECM_ECMETMK_ALL_MASK\\n[15 to 26]=MCU_ECM_ECMETMK_ALL_MASK'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMINCFG00Reg[0 to 1]', 'Value': '[0 to 1]=0x00000000'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMIRCFG0Reg[0]', 'Value': '0x00000000'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMMECLRReg[0]', 'Value': 'MCU_ECM_ECLR_ERRCLR_VALUE'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMMECLR0Reg[0 to 3]', 'Value': '[0]=MCU_ECM_ECLR_ERRCLR_VALUE\\n[2]=MCU_ECM_ECLR_ERRCLR_VALUE'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pECMCECLRReg[0]', 'Value': 'MCU_ECM_ECLR_ERRCLR_VALUE'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMCECLR0Reg[0 to 3]', 'Value': '[0]=MCU_ECM_ECLR_ERRCLR_VALUE\\n[2]=MCU_ECM_ECLR_ERRCLR_VALUE'], 'Output_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMMESSTR0Reg[0 to 4]', 'Value': '[0 to 4]=0x00000000'], 'Output_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMCESSTR0Reg[0 to 4]', 'Value': '[0 to 4]=0x00000001'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (MCU_EIINT_EIC8_ISR_API == STD_ON) #define MCU_START_SEC_CODE_FAST #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined (OS_MCU_ECM_EIC8_CAT2_ISR) || (MCU_ISR_CATEGORY_2 == STD_ON) ISR(MCU_ECM_EIC8_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, MCU_CODE_FAST) MCU_ECM_EIC8_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { /* pointer to MI notification function array */ P2FUNC(void, AUTOMATIC, LpEiNotifyFuncPtr)(uint16 LusEcmNotificationErrorNumber); /* PRQA S 3432 # JV-01 */ P2CONST(volatile Mcu_EcmHwInfoType, AUTOMATIC, MCU_CONFIG_DATA) LpEcmHwInfo; /* PRQA S 3432 # JV-01 */ P2CONST(Mcu_EcmSettingType, MCU_CONST, MCU_CONFIG_DATA) LpEcmSetting; /* PRQA S 3432 # JV-01 */ P2VAR(volatile uint32, AUTOMATIC, MCU_CONFIG_DATA) LpEcmStatusRegAddr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ P2VAR(volatile uint32, AUTOMATIC, MCU_CONFIG_DATA) LpEcmStatusClearRegAddr; /* PRQA S 3432 # JV-01 */ uint32 LulEcmStatusData; uint16 LusEcmNotificationErrorNumber; uint8 LucCount; uint8 LucECMount; uint8 LucPeNum; uint8 LucPeCount; #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) boolean LblEicIntEnable; #endif LucPeNum = MCU_THIRTYTWO; LulEcmStatusData = MCU_LONG_WORD_ZERO; /* Get the address to EI callback notification function */ LpEiNotifyFuncPtr = Mcu_GpConfigPtr->pEiintNotificationPtr; /* PRQA S 2814 # JV-01 */ /* Get the address to ECM configuration structure */ LpEcmSetting = (P2CONST(Mcu_EcmSettingType, MCU_CONST, MCU_CONFIG_DATA))Mcu_GpConfigPtr->pEcmSetting; /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpEcmHwInfo = (P2CONST(Mcu_EcmHwInfoType, MCU_CONST, MCU_CONFIG_DATA))Mcu_GpConfigPtr->pEcmHwInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ for (LucPeCount = MCU_ZERO; LucPeCount < MCU_ECM_CORE_NUM; LucPeCount++) { if (LucPeCount == (uint8)(*LpEcmHwInfo->pEIBD8Reg & MCU_ECM_EIBD8_PEID_MASK)) /* PRQA S 0404, 2814, 2844 # JV-01, JV-01, JV-01 */ { /* Mask the DCLS bit correspond to the current core */ LpEcmSetting->pEcmEIC8ErrMask[MCU_SEVEN + LucPeCount] &= (uint32)( ~MCU_DCLS_PE_BIT_MASK); /* PRQA S 2814, 2824, 2844 # JV-01, JV-01, JV-01 */ /* Get the PE number */ LucPeNum = LucPeCount; } } /* ECM Interrupt consistency check */ #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) if(MCU_LONG_WORD_ZERO != (*LpEcmHwInfo->pIMR0Reg & MCU_ECM_INT_MASK_EIC8_VALUE)) /* PRQA S 0404 # JV-01 */ { LblEicIntEnable = MCU_FALSE; } else { LblEicIntEnable = MCU_TRUE; } LpEcmStatusRegAddr = LpEcmHwInfo->pECMMESSTR0Reg; /* PRQA S 2982 # JV-01 */ LpEcmStatusRegAddr = LpEcmHwInfo->pECMCESSTR0Reg; /* ECM Error status check for Checker */ for (LucECMount = MCU_ZERO; LucECMount < MCU_ECM_COMMON_REG_NUM; LucECMount++) { if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { LulEcmStatusData |= (*LpEcmStatusRegAddr & /* PRQA S 2814, 2844 # JV-01, JV-01 */ ((LpEcmSetting->pEcmEIC8ErrMask)[LucECMount]) & (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) & (uint32)~(LpEcmSetting->aaEcmIntTypeRegValue[LucECMount])); } else { /* No action required */ } /* Increment the value of index */ LpEcmStatusRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } /* Interrupt status isn't set */ if ((MCU_FALSE == LblEicIntEnable) || (MCU_LONG_WORD_ZERO == (LulEcmStatusData))) { #ifdef MCU_E_ECM_INT_INCONSISTENT MCU_DEM_REPORT_ERROR(MCU_E_ECM_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); #endif } else { #endif /* MCU_ECM_INTERRUPT_CONSISTENCY_CHECK */ LpEcmStatusRegAddr = LpEcmHwInfo->pECMMESSTR0Reg; LpEcmStatusClearRegAddr = LpEcmHwInfo->pECMESSTC0Reg; for (LucECMount = MCU_ZERO; LucECMount < MCU_ECM_COMMON_REG_NUM; LucECMount++) { if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { /* Get the value of ECM error status data of mask able interrupt */ LulEcmStatusData = (*LpEcmStatusRegAddr & /* PRQA S 2814, 2844 # JV-01, JV-01 */ ((LpEcmSetting->pEcmEIC8ErrMask)[LucECMount]) & (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) & (uint32)~(LpEcmSetting->aaEcmIntTypeRegValue[LucECMount])); } for (LucCount = MCU_ZERO; LucCount < MCU_THIRTYTWO; LucCount++) { /* Find the notification index for the particular ecm source. * step 1.find the total number of configured ecm error sources * for MI upto this current source. * step 2.Find the notification index for current ecm source = * \"value in step1- MCU_ONE\" */ if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { /* When Check DCLS error */ if (MCU_LONG_WORD_ONE == (( (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) >> LucCount) & MCU_LONG_WORD_ONE)) { LusEcmNotificationErrorNumber = (uint16)((MCU_ECM_STATUS_REG_SIZE * LucECMount) + LucCount); /* PRQA S 4391 # JV-01 */ } } /* Find which ecm source caused this interrupt */ if (MCU_LONG_WORD_ONE == ((LulEcmStatusData >> LucCount) & MCU_LONG_WORD_ONE)) { /* Check whether notification function configured or not */ if (NULL_PTR != LpEiNotifyFuncPtr) { /* Invoke the configured notification function */ LpEiNotifyFuncPtr((uint16)LusEcmNotificationErrorNumber); /* PRQA S 2962 # JV-01 */ } /* Release Register Access Protection */ *LpEcmHwInfo->pECMKCPROTReg = MCU_ECM_DISABLE_REG_PROTECT_VALUE; /* Clear status for ECM interrupt */ *LpEcmStatusClearRegAddr = /* PRQA S 2814, 2844 # JV-01, JV-01 */ (uint32)(MCU_LONG_WORD_ONE << (uint32)LucCount); /* Hold Register Access protection */ *LpEcmHwInfo->pECMKCPROTReg = MCU_ECM_ENABLE_REG_PROTECT_VALUE; #if ((MCU_GET_RAM_STATE_API == STD_ON) && \\ (MCU_PROVIDE_RAM_STATE_ISR == STD_ON)) /* Check local ram and cluster ram error */ if (MCU_LONG_WORD_ZERO != (LulEcmStatusData & (LpEcmSetting->pEcmRamErrMask)[LucECMount])) /* PRQA S 2824 # JV-01 */ { /* Set the value of RAM error(error) */ Mcu_GblRAMInitStatus = MCU_RAMSTATE_INVALID; } #endif /* MCU_GET_RAM_STATE_API && MCU_PROVIDE_RAM_STATE_ISR */ } } /* Increment the value of index */ LpEcmStatusRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ LpEcmStatusClearRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) } #endif return; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_GET_RAM_STATE_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_PROVIDE_RAM_STATE_ISR', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_ECM_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_E_ECM_INT_INCONSISTENT', 'Value': '<is defined>'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpConfigPtr', 'Value': '&map_Mcu_GpConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pEiintNotificationPtr', 'Value': '&ISOLATE_void_func_ptr_uint16'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmSetting', 'Value': '&map_pEcmSetting[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmHwInfo', 'Value': '&map_pEcmHwInfo[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pEIBD8Reg', 'Value': '&map_pEIBD8Reg[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pEIBD8Reg[0]', 'Value': '0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmEIC8ErrMask', 'Value': '&map_pEcmEIC8ErrMask[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pIMR0Reg', 'Value': '&map_pIMR0Reg[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'map_pIMR0Reg[0]', 'Value': '0x00000000'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'aaEcmIntNotificationValue[0][0 to 11]', 'Value': '[0 to 11] = 0xFFFFFFFF'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'aaEcmIntTypeRegValue[0 to 11]', 'Value': '[0 to 10] = 0xFFFFFFFF'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pECMMESSTR0Reg', 'Value': '&map_pECMMESSTR0Reg[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pECMCESSTR0Reg', 'Value': '&map_pECMCESSTR0Reg[0]'], 'Input_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMMESSTR0Reg[0 to 11]', 'Value': '[0 to 4] = 0x00000000\\n[5] = 0x00000020\\n[6 to 11] =0x00000000'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMCESSTR0Reg[0 to 11]', 'Value': '[0 to 4] = 0x00000000\\n[5] = 0x00000020\\n[6 to 11] =0x00000000'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'pECMESSTC0Reg', 'Value': '&map_pECMESSTC0Reg[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmRamErrMask', 'Value': '&map_pEcmRamErrMask[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'map_pEcmRamErrMask[0 to 11]', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pECMKCPROTReg', 'Value': '&map_pECMKCPROTReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'map_pEcmEIC8ErrMask[0 to 11]', 'Value': '[7] = 0x55555554'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'MCU_E_ECM_INT_INCONSISTENT'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusEcmNotificationErrorNumber', 'Value': '-'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMESSTC0Reg[0 to 11]', 'Value': '-'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_pECMKCPROTReg[0]', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GblRAMInitStatus', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (MCU_FEINT_ISR_API == STD_ON) #define MCU_START_SEC_CODE_FAST #include \"Mcu_MemMap.h\" /* Defines the CAT2 interrupt mapping */ #if defined (OS_MCU_FEINT_CAT2_ISR) || (MCU_ISR_CATEGORY_2 == STD_ON) ISR(MCU_FEINT_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_FE_ FUNC(void, MCU_CODE_FAST) MCU_FEINT_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { /* pointer to FE notification callback function */ P2FUNC(void, AUTOMATIC, LpFeiNotifyFuncPtr)(uint16 LusEcmNotificationErrorNumber); /* PRQA S 3432 # JV-01 */ P2CONST(Mcu_EcmSettingType, MCU_CONST, MCU_CONFIG_DATA) LpEcmSetting; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Mcu_EcmHwInfoType, AUTOMATIC, MCU_CONFIG_DATA) LpEcmHwInfo; /* PRQA S 3432 # JV-01 */ P2VAR(volatile uint32, AUTOMATIC, MCU_CONFIG_DATA) LpEcmStatusRegAddr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ P2VAR(volatile uint32, AUTOMATIC, MCU_CONFIG_DATA) LpEcmStatusClearRegAddr; /* PRQA S 3432 # JV-01 */ uint32 LulEcmStatusData; uint16 LusEcmNotificationErrorNumber; uint8 LucCount; uint8 LucECMount; uint8 LucPeNum; uint8 LucPeCount; #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) uint32 LulFEINTstatus; #endif LucPeNum = MCU_THIRTYTWO; LulEcmStatusData = MCU_LONG_WORD_ZERO; LpEcmHwInfo = (P2CONST(Mcu_EcmHwInfoType, MCU_CONST, MCU_CONFIG_DATA))(Mcu_GpConfigPtr->pEcmHwInfo); /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* Get the address to FE notification callback function */ LpFeiNotifyFuncPtr = Mcu_GpConfigPtr->pFeintNotificationPtr; /* Get the address to ECM configuration structure */ LpEcmSetting = (P2CONST(Mcu_EcmSettingType, MCU_CONST, MCU_CONFIG_DATA))(Mcu_GpConfigPtr->pEcmSetting); /* PRQA S 0316, 3432 # JV-01, JV-01 */ for (LucPeCount = MCU_ZERO; LucPeCount < MCU_ECM_CORE_NUM; LucPeCount++) { if (LucPeCount == (uint8)(*LpEcmHwInfo->pFIBD0Reg & MCU_ECM_FIBD0_PEID_MASK)) /* PRQA S 0404, 2814, 2844 # JV-01, JV-01, JV-01 */ { /* Get the PE number */ LucPeNum = LucPeCount; } } /* ECM Interrupt consistency check */ #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) LpEcmStatusRegAddr = LpEcmHwInfo->pECMMESSTR0Reg; /* Check FE interrupt flag for the appropriate core */ if (MCU_ZERO == LucPeNum) { LulFEINTstatus = *LpEcmHwInfo->pFEINTF0Reg & MCU_ECM_INT_MASK_FE_VALUE; /* PRQA S 0404 # JV-01 */ } else if (MCU_ONE == LucPeNum) /* PRQA S 2004 # JV-01 */ { LulFEINTstatus = *LpEcmHwInfo->pFEINTF1Reg & MCU_ECM_INT_MASK_FE_VALUE; /* PRQA S 0404 # JV-01 */ } /* ECMESSTR0 .. x read */ /* ECM Error status check for Master */ for (LucECMount = MCU_ZERO; LucECMount < MCU_ECM_COMMON_REG_NUM; LucECMount++) { /* Check FE interrupt flag for the appropriate core */ if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { /* Get ECM status value */ LulEcmStatusData |= ( *LpEcmStatusRegAddr & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntTypeRegValue[LucECMount])); } LpEcmStatusRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } LpEcmStatusRegAddr = LpEcmHwInfo->pECMCESSTR0Reg; /* ECM Error status check for Checker */ for (LucECMount = MCU_ZERO; LucECMount < MCU_ECM_COMMON_REG_NUM; LucECMount++) { if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { LulEcmStatusData |= ( *LpEcmStatusRegAddr & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) & (LpEcmSetting->aaEcmIntTypeRegValue[LucECMount])); } /* Increment the value of index */ LpEcmStatusRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } /* Interrupt status isn't set */ if ((MCU_LONG_WORD_ZERO == LulEcmStatusData) || (MCU_ECM_INT_MASK_FE_VALUE != LulFEINTstatus)) /* PRQA S 2962 # JV-01 */ { #if defined (MCU_E_ECM_INT_INCONSISTENT) MCU_DEM_REPORT_ERROR(MCU_E_ECM_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); #endif } else { #endif /* MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON */ /* ECM Master/Checker Error Source Status Register j */ LpEcmStatusRegAddr = LpEcmHwInfo->pECMMESSTR0Reg; /* ECM error source status clear trigger register j */ LpEcmStatusClearRegAddr = LpEcmHwInfo->pECMESSTC0Reg; for (LucECMount = MCU_ZERO; LucECMount < MCU_ECM_COMMON_REG_NUM; LucECMount++) { if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { /* Get the value of ECM error status data of non mask-able interrupt */ LulEcmStatusData = (*LpEcmStatusRegAddr & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntTypeRegValue[LucECMount])); } for (LucCount = MCU_ZERO; LucCount < MCU_THIRTYTWO; LucCount++) { /* Find the notification index for the particular ecm source. * step 1.find the total number of configured ecm error sources * for MI up to this current source. * step 2.Find the notification index for current ecm source = * \"value in step 1- MCU_ONE\" */ if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { if (MCU_LONG_WORD_ONE == (( (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) >> LucCount) & MCU_LONG_WORD_ONE)) { /* Calculate the ECM Error number */ LusEcmNotificationErrorNumber = (uint16)((MCU_ECM_STATUS_REG_SIZE * LucECMount) + LucCount); /* PRQA S 4391 # JV-01 */ } } /* Find which ecm source caused this interrupt */ if (MCU_LONG_WORD_ONE == ((LulEcmStatusData >> LucCount) & MCU_LONG_WORD_ONE)) { /* Check whether notification function configured or not */ if (NULL_PTR != LpFeiNotifyFuncPtr) { /* Invoke the configured notification function */ LpFeiNotifyFuncPtr((uint16)LusEcmNotificationErrorNumber); /* PRQA S 2962 # JV-01 */ } /* Release Register Access Protection */ *LpEcmHwInfo->pECMKCPROTReg = MCU_ECM_DISABLE_REG_PROTECT_VALUE; /* Clear status for ECM interrupt */ *LpEcmStatusClearRegAddr = (uint32)(MCU_LONG_WORD_ONE << (uint32)LucCount); /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Hold Register Access protection */ *LpEcmHwInfo->pECMKCPROTReg = MCU_ECM_ENABLE_REG_PROTECT_VALUE;; #if ((MCU_GET_RAM_STATE_API == STD_ON) && \\ (MCU_PROVIDE_RAM_STATE_ISR == STD_ON)) /* Check local ram and cluster ram error */ if (MCU_LONG_WORD_ZERO != (LulEcmStatusData & (LpEcmSetting->pEcmRamErrMask)[LucECMount])) /* PRQA S 2824 # JV-01 */ { /* Set the value of RAM error(error) */ Mcu_GblRAMInitStatus = MCU_RAMSTATE_INVALID; } #endif } } /* Increment the value of index */ LpEcmStatusRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ LpEcmStatusClearRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) } #endif /* It should be changed to code that does not depend on the number of cores ... */ if (MCU_ZERO == LucPeNum) { *LpEcmHwInfo->pFEINTC0Reg = MCU_ECM_INT_MASK_FE_VALUE; } else if ( MCU_ONE == LucPeNum) /* PRQA S 2004 # JV-01 */ { *LpEcmHwInfo->pFEINTC1Reg = MCU_ECM_INT_MASK_FE_VALUE; } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_GET_RAM_STATE_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_PROVIDE_RAM_STATE_ISR', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_ECM_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_E_ECM_INT_INCONSISTENT', 'Value': '<is defined>'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpConfigPtr', 'Value': '&map_Mcu_GpConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pFeintNotificationPtr', 'Value': 'NULL_PTR'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmSetting', 'Value': '&map_pEcmSetting[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmHwInfo', 'Value': '&map_pEcmHwInfo[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pFIBD0Reg', 'Value': '&map_pFIBD0Reg[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pFIBD0Reg[0]', 'Value': '0x00000001'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'aaEcmIntNotificationValue[0][0 to 11]', 'Value': '[0 to 11] = 0x00000000'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'aaEcmIntTypeRegValue[0 to 11]', 'Value': '[0 to 1] = 0x00000000\\n[2] = 0x00000004\\n[3 to 11] = 0x00000000'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pECMMESSTR0Reg', 'Value': '&map_pECMMESSTR0Reg[0]'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMMESSTR0Reg[0 to 11]', 'Value': '[0 to 1] = 0x00000000\\n[2] = 0x00000004\\n[3 to 11] = 0x00000000'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pECMCESSTR0Reg', 'Value': '&map_pECMCESSTR0Reg[0]'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMCESSTR0Reg[0 to 11]', 'Value': '[0 to 1] = 0x00000000\\n[2] = 0x00000004\\n[3 to 11] = 0x00000000'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pECMESSTC0Reg', 'Value': '&map_pECMESSTC0Reg[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmRamErrMask', 'Value': '&map_pEcmRamErrMask[0]'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'map_pEcmRamErrMask[0 to 11]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'pFEINTF0Reg', 'Value': '&map_pFEINTF0Reg[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_pFEINTF0Reg[0]', 'Value': '0x0000000F'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pFEINTF1Reg', 'Value': '&map_pFEINTF1Reg[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_pFEINTF1Reg[0]', 'Value': '0x0000000F'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'pFEINTC0Reg', 'Value': '&map_pFEINTC0Reg[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'pFEINTC1Reg', 'Value': '&map_pFEINTC1Reg[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'pECMKCPROTReg', 'Value': '&map_pECMKCPROTReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusEcmNotificationErrorNumber', 'Value': '-'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMESSTC0Reg[0 to 11]', 'Value': '[2] = 0x00000004'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_pECMKCPROTReg[0]', 'Value': 'MCU_ECM_ENABLE_REG_PROTECT_VALUE'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GblRAMInitStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_pFEINTC0Reg[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_pFEINTC1Reg[0]', 'Value': 'MCU_ECM_INT_MASK_FE_VALUE'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (MCU_FEINT_ISR_API == STD_ON) #define MCU_START_SEC_CODE_FAST #include \"Mcu_MemMap.h\" /* Defines the CAT2 interrupt mapping */ #if defined (OS_MCU_FEINT_CAT2_ISR) || (MCU_ISR_CATEGORY_2 == STD_ON) ISR(MCU_FEINT_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_FE_ FUNC(void, MCU_CODE_FAST) MCU_FEINT_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { /* pointer to FE notification callback function */ P2FUNC(void, AUTOMATIC, LpFeiNotifyFuncPtr)(uint16 LusEcmNotificationErrorNumber); /* PRQA S 3432 # JV-01 */ P2CONST(Mcu_EcmSettingType, MCU_CONST, MCU_CONFIG_DATA) LpEcmSetting; /* PRQA S 3432 # JV-01 */ P2CONST(volatile Mcu_EcmHwInfoType, AUTOMATIC, MCU_CONFIG_DATA) LpEcmHwInfo; /* PRQA S 3432 # JV-01 */ P2VAR(volatile uint32, AUTOMATIC, MCU_CONFIG_DATA) LpEcmStatusRegAddr; /* PRQA S 3432, 3678 # JV-01, JV-01 */ P2VAR(volatile uint32, AUTOMATIC, MCU_CONFIG_DATA) LpEcmStatusClearRegAddr; /* PRQA S 3432 # JV-01 */ uint32 LulEcmStatusData; uint16 LusEcmNotificationErrorNumber; uint8 LucCount; uint8 LucECMount; uint8 LucPeNum; uint8 LucPeCount; #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) uint32 LulFEINTstatus; #endif LucPeNum = MCU_THIRTYTWO; LulEcmStatusData = MCU_LONG_WORD_ZERO; LpEcmHwInfo = (P2CONST(Mcu_EcmHwInfoType, MCU_CONST, MCU_CONFIG_DATA))(Mcu_GpConfigPtr->pEcmHwInfo); /* PRQA S 0316, 2814, 3432 # JV-01, JV-01, JV-01 */ /* Get the address to FE notification callback function */ LpFeiNotifyFuncPtr = Mcu_GpConfigPtr->pFeintNotificationPtr; /* Get the address to ECM configuration structure */ LpEcmSetting = (P2CONST(Mcu_EcmSettingType, MCU_CONST, MCU_CONFIG_DATA))(Mcu_GpConfigPtr->pEcmSetting); /* PRQA S 0316, 3432 # JV-01, JV-01 */ for (LucPeCount = MCU_ZERO; LucPeCount < MCU_ECM_CORE_NUM; LucPeCount++) { if (LucPeCount == (uint8)(*LpEcmHwInfo->pFIBD0Reg & MCU_ECM_FIBD0_PEID_MASK)) /* PRQA S 0404, 2814, 2844 # JV-01, JV-01, JV-01 */ { /* Get the PE number */ LucPeNum = LucPeCount; } } /* ECM Interrupt consistency check */ #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) LpEcmStatusRegAddr = LpEcmHwInfo->pECMMESSTR0Reg; /* Check FE interrupt flag for the appropriate core */ if (MCU_ZERO == LucPeNum) { LulFEINTstatus = *LpEcmHwInfo->pFEINTF0Reg & MCU_ECM_INT_MASK_FE_VALUE; /* PRQA S 0404 # JV-01 */ } else if (MCU_ONE == LucPeNum) /* PRQA S 2004 # JV-01 */ { LulFEINTstatus = *LpEcmHwInfo->pFEINTF1Reg & MCU_ECM_INT_MASK_FE_VALUE; /* PRQA S 0404 # JV-01 */ } /* ECMESSTR0 .. x read */ /* ECM Error status check for Master */ for (LucECMount = MCU_ZERO; LucECMount < MCU_ECM_COMMON_REG_NUM; LucECMount++) { /* Check FE interrupt flag for the appropriate core */ if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { /* Get ECM status value */ LulEcmStatusData |= ( *LpEcmStatusRegAddr & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntTypeRegValue[LucECMount])); } LpEcmStatusRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } LpEcmStatusRegAddr = LpEcmHwInfo->pECMCESSTR0Reg; /* ECM Error status check for Checker */ for (LucECMount = MCU_ZERO; LucECMount < MCU_ECM_COMMON_REG_NUM; LucECMount++) { if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { LulEcmStatusData |= ( *LpEcmStatusRegAddr & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) & (LpEcmSetting->aaEcmIntTypeRegValue[LucECMount])); } /* Increment the value of index */ LpEcmStatusRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } /* Interrupt status isn't set */ if ((MCU_LONG_WORD_ZERO == LulEcmStatusData) || (MCU_ECM_INT_MASK_FE_VALUE != LulFEINTstatus)) /* PRQA S 2962 # JV-01 */ { #if defined (MCU_E_ECM_INT_INCONSISTENT) MCU_DEM_REPORT_ERROR(MCU_E_ECM_INT_INCONSISTENT, DEM_EVENT_STATUS_FAILED); #endif } else { #endif /* MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON */ /* ECM Master/Checker Error Source Status Register j */ LpEcmStatusRegAddr = LpEcmHwInfo->pECMMESSTR0Reg; /* ECM error source status clear trigger register j */ LpEcmStatusClearRegAddr = LpEcmHwInfo->pECMESSTC0Reg; for (LucECMount = MCU_ZERO; LucECMount < MCU_ECM_COMMON_REG_NUM; LucECMount++) { if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { /* Get the value of ECM error status data of non mask-able interrupt */ LulEcmStatusData = (*LpEcmStatusRegAddr & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) & /* PRQA S 2814, 2844 # JV-01, JV-01 */ (LpEcmSetting->aaEcmIntTypeRegValue[LucECMount])); } for (LucCount = MCU_ZERO; LucCount < MCU_THIRTYTWO; LucCount++) { /* Find the notification index for the particular ecm source. * step 1.find the total number of configured ecm error sources * for MI up to this current source. * step 2.Find the notification index for current ecm source = * \"value in step 1- MCU_ONE\" */ if ((MCU_ZERO == LucPeNum) || (MCU_ONE == LucPeNum)) { if (MCU_LONG_WORD_ONE == (( (LpEcmSetting->aaEcmIntNotificationValue[LucPeNum][LucECMount]) >> LucCount) & MCU_LONG_WORD_ONE)) { /* Calculate the ECM Error number */ LusEcmNotificationErrorNumber = (uint16)((MCU_ECM_STATUS_REG_SIZE * LucECMount) + LucCount); /* PRQA S 4391 # JV-01 */ } } /* Find which ecm source caused this interrupt */ if (MCU_LONG_WORD_ONE == ((LulEcmStatusData >> LucCount) & MCU_LONG_WORD_ONE)) { /* Check whether notification function configured or not */ if (NULL_PTR != LpFeiNotifyFuncPtr) { /* Invoke the configured notification function */ LpFeiNotifyFuncPtr((uint16)LusEcmNotificationErrorNumber); /* PRQA S 2962 # JV-01 */ } /* Release Register Access Protection */ *LpEcmHwInfo->pECMKCPROTReg = MCU_ECM_DISABLE_REG_PROTECT_VALUE; /* Clear status for ECM interrupt */ *LpEcmStatusClearRegAddr = (uint32)(MCU_LONG_WORD_ONE << (uint32)LucCount); /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Hold Register Access protection */ *LpEcmHwInfo->pECMKCPROTReg = MCU_ECM_ENABLE_REG_PROTECT_VALUE;; #if ((MCU_GET_RAM_STATE_API == STD_ON) && \\ (MCU_PROVIDE_RAM_STATE_ISR == STD_ON)) /* Check local ram and cluster ram error */ if (MCU_LONG_WORD_ZERO != (LulEcmStatusData & (LpEcmSetting->pEcmRamErrMask)[LucECMount])) /* PRQA S 2824 # JV-01 */ { /* Set the value of RAM error(error) */ Mcu_GblRAMInitStatus = MCU_RAMSTATE_INVALID; } #endif } } /* Increment the value of index */ LpEcmStatusRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ LpEcmStatusClearRegAddr++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } #if (MCU_ECM_INTERRUPT_CONSISTENCY_CHECK == STD_ON) } #endif /* It should be changed to code that does not depend on the number of cores ... */ if (MCU_ZERO == LucPeNum) { *LpEcmHwInfo->pFEINTC0Reg = MCU_ECM_INT_MASK_FE_VALUE; } else if ( MCU_ONE == LucPeNum) /* PRQA S 2004 # JV-01 */ { *LpEcmHwInfo->pFEINTC1Reg = MCU_ECM_INT_MASK_FE_VALUE; } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_GET_RAM_STATE_API', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_PROVIDE_RAM_STATE_ISR', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_ECM_INTERRUPT_CONSISTENCY_CHECK', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_E_ECM_INT_INCONSISTENT', 'Value': '<is defined>'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpConfigPtr', 'Value': '&map_Mcu_GpConfigPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pFeintNotificationPtr', 'Value': '&ISOLATE_void_func_ptr_uint16'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmSetting', 'Value': '&map_pEcmSetting[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmHwInfo', 'Value': '&map_pEcmHwInfo[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pFIBD0Reg', 'Value': '&map_pFIBD0Reg[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pFIBD0Reg[0]', 'Value': '0x00000002'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'aaEcmIntNotificationValue[0][0 to 11]', 'Value': '[0 to 11] = 0x00000000'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'aaEcmIntTypeRegValue[0 to 11]', 'Value': '[0 to 9] = 0x00000000\\n[11] = 0x00000400'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pECMMESSTR0Reg', 'Value': '&map_pECMMESSTR0Reg[0]'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMMESSTR0Reg[0 to 11]', 'Value': '[0 to 6] = 0x00000000\\n[7] = 0x00000080\\n[8 to 11] = 0x00000000'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pECMCESSTR0Reg', 'Value': '&map_pECMCESSTR0Reg[0]'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMCESSTR0Reg[0 to 11]', 'Value': '[0 to 6] = 0x00000000\\n[7] = 0x00000080\\n[8 to 11] = 0x00000000'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pECMESSTC0Reg', 'Value': '&map_pECMESSTC0Reg[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pEcmRamErrMask', 'Value': '&map_pEcmRamErrMask[0]'], 'Input_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'map_pEcmRamErrMask[0 to 11]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'pFEINTF0Reg', 'Value': '&map_pFEINTF0Reg[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_pFEINTF0Reg[0]', 'Value': '0x0000000F'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'pFEINTF1Reg', 'Value': '&map_pFEINTF1Reg[0]'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_pFEINTF1Reg[0]', 'Value': '0x0000000F'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'pFEINTC0Reg', 'Value': '&map_pFEINTC0Reg[0]'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'pFEINTC1Reg', 'Value': '&map_pFEINTC1Reg[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'pECMKCPROTReg', 'Value': '&map_pECMKCPROTReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusEcmNotificationErrorNumber', 'Value': '-'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'map_pECMESSTC0Reg[0 to 11]', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_pECMKCPROTReg[0]', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GblRAMInitStatus', 'Value': '-'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_pFEINTC0Reg[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_pFEINTC1Reg[0]', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define MCU_START_SEC_PUBLIC_CODE #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(Mcu_PllStatusType, MCU_PUBLIC_CODE) Mcu_GetPllStatus(void) /* PRQA S 1532 # JV-01 */ { Mcu_PllStatusType LenPllLockStatus; if (MCU_UNINITIALIZED == Mcu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { #if (MCU_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if module is not initialized */ (void)Det_ReportError(MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_GETPLLSTATUS_SID, MCU_E_UNINIT); #endif /* (MCU_DEV_ERROR_DETECT == STD_ON) */ /* Set PLL status to undefined */ LenPllLockStatus = MCU_PLL_STATUS_UNDEFINED; } else { LenPllLockStatus = Mcu_GpHwFuncTable->pHwGetPLLStatus(); /* PRQA S 2814 # JV-01 */ } return (LenPllLockStatus); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Variable', 'Range': 'MCU_UNINITIALIZED\\nMCU_INITIALIZED', 'Name': 'Mcu_GblDriverStatus', 'Value': 'MCU_UNINITIALIZED'], 'Input_Param_002': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_005': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'MCU_PLL_STATUS_UNDEFINED'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define MCU_START_SEC_PUBLIC_CODE #include \"Mcu_MemMap.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, MCU_PUBLIC_CODE) Mcu_SetMode(Mcu_ModeType McuMode) /* PRQA S 1503 # JV-01 */ { #if (MCU_DEV_ERROR_DETECT == STD_ON) /* Report to DET, if the component is not initialized */ if (MCU_UNINITIALIZED == Mcu_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_SETMODE_SID, MCU_E_UNINIT); } else if (McuMode >= Mcu_GpConfigPtr->ucNofModeSettings) /* PRQA S 2814 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_SETMODE_SID, MCU_E_PARAM_MODE); } else #endif /* MCU_DEV_ERROR_DETECT == STD_ON */ { Mcu_GpHwFuncTable->pHwSetMode(McuMode); /* PRQA S 2814 # JV-01 */ } /* If Mcu_SetMode is success, it should never return */ return; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'MCU_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Variable', 'Range': 'MCU_UNINITIALIZED\\nMCU_INITIALIZED', 'Name': 'Mcu_GblDriverStatus', 'Value': 'MCU_INITIALIZED'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpConfigPtr', 'Value': '&map_Mcu_GpConfigPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucNofModeSettings', 'Value': '1'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0...255', 'Name': 'McuMode', 'Value': '255']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'MCU_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'MCU_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'MCU_SETMODE_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'MCU_E_PARAM_MODE'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'McuMode', 'Value': '-'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (MCU_VMON_DIAG_OPERATION == STD_ON) #define MCU_START_SEC_PRIVATE_CODE #include \"Mcu_MemMap.h\" FUNC(Std_ReturnType, MCU_PRIVATE_CODE) Mcu_VMNSetVoltageMonitorDiag(void) /* PRQA S 1532 # JV-01 */ { Std_ReturnType LucReturnValue; P2CONST(Mcu_VmonSettingType, MCU_CONST, MCU_CONFIG_DATA) LpVmonSetting; /* PRQA S 3432 # JV-01 */ volatile uint32 LulCount; volatile uint8 LulVmonDiagExpectValue; volatile uint32 LulOPBT4ExpectValue; LulVmonDiagExpectValue = (uint8)MCU_OPBT4_ISOVDDLDE_INIT; LulOPBT4ExpectValue = MCU_OPBT4_ISOVDDLDE_INIT; /* Get the address to Voltage monitor configuration structure */ LpVmonSetting = (P2CONST(Mcu_VmonSettingType, MCU_CONST, MCU_CONFIG_DATA)) /* PRQA S 0316, 3432 # JV-01, JV-01 */ (Mcu_GpConfigPtr->pVmonSetting); /* PRQA S 2814 # JV-01 */ /* Initialize the following variables */ LucReturnValue = E_OK; *Mcu_GpVmonHwInfo->pVMONKCPROTReg = MCU_VMON_DISABLE_REG_PROTECT_VALUE; /* PRQA S 2814 # JV-01 */ /* Check VMONF register value */ LulCount = (uint32)MCU_VMONDIAG_CLEARRETRY_MAX; while ((MCU_VMON_VMONF_NO_VIOLATION != (*Mcu_GpVmonHwInfo->pVMONFReg)) && (LulCount > (uint32)MCU_ZERO)) /* PRQA S 3415, 3416 # JV-01, JV-01 */ { /* Clear VMONF violation */ *Mcu_GpVmonHwInfo->pVMONFCReg = MCU_VMON_VMONFC_ALL_CLEAR_VALUE; LulCount--; /* PRQA S 3384, 3387 # JV-01, JV-01 */ } /* VMONF check */ if (MCU_VMON_VMONF_NO_VIOLATION != (*Mcu_GpVmonHwInfo->pVMONFReg)) /* PRQA S 0404 # JV-01 */ { LucReturnValue = E_NOT_OK; } else { /* Check VMONDIAGME register value */ if (MCU_VMON_VMONDIAGME_CANNOT_ENABLE_VALUE != *Mcu_GpVmonHwInfo->pVMONDIAGMEReg) /* PRQA S 0404 # JV-01 */ { /* Set VMONDMASK to all reset request masked */ *Mcu_GpVmonHwInfo->pVMONDMASKReg = MCU_VMON_VMONDMASK_ALL_MASK_VALUE; /* Set VMONDIAG to all detection enable */ *Mcu_GpVmonHwInfo->pVMONDIAGReg = MCU_VMON_VMONDIAG_ALL_DETECTION_ENABLE_VALUE; /* Wait specific time */ /* Wait for switching clock sources */ LulCount = (uint32)MCU_VMON_WAIT_CNT_NUM; /* PRQA S 2814 # JV-01 */ while (MCU_LONG_WORD_ZERO < LulCount) /* PRQA S 3416 # JV-01 */ { LulCount--; /* PRQA S 3384, 3387 # JV-01, JV-01 */ EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ } LulOPBT4ExpectValue = ((*Mcu_GpVmonHwInfo->pOPBT4Reg) & MCU_OPBT4_ISOVDDHDE_MASK); /* PRQA S 0404, 2814 # JV-01, JV-01 */ if (MCU_OPBT4_ISOVDDLDE_ENABLE == LulOPBT4ExpectValue) /* PRQA S 3416 # JV-01 */ { LulVmonDiagExpectValue |= MCU_VMON_VMONF_ISOVDDLVF_VIOLATION; } if (MCU_VMON_VMONF_VIOLATION != ((*Mcu_GpVmonHwInfo->pVMONFReg) | LulVmonDiagExpectValue)) /* PRQA S 0404 # JV-01 */ { LucReturnValue = E_NOT_OK; } else { /* Set VMONDIAG to all detection disable */ *Mcu_GpVmonHwInfo->pVMONDIAGReg = MCU_VMON_VMONDIAG_NO_DETECTION_ENABLE_VALUE; /* Wait specific time */ /* Wait for switching clock sources */ LulCount = (uint32)MCU_VMON_WAIT_CNT_NUM; while (LulCount > MCU_LONG_WORD_ZERO) /* PRQA S 3416 # JV-01 */ { LulCount--; /* PRQA S 3384, 3387 # JV-01, JV-01 */ EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ } LulCount = (uint32)MCU_VMONDIAG_CLEARRETRY_MAX; /* Clear VMONF violation */ do { /* Set MCU_VMONFC until MCU_VMONF all clear */ *Mcu_GpVmonHwInfo->pVMONFCReg = MCU_VMON_VMONFC_ALL_CLEAR_VALUE; /* PRQA S 2814 # JV-01 */ EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ LulCount--; /* PRQA S 3384, 3387 # JV-01, JV-01 */ } while ((MCU_VMON_VMONF_NO_VIOLATION != (*Mcu_GpVmonHwInfo->pVMONFReg)) /* PRQA S 2814, 3415, 3416 # JV-01, JV-01, JV-01 */ && (LulCount > (uint32)MCU_ZERO)); if (MCU_VMON_VMONF_NO_VIOLATION != (*Mcu_GpVmonHwInfo->pVMONFReg)) /* PRQA S 0404, 2814 # JV-01, JV-01 */ { LucReturnValue = E_NOT_OK; } else { /* Clear MCU_VMONDMASK */ (*Mcu_GpVmonHwInfo->pVMONDMASKReg) = MCU_VMON_VMONDMASK_ALL_CLEAR_VALUE; /* Set ISOVDDDE.ISOVDDCIRREN */ (*Mcu_GpVmonHwInfo->pISOVDDDEReg) |= LpVmonSetting->ucVMONISOVDDDEValue; /* PRQA S 2814 # JV-01 */ /* Set AWOVDDDE.AWOVDDCIRREN */ (*Mcu_GpVmonHwInfo->pAWOVDDDEReg) |= LpVmonSetting->ucVMONAWOVDDDEValue; /* VMONDIAGME set to \"VMON DIAG cannot enable\" */ (*Mcu_GpVmonHwInfo->pVMONDIAGMEWReg) = MCU_VMON_VMONDIAGME_CANNOT_ENABLE_VALUE; } } } } (*Mcu_GpVmonHwInfo->pVMONKCPROTReg) = MCU_VMON_ENABLE_REG_PROTECT_VALUE; /* PRQA S 2814 # JV-01 */ return(LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpConfigPtr', 'Value': '&map_Mcu_GpConfigPtr[0]'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'pVmonSetting', 'Value': '&map_pVmonSetting[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpVmonHwInfo', 'Value': '&map_Mcu_GpVmonHwInfo[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pVMONKCPROTReg', 'Value': '&map_pVMONKCPROTReg[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pVMONFReg', 'Value': '&map_pVMONFReg[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_pVMONFReg[0]', 'Value': '0x7'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pVMONFCReg', 'Value': '&map_pVMONFCReg[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pVMONDIAGMEReg', 'Value': '&map_pVMONDIAGMEReg[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_pVMONDIAGMEReg[0]', 'Value': '1'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pVMONDMASKReg', 'Value': '&map_pVMONDMASKReg[0] '], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pVMONDIAGReg', 'Value': '&map_pVMONDIAGReg[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Mcu_GpClockSetting', 'Value': '&map_Mcu_GpClockSetting[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulClkStbCount', 'Value': '0x0000'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pOPBT4Reg', 'Value': '&map_pOPBT4Reg[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_pOPBT4Reg[0]', 'Value': '0xFFFFFFFF'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucVMONISOVDDDEValue', 'Value': '0xFF'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucVMONAWOVDDDEValue', 'Value': '0xFF'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'pISOVDDDEReg', 'Value': '&map_pISOVDDDEReg[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_pISOVDDDEReg[0]', 'Value': '0xFF'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'pAWOVDDDEReg', 'Value': '&map_pAWOVDDDEReg[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'pVMONDIAGMEWReg', 'Value': '&map_pVMONDIAGMEWReg[0]']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_pVMONKCPROTReg[0]', 'Value': 'MCU_VMON_ENABLE_REG_PROTECT_VALUE'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_pVMONFCReg[0]', 'Value': 'MCU_VMON_VMONFC_ALL_CLEAR_VALUE'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_pVMONDMASKReg[0]', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_pVMONDIAGReg[0]', 'Value': '-'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_pISOVDDDEReg[0]', 'Value': '-'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_pAWOVDDDEReg[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'map_pVMONDIAGMEWReg[0]', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC (Std_ReturnType, PORT_PRIVATE_CODE) Port_ChangePinDirection (CONST(Port_PinDirectionType, AUTOMATIC) LddDirection, /* PRQA S 1532 # JV-01 */ P2CONST(volatile Port_PinsDirChangeable, AUTOMATIC, PORT_APPL_CONST) LpChangeablePin)/* PRQA S 3432 # JV-01 */ { /* Local Pointer to point INOUTSEL register address */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpINOUTSELRegAdd; /* PRQA S 3432 # JV-01 */ /* Local Pointer to point OUTDTSEL register address */ P2CONST(volatile uint32, AUTOMATIC, REGSPACE) LpOUTDTSELRegAdd; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Local Pointer to point OUTDTSEL register address */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpOUTDTLRegAdd; /* PRQA S 3432 # JV-01 */ /* Local Pointer to point OUTDTSEL register address */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpOUTDTHRegAdd; /* PRQA S 3432 # JV-01 */ /* Local Pointer to point OUTDTSEL register address */ P2VAR(volatile uint32, AUTOMATIC, REGSPACE) LpOUTDTRegAdd; /* PRQA S 3432 # JV-01 */ /* Local variable to store offset */ VAR(volatile uint16, AUTOMATIC) LusOffsetRegs; VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Initialize value*/ LddReturnValue = E_OK; /* PRQA S 2982 # JV-01 */ #if (PORT_EXCLUSIVE_CONTROL == STD_ON) /* Get exclusive control for GPIO module */ LddReturnValue = Port_ExclusiveControl(PORT_GET_EXCLUSIVE); if (E_OK == LddReturnValue) { #endif /* PORT_EXCLUSIVE_CONTROL == STD_ON */ /* Get offset of INOUTSEL registers*/ LusOffsetRegs = LpChangeablePin->usINOUTSELRegAddrOffset; /* PRQA S 2814 # JV-01 */ /* Get Address of INOUTSEL registers*/ LpINOUTSELRegAdd = GET_ADD_FROM_OFFSET(LusOffsetRegs); /* PRQA S 3432, 3464, 0303, 3383, 3384, 0404 # JV-01, JV-01, JV-01, JV-01, JV-01, JV-01 */ /* if requested direction is INPUT and current direction is OUTPUT */ if ((PORT_PIN_IN == LddDirection) && ((*LpINOUTSELRegAdd & LpChangeablePin->ulOrMaskVal) == /* PRQA S 2814, 2844, 0404 # JV-01, JV-01, JV-01 */ LpChangeablePin->ulOrMaskVal)) { /* Set the requested direction for the corresponding pin position */ *LpINOUTSELRegAdd &= ~LpChangeablePin->ulOrMaskVal; } /* Else no action required */ /* End of if ((PORT_PIN_IN == LddDirection) && * ((*LpINOUTSELRegAdd & LpChangeablePin->ulOrMaskVal) == * LpChangeablePin->ulOrMaskVal)) */ /* if requested direction is OUTPUT and current direction is INPUT */ if ((PORT_PIN_OUT == LddDirection) && (PORT_WORD_ZERO == (*LpINOUTSELRegAdd & LpChangeablePin->ulOrMaskVal))) /* PRQA S 0404 # JV-01 */ { /* Get offset of OUTDTSEL from offset INOUTSEL registers*/ LusOffsetRegs = COV_OFFSET_INOUTSEL_TO_OUTDTSEL(LpChangeablePin->usINOUTSELRegAddrOffset); /* PRQA S 0404, 3432, 3383 # JV-01, JV-01, JV-01 */ LpOUTDTSELRegAdd = GET_ADD_FROM_OFFSET(LusOffsetRegs); /* PRQA S 3432, 3464, 0303, 3383, 3384, 0404 # JV-01, JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Check if data out is output by OUTDTH/OUTDTL register */ if ((*LpOUTDTSELRegAdd & LpChangeablePin->ulOrMaskVal) == LpChangeablePin->ulOrMaskVal) /* PRQA S 2844, 0404, 2814 # JV-01, JV-01, JV-01 */ { /* Get offset of OUTDTL from offset INOUTSEL registers*/ LusOffsetRegs = COV_OFFSET_INOUTSEL_TO_OUTDTL(LpChangeablePin->usINOUTSELRegAddrOffset); /* PRQA S 0404, 3432, 3383 # JV-01, JV-01, JV-01 */ LpOUTDTLRegAdd = GET_ADD_FROM_OFFSET(LusOffsetRegs); /* PRQA S 3432, 3464, 0303, 3383, 3384, 0404 # JV-01, JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Get offset of OUTDTH from offset INOUTSEL registers*/ LusOffsetRegs = COV_OFFSET_INOUTSEL_TO_OUTDTH(LpChangeablePin->usINOUTSELRegAddrOffset); /* PRQA S 0404, 3432, 3383 # JV-01, JV-01, JV-01 */ LpOUTDTHRegAdd = GET_ADD_FROM_OFFSET(LusOffsetRegs); /* PRQA S 3432, 3464, 0303, 3383, 3384, 0404 # JV-01, JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Clear bit at position required to write */ *LpOUTDTLRegAdd &= ~(LpChangeablePin->ulOrMaskVal); /* PRQA S 2844, 2814 # JV-01, JV-01 */ /* Write configured value to OUTDTL */ *LpOUTDTLRegAdd |= LpChangeablePin->ulChangeableConfigVal; /* Clear bit at position required to write */ *LpOUTDTHRegAdd &= ~(LpChangeablePin->ulOrMaskVal); /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Write configured value to OUTDTH */ *LpOUTDTHRegAdd |= LpChangeablePin->ulChangeableConfigVal; } /* Data out is output by OUTDT register */ else { /* Get offset of OUTDT from offset INOUTSEL registers*/ LusOffsetRegs = COV_OFFSET_INOUTSEL_OUTDT(LpChangeablePin->usINOUTSELRegAddrOffset); /* PRQA S 0404, 3432, 3383 # JV-01, JV-01, JV-01 */ LpOUTDTRegAdd = GET_ADD_FROM_OFFSET(LusOffsetRegs); /* PRQA S 3432, 3464, 0303, 3383, 3384, 0404 # JV-01, JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Clear bit at position required to write */ *LpOUTDTRegAdd &= ~(LpChangeablePin->ulOrMaskVal); /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Write configured value to OUTDT */ *LpOUTDTRegAdd |= LpChangeablePin->ulChangeableConfigVal; } /* End of if ((*LpOUTDTSELRegAdd & LpChangeablePin->ulOrMaskVal) * == LpChangeablePin->ulOrMaskVal) */ /* Set the requested direction for the corresponding pin position */ *LpINOUTSELRegAdd |= LpChangeablePin->ulOrMaskVal; } /* Else no action required */ /* End of if if ((PORT_PIN_OUT == LddDirection) && (PORT_WORD_ZERO == \\ * (*LpINOUTSELRegAdd & LpChangeablePin->ulOrMaskVal))) */ #if (PORT_EXCLUSIVE_CONTROL == STD_ON) /* Release exclusive control from another CPU for PFC */ (void) Port_ExclusiveControl(PORT_RELEASE_EXCLUSIVE); } else { /* Release exclusive control from another CPU for PFC */ (void) Port_ExclusiveControl(PORT_RELEASE_EXCLUSIVE); } /* End of if (E_OK == LddReturnValue) */ #endif return LddReturnValue; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_NUM_PORT_GROUPS_AVAILABLE', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_EXCLUSIVE_CONTROL', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_SET_PIN_DIRECTION_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LddDirection', 'Value': 'PORT_PIN_IN'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LpChangeablePin', 'Value': '&map_LpDirChangeablePin[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'INOUTSEL', 'Name': 'usINOUTSELRegAddrOffset', 'Value': '0x3FFF'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulOrMaskVal', 'Value': '0x000000FF'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulChangeableConfigVal', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'INOUTSEL', 'Name': 'map_PORT_USER_BASE_ADDRESS1[16383]', 'Value': '0x0000FFFF'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_PORT_USER_BASE_ADDRESS1[32767]', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'OUTDTSEL', 'Name': 'map_PORT_USER_BASE_ADDRESS2[59]', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': 'OUTDTL', 'Name': 'map_PORT_USER_BASE_ADDRESS2[67]', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'OUTDTH', 'Name': 'map_PORT_USER_BASE_ADDRESS2[63]', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': 'OUTDT', 'Name': 'map_PORT_USER_BASE_ADDRESS2[3]', 'Value': '-'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0 to 1] = E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'enExclusiveType', 'Value': '[0] = PORT_GET_EXCLUSIVE\\n[1] = PORT_RELEASE_EXCLUSIVE'], 'Output_Param_001': ['Type': 'Variable', 'Range': 'IN/OUT SEL', 'Name': 'map_PORT_USER_BASE_ADDRESS1[16383]', 'Value': '0x0000FF00'], 'Output_Param_002': ['Type': 'Variable', 'Range': 'IN/OUT SEL', 'Name': 'map_PORT_USER_BASE_ADDRESS1[32767]', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_PORT_USER_BASE_ADDRESS2[59]', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_PORT_USER_BASE_ADDRESS2[67]', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_PORT_USER_BASE_ADDRESS2[63]', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_PORT_USER_BASE_ADDRESS2[3]', 'Value': '-'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return_Value', 'Value': 'E_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PORT_FUSE_MONITORING_API == STD_ON) FUNC(Std_ReturnType, PORT_PRIVATE_CODE) Port_CheckExpectedFUSEValue(void) /* PRQA S 1532 # JV-01 */ { VAR(uint8, AUTOMATIC) LucIndex; VAR(uint8, AUTOMATIC) LucSizeOfArray; /* Variable to store the return value of function */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; /* Pointer to FUSE data structure */ P2CONST (Port_FUSEInfo, AUTOMATIC, PORT_CONFIG_DATA) LpFUSEInfoStruct; /* PRQA S 3432 # JV-01 */ /* Initialize the return value */ LddReturnValue = E_OK; /* Get size of FUSE array of structure */ LucSizeOfArray = PORT_MAX_NO_FUSE_REG; /* Get pointer to FUSE array of structure */ LpFUSEInfoStruct = &Port_GstFUSEInfo[0]; /* PRQA S 2814 # JV-01 */ /* Traverse list of FUSE info in each register */ for (LucIndex = PORT_ZERO ; ((LucIndex < LucSizeOfArray)&&(E_OK == LddReturnValue)); LucIndex++) { /* Check if value of FUSE registers are expected value */ if ((LpFUSEInfoStruct[LucIndex].ulFuSeValueExpected & LpFUSEInfoStruct[LucIndex].ulFuSeMaskRegister) != (*((volatile uint32*)(LpFUSEInfoStruct[LucIndex].ulAddressRegisterFuSe)) & /* PRQA S 0303, 2814 # JV-01, JV-01 */ LpFUSEInfoStruct[LucIndex].ulFuSeMaskRegister)) { /* Report error to DEM */ (void) Dem_SetEventStatus(PORT_E_FUSE_MONITORING_FAILURE, DEM_EVENT_STATUS_FAILED); /* Set return value to E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Else no action required */ } return (LddReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_FUSE_MONITORING_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Port_GstFUSEInfo', 'Value': '&Port_GstFUSEInfo[0]'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'ulAddressRegisterFuSe', 'Value': '[0] = &map_ulAddressRegisterFuSe[0]\\n[1] = &map_ulAddressRegisterFuSe[1]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'map_ulAddressRegisterFuSe[0 to PORT_MAX_NO_FUSE_REG]', 'Value': '[0] = 0xFFFFFFFF\\n[1] = 0x00000002'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulFuSeMaskRegister', 'Value': '[0] = 0xFFFFFFFF\\n[1] = 0xFFFFFFFF'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ulFuSeValueExpected', 'Value': '[0] = 0xFFFFFFFF\\n[1] = 0xFFFFFFFF']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'PORT_E_FUSE_MONITORING_FAILURE'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_002': ['Type': 'Return_Value', 'Range': '', 'Name': 'LddReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((PORT_SET_TO_DIO_ALT_MODE_API == STD_ON) && (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON)) static FUNC_P2CONST (Port_PinDioAltChangeableDetails, PORT_APPL_CONST, /* PRQA S 1505 # JV-01 */ PORT_PRIVATE_CODE) Port_SearchDioAltModePin(const Port_PinType LddPinNumber, /* PRQA S 3432 # JV-01 */ P2CONST(Port_PinDioAltChangeableDetails, AUTOMATIC, PORT_APPL_CONST) LpStartPtr) /* PRQA S 3432 # JV-01 */ { P2CONST (Port_PinDioAltChangeableDetails, AUTOMATIC, PORT_APPL_CONST) LpRetPtr; /* PRQA S 3432 # JV-01 */ VAR(uint16, AUTOMATIC) LusListSearchId; VAR(uint8, AUTOMATIC) LucNoOfPinsDioAlt; VAR(uint8, AUTOMATIC) LucIndex; /* Initializing Pointer to Null pointer */ LpRetPtr = NULL_PTR; /* Check pPinDioAltModeDetails is not NULL */ if (NULL_PTR != LpStartPtr) { /* Get the lower limit of Search ID */ LusListSearchId = LpStartPtr->ddPinId; /* PRQA S 2814 # JV-01 */ /* Get number of pins is configured as dio or alt changeable */ LucNoOfPinsDioAlt = PORT_NUM_PINS_DIO_ALT_CHANGEABLE; /* Check whether searched pin is at the first of search list */ if (LddPinNumber != LusListSearchId) { if (PORT_ZERO != LucNoOfPinsDioAlt) /* PRQA S 2991, 2995 # JV-01, JV-01 */ { /* Traverse remain list */ for (LucIndex = PORT_ONE; ((LucIndex < LucNoOfPinsDioAlt) && (LpRetPtr == NULL_PTR)); LucIndex++) /* PRQA S 0488, 2824 # JV-01, JV-01 */ { /* Get the ID of next element */ LusListSearchId = (LpStartPtr + LucIndex)->ddPinId; /* PRQA S 0488 # JV-01 */ /* Compare Search-ID with the requested one */ if (LusListSearchId == LddPinNumber) { /* Update the return pointer with the pin number structure */ LpRetPtr = (LpStartPtr + LucIndex); /* PRQA S 0488 # JV-01 */ } /* End of LusListSearchId == LddPinNumber */ /* Else no action required */ } } /* Else no action required */ } else { /* Update the return pointer with start pointer (Matches with first Id) */ LpRetPtr = LpStartPtr; } /* End of if (LddPinNumber != LusListSearchId) */ } /* Else no action required */ return (LpRetPtr); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, \\nSTD_OFF', 'Name': 'PORT_SET_PIN_DIRECTION_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON, \\nSTD_OFF', 'Name': 'PORT_NUM_PORT_GROUPS_AVAILABLE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x0000\u20260xFFFF', 'Name': 'LddPinNumber', 'Value': '0x00FF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x0000\u20260xFFFF', 'Name': 'LpStartPtr', 'Value': '&map_LpStartPtr_DioAlt[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '0x0001\u20260xFFFF', 'Name': 'ddPinId', 'Value': '[0] = 0x0000\\n[1] = 0x0001\\n[2] = 0x0005\\n[3] = 0x00FA\\n[4] = 0x00FB\\n[5] = 0x00FC\\n[6] = 0x00FC']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LpRetPtr', 'Value': 'NULL_PTR'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((PORT_SET_TO_DIO_ALT_MODE_API == STD_ON) && (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON)) static FUNC_P2CONST (Port_PinDioAltChangeableDetails, PORT_APPL_CONST, /* PRQA S 1505 # JV-01 */ PORT_PRIVATE_CODE) Port_SearchDioAltModePin(const Port_PinType LddPinNumber, /* PRQA S 3432 # JV-01 */ P2CONST(Port_PinDioAltChangeableDetails, AUTOMATIC, PORT_APPL_CONST) LpStartPtr) /* PRQA S 3432 # JV-01 */ { P2CONST (Port_PinDioAltChangeableDetails, AUTOMATIC, PORT_APPL_CONST) LpRetPtr; /* PRQA S 3432 # JV-01 */ VAR(uint16, AUTOMATIC) LusListSearchId; VAR(uint8, AUTOMATIC) LucNoOfPinsDioAlt; VAR(uint8, AUTOMATIC) LucIndex; /* Initializing Pointer to Null pointer */ LpRetPtr = NULL_PTR; /* Check pPinDioAltModeDetails is not NULL */ if (NULL_PTR != LpStartPtr) { /* Get the lower limit of Search ID */ LusListSearchId = LpStartPtr->ddPinId; /* PRQA S 2814 # JV-01 */ /* Get number of pins is configured as dio or alt changeable */ LucNoOfPinsDioAlt = PORT_NUM_PINS_DIO_ALT_CHANGEABLE; /* Check whether searched pin is at the first of search list */ if (LddPinNumber != LusListSearchId) { if (PORT_ZERO != LucNoOfPinsDioAlt) /* PRQA S 2991, 2995 # JV-01, JV-01 */ { /* Traverse remain list */ for (LucIndex = PORT_ONE; ((LucIndex < LucNoOfPinsDioAlt) && (LpRetPtr == NULL_PTR)); LucIndex++) /* PRQA S 0488, 2824 # JV-01, JV-01 */ { /* Get the ID of next element */ LusListSearchId = (LpStartPtr + LucIndex)->ddPinId; /* PRQA S 0488 # JV-01 */ /* Compare Search-ID with the requested one */ if (LusListSearchId == LddPinNumber) { /* Update the return pointer with the pin number structure */ LpRetPtr = (LpStartPtr + LucIndex); /* PRQA S 0488 # JV-01 */ } /* End of LusListSearchId == LddPinNumber */ /* Else no action required */ } } /* Else no action required */ } else { /* Update the return pointer with start pointer (Matches with first Id) */ LpRetPtr = LpStartPtr; } /* End of if (LddPinNumber != LusListSearchId) */ } /* Else no action required */ return (LpRetPtr); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, \\nSTD_OFF', 'Name': 'PORT_SET_PIN_DIRECTION_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON, \\nSTD_OFF', 'Name': 'PORT_NUM_PORT_GROUPS_AVAILABLE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x0000\u20260xFFFF', 'Name': 'LddPinNumber', 'Value': '0x0005'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x0000\u20260xFFFF', 'Name': 'LpStartPtr', 'Value': '&map_LpStartPtr_DioAlt[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '0x0001\u20260xFFFF', 'Name': 'ddPinId', 'Value': '[0 to 6] = 0x0005']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LpRetPtr', 'Value': '&map_LpStartPtr_DioAlt[0]'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PORT_SET_PIN_MODE_API == STD_ON) #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) FUNC_P2CONST (Port_PinModeChangeableDetails, PORT_APPL_CONST, PORT_PRIVATE_CODE) /* PRQA S 3432 # JV-01 */ Port_SearchModeChangeablePin(const Port_PinType LddPinNumber, /* PRQA S 1532 # JV-01 */ P2CONST(Port_PinModeChangeableDetails, AUTOMATIC, PORT_APPL_CONST) LpStartPtr) /* PRQA S 3432 # JV-01 */ { P2CONST (Port_PinModeChangeableDetails, AUTOMATIC, PORT_APPL_CONST) LpRetPtr; /* PRQA S 3432 # JV-01 */ VAR(uint16, AUTOMATIC) LusListSearchId; VAR(uint8, AUTOMATIC) LucIndex; uint8 Lucsize; /* Initializing Pointer to Null pointer */ LpRetPtr = NULL_PTR; /* Get the ID of first element */ LusListSearchId = LpStartPtr->ddPinId; /* PRQA S 2814 # JV-01 */ Lucsize = PORT_NUM_PINS_MODE_CHANGEABLE; /* Check whether searched pin is at the first of search list */ if (LddPinNumber != LusListSearchId) { /* Traverse remain list */ for (LucIndex = PORT_ONE; ((LucIndex < Lucsize) && (LpRetPtr == NULL_PTR)); LucIndex++) { /* Get the ID of next element */ LusListSearchId = (LpStartPtr + LucIndex)->ddPinId; /* PRQA S 0488, 2824 # JV-01, JV-01 */ /* Compare Search-ID with the requested one */ if (LusListSearchId == LddPinNumber) { /* Update the return pointer with the pin number structure */ LpRetPtr = (LpStartPtr + LucIndex); /* PRQA S 0488 # JV-01 */ } /* End of LusListSearchId == LddPinNumber */ /* Else no action required */ } } else { /* Update the return pointer with start pointer (Matches with first Id) */ LpRetPtr = LpStartPtr; } /* End of if (LddPinNumber != LusListSearchId) */ return (LpRetPtr); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, \\nSTD_OFF', 'Name': 'PORT_SET_PIN_DIRECTION_API', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON, \\nSTD_OFF', 'Name': 'PORT_NUM_PORT_GROUPS_AVAILABLE', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x0000\u20260xFFFF', 'Name': 'LddPinNumber', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x0000\u20260xFFFF', 'Name': 'LpStartPtr', 'Value': '-'], 'Input_Param_004': ['Type': 'Array', 'Range': '0x0001\u20260xFFFF', 'Name': 'ddPinId', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LpRetPtr', 'Value': '-'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PORT_SET_PIN_MODE_API == STD_ON) #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) FUNC_P2CONST (Port_PinModeChangeableDetails, PORT_APPL_CONST, PORT_PRIVATE_CODE) /* PRQA S 3432 # JV-01 */ Port_SearchModeChangeablePin(const Port_PinType LddPinNumber, /* PRQA S 1532 # JV-01 */ P2CONST(Port_PinModeChangeableDetails, AUTOMATIC, PORT_APPL_CONST) LpStartPtr) /* PRQA S 3432 # JV-01 */ { P2CONST (Port_PinModeChangeableDetails, AUTOMATIC, PORT_APPL_CONST) LpRetPtr; /* PRQA S 3432 # JV-01 */ VAR(uint16, AUTOMATIC) LusListSearchId; VAR(uint8, AUTOMATIC) LucIndex; uint8 Lucsize; /* Initializing Pointer to Null pointer */ LpRetPtr = NULL_PTR; /* Get the ID of first element */ LusListSearchId = LpStartPtr->ddPinId; /* PRQA S 2814 # JV-01 */ Lucsize = PORT_NUM_PINS_MODE_CHANGEABLE; /* Check whether searched pin is at the first of search list */ if (LddPinNumber != LusListSearchId) { /* Traverse remain list */ for (LucIndex = PORT_ONE; ((LucIndex < Lucsize) && (LpRetPtr == NULL_PTR)); LucIndex++) { /* Get the ID of next element */ LusListSearchId = (LpStartPtr + LucIndex)->ddPinId; /* PRQA S 0488, 2824 # JV-01, JV-01 */ /* Compare Search-ID with the requested one */ if (LusListSearchId == LddPinNumber) { /* Update the return pointer with the pin number structure */ LpRetPtr = (LpStartPtr + LucIndex); /* PRQA S 0488 # JV-01 */ } /* End of LusListSearchId == LddPinNumber */ /* Else no action required */ } } else { /* Update the return pointer with start pointer (Matches with first Id) */ LpRetPtr = LpStartPtr; } /* End of if (LddPinNumber != LusListSearchId) */ return (LpRetPtr); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_ON, \\nSTD_OFF', 'Name': 'PORT_SET_PIN_DIRECTION_API', 'Value': '-'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON, \\nSTD_OFF', 'Name': 'PORT_NUM_PORT_GROUPS_AVAILABLE', 'Value': '-'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x0000\u20260xFFFF', 'Name': 'LddPinNumber', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x0000\u20260xFFFF', 'Name': 'LpStartPtr', 'Value': '-'], 'Input_Param_004': ['Type': 'Array', 'Range': '0x0001\u20260xFFFF', 'Name': 'ddPinId', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LpRetPtr', 'Value': '-'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC (void, PORT_PUBLIC_CODE) Port_SetPinDefaultDirection (const Port_PinType LddPinNumber) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) /* Local pointer to return address from Port_SearchDirChangeablePin */ P2CONST(volatile Port_PinsDirChangeable, AUTOMATIC, PORT_APPL_CONST) LpChangeablePinDet; /* PRQA S 3432 # JV-01 */ /* Pointer to Direction Control Registers Data structure */ P2CONST (Port_INOUTSELRegs, AUTOMATIC, PORT_APPL_CONST) LpPortINOUTSELReg; /* PRQA S 3432 # JV-01 */ /* Local variable to store LulInitModeRegVal */ VAR(volatile uint32, AUTOMATIC) LulInitModeRegVal; #endif /* End of PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) VAR(Port_PinDirectionType, AUTOMATIC) LddDirection; #endif /* End of #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) */ /* Initialize the value of LddReturnValue*/ LddReturnValue = E_OK; /* Solve unused parameter error */ #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_OFF) (void) LddPinNumber; #endif /* End of #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) */ /* Check whether the PORT module is initialized */ if (PORT_UNINITIALIZED == Port_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError (PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_PIN_DEFAULT_DIR_SID, PORT_E_UNINIT); /* Set Return Value as E_NOT_OK */ #endif /* End of PORT_DEV_ERROR_DETECT == STD_ON */ LddReturnValue = E_NOT_OK; } /* Else no action required */ /* End of if (E_OK == LddReturnValue) */ /* Check valid input port pin*/ if (E_OK == LddReturnValue) { /* Check whether the requested LddPinNumber number is invalid */ #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) if (PORT_TOTAL_NUMBER_OF_PINS <= LddPinNumber) { #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError (PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_PIN_DEFAULT_DIR_SID, PORT_E_PARAM_PIN); #endif /* End of PORT_DEV_ERROR_DETECT == STD_ON */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Else no action required */ #else #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError (PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_PIN_DEFAULT_DIR_SID, PORT_E_PARAM_PIN); #endif /* End of PORT_DEV_ERROR_DETECT == STD_ON */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; #endif /* End of #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) */ } /* Else no action required */ /*End of if (E_OK == LddReturnValue)*/ /* Check valid the LddPinNumber direction changeable*/ if (E_OK == LddReturnValue) /* PRQA S 2992, 2996 # JV-01, JV-01 */ { #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) /* Check whether the LddPinNumber direction is changeable at run time */ LpChangeablePinDet = Port_SearchDirChangeablePin (LddPinNumber, Port_GpConfigPtr->pPinDirChangeable); /* PRQA S 2814 # JV-01 */ /* Return value LpChangeablePinDet - Changeable, NULL - Unchangeable */ if (NULL_PTR == LpChangeablePinDet) { #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_PIN_DEFAULT_DIR_SID, PORT_E_DIRECTION_UNCHANGEABLE); #endif /* End of PORT_DEV_ERROR_DETECT == STD_ON */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Else no action required */ #endif /* End of #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) */ } /* Else no action required */ /* End of if (E_OK == LddReturnValue) */ if (E_OK == LddReturnValue) /* PRQA S 2992, 2996 # JV-01, JV-01 */ { #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) /* Get the base address of the corresponding Port Type */ LpPortINOUTSELReg = Port_GpConfigPtr->pPortNumINOUTSELRegs; /* PRQA S 2814 # JV-01 */ LulInitModeRegVal = (LpPortINOUTSELReg + LpChangeablePinDet->ucINOUTSELRegIndex)->ulInitModeRegVal; /* PRQA S 0488, 2814 # JV-01, JV-01 */ /* Enter critical section */ #if (PORT_CRITICAL_SECTION_PROTECTION == STD_ON) PORT_ENTER_CRITICAL_SECTION(PORT_INTERRUPT_CONTROL_PROTECTION); #endif /* End of PORT_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get pin direction */ if(PORT_WORD_ZERO == (LulInitModeRegVal & LpChangeablePinDet->ulOrMaskVal)) /* PRQA S 0404 # JV-01 */ { LddDirection = PORT_PIN_IN; } else { LddDirection = PORT_PIN_OUT; } /* Get return value */ LddReturnValue = Port_ChangePinDirection(LddDirection, LpChangeablePinDet); /* PRQA S 2983 # JV-01 */ /* Exit critical section */ #if (PORT_CRITICAL_SECTION_PROTECTION == STD_ON) PORT_EXIT_CRITICAL_SECTION(PORT_INTERRUPT_CONTROL_PROTECTION); #endif /* End of PORT_CRITICAL_SECTION_PROTECTION == STD_ON */ #if((PORT_DEM_ERROR_DETECT == STD_ON) && (PORT_EXCLUSIVE_CONTROL == STD_ON)) /* Check error exclusive control */ if(E_NOT_OK == LddReturnValue) { /* Raise DEM status fail error */ (void) Dem_SetEventStatus(PORT_E_GET_CONTROL_FAILURE, DEM_EVENT_STATUS_FAILED); } /* Else no action required */ #endif /* End of ((PORT_DEM_ERROR_DETECT == STD_ON) && (PORT_EXCLUSIVE_CONTROL == STD_ON)) */ #endif /* End of PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON */ } /* Else no action required */ /* End of E_OK == LddReturnValue */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_NUM_PORT_GROUPS_AVAILABLE', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0.. PORT_TOTAL_NUMBER_OF_PINS-1', 'Name': 'LddPinNumber', 'Value': '0x0000'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'PORT_UNINITIALIZED.. PORT_INITIALIZED ', 'Name': 'Port_GblDriverStatus', 'Value': 'PORT_UNINITIALIZED'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Port_GpConfigPtr', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pPinDirChangeable', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pPortNumINOUTSELRegs', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucINOUTSELRegIndex', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulInitModeRegVal', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulOrMaskVal', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddPinNumber', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpStartPtr', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'PORT_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'PORT_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'PORT_SET_PIN_DEFAULT_DIR_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'PORT_E_UNINIT'], 'Output_Param_006': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddDirection', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChangeablePin', 'Value': '-'], 'Output_Param_009': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC (void, PORT_PUBLIC_CODE) Port_SetPinDirection (Port_PinType Pin, Port_PinDirectionType Direction) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) /* Local pointer to return address from Port_SearchDirChangeablePin */ P2CONST(volatile Port_PinsDirChangeable, AUTOMATIC, PORT_APPL_CONST) LpChangeablePinDet; /* PRQA S 3432 # JV-01 */ #endif /* End of PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; LddReturnValue = E_OK; /* Solve unused parameter error */ #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_OFF) (void) Pin; (void) Direction; #endif /* End of PORT_NUM_PORT_GROUPS_AVAILABLE == STD_OFF */ /* Check whether the PORT module is Initialized */ if (PORT_UNINITIALIZED == Port_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError (PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_PIN_DIR_SID, PORT_E_UNINIT); #endif /* End of PORT_DEV_ERROR_DETECT == STD_ON */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Else no action required */ /* Check valid input port pin */ if (E_OK == LddReturnValue) { /* Check whether the requested PIN number is invalid */ #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) if (PORT_TOTAL_NUMBER_OF_PINS <= Pin) { #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError (PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_PIN_DIR_SID, PORT_E_PARAM_PIN); #endif /* End of PORT_DEV_ERROR_DETECT == STD_ON */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Else no action required */ #else #if (PORT_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_PIN_DIR_SID, PORT_E_PARAM_PIN); #endif /* End of PORT_DEV_ERROR_DETECT == STD_ON */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; #endif /* End of #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) */ } /* Else no action required */ /* End of if (E_OK == LddReturnValue) */ /* Check valid the Pin direction changeable*/ if (E_OK == LddReturnValue) /* PRQA S 2996, 2992 # JV-01, JV-01 */ { #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) /* Check whether the Pin direction is changeable at run time */ LpChangeablePinDet = Port_SearchDirChangeablePin (Pin, Port_GpConfigPtr->pPinDirChangeable); /* PRQA S 2814 # JV-01 */ if (NULL_PTR == LpChangeablePinDet) { #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError (PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_PIN_DIR_SID, PORT_E_DIRECTION_UNCHANGEABLE); #endif /* End of PORT_DEV_ERROR_DETECT == STD_ON */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* Else no action required */ #endif /* End of PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON */ } /* Else no action required */ /* End of if (E_OK == LddReturnValue) */ if (E_OK == LddReturnValue) /* PRQA S 2996, 2992 # JV-01, JV-01 */ { #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) /* Enter critical section */ #if (PORT_CRITICAL_SECTION_PROTECTION == STD_ON) PORT_ENTER_CRITICAL_SECTION(PORT_INTERRUPT_CONTROL_PROTECTION); #endif /* End of PORT_CRITICAL_SECTION_PROTECTION == STD_ON */ /* Get return value */ LddReturnValue = Port_ChangePinDirection(Direction, LpChangeablePinDet); /* PRQA S 2983 # JV-01 */ /* Exit critical section */ #if (PORT_CRITICAL_SECTION_PROTECTION == STD_ON) PORT_EXIT_CRITICAL_SECTION(PORT_INTERRUPT_CONTROL_PROTECTION); #endif /* End of PORT_CRITICAL_SECTION_PROTECTION == STD_ON */ #if((PORT_DEM_ERROR_DETECT == STD_ON) && (PORT_EXCLUSIVE_CONTROL == STD_ON)) /* Check error exclusive control */ if(E_NOT_OK == LddReturnValue) { /* Raise DEM status fail error */ (void) Dem_SetEventStatus(PORT_E_GET_CONTROL_FAILURE, DEM_EVENT_STATUS_FAILED); } /* Else no action required */ #endif /* End of ((PORT_DEM_ERROR_DETECT == STD_ON) && (PORT_EXCLUSIVE_CONTROL == STD_ON)) */ #endif /* End of PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON */ } /* Else no action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_NUM_PORT_GROUPS_AVAILABLE', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_SET_PIN_DIRECTION_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0.. PORT_TOTAL_NUMBER_OF_PINS-1', 'Name': 'Pin', 'Value': '-'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'PORT_PIN_OUT.. PORT_PIN_IN', 'Name': 'Direction', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'PORT_UNINITIALIZED.. PORT_INITIALIZED ', 'Name': 'Port_GblDriverStatus', 'Value': 'PORT_UNINITIALIZED'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Port_GpConfigPtr', 'Value': '-'], 'Input_Param_008': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pPinDirChangeable', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddPinNumber', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpStartPtr', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'PORT_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'PORT_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'PORT_SET_PIN_DIR_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'PORT_E_UNINIT'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddDirection', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChangeablePin', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': '-', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_012': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC (void, PORT_PUBLIC_CODE) Port_SetToDioMode (const Port_PinType Pin) /* PRQA S 1503, 1532 # JV-01, JV-01 */ { /* Variable to store the return value of internal checking */ VAR(Std_ReturnType, AUTOMATIC) LddReturnValue; LddReturnValue = E_OK; /* Check whether the PORT module is initialized */ if (PORT_UNINITIALIZED == Port_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError (PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_TO_DIO_MODE_SID, PORT_E_UNINIT); #endif /* #if (PORT_DEV_ERROR_DETECT == STD_ON) */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* End of if (PORT_UNINITIALIZED == Port_GblDriverStatus) */ /* Else no action required */ if (E_OK == LddReturnValue) { /* Check whether the requested PIN number is invalid */ #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) if (PORT_TOTAL_NUMBER_OF_PINS <= Pin) { #if (PORT_DEV_ERROR_DETECT == STD_ON) /* Report to DET */ (void)Det_ReportError(PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_TO_DIO_MODE_SID, PORT_E_PARAM_PIN); #endif /* #if (PORT_DEV_ERROR_DETECT == STD_ON) */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; } /* End of Pin >= PORT_TOTAL_NUMBER_OF_PINS */ /* Else no action required */ #else #if (PORT_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(PORT_MODULE_ID, PORT_INSTANCE_ID, PORT_SET_TO_DIO_MODE_SID, PORT_E_PARAM_PIN); #endif /* #if (PORT_DEV_ERROR_DETECT == STD_ON) */ /* Set Return Value as E_NOT_OK */ LddReturnValue = E_NOT_OK; #endif /* #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) */ } /* Else no action required */ if (E_OK == LddReturnValue) /* PRQA S 2992, 2996 # JV-01, JV-01 */ { #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON) /* Invoke the internal function to set the requested pin to DIO mode */ Port_SetToDioOrAltMode (Pin, PORT_TRUE); #endif /* End of PORT_NUM_PORT_GROUPS_AVAILABLE == STD_ON */ } /* Else no action required */ /* Solve unused parameter error */ #if (PORT_NUM_PORT_GROUPS_AVAILABLE == STD_OFF) (void) Pin; #endif /* End of PORT_NUM_PORT_GROUPS_AVAILABLE == STD_OFF */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_NUM_PORT_GROUPS_AVAILABLE', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_OFF, \\nSTD_ON', 'Name': 'PORT_SET_TO_DIO_ALT_MODE_API', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0.. PORT_TOTAL_NUMBER_OF_PINS-1', 'Name': 'Pin', 'Value': '0x0005'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'PORT_UNINITIALIZED.. PORT_INITIALIZED ', 'Name': 'Port_GblDriverStatus', 'Value': 'PORT_INITIALIZED']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'Pin', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblDioMode', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'PORT_MODULE_ID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'PORT_INSTANCE_ID'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'PORT_SET_TO_DIO_MODE_SID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'PORT_E_PARAM_PIN'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_ATUE5_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATUE5_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(ATUE5_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) ATUE5_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_Callback((Pwm_ChannelType)PWM_ATUE5_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_ATUE0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '2 = ATUE5_CH02_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '22'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_ATUE8_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ /* Defines the CAT2 interrupt mapping */ #if defined(Os_ATUE8_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(ATUE8_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) ATUE8_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_Callback((Pwm_ChannelType)PWM_ATUE8_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_ATUE0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '3 = ATUE8_CH03_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '35'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_DE_INIT_API == STD_ON) #define PWM_START_SEC_PUBLIC_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PUBLIC_CODE) Pwm_DeInit(void) /* PRQA S 1532 # JV-01 */ { /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; VAR(uint32, AUTOMATIC) LulCount; #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Check if PWM Driver is initialized */ if (PWM_INITIALIZED != Pwm_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_DEINIT_SID, PWM_E_UNINIT); } else #endif { #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Set PWM Driver status to uninitialized */ Pwm_SetStatus(PWM_UNINITIALIZED); #if (PWM_SYNC_START_SUPPORT == STD_ON) /* Set PWM Synchronous Init status to uninitialized */ Pwm_GblSyncInitStatus = PWM_UNINITIALIZED; /* Set PWM Synchronous Operation status to stopped */ Pwm_GblSyncOperationStatus = PWM_SYNC_STOPPED; #endif #endif /* End of PWM_DEV_ERROR_DETECT == STD_ON */ /* DeInitialize all PWM channels */ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWDeInitUnit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucHWIPType]->pHWDeInitUnit(); } /* else No action required */ if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWDeInitChannel) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucHWIPType]->pHWDeInitChannel(); } /* else No action required */ } } /* (PWM_INITIALIZED == Pwm_GblDriverStatus) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_DEV_ERROR_DETECT', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUJ_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TIMER_IP_ATU', 'Value': 'STD_OFF(0)'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblDriverStatus', 'Value': 'PWM_INITIALIZED'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaHwFunc[0 to 4]', 'Value': '[0]= &map_Pwm_GaaHwFunc[0]\\n[1]= &map_Pwm_GaaHwFunc[1]\\n[2]= &map_Pwm_GaaHwFunc[2]\\n[3]= &map_Pwm_GaaHwFunc[3]\\n[4]= &map_Pwm_GaaHwFunc[4]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Pwm_GaaHWIP_Used', 'Value': '&Pwm_GaaHWIP_Used[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0]= PWM_HWIP_TAUD\\n[1] = PWM_HWIP_TAUJ'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'pHWDeInitUnit', 'Value': '[0]= NULL_PTR\\n[1] = &ISOLATE_void_func_ptr\\n[2]=NULL_PTR\\n[3]=NULL_PTR\\n[4]=NULL_PTR'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pHWDeInitChannel', 'Value': '[0]= NULL_PTR\\n[1] = &ISOLATE_void_func_ptr\\n[2]=NULL_PTR\\n[3]=NULL_PTR\\n[4]=NULL_PTR']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatus', 'Value': 'PWM_UNINITIALIZED'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblSyncInitStatus', 'Value': 'PWM_UNINITIALIZED'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblSyncOperationStatus', 'Value': 'PWM_SYNC_STOPPED'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_GET_OUTPUT_STATE_API == STD_ON) #define PWM_START_SEC_PUBLIC_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(Pwm_OutputStateType, PWM_PUBLIC_CODE) Pwm_GetOutputState(Pwm_ChannelType ChannelNumber) /* PRQA S 1503 # JV-01 */ { /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpChannelConfig; /* PRQA S 3432 # JV-01 */ VAR(Pwm_OutputStateType, AUTOMATIC) LenRetOutputState; VAR(volatile uint8, AUTOMATIC) LucTimerUnitType; #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(uint8, AUTOMATIC) LucDetErrFlag; /* Checking Det error */ LucDetErrFlag = Pwm_CheckDetErrors(ChannelNumber, PWM_GET_OUTPUTSTATE_SID); #endif /* Initialize the return value in case of DET error */ LenRetOutputState = PWM_LOW; #if (PWM_DEV_ERROR_DETECT == STD_ON) if (E_OK == LucDetErrFlag) #endif { /* Updating the channel config parameter to the current channel */ LpChannelConfig = &Pwm_GpChannelConfig[ChannelNumber]; /* Get the Timer Unit Type*/ LucTimerUnitType = LpChannelConfig->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Set the output of a channel to its Idle state */ if (NULL_PTR != Pwm_GaaHwFunc[LucTimerUnitType]->pHWGetOutputState) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ LenRetOutputState = Pwm_GaaHwFunc[LucTimerUnitType]->pHWGetOutputState(ChannelNumber); } /* else No action required */ } /* else No action required */ return LenRetOutputState; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_DEV_ERROR_DETECT', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUJ_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TIMER_IP_ATU', 'Value': 'STD_OFF(0)'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0\u202663', 'Name': 'ChannelNumber', 'Value': '0'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaHwFunc[0 to 3]', 'Value': '[0]= &map_Pwm_GaaHwFunc[0]\\n[1]= &map_Pwm_GaaHwFunc[1]\\n[2]= &map_Pwm_GaaHwFunc[2]\\n[3]= &map_Pwm_GaaHwFunc[3]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pHWGetOutputState', 'Value': '[0]= NULL_PTR\\n[1] = &ISOLATE_Pwm_OutputStateType_func_ptr_Pwm_ChannelType\\n[2]= NULL_PTR\\n[3]= NULL_PTR'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GaaChannelConfig[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[0]= PWM_HWIP_TAUD'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelNumber', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApi_SID', 'Value': 'PWM_GET_OUTPUTSTATE_SID'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '0'], 'Output_Param_003': ['Type': 'Return_Value', 'Range': '', 'Name': 'LenRetOutputState', 'Value': 'PWM_HIGH'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_DE_INIT_API == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_DIAG_DeInitUnit(void) /* PRQA S 1532 # JV-01 */ { P2CONST(Pwm_DiagPrescalerConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpPrescalerConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Pwm_DiagPeriodConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpPeriodConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Pwm_DiagPeriodSelectConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpPeriodSelectConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Pwm_DiagNotifyConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpDiagNotify; /* PRQA S 3432 # JV-01 */ VAR(uint8, AUTOMATIC) LucIndex; VAR(uint8, AUTOMATIC) LucGrId; /* Load configuration */ LpPrescalerConfig = &Pwm_GpDiagConfig->pPrescalerConfig[0]; /* PRQA S 2814, 2824 # JV-02, JV-01 */ LpPeriodConfig = &Pwm_GpDiagConfig->pPeriodConfig[0]; /* PRQA S 2824 # JV-01 */ LpPeriodSelectConfig = &Pwm_GpDiagConfig->pPeriodSelectConfig[0]; /* PRQA S 2824 # JV-01 */ /* Disable setting clock */ Pwm_GpDiagConfig->pPWBA->ucPWBAnTT &= ~PWM_DIAG_CLK_SETTING; /* Disable A/D conversion result storing control */ Pwm_GpDiagConfig->pPWSD->ucPWSDnCTL &= ~(PWM_DIAG_PWSD_ARSE | PWM_DIAG_PWSD_ENBL); /* PRQA S 2814 # JV-01 */ /* Disable EIC registers */ /* Loop Notification Group0 to Group3 */ for (LucIndex = 0; LucIndex < PWM_DIAG_NOTI_GROUP; LucIndex++) { /* Loop Channel Group0 to Group2 */ for (LucGrId = 0; LucGrId < PWM_DIAG_CH_GROUP; LucGrId++) { /* Load configuration */ LpDiagNotify = Pwm_GpDiagConfig->pDiagNotiGrConfig->aaDiagNotifyConfig[LucIndex][LucGrId]; /* PRQA S 2814 # JV-01 */ if (NULL_PTR != LpDiagNotify->pEICn) /* PRQA S 2814 # JV-01 */ { /* Disable interrupt of INTC */ RH850_SV_MODE_ICR_OR(8, LpDiagNotify->pEICn, (uint8)PWM_EIC_EIMK_MASK); /* PRQA S 0751, 2814, 4399 # JV-01, JV-01, JV-01 */ #if (PWM_CLEAR_PENDING_INTERRUPT == STD_ON) /* Clear pending interrupt */ RH850_SV_MODE_ICR_AND(16, LpDiagNotify->pEICn, PWM_CLEAR_PENDING_INTR_MASK); /* PRQA S 0499, 4399 # JV-01, JV-01 */ #endif /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, LpDiagNotify->pEICn); EXECUTE_SYNCP(); } /* else: No action */ } /* End of for (LucGrId = 0; LucGrId < PWM_DIAG_CH_GROUP; LucGrId++) */ } /* End of for (LucIndex = 0; LucIndex < PWM_DIAG_NOTI_GROUP; LucIndex++) */ /* Reset prescaler */ for (LucIndex = 0; LucIndex < PWM_DIAG_TOTAL_PRESCALER; LucIndex++) { Pwm_GpDiagConfig->pPWBA->aaPWBAnBRSm[LpPrescalerConfig[LucIndex].ucBRSmIndex].usPWBAnBRSm /* PRQA S 2824 # JV-01 */ &= ~(LpPrescalerConfig[LucIndex].usBSRmValue); } /* Reset period setting */ for (LucIndex = 0; LucIndex < PWM_DIAG_TOTAL_PERIOD; LucIndex++) { Pwm_GpDiagConfig->pSLPWG->aaPWGCPRDm[LpPeriodConfig[LucIndex].ucPRDmIndex].usPWGCPRDm /* PRQA S 2814, 2824 # JV-01, JV-01 */ &= ~(LpPeriodConfig[LucIndex].usPRDmValue); } /* Reset selection of period */ for (LucIndex = 0; LucIndex < PWM_DIAG_TOTAL_PERIOD_SELECT; LucIndex++) { Pwm_GpDiagConfig->pSLPWG->aaPWGCPRDSLq[LpPeriodSelectConfig[LucIndex].ucPWGCPRDSLqIndex].ulPWGCPRDSLq /* PRQA S 2824 # JV-01 */ &= ~(LpPeriodSelectConfig[LucIndex].ulPWGCPRDSLqValue); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'Pwm_GpDiagConfig', 'Value': '&map_Pwm_GaaDiagUnitConfig[0]'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'pPWSD', 'Value': '&map_pPWSD[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pPWBA', 'Value': '&map_pPWBA[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pSLPWG', 'Value': '&map_pSLPWG[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'Register Value', 'Name': 'ucPWBAnTT', 'Value': '0x0F'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'Register Value', 'Name': 'ucPWSDnCTL', 'Value': '0x81'], 'Input_Param_006': ['Type': 'Array', 'Range': 'Register Value', 'Name': 'usPWBAnBRSm', 'Value': '[0 to 3] = 0x0001'], 'Input_Param_007': ['Type': 'Array', 'Range': 'Register Value', 'Name': 'usPWGCPRDm', 'Value': '[0 to 3] = 0xFFFF'], 'Input_Param_008': ['Type': 'Array', 'Range': 'Register Value', 'Name': 'ulPWGCPRDSLq', 'Value': '[0 to 5] = 0x00000001'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pPrescalerConfig', 'Value': '&map_GaaDiagPrescalerConfig[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '0x00..0x03', 'Name': 'ucBRSmIndex', 'Value': '[0] = 0x00\\n[1] = 0x01\\n[2] = 0x02\\n[3] = 0x03'], 'Input_Param_011': ['Type': 'Array', 'Range': '0x0000..0xFFFF (No effect bihavior)', 'Name': 'usBSRmValue', 'Value': '[0 to 3] = 0x0001'], 'Input_Param_012': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pPeriodConfig', 'Value': '&map_Pwm_GaaDiagPeriodConfig[0]'], 'Input_Param_013': ['Type': 'Array', 'Range': '0x00..0x03', 'Name': 'ucPRDmIndex', 'Value': '[0] = 0x00\\n[1] = 0x01\\n[2] = 0x02\\n[3] = 0x03'], 'Input_Param_014': ['Type': 'Array', 'Range': '0x0000..0xFFFF (No effect bihavior)', 'Name': 'usPRDmValue', 'Value': '[0 to 3] = 0xFFFF'], 'Input_Param_015': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pDiagNotiGrConfig', 'Value': '&map_pDiagNotiGrConfig[0]'], 'Input_Param_016': ['Type': 'Array', 'Range': 'Adress', 'Name': 'aaDiagNotifyConfig[0 to 3][0 to 2]', 'Value': '[0][0] = &map_Pwm_GaaDiagNotifyConfig[0][0]\\n[0][1] = &map_Pwm_GaaDiagNotifyConfig[0][1]\\n[0][2] = &map_Pwm_GaaDiagNotifyConfig[0][2]\\n[1][0] = &map_Pwm_GaaDiagNotifyConfig[1][0]\\n[1][1] = &map_Pwm_GaaDiagNotifyConfig[1][1]\\n[1][2] = &map_Pwm_GaaDiagNotifyConfig[1][2]\\n[2][0] = &map_Pwm_GaaDiagNotifyConfig[2][0]\\n[2][1] = &map_Pwm_GaaDiagNotifyConfig[2][1]\\n[2][2] = &map_Pwm_GaaDiagNotifyConfig[2][2]\\n[3][0] = &map_Pwm_GaaDiagNotifyConfig[3][0]\\n[3][1] = &map_Pwm_GaaDiagNotifyConfig[3][1]\\n[3][2] = &map_Pwm_GaaDiagNotifyConfig[3][2]'], 'Input_Param_017': ['Type': 'Array', 'Range': 'Register Value', 'Name': 'pEICn', 'Value': '[0 to 3][0 to 2] = NULL'], 'Input_Param_018': ['Type': 'Array', 'Range': 'Register value', 'Name': 'map_pEICn[0 to 11]', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pPeriodSelectConfig', 'Value': '&map_Pwm_GaaDiagPeriodSelectConfig[0]'], 'Input_Param_020': ['Type': 'Array', 'Range': '0x00..0x05', 'Name': 'ucPWGCPRDSLqIndex', 'Value': '[0] = 0x00\\n[1] = 0x01\\n[2] = 0x02\\n[3] = 0x03\\n[4] = 0x04\\n[5] = 0x05'], 'Input_Param_021': ['Type': 'Array', 'Range': '0x00000000..0xFFFFFFFF (No effect behabior)', 'Name': 'ulPWGCPRDSLqValue', 'Value': '[0 to 5] = 0x00000001'], 'Input_Param_022': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_DIAG_CLK_SETTING', 'Value': '0x0F'], 'Input_Param_023': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_EIC_EIMK', 'Value': '0x0080'], 'Input_Param_024': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_EIC_EIRF', 'Value': '0x1000'], 'Input_Param_025': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_DIAG_TOTAL_PRESCALER', 'Value': '4'], 'Input_Param_026': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_DIAG_TOTAL_PERIOD', 'Value': '4'], 'Input_Param_027': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_DIAG_TOTAL_PERIOD_SELECT', 'Value': '6'], 'Input_Param_028': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_DIAG_NOTI_GROUP', 'Value': '4'], 'Input_Param_029': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_DIAG_CH_GROUP', 'Value': '3']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'Register Value', 'Name': 'ucPWBAnTT', 'Value': '0x0000'], 'Output_Param_001': ['Type': 'Variable', 'Range': 'Register Value', 'Name': 'ucPWSDnCTL', 'Value': '0x00'], 'Output_Param_002': ['Type': 'Array', 'Range': 'Register Value', 'Name': 'usPWBAnBRSm', 'Value': '[0 to 3] = 0x0000'], 'Output_Param_003': ['Type': 'Array', 'Range': 'Register Value', 'Name': 'usPWGCPRDm', 'Value': '[0 to 3] = 0x0000'], 'Output_Param_004': ['Type': 'Array', 'Range': 'Register Value', 'Name': 'ulPWGCPRDSLq', 'Value': '[0 to 5] = 0x00000000'], 'Output_Param_005': ['Type': 'Array', 'Range': 'Register value', 'Name': 'map_pEICn[0 to 11]', 'Value': '-'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_NOTIFICATION_SUPPORTED == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_DIAG_DisableNotification(Pwm_ChannelType LddChannelId) /* PRQA S 1532 # JV-01 */ { P2CONST(Pwm_DiagChannelConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpDiagCh; /* PRQA S 3432 # JV-01 */ P2CONST(Pwm_DiagUnitConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpDiagConfig; /* PRQA S 3432 # JV-01 */ /* Load configuration */ LpDiagConfig = Pwm_GpDiagConfig; LpDiagCh = (P2CONST(Pwm_DiagChannelConfigType, AUTOMATIC, PWM_CONFIG_DATA)) /* PRQA S 0316, 3432 # JV-01, JV-01 */ Pwm_GpChannelConfig[LddChannelId].pHWIPChannelConfig; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Disable rising/falling edge interrupt */ LpDiagCh->pPWGC->usPWGCnCTL &= ~(PWM_DIAG_RISING_EDGE|PWM_DIAG_FALLING_EDGE); /* PRQA S 2814 # JV-01 */ /* Disable interrupt of DIAG */ LpDiagConfig->pPWGC_INTF[LpDiagCh->ucNotifyGrId].aaPWGC_INTF[LpDiagCh->ucGroupId].ulPWGCINTMSKhk /* PRQA S 2814, 2824 # JV-01, JV-01 */ |= 1UL << (LpDiagCh->ucChNo & 0x1FUL); #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0~Max number of ID\\n(No impact to behavior)', 'Name': 'LddChannelId', 'Value': '32'], 'Input_Param_001': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'Pwm_GpDiagConfig', 'Value': '&map_Pwm_GaaDiagUnitConfig[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GaaChannelConfig[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pPWGC_INTF', 'Value': '&map_pPWGC_INTF[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pPWGC', 'Value': '&map_pPWGC[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'Register Value', 'Name': 'ulPWGCINTMSKhk', 'Value': '0x00000000'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pHWIPChannelConfig', 'Value': '&map_Pwm_GaaDiagChConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'Register Value', 'Name': 'usPWGCnCTL', 'Value': '0xC000'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0..2 (No impact to behavior)', 'Name': 'ucGroupId', 'Value': '0x00'], 'Input_Param_009': ['Type': 'Variable', 'Range': '0..95 (No impact to behavior)', 'Name': 'ucChNo', 'Value': '32'], 'Input_Param_010': ['Type': 'Variable', 'Range': '0..3 (No impact to behavior)', 'Name': 'ucNotifyGrId', 'Value': '0x00'], 'Input_Param_011': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_DIAG_RISING_EDGE', 'Value': '0x4000'], 'Input_Param_012': ['Type': 'Macro', 'Range': 'Fixed Value', 'Name': 'PWM_DIAG_FALLING_EDGE', 'Value': '0x8000']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'Register Value', 'Name': 'usPWGCnCTL', 'Value': '0x0000'], 'Output_Param_001': ['Type': 'Variable', 'Range': 'Register Value', 'Name': 'ulPWGCINTMSKhk', 'Value': '0x00000001'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': 'Called'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '-', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_DIAG_InitUnit(P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { P2CONST(Pwm_DiagPeriodConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpPeriodConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Pwm_DiagPeriodSelectConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpPeriodSelectConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Pwm_DiagPrescalerConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpPrescalerConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Pwm_DiagNotifyConfigType, AUTOMATIC, PWM_CONFIG_DATA) LpDiagNotify; /* PRQA S 3432 # JV-01 */ VAR(uint32, AUTOMATIC) LulIndex; VAR(uint8, AUTOMATIC) LucGrId; /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; for (LulIndex = (uint32)PWM_ZERO; LulIndex < (uint32)PWM_TOTAL_HW_IP_SUPPORTED; LulIndex++) { LucHWIPType = Pwm_GaaHWIP_Used[LulIndex].ucIndex; /* PRQA S 2841 # JV-01 */ if (PWM_HWIP_DIAG == LucHWIPType) /* PRQA S 3416 # JV-01 */ { /* Initialize global pointer */ Pwm_GpDiagConfig = (P2CONST(Pwm_DiagUnitConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA)) /* PRQA S 0316, 3432 # JV-01, JV-01 */ LpConfigPtr->aaTimerUnitConfig[LucHWIPType]; /* PRQA S 2814, 3432 # JV-02, JV-01 */ } /* else No action required */ } /* Load configuration */ LpPrescalerConfig = &Pwm_GpDiagConfig->pPrescalerConfig[0]; /* PRQA S 2814, 2824 # JV-02, JV-01 */ LpPeriodConfig = &Pwm_GpDiagConfig->pPeriodConfig[0]; /* PRQA S 2824 # JV-01 */ LpPeriodSelectConfig = &Pwm_GpDiagConfig->pPeriodSelectConfig[0]; /* PRQA S 2824 # JV-01 */ /* Setting prescaler */ for (LulIndex = 0; LulIndex < PWM_DIAG_TOTAL_PRESCALER; LulIndex++) { Pwm_GpDiagConfig->pPWBA->aaPWBAnBRSm[LpPrescalerConfig[LulIndex].ucBRSmIndex].usPWBAnBRSm /* PRQA S 2824 # JV-01 */ = LpPrescalerConfig[LulIndex].usBSRmValue; } /* Setting default period */ for (LulIndex = 0; LulIndex < PWM_DIAG_TOTAL_PERIOD; LulIndex++) { Pwm_GpDiagConfig->pSLPWG->aaPWGCPRDm[LpPeriodConfig[LulIndex].ucPRDmIndex].usPWGCPRDm /* PRQA S 2814, 2824 # JV-01, JV-01 */ = LpPeriodConfig[LulIndex].usPRDmValue; } /* Setting default selection of period */ for (LulIndex = 0; LulIndex < PWM_DIAG_TOTAL_PERIOD_SELECT; LulIndex++) { Pwm_GpDiagConfig->pSLPWG->aaPWGCPRDSLq[LpPeriodSelectConfig[LulIndex].ucPWGCPRDSLqIndex].ulPWGCPRDSLq /* PRQA S 2824 # JV-01 */ = LpPeriodSelectConfig[LulIndex].ulPWGCPRDSLqValue; } /* Enable EIC registers */ /* Loop Notification Group0 to Group3 */ for (LulIndex = 0; LulIndex < PWM_DIAG_NOTI_GROUP; LulIndex++) { /* Loop Channel Group0 to Group2 */ for (LucGrId = 0; LucGrId < PWM_DIAG_CH_GROUP; LucGrId++) { /* Load configuration */ LpDiagNotify = Pwm_GpDiagConfig->pDiagNotiGrConfig->aaDiagNotifyConfig[LulIndex][LucGrId]; /* PRQA S 2814 # JV-02 */ if (NULL_PTR != LpDiagNotify->pEICn) /* PRQA S 2814 # JV-01 */ { #if (PWM_CLEAR_PENDING_INTERRUPT == STD_ON) /* Clear pending interrupt */ RH850_SV_MODE_ICR_AND(16, LpDiagNotify->pEICn, PWM_CLEAR_PENDING_INTR_MASK); /* PRQA S 0499, 2814, 4399 # JV-01, JV-01, JV-01 */ #endif /* Enable interrupt of INTC */ RH850_SV_CLEAR_ICR_SYNCP(8, LpDiagNotify->pEICn, (uint8)~PWM_EIC_EIMK_MASK); /* PRQA S 0751, 4399 # JV-01, JV-01 */ } /* else: No action */ } /* End of for (LucGrId = 0; LucGrId < PWM_DIAG_CH_GROUP; LucGrId++) */ } /* End of for (LulIndex = 0; LulIndex < PWM_DIAG_NOTI_GROUP; LulIndex++) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Pwm_GaaHWIP_Used', 'Value': '&Pwm_GaaHWIP_Used[0]'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = PWM_HWIP_DIAG\\n'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'Address', 'Name': 'LpConfigPtr', 'Value': '&map_LddConfigPtr[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'aaTimerUnitConfig[PWM_HWIP_DIAG]', 'Value': '&map_aaTimerUnitConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'Pwm_GpDiagConfig', 'Value': '&map_Pwm_GaaDiagUnitConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pPWBA', 'Value': '&map_pPWBA[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pSLPWG', 'Value': '&map_pSLPWG[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pPrescalerConfig', 'Value': '&map_pPrescalerConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pPeriodConfig', 'Value': '&map_pPeriodConfig[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pDiagNotiGrConfig', 'Value': '&map_pDiagNotiGrConfig[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'pPeriodSelectConfig', 'Value': '&map_pPeriodSelectConfig[0]'], 'Input_Param_011': ['Type': 'Array', 'Range': 'Register value', 'Name': 'usPWBAnBRSm', 'Value': '[0 to 3] = 0x0000'], 'Input_Param_012': ['Type': 'Array', 'Range': 'Register value', 'Name': 'usPWGCPRDm', 'Value': '[0 to 3] = 0x0000'], 'Input_Param_013': ['Type': 'Array', 'Range': 'Register value', 'Name': 'ulPWGCPRDSLq', 'Value': '[0 to 5] = 0x00000000'], 'Input_Param_014': ['Type': 'Array', 'Range': '0..3', 'Name': 'ucBRSmIndex', 'Value': '[0] = 0x00\\n[1] = 0x01\\n[2] = 0x02\\n[3] = 0x03'], 'Input_Param_015': ['Type': 'Array', 'Range': '0x0000..0xFFFF', 'Name': 'usBSRmValue', 'Value': '[0 to 3] = 0x0001'], 'Input_Param_016': ['Type': 'Array', 'Range': '0..3', 'Name': 'ucPRDmIndex', 'Value': '[0] = 0x00\\n[1] = 0x01\\n[2] = 0x02\\n[3] = 0x03'], 'Input_Param_017': ['Type': 'Array', 'Range': '0x0000..0xFFFF', 'Name': 'usPRDmValue', 'Value': '[0 to 3] = 0xFFFF'], 'Input_Param_018': ['Type': 'Array', 'Range': 'Adress', 'Name': 'aaDiagNotifyConfig[0 to 3][0 to 2]', 'Value': '[0][0] = &map_Pwm_GaaDiagNotifyConfig[0][0]\\n[0][1] = &map_Pwm_GaaDiagNotifyConfig[0][1]\\n[0][2] = &map_Pwm_GaaDiagNotifyConfig[0][2]\\n[1][0] = &map_Pwm_GaaDiagNotifyConfig[1][0]\\n[1][1] = &map_Pwm_GaaDiagNotifyConfig[1][1]\\n[1][2] = &map_Pwm_GaaDiagNotifyConfig[1][2]\\n[2][0] = &map_Pwm_GaaDiagNotifyConfig[2][0]\\n[2][1] = &map_Pwm_GaaDiagNotifyConfig[2][1]\\n[2][2] = &map_Pwm_GaaDiagNotifyConfig[2][2]\\n[3][0] = &map_Pwm_GaaDiagNotifyConfig[3][0]\\n[3][1] = &map_Pwm_GaaDiagNotifyConfig[3][1]\\n[3][2] = &map_Pwm_GaaDiagNotifyConfig[3][2]\\n'], 'Input_Param_019': ['Type': 'Array', 'Range': 'Register value', 'Name': 'pEICn', 'Value': '[0][0] = &map_pEICn[0]\\n[0][1] = &map_pEICn[1]\\n[0][2] = &map_pEICn[2]\\n[1][0] = &map_pEICn[3]\\n[1][1] = &map_pEICn[4]\\n[1][2] = &map_pEICn[5]\\n[2][0] = &map_pEICn[6]\\n[2][1] = &map_pEICn[7]\\n[2][2] = &map_pEICn[8]\\n[3][0] = &map_pEICn[9]\\n[3][1] = &map_pEICn[10]\\n[3][2] = &map_pEICn[11]'], 'Input_Param_020': ['Type': 'Array', 'Range': 'Register value', 'Name': 'map_pEICn[0 to 11]', 'Value': '[0 to 11]  = NULL'], 'Input_Param_021': ['Type': 'Array', 'Range': '0..5', 'Name': 'ucPWGCPRDSLqIndex', 'Value': '[0] = 0x00\\n[1] = 0x01\\n[2] = 0x02\\n[3] = 0x03\\n[4] = 0x04\\n[5] = 0x05'], 'Input_Param_022': ['Type': 'Array', 'Range': '0x00000000..0xFFFFFFFF (no effect behavior)', 'Name': 'ulPWGCPRDSLqValue', 'Value': '[0 to 5] = 0x00000001'], 'Input_Param_023': ['Type': 'Macro', 'Range': 'Fixed value', 'Name': 'PWM_EIC_EIRF', 'Value': '0x1000'], 'Input_Param_024': ['Type': 'Macro', 'Range': 'Fixed value', 'Name': 'PWM_EIC_EIMK', 'Value': '0x0080'], 'Input_Param_025': ['Type': 'Macro', 'Range': 'Fixed value', 'Name': 'PWM_DIAG_TOTAL_PRESCALER', 'Value': '4'], 'Input_Param_026': ['Type': 'Macro', 'Range': 'Fixed value', 'Name': 'PWM_DIAG_TOTAL_PERIOD', 'Value': '4'], 'Input_Param_027': ['Type': 'Macro', 'Range': 'Fixed value', 'Name': 'PWM_DIAG_TOTAL_PERIOD_SELECT', 'Value': '6'], 'Input_Param_028': ['Type': 'Macro', 'Range': 'Fixed value', 'Name': 'PWM_DIAG_NOTI_GROUP', 'Value': '4'], 'Input_Param_029': ['Type': 'Macro', 'Range': 'Fixed value', 'Name': 'PWM_DIAG_CH_GROUP', 'Value': '3']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': 'Adress', 'Name': 'Pwm_GpDiagConfig', 'Value': '&map_aaTimerUnitConfig[0]'], 'Output_Param_001': ['Type': 'Array', 'Range': 'Register value', 'Name': 'usPWBAnBRSm', 'Value': '[0 to 3] = 0x0001'], 'Output_Param_002': ['Type': 'Array', 'Range': 'Register value', 'Name': 'usPWGCPRDm', 'Value': '[0 to 3] = 0xFFFF'], 'Output_Param_003': ['Type': 'Array', 'Range': 'Register value', 'Name': 'ulPWGCPRDSLq', 'Value': '[0 to 5] = 0x00000001'], 'Output_Param_004': ['Type': 'Array', 'Range': 'Register value', 'Name': 'map_pEICn[0 to 11]', 'Value': '-'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((PWM_SET_OUTPUT_TO_IDLE_API == STD_ON) || (PWM_SYNC_START_SUPPORT == STD_ON) || (PWM_DE_INIT_API == STD_ON)) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_SetDutyToIdleState(const Pwm_ChannelConfigType *LpChannelConfig, Pwm_ATUEChDataRegs *LpATUEChDataRegs) { /* Condition check for polarity and idle level of the channel */ if ((((uint8)PWM_HIGH == LpChannelConfig->ucIdleLevel) && ((uint8)PWM_LOW == LpChannelConfig->ucPolarity)) /* PRQA S 2814 # JV-02 */ || (((uint8)PWM_LOW == LpChannelConfig->ucIdleLevel) && ((uint8)PWM_HIGH == LpChannelConfig->ucPolarity))) { /* Assign the duty cycle value of the channel to register */ LpATUEChDataRegs->ulATUEDRLDExy = (uint32)PWM_DUTY_CYCLE_RESET_VALUE; /* PRQA S 2814 # JV-03 */ } else if ((((uint8)PWM_LOW == LpChannelConfig->ucIdleLevel) && ((uint8)PWM_LOW == LpChannelConfig->ucPolarity)) /* PRQA S 2004 # JV-01 */ || (((uint8)PWM_HIGH == LpChannelConfig->ucIdleLevel) && ((uint8)PWM_HIGH == LpChannelConfig->ucPolarity))) { /* Assign the duty cycle value of the channel to register */ LpATUEChDataRegs->ulATUEDRLDExy = LpATUEChDataRegs->ulATUECYLRExy; } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpATUEChDataRegs', 'Value': '&map_Pwm_ATUEChDataRegs[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0].ucIdleLevel', 'Value': 'PWM_HIGH'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0].ucPolarity', 'Value': 'PWM_LOW'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_ATUEChDataRegs[0].ulATUECYLRExy', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_Pwm_ATUEChDataRegs[0].ulATUEDRLDExy', 'Value': 'PWM_DUTY_CYCLE_RESET_VALUE'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SET_PERIOD_AND_DUTY_API == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_SetPeriodAndDuty( /* PRQA S 1532 # JV-01 */ Pwm_ChannelType LddChannelId, Pwm_PeriodType LddSetPeriod, uint16 LusSetDutyCycle) { /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_ATUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpATUChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Pointer used for each Timer-E channel control registers */ P2CONST(Pwm_ATUChannelPropType, AUTOMATIC, PWM_CONFIG_CONST) LpChannelProp; /* PRQA S 3432 # JV-01 */ /* Local Pointer used for each Timer-E channel data registers */ P2VAR(Pwm_ATUEChDataRegs, AUTOMATIC, REGSPACE) LpATUEChDataRegs; /* PRQA S 3432 # JV-01 */ /* Update the pointer for base address of the Channel control register */ P2VAR(Pwm_ATUEChCntrlRegs, AUTOMATIC, REGSPACE) LpATUEChCntrlRegs; /* PRQA S 3432 # JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(uint8, AUTOMATIC) LucDetErrFlag; #endif /* Update the configure pointer to point to the current Timer channel*/ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Set ATU channel config data pointer */ LpATUChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) LucDetErrFlag = E_OK; /* Check for valid Duty range Check for valid Period */ if (PWM_PERIOD_MAX_LIMIT < LddSetPeriod) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SET_PERIODANDDUTY_SID, PWM_E_PARAM_VALUE); LucDetErrFlag = E_NOT_OK; } /* else No action required */ if (E_OK == LucDetErrFlag) #endif /* (PWM_DEV_ERROR_DETECT == STD_ON) */ { /* Update the pointer to point to the current Timer channel properties */ LpChannelProp = (P2CONST(Pwm_ATUChannelPropType, AUTOMATIC, PWM_CONFIG_CONST))LpChannelConfig->pChannelProp; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Get the pointer to the PWM Channel data registers */ LpATUEChDataRegs = LpATUChannelConfigData->pATUEChDataRegs; /* PRQA S 2814 # JV-03 */ /* Get the pointer to the PWM Channel control registers */ LpATUEChCntrlRegs = LpATUChannelConfigData->pATUEChCntrlRegs; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Disable Reload function for cycle match */ LpATUEChCntrlRegs->ucATUERLDCREx &= (uint8)(~(LpChannelProp->ucChannelSelMask & PWM_LOWER_NIBBLE_MASK)); /* PRQA S 2814 # JV-03 */ if ((Pwm_PeriodType)PWM_ZERO != LddSetPeriod) { /* Load the duty value to reload duty register */ LpATUEChDataRegs->ulATUEDRLDExy = Pwm_HW_CalculateDuty(LddSetPeriod, (Pwm_PeriodType)LusSetDutyCycle); /* PRQA S 2814 # JV-03 */ /* Load the cycle value to reload cycle register */ LpATUEChDataRegs->ulATUECRLDExy = LddSetPeriod << (uint32)PWM_BYTE_SHIFT_VALUE; } else { /* If period is set to zero the setting of the duty-cycle is not relevant */ /* In this case the output shall be zero (zero percent duty-cycle). */ LpATUEChDataRegs->ulATUEDRLDExy = (uint32)PWM_DUTY_CYCLE_RESET_VALUE; /* Register CRLDExy can only be set from 0x01, set cycle value to one when period is zero */ LpATUEChDataRegs->ulATUECRLDExy = (uint32)PWM_ONE << (uint32)PWM_BYTE_SHIFT_VALUE; } /* Enable Reload function for cycle match */ LpATUEChCntrlRegs->ucATUERLDCREx |= (LpChannelProp->ucChannelSelMask & PWM_LOWER_NIBBLE_MASK); #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif } /* else No action required */ /* End of if (E_OK == LucDetErrFlag) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannelId', 'Value': '34'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x0..0xFFFFFF', 'Name': 'LddSetPeriod', 'Value': '0x000000'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0x0..0xFFFF', 'Name': 'LusSetDutyCycle', 'Value': '0x0000'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 39].pHWIPChannelConfig', 'Value': '[34]= &map_Pwm_HWIPChannelConfig[0]\\n'], 'Input_Param_006': ['Type': 'Array', 'Range': 'PWM_VARIABLE_PERIOD\\nPWM_FIXED_PERIOD\\nPWM_FIXED_PERIOD_SHIFTED', 'Name': 'map_Pwm_GpChannelConfig[0 to 39].enClassType', 'Value': '[34]= PWM_VARIABLE_PERIOD'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 39].pChannelProp', 'Value': '[34]= &map_pChannelProp[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0].pATUEChCntrlRegs', 'Value': '&map_Pwm_ATUEChCntrlRegs[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0].pATUEChDataRegs', 'Value': '&map_Pwm_ATUEChDataRegs[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_ATUEChCntrlRegs[0].ucATUERLDCREx', 'Value': '0x00'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelProp[0].ucChannelSelMask', 'Value': '0x81'], 'Input_Param_012': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddSetPeriod', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusSetDutyCycle', 'Value': '-'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_Pwm_ATUEChDataRegs[0].ulATUECRLDExy', 'Value': '0x00000100'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_Pwm_ATUEChDataRegs[0].ulATUEDRLDExy', 'Value': '0x000000'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'map_Pwm_ATUEChCntrlRegs[0].ucATUERLDCREx', 'Value': '0x01'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_NOTIFICATION_SUPPORTED == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUD_EnableNotification(Pwm_ChannelType LddChannelId, /* PRQA S 1532 # JV-01 */ Pwm_EdgeNotificationType LenNotification) { /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUDChannelConfigData; /* PRQA S 3432 # JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Pointer to channel configuration of master channel*/ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpMasterChannelConfig; /* PRQA S 3432 # JV-01 */ VAR(uint8, AUTOMATIC) LucDetErrFlag; #endif /* Initialize a pointer to the channel configuration */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Initialize DET error flag */ LucDetErrFlag = E_OK; if ((uint8)PWM_SLAVE_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { LpMasterChannelConfig = &Pwm_GpChannelConfig[LddChannelId - LpTAUDChannelConfigData->ucMasterOffset]; /* Check notification is PWM_BOTH_EDGES */ if (PWM_BOTH_EDGES == LenNotification) { if ((NULL_PTR == LpMasterChannelConfig->pPwmEdgeNotifPtr) || (NULL_PTR == LpChannelConfig->pPwmEdgeNotifPtr)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_ENABLENOTIFICATION_SID, PWM_E_NOTIFY_NOTCONFIG); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } /* For notification is PWM_RISING_EDGE */ else if (PWM_RISING_EDGE == LenNotification) { if ((((uint8)PWM_POLARITY_HIGH == LpChannelConfig->ucPolarity) && (NULL_PTR == LpMasterChannelConfig->pPwmEdgeNotifPtr)) || (((uint8)PWM_POLARITY_LOW == LpChannelConfig->ucPolarity) && (NULL_PTR == LpChannelConfig->pPwmEdgeNotifPtr))) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_ENABLENOTIFICATION_SID, PWM_E_NOTIFY_NOTCONFIG); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } /* For notification is PWM_FALLING_EDGE */ else { if ((((uint8)PWM_POLARITY_HIGH == LpChannelConfig->ucPolarity) && (NULL_PTR == LpChannelConfig->pPwmEdgeNotifPtr)) || (((uint8)PWM_POLARITY_LOW == LpChannelConfig->ucPolarity) && (NULL_PTR == LpMasterChannelConfig->pPwmEdgeNotifPtr))) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_ENABLENOTIFICATION_SID, PWM_E_NOTIFY_NOTCONFIG); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } } /* else No action required */ /* End of if (PWM_SLAVE_CHANNEL == LpChannelConfig->ucTimerMode) */ if (E_OK == LucDetErrFlag) #endif /* End of (PWM_DEV_ERROR_DETECT == STD_ON) */ { /* Check if this channel is in the Slave mode and isn't Delay channel */ if (((uint8)PWM_MASTER_CHANNEL != LpTAUDChannelConfigData->ucTimerMode) && /* PRQA S 2814 # JV-02 */ ((PWM_FIXED_PERIOD_SHIFTED != LpChannelConfig->enClassType) || ((PWM_FIXED_PERIOD_SHIFTED == LpChannelConfig->enClassType) && (PWM_TWO != LpTAUDChannelConfigData->ucMasterOffset)))) { if (PWM_BOTH_EDGES == LenNotification) { /* Check whether any notification is configured for this channel */ if (NULL_PTR != LpChannelConfig->pPwmEdgeNotifPtr) { /* Set the Notification enable status as PWM_TRUE for this channel */ Pwm_GaaNotifStatus[LddChannelId] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ /* Clear the Pending Interrupts and Enable Interrupt Processing for Slave */ Pwm_HW_TAUD_IntNotification(LddChannelId); if ((PWM_FIXED_PERIOD_SHIFTED == LpChannelConfig->enClassType) && (PWM_THREE == LpTAUDChannelConfigData->ucMasterOffset)) { /* Get Delay's channel ID */ LddChannelId = (LddChannelId - PWM_ONE); /* PRQA S 1338 # JV-01 */ } else { /* Get Master's channel ID */ LddChannelId = (LddChannelId - (LpTAUDChannelConfigData->ucMasterOffset)); /* PRQA S 1338 # JV-01 */ } /* Get Master's channel Config */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Clear the Pending Interrupts and Enable Interrupt Processing for Master */ Pwm_HW_TAUD_IntNotification(LddChannelId); /* Check whether any notification is configured for this channel */ if (NULL_PTR != LpChannelConfig->pPwmEdgeNotifPtr) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Set the Notification enable status as PWM_TRUE for Master channel */ Pwm_GaaNotifStatus[LddChannelId] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ } else if (((PWM_RISING_EDGE == LenNotification) && ((uint8)PWM_POLARITY_HIGH == LpChannelConfig->ucPolarity)) || ((PWM_FALLING_EDGE == LenNotification) && ((uint8)PWM_POLARITY_LOW == LpChannelConfig->ucPolarity))) { /* Check whether this channel is channel slave 3 of Pwm period shifted set */ if ((PWM_FIXED_PERIOD_SHIFTED == LpChannelConfig->enClassType) && (PWM_THREE == LpTAUDChannelConfigData->ucMasterOffset)) { /* Get the channel number of delay channel */ LddChannelId = LddChannelId - PWM_ONE; /* PRQA S 1338 # JV-01 */ } else { /* Get Master's channel ID */ LddChannelId = (LddChannelId - (LpTAUDChannelConfigData->ucMasterOffset)); /* PRQA S 1338 # JV-01 */ } /* Get Delay's channel Config */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Clear the Pending Interrupts and Enable Interrupt Processing for Delay channel */ Pwm_HW_TAUD_IntNotification(LddChannelId); /* Check whether any notification is configured for this channel */ if (NULL_PTR != LpChannelConfig->pPwmEdgeNotifPtr) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Set the Notification enable status as PWM_TRUE for this channel */ Pwm_GaaNotifStatus[LddChannelId] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ } /* For FALLING EDGE Notification with polarity PWM_HIGH or RISING EDGE Notification with polarity PWM_LOW */ else { /* Clear the Pending Interrupts and Enable Interrupt Processing for Slave */ Pwm_HW_TAUD_IntNotification(LddChannelId); /* Set Notification enable status as PWM_TRUE for this channel */ Pwm_GaaNotifStatus[LddChannelId] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ } } /* else No action required */ /*End of if(PWM_MASTER_CHANNEL != LpTAUDChannelConfigData->ucTimerMode)*/ } /* else No action required */ /* End of LucDetErrFlag is E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_NOTIFICATION_SUPPORTED\\nPWM_DEV_ERROR_DETECT\\nPWM_TAUD_UNIT_USED', 'Value': 'STD_ON\\nSTD_ON\\nSTD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannelId', 'Value': '5'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'PWM_RISING_EDGE,\\nPWM_FALLING_EDGE,\\nPWM_BOTH_EDGES', 'Name': 'LenNotification', 'Value': 'PWM_RISING_EDGE'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '&map_Pwm_HWIPChannelConfig[5]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pPwmEdgeNotifPtr', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucPolarity', 'Value': 'PWM_POLARITY_HIGH'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'PWM_VARIABLE_PERIOD\\nPWM_FIXED_PERIOD\\nPWM_FIXED_PERIOD_SHIFTED', 'Name': 'enClassType', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerMode', 'Value': 'PWM_SLAVE_CHANNEL'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucMasterOffset', 'Value': '3'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'pPwmEdgeNotifPtr', 'Value': 'NULL_PTR'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'pPwmEdgeNotifPtr', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPwmEdgeNotifPtr[0]', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'PWM_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'PWM_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'PWM_ENABLENOTIFICATION_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'PWM_E_NOTIFY_NOTCONFIG'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GaaNotifStatus[5]', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GaaNotifStatus[2]', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GaaNotifStatus[4]', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUD_InitChannel(void) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUDChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Pointer to the TAU Channel Properties structure */ P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer to the TAU Master Channel Properties structure */ P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDMasterProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer used for TAU channel control registers */ P2VAR(volatile Pwm_TAUDChannelUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDChannelReg; /* PRQA S 3432 # JV-01 */ /* Pointer used for TAU Master channel control registers */ P2VAR(volatile Pwm_TAUDChannelUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDMasterChannelReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucTimerUnitType; VAR(Pwm_PeriodType, AUTOMATIC) LddMasterPeriod; VAR(Pwm_PeriodType, AUTOMATIC) LddSlaveDuty; VAR(uint8, AUTOMATIC) LucVar; VAR(uint32, AUTOMATIC) LulCount; /* Loop to set the attributes of TAU channels */ LpChannelConfig = Pwm_GpChannelConfig; /* Initialize all PWM channels configured to support synchronous start/stop of timers, this excludes initialization of channels that will be handled by complex drivers */ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_CHANNELS_CONFIG; LulCount++) { /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ /* Get the Timer Unit Type*/ LucTimerUnitType = LpChannelConfig->ucTimerUnitType; if ((uint8)PWM_HWIP_TAUD == LucTimerUnitType) /* PRQA S 3416 # JV-01 */ { #if (PWM_SYNC_START_SUPPORT == STD_ON) /* Set attributes of TAU channels which are not to be started synchronously */ if ((PWM_FALSE == LpChannelConfig->blSyncStartReq) && (PWM_FALSE == LpTAUDChannelConfigData->blComplexDriverInit)) /* PRQA S 2814 # JV-02 */ #endif { /* Get the pointer to the TAU channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ /* Get the pointer to the TAU channel control registers */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Initialize value for TAUD3 Interrupt Number Selection register */ #if (STD_ON == PWM_TAUD3_UNIT_USED) /* Check the TAUD3 Interrupt Number Selection register is configured for the current channel */ if (NULL_PTR != LpTAUDProperties->pTAUD3INTNOSELxReg) { RH850_SET_IOREG_SYNCP(32, LpTAUDProperties->pTAUD3INTNOSELxReg, /* PRQA S 2814 # JV-01 */ LpTAUDProperties->ulTAUD3InterruptSelectionMask); } /* else No action required */ #endif /* Check for channel in the Master Mode */ if ((uint8)PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { /* Update the CMORm register of Master with the usCMORRegSettingsMask based on the configuration */ *LpTAUDProperties->pCMORReg = LpTAUDProperties->usCMORRegSettingsMask; /* PRQA S 2814 # JV-03 */ if ((Pwm_PeriodType)PWM_TAUD_MIN_PERIOD_VAL != LpTAUDProperties->ddDefaultPeriodOrDuty) { LpTAUDChannelReg->usTAUDnCDRm = (uint16)(LpTAUDProperties->ddDefaultPeriodOrDuty) - (uint16)PWM_ONE; /* PRQA S 2814 # JV-03 */ } else { LpTAUDChannelReg->usTAUDnCDRm = PWM_TAUD_MIN_PERIOD_VAL; } } /* Channel in Slave Mode */ else { /* Master offset from the slave channel */ LucVar = LpTAUDChannelConfigData->ucMasterOffset; /* Get the pointer to the TAU Master channel properties */ LpTAUDMasterProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))(LpChannelConfig - LucVar)->pChannelProp; /* PRQA S 0311, 0316, 0488, 2824, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ /* if Default Period of Master of the slave channel is not zero */ if ((Pwm_PeriodType)PWM_TAUD_MIN_PERIOD_VAL != LpTAUDMasterProperties->ddDefaultPeriodOrDuty) /* PRQA S 2814 # JV-02 */ { /* Pointer to the Master channel registers */ LpTAUDMasterChannelReg = LpTAUDMasterProperties->pCntlRegs; /* Get Master's period */ LddMasterPeriod = LpTAUDMasterChannelReg->usTAUDnCDRm; /* PRQA S 2814 # JV-03 */ /* Get Slave's Duty */ LddSlaveDuty = LpTAUDProperties->ddDefaultPeriodOrDuty; /* Load the Absolute duty value in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = (uint16)Pwm_HW_TAUD_CalculateDuty(LddMasterPeriod, LddSlaveDuty); } else { /* Load the zero in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = PWM_TAUD_MIN_PERIOD_VAL; } /* Update the CMORm register of Slave with the usCMORRegSettingsMask based on the configuration */ *LpTAUDProperties->pCMORReg = LpTAUDProperties->usCMORRegSettingsMask; } /* End of Channel in Slave Mode */ /* Initialize the Idle state of normal channel as PWM_FALSE */ Pwm_GaaChannelIdleStatus[LulCount] = PWM_FALSE; #if (PWM_SET_CHANNEL_OUTPUT_API == STD_ON) /* Initialize the Constant state status of normal channel as PWM_FALSE */ Pwm_GaaChannelConstantStatus[LulCount] = PWM_FALSE; #endif } /* else No action required */ /* End of if ((PWM_FALSE == LpChannelConfig->blSyncStartReq) && (PWM_FALSE == LpTAUDChannelConfigData->blComplexDriverInit)) */ #if (PWM_SYNC_START_SUPPORT == STD_ON) /* Set attributes of TAU channels which are started synchronously */ if ((PWM_TRUE == LpChannelConfig->blSyncStartReq) && (PWM_FALSE == LpTAUDChannelConfigData->blComplexDriverInit)) { /* Initialize the Idle state of Synchronous channel to Idle */ Pwm_GaaChannelIdleStatus[LulCount] = PWM_TRUE; } /* else No action required */ #endif /* End of PWM_SYNC_START_SUPPORT == STD_ON*/ #if (PWM_NOTIFICATION_SUPPORTED == STD_ON) /* Set the Notification status as PWM_FALSE */ Pwm_GaaNotifStatus[LulCount] = PWM_FALSE; #endif } /* else No action required */ /* End of LucTimerUnitType checking */ /* Increment the pointer to the next channel */ LpChannelConfig++; /* PRQA S 2934 # JV-01 */ } /* End of for loop channels */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '[0 to 63]= &map_Pwm_HWIPChannelConfig[0]'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON\\nSTD_OFF', 'Name': 'PWM_TAUD3_UNIT_USED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[0 to 63] = PWM_HWIP_TAUD'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'blComplexDriverInit', 'Value': 'PWM_TRUE'], 'Input_Param_005': ['Type': 'Array', 'Range': 'PWM_TRUE\\nPWM_FALSE', 'Name': 'blSyncStartReq', 'Value': '[0 to 63]= PWM_FALSE'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pChannelProp', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'NULL_PTR\\n!NULL_PTR', 'Name': 'pTAUD3INTNOSELxReg', 'Value': '&map_pTAUD3INTNOSELxReg[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulTAUD3InterruptSelectionMask', 'Value': '0x00000100'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTAUD3INTNOSELxReg[0]', 'Value': '0x00000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerMode', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucMasterOffset', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pCMORReg', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'usCMORRegSettingsMask', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '0x0000..0xFFFF', 'Name': 'ddDefaultPeriodOrDuty', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'usTAUDnCDRm', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_unsigned_short_int[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_unsigned_short_int[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'usTAUDnCDRm', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_pTAUD3INTNOSELxReg[0]', 'Value': '0x00000000 | 0x00000000'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddAbsolutePeriod', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddRelativeDuty', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to 63]', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelConstantStatus[0 to 63]', 'Value': '-'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaNotifStatus[0 to 63]', 'Value': '[0 to 63]= PWM_FALSE'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((PWM_SET_DUTY_CYCLE_API == STD_ON) || (PWM_SET_PERIOD_AND_DUTY_API == STD_ON)) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUD_SetDuty_FixedPeriodShifted(Pwm_ChannelType LddChannelId, uint16 LusDutyCycle) /* PRQA S 1505 # JV-01 */ { /* Pointer pointing to the TAUD Unit configuration */ P2CONST(Pwm_TAUDUnitConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpTAUDUnitConfig; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUDChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the TAUD Unit control registers */ P2VAR(volatile Pwm_TAUDUnitUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDUnitUserReg; /* PRQA S 3432 # JV-01 */ /* Pointer used for TAUD channel control registers */ P2VAR(volatile Pwm_TAUDChannelUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDChannelReg; /* PRQA S 3432 # JV-01 */ /* Pointer to the TAUD Channel Properties structure */ P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer to the TAUD Master Channel Properties structure */ P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDMasterProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(Pwm_PeriodType, AUTOMATIC) LddMasterPeriod; VAR(uint32, AUTOMATIC) LulCount; VAR(uint16, AUTOMATIC) LusChannelMask; VAR(uint8, AUTOMATIC) LucVar; #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) VAR(boolean, AUTOMATIC) blDemReport; blDemReport = PWM_FALSE; #endif /* Initialize a pointer to the channel configuration */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ /* Get the pointer to the TAUD channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ /* Check whether the channel in Master mode */ if ((uint8)PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { /* Get the channel mask for the particular channel */ LusChannelMask = LpTAUDProperties->usChannelMask; /* PRQA S 2814 # JV-03 */ /* Fetch the pointer to the current TAUD Unit config */ LpTAUDUnitConfig = &Pwm_GpTAUDUnitConfig[LpTAUDChannelConfigData->ucTimerUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Fetch the pointer to the current TAUD Unit Registers */ LpTAUDUnitUserReg = LpTAUDUnitConfig->pUserCntlRegs; /* PRQA S 2814 # JV-03 */ /* Initialize a pointer to the Master's control register configuration of TAUD */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Get the master's period */ LddMasterPeriod = LpTAUDChannelReg->usTAUDnCDRm; /* PRQA S 2814 # JV-03 */ for (LulCount = (uint32)PWM_ONE; (uint32)PWM_THREE >= LulCount; LulCount++) { /* Increment the channel Id */ LddChannelId++; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Increment the channel for the next channel */ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ /* Get the pointer to the TAUD channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Initialize a pointer to the slave's control register configuration of TAUD */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Check for the Slave1 and Slave3 channels */ if (((uint32)PWM_ONE == LulCount) || ((uint32)PWM_THREE == LulCount)) { /* Check whether the channel is set to its Idle state */ if (PWM_TRUE == Pwm_GaaChannelIdleStatus[LddChannelId]) /* PRQA S 2844 # JV-01 */ { /* Enable the output of the current channel */ LpTAUDUnitUserReg->usTAUDnTOE = (LpTAUDUnitUserReg->usTAUDnTOE | LpTAUDProperties->usChannelMask); /* PRQA S 2814 # JV-03 */ /* Set the Idle state of the channel to PWM_FALSE */ Pwm_GaaChannelIdleStatus[LddChannelId] = PWM_FALSE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ } /* else No action required */ /* Check whether simultaneous rewrite has been completed */ if (PWM_TAUD_RESET_16BIT_REG == (uint16)(LusChannelMask & LpTAUDUnitUserReg->usTAUDnRSF)) { /* Load the Absolute duty value in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = /* PRQA S 2814 # JV-03 */ (uint16)Pwm_HW_TAUD_CalculateDuty(LddMasterPeriod, (Pwm_PeriodType)LusDutyCycle); } else { LusChannelMask = LusChannelMask & (uint16)(~LpTAUDProperties->usChannelMask); #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) /* Set Dem error flag */ blDemReport = PWM_TRUE; #endif } } /*End of for (LulCount = (uint32)PWM_ONE; (uint32)PWM_THREE >= LulCount; LulCount++) */ /* Set the corresponding channel Trigger bit to specifies the channel for which simultaneous rewrite is executed */ LpTAUDUnitUserReg->usTAUDnRDT = LusChannelMask; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) if (PWM_TRUE == blDemReport) { PWM_DEM_REPORT_ERROR(PWM_E_REWRITE_FAILED, DEM_EVENT_STATUS_FAILED); } /* else No action required */ #endif } /* End of if (PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) */ else { /* Get the offset of the Master from the slave channel */ LucVar = LpTAUDChannelConfigData->ucMasterOffset; /* Get the pointer to the TAUD Master channel properties */ LpTAUDMasterProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))(LpChannelConfig - LucVar)->pChannelProp; /* PRQA S 0311, 0316, 0488, 2824, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Fetch the pointer to the current TAUD Unit config */ LpTAUDUnitConfig = &Pwm_GpTAUDUnitConfig[LpTAUDChannelConfigData->ucTimerUnitIndex]; /* Fetch the pointer to the current TAUD Unit Registers */ LpTAUDUnitUserReg = LpTAUDUnitConfig->pUserCntlRegs; /* PRQA S 2814 # JV-03 */ /* Get the masters channel ID*/ LddChannelId = (LddChannelId - (LpTAUDChannelConfigData->ucMasterOffset)); /* PRQA S 1338 # JV-01 */ /* Get the Master channel config pointer*/ LpChannelConfig = LpChannelConfig - LpTAUDChannelConfigData->ucMasterOffset; /* PRQA S 0488, 2934 # JV-01, JV-01 */ /* Get the channel mask from the channel configuration */ LusChannelMask = LpTAUDProperties->usChannelMask; /* Initialize a pointer to the Master's control register configuration of TAUD */ LpTAUDChannelReg = LpTAUDMasterProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Get the master's period */ LddMasterPeriod = LpTAUDChannelReg->usTAUDnCDRm; /* PRQA S 2814 # JV-01 */ /* Initialize a pointer to the slave's control register configuration of TAUD */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* Loop to set slave 1 and slave 2 of the particular Master for the 3 consecutive channels configured in fixed period shifted classtype */ for (LulCount = (uint32)PWM_ONE; (uint32)PWM_THREE >= LulCount; LulCount++) { /* Increment the channel Id */ LddChannelId++; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Increment the pointer to the next channel */ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ /* Get the pointer to the TAUD channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Check for Salve 1 or Slave 3 of the Master */ if (((uint32)PWM_ONE == LulCount) || ((uint32)PWM_THREE == LulCount)) { /* Check whether the channel is set to its Idle state */ if (PWM_TRUE == Pwm_GaaChannelIdleStatus[LddChannelId]) /* PRQA S 2844 # JV-01 */ { /* Enable the output of the current channel */ LpTAUDUnitUserReg->usTAUDnTOE = (LpTAUDUnitUserReg->usTAUDnTOE | LpTAUDProperties->usChannelMask); /* PRQA S 2814 # JV-03 */ /* Set the Idle state of the channel to PWM_FALSE */ Pwm_GaaChannelIdleStatus[LddChannelId] = PWM_FALSE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ } /* else No action required */ } /*End of for (LulCount = (uint8)PWM_ONE; (uint8)PWM_THREE >= LulCount; LulCount++)*/ /* Check whether simultaneous rewrite has been completed */ if (PWM_TAUD_RESET_16BIT_REG == (uint16)(LusChannelMask & LpTAUDUnitUserReg->usTAUDnRSF)) { /* Load the Absolute duty value in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = (uint16)Pwm_HW_TAUD_CalculateDuty(LddMasterPeriod, (Pwm_PeriodType)LusDutyCycle); /* PRQA S 2814 # JV-03 */ /* Set the corresponding channel Trigger bit to specifies the channel for which simultaneous rewrite is executed */ LpTAUDUnitUserReg->usTAUDnRDT = LusChannelMask; } #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) else { /* Set Dem error flag */ blDemReport = PWM_TRUE; } #endif #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) if (PWM_TRUE == blDemReport) { PWM_DEM_REPORT_ERROR(PWM_E_REWRITE_FAILED, DEM_EVENT_STATUS_FAILED); } /* else No action required */ #endif } /* End of if (PWM_MASTER_CHANNEL != LpTAUDChannelConfigData->ucTimerMode) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_SET_PERIOD_AND_DUTY_API', 'Value': 'STD_ON(1)'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_SET_DUTY_CYCLE_API', 'Value': 'STD_ON(1)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_E_REWRITE_FAILED', 'Value': '#define'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON(1)'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannelId', 'Value': '0'], 'Input_Param_006': ['Type': 'Argument', 'Range': '0x0..0x8000', 'Name': 'LusDutyCycle', 'Value': '0x0000'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpTAUDUnitConfig', 'Value': '&map_Pwm_GpTAUDUnitConfig[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 7].pHWIPChannelConfig', 'Value': '[0]= &map_Pwm_HWIPChannelConfig[0]\\n[1]= &map_Pwm_HWIPChannelConfig[1]\\n[2]= &map_Pwm_HWIPChannelConfig[2]\\n[3]= &map_Pwm_HWIPChannelConfig[3]\\n[4]= &map_Pwm_HWIPChannelConfig[4]\\n[5]= &map_Pwm_HWIPChannelConfig[5]\\n[6]= &map_Pwm_HWIPChannelConfig[6]\\n[7]= &map_Pwm_HWIPChannelConfig[7]\\n'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to 7].ucTimerMode', 'Value': '[0] = PWM_MASTER_CHANNEL\\n[1 to 3] = PWM_SLAVE_CHANNEL\\n[4] = PWM_MASTER_CHANNEL\\n[5 to 7] = 0x55555555'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to 7].ucMasterOffset', 'Value': '-'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to 7].ucTimerUnitIndex', 'Value': '[0]= 0x00'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpTAUDUnitConfig[0].pUserCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUnitUserRegs[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0].pChannelProp', 'Value': '&map_Pwm_TAUDProperties[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[1].pChannelProp', 'Value': '&map_Pwm_TAUDProperties_1[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[2].pChannelProp', 'Value': '&map_Pwm_TAUDProperties_2[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[3].pChannelProp', 'Value': '&map_Pwm_TAUDProperties_3[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_1[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_2[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs_2[0].usTAUDnCDRm'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_3[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs_3[0].usTAUDnCDRm'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnTOE', 'Value': '0x0000'], 'Input_Param_023': ['Type': 'Variable', 'Range': '0x0000\u20260xFFFF', 'Name': 'map_Pwm_TAUDProperties[0].usChannelMask', 'Value': '0x000F'], 'Input_Param_024': ['Type': 'Variable', 'Range': '0x0000\u20260xFFFF', 'Name': 'map_Pwm_TAUDProperties_1[0].usChannelMask', 'Value': '0x0000'], 'Input_Param_025': ['Type': 'Variable', 'Range': '0x0000\u20260xFFFF', 'Name': 'map_Pwm_TAUDProperties_2[0].usChannelMask', 'Value': '0x0002'], 'Input_Param_026': ['Type': 'Variable', 'Range': '0x0000\u20260xFFFF', 'Name': 'map_Pwm_TAUDProperties_3[0].usChannelMask', 'Value': '0xFFFF'], 'Input_Param_027': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnRSF', 'Value': '0x0000'], 'Input_Param_028': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm', 'Value': '0x8000'], 'Input_Param_029': ['Type': 'Array', 'Range': 'PWM_FALSE(0x00)\\nPWM_TRUE(0x01)', 'Name': 'Pwm_GaaChannelIdleStatus[0 to 7]', 'Value': '[0 to 2] = PWM_TRUE\\n[3] = PWM_FALSE\\n[4 to 7] = 0x55555555']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm', 'Value': '0x8000'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm', 'Value': '0x0001'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_2[0].usTAUDnCDRm', 'Value': '0x0001'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_3[0].usTAUDnCDRm', 'Value': '0x0001'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnRDT', 'Value': '0x000F'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnTOE', 'Value': '0x0000'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to 7]', 'Value': '[0] = PWM_TRUE\\n[1] = PWM_FALSE\\n[2] = PWM_TRUE\\n[3] = PWM_FALSE\\n[4 to 7] = 0x55555555'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddMasterPeriod', 'Value': '[0 to 2]  = 0x8000'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusDutyCycle', 'Value': '[0 to 2] = 0x0000'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SET_PERIOD_AND_DUTY_API == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUD_SetPeriodAndDuty( /* PRQA S 1532 # JV-01 */ Pwm_ChannelType LddChannelId, Pwm_PeriodType LddPeriod, uint16 LusDutyCycle) { /* Pointer pointing to the TAU Unit configuration */ P2CONST(Pwm_TAUDUnitConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpTAUDUnitConfig; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUDChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the TAU Unit control registers */ P2VAR(volatile Pwm_TAUDUnitUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDUnitUserReg; /* PRQA S 3432 # JV-01 */ /* Pointer used for TAU channel control registers */ P2VAR(volatile Pwm_TAUDChannelUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDChannelReg; /* PRQA S 3432 # JV-01 */ /* Pointer to the TAU Channel Properties structure */ P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(uint16, AUTOMATIC) LusMasterChannelMask; #if (PWM_DEV_ERROR_DETECT == STD_ON) VAR(uint8, AUTOMATIC) LucDetErrFlag; #endif #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) VAR(boolean, AUTOMATIC) blDemReport; /* Initialize DEM report status */ blDemReport = PWM_FALSE; #endif /* Initialize a pointer to the channel configuration */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Initialize DET error flag */ LucDetErrFlag = E_OK; if ((uint8)PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { if ((Pwm_PeriodType)PWM_TAUD_MAX_PERIOD_VAL < LddPeriod) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SET_PERIODANDDUTY_SID, PWM_E_PARAM_VALUE); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } /* else No action required */ /* End of if PWM_MASTER_CHANNEL == LpTAUJChannelConfigData->ucTimerMode */ if (E_OK == LucDetErrFlag) #endif /* (PWM_DEV_ERROR_DETECT == STD_ON) */ { /* Set the period if the channel is master and set the duty of all the slaves of that master */ if ((uint8)PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { /* Fetch the pointer to the current TAUD Unit config */ LpTAUDUnitConfig = &Pwm_GpTAUDUnitConfig[LpTAUDChannelConfigData->ucTimerUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Fetch the pointer to the current TAUD Unit Registers */ LpTAUDUnitUserReg = LpTAUDUnitConfig->pUserCntlRegs; /* PRQA S 2814 # JV-03 */ /* Get the pointer to the TAUD channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ /* Initialize a pointer to the control register configuration of TAUD */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Get the Channel Mask of the Master channel for RDT register */ LusMasterChannelMask = LpTAUDProperties->usChannelMask; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Check whether simultaneous rewrite has been completed */ if (PWM_TAUD_RESET_16BIT_REG == (uint16)(LpTAUDProperties->usChannelMask & LpTAUDUnitUserReg->usTAUDnRSF)) /* PRQA S 2814 # JV-03 */ { if ((Pwm_PeriodType)PWM_TAUD_MIN_PERIOD_VAL != LddPeriod) { /* Decrement the period value */ LddPeriod--; /* PRQA S 1338 # JV-01 */ /* Load the period value in to the CDR register of master channel */ LpTAUDChannelReg->usTAUDnCDRm = (uint16)LddPeriod; /* PRQA S 2814 # JV-03 */ } else { /* Set 0 in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = PWM_TAUD_MIN_PERIOD_VAL; } } #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) else { /* Set Dem error flag */ blDemReport = PWM_TRUE; } #endif #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Increment the channel Id */ LddChannelId++; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Increment the pointer to the next channel*/ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif do { /* Get the pointer to the TAU channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Initialize a pointer to the slave's control register configuration of TAU */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Check whether the channel is set to its Idle state */ if (PWM_TRUE == Pwm_GaaChannelIdleStatus[LddChannelId]) /* PRQA S 2844 # JV-01 */ { /* Enable the output of the current channel */ LpTAUDUnitUserReg->usTAUDnTOE = (LpTAUDUnitUserReg->usTAUDnTOE | LpTAUDProperties->usChannelMask); /* Set the Idle state of the channel to PWM_FALSE */ Pwm_GaaChannelIdleStatus[LddChannelId] = PWM_FALSE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ /* Check whether simultaneous rewrite has been completed */ if (PWM_TAUD_RESET_16BIT_REG == (uint16)(LpTAUDProperties->usChannelMask & LpTAUDUnitUserReg->usTAUDnRSF)) { if ((Pwm_PeriodType)PWM_TAUD_MIN_PERIOD_VAL != LddPeriod) { /* Load the Absolute duty value in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = (uint16)Pwm_HW_TAUD_CalculateDuty(LddPeriod, (Pwm_PeriodType)LusDutyCycle); /* PRQA S 2814 # JV-03 */ } else { /* Set 0 in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = PWM_TAUD_MIN_PERIOD_VAL; } } else { LusMasterChannelMask = LusMasterChannelMask & (uint16)(~LpTAUDProperties->usChannelMask); #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) /* Set Dem error flag */ blDemReport = PWM_TRUE; #endif } /* Increment the channel */ LddChannelId++; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Increment the pointer to the next channel*/ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ if (PWM_TOTAL_CHANNELS_CONFIG > LddChannelId) { /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ } /* else No action required */ } while ((PWM_TOTAL_CHANNELS_CONFIG > LddChannelId) && ((uint8)PWM_MASTER_CHANNEL != LpTAUDChannelConfigData->ucTimerMode)); /* PRQA S 2814 # JV-02 */ /* Set the corresponding channels Trigger bits to specifies the channels for which simultaneous rewrite is executed */ LpTAUDUnitUserReg->usTAUDnRDT = LusMasterChannelMask; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) if (PWM_TRUE == blDemReport) { PWM_DEM_REPORT_ERROR(PWM_E_REWRITE_FAILED, DEM_EVENT_STATUS_FAILED); } /* else No action required */ #endif } /* End of if (PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) */ /* Set the Duty cycle of the requested channel if Slave */ else { /* Set the Duty cycle for the slave channel */ Pwm_HW_TAUD_SetDutyCycle(LddChannelId, LusDutyCycle); } } /* else No action required */ /* End of if (E_OK == LucDetErrFlag) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_SET_PERIOD_AND_DUTY_API', 'Value': 'STD_ON(1)'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_E_REWRITE_FAILED', 'Value': '#define'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON(1)'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannelId', 'Value': '0'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'PWM_TAUD_MIN_PERIOD_VAL\u2026\u2026.\\nPWM_TAUD_MAX_PERIOD_VAL', 'Name': 'LddPeriod', 'Value': 'PWM_TAUD_MAX_PERIOD_VAL'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'PWM_MIN_DUTY_CYCLE_VALUE...\\nPWM_MAX_DUTY_CYCLE_VALUE', 'Name': 'LusDutyCycle', 'Value': 'PWM_MAX_DUTY_CYCLE_VALUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpTAUDUnitConfig', 'Value': '&map_Pwm_GpTAUDUnitConfig[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].pHWIPChannelConfig', 'Value': '[0]= &map_Pwm_HWIPChannelConfig[0]\\n[1]= &map_Pwm_HWIPChannelConfig[1]\\n[2]= &map_Pwm_HWIPChannelConfig[2]\\n[3]= &map_Pwm_HWIPChannelConfig[3]\\n[4]= &map_Pwm_HWIPChannelConfig[4]\\n[5]= &map_Pwm_HWIPChannelConfig[5]\\n[6]= &map_Pwm_HWIPChannelConfig[6]\\n[7]= &map_Pwm_HWIPChannelConfig[7]\\n'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucTimerMode', 'Value': '[0] = PWM_MASTER_CHANNEL\\n[1 to 2] = PWM_SLAVE_CHANNEL\\n[3] = PWM_MASTER_CHANNEL\\n[4 to 7] = 0x55555555'], 'Input_Param_011': ['Type': 'Array', 'Range': 'PWM_VARIABLE_PERIOD\\nPWM_FIXED_PERIOD\\nPWM_FIXED_PERIOD_SHIFTED', 'Name': 'map_Pwm_GpChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].enClassType', 'Value': '[0 to 7] = PWM_VARIABLE_PERIOD'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucMasterOffset', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucTimerUnitIndex', 'Value': '[0]= 0x00'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpTAUDUnitConfig[0].pUserCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUnitUserRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0].pChannelProp', 'Value': '&map_Pwm_TAUDProperties[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[1].pChannelProp', 'Value': '&map_Pwm_TAUDProperties_1[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[2].pChannelProp', 'Value': '&map_Pwm_TAUDProperties_2[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[38].pChannelProp', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[39].pChannelProp', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[62].pChannelProp', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[63].pChannelProp', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[82].pChannelProp', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[83].pChannelProp', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[98].pChannelProp', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[99].pChannelProp', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[110].pChannelProp', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[111].pChannelProp', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_1[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_2[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs_2[0].usTAUDnCDRm'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnTOE', 'Value': '0x0000'], 'Input_Param_032': ['Type': 'Variable', 'Range': '0x0000\u20260xFFFF', 'Name': 'map_Pwm_TAUDProperties[0].usChannelMask', 'Value': '0xFFFF'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_1[0].usChannelMask', 'Value': '0x0002'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_2[0].usChannelMask', 'Value': '0x0004'], 'Input_Param_035': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnRSF', 'Value': '0x0000'], 'Input_Param_036': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm', 'Value': '0x0000'], 'Input_Param_037': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm', 'Value': '0x0000'], 'Input_Param_038': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to PWM_TOTAL_CHANNELS_CONFIG]', 'Value': '[0 to 2] = PWM_TRUE\\n[3 to 39] = 0x55555555'], 'Input_Param_039': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0]= 0xFFFF\\n[1]= 0x2000']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm', 'Value': 'PWM_TAUD_MAX_PERIOD_VAL - 1'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm', 'Value': '0xFFFF'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_2[0].usTAUDnCDRm', 'Value': '0x2000'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnRDT', 'Value': '0xFFFF'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnTOE', 'Value': '0x0006'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to PWM_TOTAL_CHANNELS_CONFIG]', 'Value': '[0] = PWM_TRUE\\n[1 to 2] = PWM_FALSE\\n[3 to 39] = 0x55555555'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusDutyCycle', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddAbsolutePeriod', 'Value': '[0 to 1] = PWM_TAUD_MAX_PERIOD_VAL - 1'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddRelativeDuty', 'Value': '[0 to 1] = PWM_MAX_DUTY_CYCLE_VALUE'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'PWM_E_REWRITE_FAILED', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'DEM_EVENT_STATUS_FAILED', 'Value': '<Not Called>'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SET_PERIOD_AND_DUTY_API == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUD_SetPeriodAndDuty( /* PRQA S 1532 # JV-01 */ Pwm_ChannelType LddChannelId, Pwm_PeriodType LddPeriod, uint16 LusDutyCycle) { /* Pointer pointing to the TAU Unit configuration */ P2CONST(Pwm_TAUDUnitConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpTAUDUnitConfig; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUDChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the TAU Unit control registers */ P2VAR(volatile Pwm_TAUDUnitUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDUnitUserReg; /* PRQA S 3432 # JV-01 */ /* Pointer used for TAU channel control registers */ P2VAR(volatile Pwm_TAUDChannelUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDChannelReg; /* PRQA S 3432 # JV-01 */ /* Pointer to the TAU Channel Properties structure */ P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(uint16, AUTOMATIC) LusMasterChannelMask; #if (PWM_DEV_ERROR_DETECT == STD_ON) VAR(uint8, AUTOMATIC) LucDetErrFlag; #endif #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) VAR(boolean, AUTOMATIC) blDemReport; /* Initialize DEM report status */ blDemReport = PWM_FALSE; #endif /* Initialize a pointer to the channel configuration */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Initialize DET error flag */ LucDetErrFlag = E_OK; if ((uint8)PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { if ((Pwm_PeriodType)PWM_TAUD_MAX_PERIOD_VAL < LddPeriod) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SET_PERIODANDDUTY_SID, PWM_E_PARAM_VALUE); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } /* else No action required */ /* End of if PWM_MASTER_CHANNEL == LpTAUJChannelConfigData->ucTimerMode */ if (E_OK == LucDetErrFlag) #endif /* (PWM_DEV_ERROR_DETECT == STD_ON) */ { /* Set the period if the channel is master and set the duty of all the slaves of that master */ if ((uint8)PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { /* Fetch the pointer to the current TAUD Unit config */ LpTAUDUnitConfig = &Pwm_GpTAUDUnitConfig[LpTAUDChannelConfigData->ucTimerUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Fetch the pointer to the current TAUD Unit Registers */ LpTAUDUnitUserReg = LpTAUDUnitConfig->pUserCntlRegs; /* PRQA S 2814 # JV-03 */ /* Get the pointer to the TAUD channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ /* Initialize a pointer to the control register configuration of TAUD */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Get the Channel Mask of the Master channel for RDT register */ LusMasterChannelMask = LpTAUDProperties->usChannelMask; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Check whether simultaneous rewrite has been completed */ if (PWM_TAUD_RESET_16BIT_REG == (uint16)(LpTAUDProperties->usChannelMask & LpTAUDUnitUserReg->usTAUDnRSF)) /* PRQA S 2814 # JV-03 */ { if ((Pwm_PeriodType)PWM_TAUD_MIN_PERIOD_VAL != LddPeriod) { /* Decrement the period value */ LddPeriod--; /* PRQA S 1338 # JV-01 */ /* Load the period value in to the CDR register of master channel */ LpTAUDChannelReg->usTAUDnCDRm = (uint16)LddPeriod; /* PRQA S 2814 # JV-03 */ } else { /* Set 0 in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = PWM_TAUD_MIN_PERIOD_VAL; } } #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) else { /* Set Dem error flag */ blDemReport = PWM_TRUE; } #endif #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Increment the channel Id */ LddChannelId++; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Increment the pointer to the next channel*/ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif do { /* Get the pointer to the TAU channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Initialize a pointer to the slave's control register configuration of TAU */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Check whether the channel is set to its Idle state */ if (PWM_TRUE == Pwm_GaaChannelIdleStatus[LddChannelId]) /* PRQA S 2844 # JV-01 */ { /* Enable the output of the current channel */ LpTAUDUnitUserReg->usTAUDnTOE = (LpTAUDUnitUserReg->usTAUDnTOE | LpTAUDProperties->usChannelMask); /* Set the Idle state of the channel to PWM_FALSE */ Pwm_GaaChannelIdleStatus[LddChannelId] = PWM_FALSE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ /* Check whether simultaneous rewrite has been completed */ if (PWM_TAUD_RESET_16BIT_REG == (uint16)(LpTAUDProperties->usChannelMask & LpTAUDUnitUserReg->usTAUDnRSF)) { if ((Pwm_PeriodType)PWM_TAUD_MIN_PERIOD_VAL != LddPeriod) { /* Load the Absolute duty value in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = (uint16)Pwm_HW_TAUD_CalculateDuty(LddPeriod, (Pwm_PeriodType)LusDutyCycle); /* PRQA S 2814 # JV-03 */ } else { /* Set 0 in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = PWM_TAUD_MIN_PERIOD_VAL; } } else { LusMasterChannelMask = LusMasterChannelMask & (uint16)(~LpTAUDProperties->usChannelMask); #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) /* Set Dem error flag */ blDemReport = PWM_TRUE; #endif } /* Increment the channel */ LddChannelId++; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Increment the pointer to the next channel*/ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ if (PWM_TOTAL_CHANNELS_CONFIG > LddChannelId) { /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ } /* else No action required */ } while ((PWM_TOTAL_CHANNELS_CONFIG > LddChannelId) && ((uint8)PWM_MASTER_CHANNEL != LpTAUDChannelConfigData->ucTimerMode)); /* PRQA S 2814 # JV-02 */ /* Set the corresponding channels Trigger bits to specifies the channels for which simultaneous rewrite is executed */ LpTAUDUnitUserReg->usTAUDnRDT = LusMasterChannelMask; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) if (PWM_TRUE == blDemReport) { PWM_DEM_REPORT_ERROR(PWM_E_REWRITE_FAILED, DEM_EVENT_STATUS_FAILED); } /* else No action required */ #endif } /* End of if (PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) */ /* Set the Duty cycle of the requested channel if Slave */ else { /* Set the Duty cycle for the slave channel */ Pwm_HW_TAUD_SetDutyCycle(LddChannelId, LusDutyCycle); } } /* else No action required */ /* End of if (E_OK == LucDetErrFlag) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_SET_PERIOD_AND_DUTY_API', 'Value': 'STD_ON(1)'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_E_REWRITE_FAILED', 'Value': '#define'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON(1)'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannelId', 'Value': '0'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'PWM_TAUD_MIN_PERIOD_VAL\u2026\u2026.\\nPWM_TAUD_MAX_PERIOD_VAL', 'Name': 'LddPeriod', 'Value': 'PWM_TAUD_MIN_PERIOD_VAL'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'PWM_MIN_DUTY_CYCLE_VALUE...\\nPWM_MAX_DUTY_CYCLE_VALUE', 'Name': 'LusDutyCycle', 'Value': 'PWM_MIN_DUTY_CYCLE_VALUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpTAUDUnitConfig', 'Value': '&map_Pwm_GpTAUDUnitConfig[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].pHWIPChannelConfig', 'Value': '[0]= &map_Pwm_HWIPChannelConfig[0]\\n[1]= &map_Pwm_HWIPChannelConfig[1]\\n[2]= &map_Pwm_HWIPChannelConfig[2]\\n[3]= &map_Pwm_HWIPChannelConfig[3]\\n[4]= &map_Pwm_HWIPChannelConfig[4]\\n[5]= &map_Pwm_HWIPChannelConfig[5]\\n[6]= &map_Pwm_HWIPChannelConfig[6]\\n[7]= &map_Pwm_HWIPChannelConfig[7]\\n'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucTimerMode', 'Value': '[0] = PWM_MASTER_CHANNEL\\n[1] = PWM_SLAVE_CHANNEL\\n[2] = PWM_MASTER_CHANNEL\\n[3 to 7] = 0x55555555'], 'Input_Param_011': ['Type': 'Array', 'Range': 'PWM_VARIABLE_PERIOD\\nPWM_FIXED_PERIOD\\nPWM_FIXED_PERIOD_SHIFTED', 'Name': 'map_Pwm_GpChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].enClassType', 'Value': '[0 to 7] = PWM_VARIABLE_PERIOD'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucMasterOffset', 'Value': '-'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucTimerUnitIndex', 'Value': '[0]= 0x00'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpTAUDUnitConfig[0].pUserCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUnitUserRegs[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0].pChannelProp', 'Value': '&map_Pwm_TAUDProperties[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[1].pChannelProp', 'Value': '&map_Pwm_TAUDProperties_1[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[2].pChannelProp', 'Value': '&map_Pwm_TAUDProperties_2[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[38].pChannelProp', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[39].pChannelProp', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[62].pChannelProp', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[63].pChannelProp', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[82].pChannelProp', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[83].pChannelProp', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[98].pChannelProp', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[99].pChannelProp', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[110].pChannelProp', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[111].pChannelProp', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_1[0].pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_2[0].pCntlRegs', 'Value': '-'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnTOE', 'Value': '0x0000'], 'Input_Param_032': ['Type': 'Variable', 'Range': '0x0000\u20260xFFFF', 'Name': 'map_Pwm_TAUDProperties[0].usChannelMask', 'Value': '0x0000'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_1[0].usChannelMask', 'Value': '0x0002'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_2[0].usChannelMask', 'Value': '-'], 'Input_Param_035': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnRSF', 'Value': '0x0000'], 'Input_Param_036': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm', 'Value': '0x0000'], 'Input_Param_037': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm', 'Value': '0x0000'], 'Input_Param_038': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to PWM_TOTAL_CHANNELS_CONFIG]', 'Value': '[0 to 39] = PWM_FALSE'], 'Input_Param_039': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm', 'Value': 'PWM_TAUD_MIN_PERIOD_VAL'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm', 'Value': 'PWM_TAUD_MIN_PERIOD_VAL'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_2[0].usTAUDnCDRm', 'Value': '-'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnRDT', 'Value': '0x0000'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnTOE', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to PWM_TOTAL_CHANNELS_CONFIG]', 'Value': '[0 to 39] = PWM_FALSE'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusDutyCycle', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddAbsolutePeriod', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddRelativeDuty', 'Value': '<Not Called>'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'INTERRUPT_CONTROL_PROTECTION'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'PWM_E_REWRITE_FAILED', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'DEM_EVENT_STATUS_FAILED', 'Value': '<Not Called>'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SET_PERIOD_AND_DUTY_API == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUD_SetPeriodAndDuty( /* PRQA S 1532 # JV-01 */ Pwm_ChannelType LddChannelId, Pwm_PeriodType LddPeriod, uint16 LusDutyCycle) { /* Pointer pointing to the TAU Unit configuration */ P2CONST(Pwm_TAUDUnitConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpTAUDUnitConfig; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUDChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the TAU Unit control registers */ P2VAR(volatile Pwm_TAUDUnitUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDUnitUserReg; /* PRQA S 3432 # JV-01 */ /* Pointer used for TAU channel control registers */ P2VAR(volatile Pwm_TAUDChannelUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDChannelReg; /* PRQA S 3432 # JV-01 */ /* Pointer to the TAU Channel Properties structure */ P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUDProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ VAR(uint16, AUTOMATIC) LusMasterChannelMask; #if (PWM_DEV_ERROR_DETECT == STD_ON) VAR(uint8, AUTOMATIC) LucDetErrFlag; #endif #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) VAR(boolean, AUTOMATIC) blDemReport; /* Initialize DEM report status */ blDemReport = PWM_FALSE; #endif /* Initialize a pointer to the channel configuration */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Initialize DET error flag */ LucDetErrFlag = E_OK; if ((uint8)PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { if ((Pwm_PeriodType)PWM_TAUD_MAX_PERIOD_VAL < LddPeriod) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SET_PERIODANDDUTY_SID, PWM_E_PARAM_VALUE); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } /* else No action required */ /* End of if PWM_MASTER_CHANNEL == LpTAUJChannelConfigData->ucTimerMode */ if (E_OK == LucDetErrFlag) #endif /* (PWM_DEV_ERROR_DETECT == STD_ON) */ { /* Set the period if the channel is master and set the duty of all the slaves of that master */ if ((uint8)PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-02 */ { /* Fetch the pointer to the current TAUD Unit config */ LpTAUDUnitConfig = &Pwm_GpTAUDUnitConfig[LpTAUDChannelConfigData->ucTimerUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Fetch the pointer to the current TAUD Unit Registers */ LpTAUDUnitUserReg = LpTAUDUnitConfig->pUserCntlRegs; /* PRQA S 2814 # JV-03 */ /* Get the pointer to the TAUD channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ /* Initialize a pointer to the control register configuration of TAUD */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Get the Channel Mask of the Master channel for RDT register */ LusMasterChannelMask = LpTAUDProperties->usChannelMask; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Check whether simultaneous rewrite has been completed */ if (PWM_TAUD_RESET_16BIT_REG == (uint16)(LpTAUDProperties->usChannelMask & LpTAUDUnitUserReg->usTAUDnRSF)) /* PRQA S 2814 # JV-03 */ { if ((Pwm_PeriodType)PWM_TAUD_MIN_PERIOD_VAL != LddPeriod) { /* Decrement the period value */ LddPeriod--; /* PRQA S 1338 # JV-01 */ /* Load the period value in to the CDR register of master channel */ LpTAUDChannelReg->usTAUDnCDRm = (uint16)LddPeriod; /* PRQA S 2814 # JV-03 */ } else { /* Set 0 in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = PWM_TAUD_MIN_PERIOD_VAL; } } #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) else { /* Set Dem error flag */ blDemReport = PWM_TRUE; } #endif #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif /* Increment the channel Id */ LddChannelId++; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Increment the pointer to the next channel*/ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Enter Protected area */ PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif do { /* Get the pointer to the TAU channel properties */ LpTAUDProperties = (P2VAR(Pwm_TAUDChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ /* Initialize a pointer to the slave's control register configuration of TAU */ LpTAUDChannelReg = LpTAUDProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Check whether the channel is set to its Idle state */ if (PWM_TRUE == Pwm_GaaChannelIdleStatus[LddChannelId]) /* PRQA S 2844 # JV-01 */ { /* Enable the output of the current channel */ LpTAUDUnitUserReg->usTAUDnTOE = (LpTAUDUnitUserReg->usTAUDnTOE | LpTAUDProperties->usChannelMask); /* Set the Idle state of the channel to PWM_FALSE */ Pwm_GaaChannelIdleStatus[LddChannelId] = PWM_FALSE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ /* Check whether simultaneous rewrite has been completed */ if (PWM_TAUD_RESET_16BIT_REG == (uint16)(LpTAUDProperties->usChannelMask & LpTAUDUnitUserReg->usTAUDnRSF)) { if ((Pwm_PeriodType)PWM_TAUD_MIN_PERIOD_VAL != LddPeriod) { /* Load the Absolute duty value in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = (uint16)Pwm_HW_TAUD_CalculateDuty(LddPeriod, (Pwm_PeriodType)LusDutyCycle); /* PRQA S 2814 # JV-03 */ } else { /* Set 0 in to the CDR Register */ LpTAUDChannelReg->usTAUDnCDRm = PWM_TAUD_MIN_PERIOD_VAL; } } else { LusMasterChannelMask = LusMasterChannelMask & (uint16)(~LpTAUDProperties->usChannelMask); #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) /* Set Dem error flag */ blDemReport = PWM_TRUE; #endif } /* Increment the channel */ LddChannelId++; /* PRQA S 1338, 3383 # JV-01, JV-01 */ /* Increment the pointer to the next channel*/ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ if (PWM_TOTAL_CHANNELS_CONFIG > LddChannelId) { /* Set TAU channel config data pointer */ LpTAUDChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ } /* else No action required */ } while ((PWM_TOTAL_CHANNELS_CONFIG > LddChannelId) && ((uint8)PWM_MASTER_CHANNEL != LpTAUDChannelConfigData->ucTimerMode)); /* PRQA S 2814 # JV-02 */ /* Set the corresponding channels Trigger bits to specifies the channels for which simultaneous rewrite is executed */ LpTAUDUnitUserReg->usTAUDnRDT = LusMasterChannelMask; #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) /* Exit Protected area */ PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif #if (STD_ON == PWM_E_REWRITE_FAILED_CONFIGURED) if (PWM_TRUE == blDemReport) { PWM_DEM_REPORT_ERROR(PWM_E_REWRITE_FAILED, DEM_EVENT_STATUS_FAILED); } /* else No action required */ #endif } /* End of if (PWM_MASTER_CHANNEL == LpTAUDChannelConfigData->ucTimerMode) */ /* Set the Duty cycle of the requested channel if Slave */ else { /* Set the Duty cycle for the slave channel */ Pwm_HW_TAUD_SetDutyCycle(LddChannelId, LusDutyCycle); } } /* else No action required */ /* End of if (E_OK == LucDetErrFlag) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_SET_PERIOD_AND_DUTY_API', 'Value': 'STD_ON(1)'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_E_REWRITE_FAILED', 'Value': '#define'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_CRITICAL_SECTION_PROTECTION', 'Value': 'STD_ON(1)'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannelId', 'Value': '63'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'PWM_TAUD_MIN_PERIOD_VAL\u2026\u2026.\\nPWM_TAUD_MAX_PERIOD_VAL', 'Name': 'LddPeriod', 'Value': 'PWM_TAUD_MAX_PERIOD_VAL'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'PWM_MIN_DUTY_CYCLE_VALUE...\\nPWM_MAX_DUTY_CYCLE_VALUE', 'Name': 'LusDutyCycle', 'Value': 'PWM_MAX_DUTY_CYCLE_VALUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpTAUDUnitConfig', 'Value': '&map_Pwm_GpTAUDUnitConfig[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].pHWIPChannelConfig', 'Value': '[63]= &map_Pwm_HWIPChannelConfig[63]'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucTimerMode', 'Value': '[0 to 62] = 0x55555555\\n[63] =PWM_SLAVE_CHANNEL\\n'], 'Input_Param_011': ['Type': 'Array', 'Range': 'PWM_VARIABLE_PERIOD\\nPWM_FIXED_PERIOD\\nPWM_FIXED_PERIOD_SHIFTED', 'Name': 'map_Pwm_GpChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].enClassType', 'Value': '[63] = PWM_FIXED_PERIOD_SHIFTED'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucMasterOffset', 'Value': '[63]= PWM_ONE'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to PWM_TOTAL_CHANNELS_CONFIG].ucTimerUnitIndex', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpTAUDUnitConfig[0].pUserCntlRegs', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0].pChannelProp', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[1].pChannelProp', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[2].pChannelProp', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[38].pChannelProp', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[39].pChannelProp', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[62].pChannelProp', 'Value': '-'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[63].pChannelProp', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[82].pChannelProp', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[83].pChannelProp', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[98].pChannelProp', 'Value': '-'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[99].pChannelProp', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[110].pChannelProp', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[111].pChannelProp', 'Value': '-'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties[0].pCntlRegs', 'Value': '-'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_1[0].pCntlRegs', 'Value': '-'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_2[0].pCntlRegs', 'Value': '-'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnTOE', 'Value': '-'], 'Input_Param_032': ['Type': 'Variable', 'Range': '0x0000\u20260xFFFF', 'Name': 'map_Pwm_TAUDProperties[0].usChannelMask', 'Value': '-'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_1[0].usChannelMask', 'Value': '-'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUDProperties_2[0].usChannelMask', 'Value': '-'], 'Input_Param_035': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnRSF', 'Value': '-'], 'Input_Param_036': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm', 'Value': '-'], 'Input_Param_037': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm', 'Value': '-'], 'Input_Param_038': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to PWM_TOTAL_CHANNELS_CONFIG]', 'Value': '-'], 'Input_Param_039': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs[0].usTAUDnCDRm', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_1[0].usTAUDnCDRm', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUserRegs_2[0].usTAUDnCDRm', 'Value': '-'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnRDT', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUDUnitUserRegs[0].usTAUDnTOE', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to PWM_TOTAL_CHANNELS_CONFIG]', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '63'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusDutyCycle', 'Value': 'PWM_MAX_DUTY_CYCLE_VALUE'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddAbsolutePeriod', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddRelativeDuty', 'Value': '<Not Called>'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'PWM_E_REWRITE_FAILED', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'DEM_EVENT_STATUS_FAILED', 'Value': '<Not Called>'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_018': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_019': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_DE_INIT_API == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUJ_DeInitChannel(void) /* PRQA S 1532 # JV-01 */ { /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Pointer to the TAU Channel Properties structure */ P2VAR(Pwm_TAUJChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucTimerUnitType; VAR(uint32, AUTOMATIC) LulCount; /* Loop to reset the attributes of TAUJ channels */ LpChannelConfig = Pwm_GpChannelConfig; for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_CHANNELS_CONFIG; LulCount++) { /* Get the Timer Unit Type*/ LucTimerUnitType = LpChannelConfig->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-02, JV-01 */ if ((uint8)PWM_HWIP_TAUJ == LucTimerUnitType) /* PRQA S 3416 # JV-01 */ { /* Get the pointer to the TAUJ channel properties */ LpTAUJProperties = (P2VAR(Pwm_TAUJChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ /* Disabling the Interrupt processing of the current channel with dummy read and execute syncp instruction */ #if ((PWM_NOTIFICATION_SUPPORTED == STD_ON) || (PWM_SET_CHANNEL_OUTPUT_API == STD_ON)) if (NULL_PTR != LpTAUJProperties->pEICReg) /* PRQA S 2814 # JV-01 */ { RH850_SV_SET_ICR_SYNCP(8, LpTAUJProperties->pEICReg, PWM_DISABLE_INTR_MASK); /* PRQA S 0751, 2814, 1006 # JV-01, JV-01, JV-01 */ } /* else No action required */ #endif /* Reset the CMORm register of the configured channel*/ *LpTAUJProperties->pCMORReg = PWM_TAUJ_RESET_CMOR_REG; /* PRQA S 2814 # JV-03 */ /* Reset the CDRm register of the configured channel */ (LpTAUJProperties->pCntlRegs)->ulTAUJnCDRm = PWM_RESET_TAUJCDR_REG; /* PRQA S 2814 # JV-03 */ #if (PWM_NOTIFICATION_SUPPORTED == STD_ON) /* Notification status of this channel to PWM_FALSE */ Pwm_GaaNotifStatus[LulCount] = PWM_FALSE; /* PRQA S 2844 # JV-01 */ #endif /* Set the Idle state status of this channel as PWM_TRUE */ Pwm_GaaChannelIdleStatus[LulCount] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ #if (PWM_SET_CHANNEL_OUTPUT_API == STD_ON) Pwm_GaaChannelConstantStatus[LulCount] = PWM_FALSE; /* PRQA S 2844 # JV-01 */ #endif } /* else No action required */ /* End of LucTimerUnitType checking */ /* Increment the pointer to the next channel */ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } /* End of for loop */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUJ_UNIT_USED', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_DE_INIT_API', 'Value': 'STD_ON(1)'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 63].pChannelProp', 'Value': '[0 to 39]= &map_Pwm_TAUJProperties[0]\\n'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 63].pHWIPChannelConfig', 'Value': '[0 to 39]= &map_Pwm_HWIPChannelConfig[0]\\n'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[0 to 39] = PWM_HWIP_TAUD'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUJProperties[0].pEICReg', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUJProperties[0].pCntlRegs', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUJProperties[0].pCMORReg', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_unsigned_short_int_1[0]', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_unsigned_short_int[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_TAUJProperties[0].pCMORReg', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUJUserRegs[0].ulTAUJnCDRm\\n', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_unsigned_short_int[0]', 'Value': '-'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaNotifStatus[0 to 63]', 'Value': '-'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to 63]', 'Value': '-'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelConstantStatus[0 to 63]', 'Value': '-'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_NOTIFICATION_SUPPORTED == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUJ_EnableNotification(Pwm_ChannelType LddChannelId, /* PRQA S 1532 # JV-01 */ Pwm_EdgeNotificationType LenNotification) { /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUJChannelConfigData; /* PRQA S 3432 # JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Pointer to channel configuration of master channel*/ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpMasterChannelConfig; /* PRQA S 3432 # JV-01 */ VAR(uint8, AUTOMATIC) LucDetErrFlag; #endif /* Initialize a pointer to the channel configuration */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Set TAU channel config data pointer */ LpTAUJChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Initialize DET error flag */ LucDetErrFlag = E_OK; if ((uint8)PWM_SLAVE_CHANNEL == LpTAUJChannelConfigData->ucTimerMode) /* PRQA S 2814 # JV-03 */ { LpMasterChannelConfig = &Pwm_GpChannelConfig[LddChannelId - LpTAUJChannelConfigData->ucMasterOffset]; /* Check notification is PWM_BOTH_EDGES */ if (PWM_BOTH_EDGES == LenNotification) { if ((NULL_PTR == LpMasterChannelConfig->pPwmEdgeNotifPtr) || (NULL_PTR == LpChannelConfig->pPwmEdgeNotifPtr)) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_ENABLENOTIFICATION_SID, PWM_E_NOTIFY_NOTCONFIG); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } /* For notification is PWM_RISING_EDGE */ else if (PWM_RISING_EDGE == LenNotification) { if ((((uint8)PWM_POLARITY_HIGH == LpChannelConfig->ucPolarity) && (NULL_PTR == LpMasterChannelConfig->pPwmEdgeNotifPtr)) || (((uint8)PWM_POLARITY_LOW == LpChannelConfig->ucPolarity) && (NULL_PTR == LpChannelConfig->pPwmEdgeNotifPtr))) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_ENABLENOTIFICATION_SID, PWM_E_NOTIFY_NOTCONFIG); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } /* For notification is PWM_FALLING_EDGE */ else { if ((((uint8)PWM_POLARITY_HIGH == LpChannelConfig->ucPolarity) && (NULL_PTR == LpChannelConfig->pPwmEdgeNotifPtr)) || (((uint8)PWM_POLARITY_LOW == LpChannelConfig->ucPolarity) && (NULL_PTR == LpMasterChannelConfig->pPwmEdgeNotifPtr))) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_ENABLENOTIFICATION_SID, PWM_E_NOTIFY_NOTCONFIG); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } } /* else No action required */ /* End of if (PWM_SLAVE_CHANNEL == LpChannelConfig->ucTimerMode) */ if (E_OK == LucDetErrFlag) #endif /* End of (PWM_DEV_ERROR_DETECT == STD_ON) */ { /* Check if this channel is in the Slave mode and isn't Delay channel */ if ((uint8)PWM_MASTER_CHANNEL != LpTAUJChannelConfigData->ucTimerMode) { if (PWM_BOTH_EDGES == LenNotification) { /* Check whether any notification is configured for this channel */ if (NULL_PTR != LpChannelConfig->pPwmEdgeNotifPtr) { /* Set the Notification enable status as PWM_TRUE for this channel */ Pwm_GaaNotifStatus[LddChannelId] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ /* Clear the Pending Interrupts and Enable Interrupt Processing for Slave */ Pwm_HW_TAUJ_IntNotification(LddChannelId); /* Get Master's channel ID */ LddChannelId = (LddChannelId - (LpTAUJChannelConfigData->ucMasterOffset)); /* PRQA S 1338 # JV-01 */ /* Get Master's channel Config */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Clear the Pending Interrupts and Enable Interrupt Processing for Master */ Pwm_HW_TAUJ_IntNotification(LddChannelId); /* Check whether any notification is configured for this channel */ if (NULL_PTR != LpChannelConfig->pPwmEdgeNotifPtr) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Set the Notification enable status as PWM_TRUE for Master channel */ Pwm_GaaNotifStatus[LddChannelId] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ } else if (((PWM_RISING_EDGE == LenNotification) && ((uint8)PWM_POLARITY_HIGH == LpChannelConfig->ucPolarity)) || ((PWM_FALLING_EDGE == LenNotification) && ((uint8)PWM_POLARITY_LOW == LpChannelConfig->ucPolarity))) { /* Get Master's channel ID */ LddChannelId = (LddChannelId - (LpTAUJChannelConfigData->ucMasterOffset)); /* PRQA S 1338 # JV-01 */ /* Get Delay's channel Config */ LpChannelConfig = &Pwm_GpChannelConfig[LddChannelId]; /* Clear the Pending Interrupts and Enable Interrupt Processing for Delay channel */ Pwm_HW_TAUJ_IntNotification(LddChannelId); /* Check whether any notification is configured for this channel */ if (NULL_PTR != LpChannelConfig->pPwmEdgeNotifPtr) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Set the Notification enable status as PWM_TRUE for this channel */ Pwm_GaaNotifStatus[LddChannelId] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ } /* For FALLING EDGE Notification with polarity PWM_HIGH or RISING EDGE Notification with polarity PWM_LOW */ else { /* Clear the Pending Interrupts and Enable Interrupt Processing for Slave */ Pwm_HW_TAUJ_IntNotification(LddChannelId); /* Set Notification enable status as PWM_TRUE for this channel */ Pwm_GaaNotifStatus[LddChannelId] = PWM_TRUE; /* PRQA S 2844 # JV-01 */ } } /* else No action required */ /*End of if(PWM_MASTER_CHANNEL != LpTAUJChannelConfigData->ucTimerMode)*/ } /* else No action required */ /* End of LucDetErrFlag is E_OK */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_NOTIFICATION_SUPPORTED\\nPWM_DEV_ERROR_DETECT\\nPWM_TAUJ_UNIT_USED', 'Value': 'STD_ON\\nSTD_ON\\nSTD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LddChannelId', 'Value': '5'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'PWM_RISING_EDGE,\\nPWM_FALLING_EDGE,\\nPWM_BOTH_EDGES', 'Name': 'LenNotification', 'Value': 'PWM_BOTH_EDGES'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '&map_Pwm_HWIPChannelConfig[5]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pPwmEdgeNotifPtr', 'Value': '&map_pPwmEdgeNotifPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucPolarity', 'Value': 'PWM_POLARITY_LOW'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerMode', 'Value': 'PWM_SLAVE_CHANNEL'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucMasterOffset', 'Value': '3'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pPwmEdgeNotifPtr', 'Value': '&map_pPwmEdgeNotifPtr[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_pPwmEdgeNotifPtr[0]', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '5'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '2'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GaaNotifStatus[5]', 'Value': 'PWM_TRUE'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GaaNotifStatus[2]', 'Value': 'PWM_TRUE'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUJ_InitUnit(P2CONST (Pwm_ConfigType, AUTOMATIC, PWM_CONFIG_DATA) LddConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { /* Pointer pointing to the TAU Unit configuration */ P2CONST(Pwm_TAUJUnitConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpTAUJUnitConfig; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the TAU Unit user control registers */ P2VAR(volatile Pwm_TAUJUnitUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJUnitUserReg; /* PRQA S 3432 # JV-01 */ #if (PWM_TAUJ_PRESCALER == STD_ON) /* Pointer pointing to the TAU Unit OS control registers */ P2VAR(volatile Pwm_TAUJUnitOsRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJUnitOsReg; /* PRQA S 3432 # JV-01 */ #endif /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; VAR(uint32, AUTOMATIC) LulCount; for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (PWM_HWIP_TAUJ == LucHWIPType) /* PRQA S 3416 # JV-01 */ { /* Save the start of TAUJ Unit Configuration in the global pointer */ Pwm_GpTAUJUnitConfig = (P2CONST(Pwm_TAUJUnitConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA)) /* PRQA S 0316, 3432 # JV-01, JV-01 */ (LddConfigPtr->aaTimerUnitConfig[LucHWIPType]); /* PRQA S 2814, 3432 # JV-02, JV-01 */ } /* else No action required */ } /* Update the TAU config pointer to point to the current TAU */ LpTAUJUnitConfig = Pwm_GpTAUJUnitConfig; /* Loop to set the configured pre-scaler for the TAU units */ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_TAUJ_UNITS_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { /* Get the pointer to the TAU unit registers */ LpTAUJUnitUserReg = LpTAUJUnitConfig->pUserCntlRegs; /* PRQA S 2814 # JV-03 */ #if (PWM_TAUJ_PRESCALER == STD_ON) /* Get the pointer to the TAU OS control registers */ LpTAUJUnitOsReg = LpTAUJUnitConfig->pOsCntlRegs; /* Check for Prescaler setting by the PWM module for TAU Unit */ if (PWM_TRUE == LpTAUJUnitConfig->blConfigurePrescaler) { /* Set all channels bits of TAU unit to disable the count operation */ LpTAUJUnitUserReg->ucTAUJnTT = PWM_STOP_TAUJ_ALL_CH; /* PRQA S 2814 # JV-03 */ /* Load the configured pre-scaler value */ LpTAUJUnitOsReg->usTAUJnTPS = LpTAUJUnitConfig->usPrescaler; /* PRQA S 2814 # JV-03 */ /* Load the configured baudrate value */ LpTAUJUnitOsReg->ucTAUJnBRS = LpTAUJUnitConfig->ucBaudRate; } else { /* Set the configured channel bits to disable the count operation */ LpTAUJUnitUserReg->ucTAUJnTT = LpTAUJUnitConfig->ucTAUChannelMask; } #else /* Set the configured channel bits to disable the count operation */ LpTAUJUnitUserReg->ucTAUJnTT = LpTAUJUnitConfig->ucTAUChannelMask; /* PRQA S 2814 # JV-03 */ #endif /* Increment the pointer to the next TAU Unit */ LpTAUJUnitConfig++; /* PRQA S 2824, 2983 # JV-01, JV-01 */ } /* End of PWM_TOTAL_TAUJ_UNITS_CONFIG for loop */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUJ_PRESCALER', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'Address', 'Name': 'LddConfigPtr', 'Value': '&map_LddConfigPtr[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Pwm_GaaHWIP_Used', 'Value': '&Pwm_GaaHWIP_Used[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = PWM_HWIP_TAUJ'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'aaTimerUnitConfig[2]', 'Value': '&map_aaTimerUnitConfig[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpTAUJUnitConfig', 'Value': '&map_Pwm_GaaTAUJUnitConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pUserCntlRegs', 'Value': '[0 to 3]= &map_struct_STag_Pwm_TAUJUnitUserRegs[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pOsCntlRegs', 'Value': '[0 to 3]= &map_struct_STag_Pwm_TAUJUnitOsRegs[0]'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'blConfigurePrescaler', 'Value': '[0 to 3]= PWM_FALSE'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'usPrescaler', 'Value': '[0 to 3]= 0x0000'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'ucBaudRate', 'Value': '[0 to 3]= 0x00'], 'Input_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'ucTAUChannelMask', 'Value': '[0 to 3]= 0x03']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUJUnitUserRegs[0].ucTAUJnTT', 'Value': '0x03'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUJUnitOsRegs[0].usTAUJnTPS', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpTAUJUnitConfig', 'Value': '&map_aaTimerUnitConfig[0]'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_struct_STag_Pwm_TAUJUnitOsRegs[0].ucTAUJnBRS', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SYNC_START_SUPPORT == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUJ_SynchronousInit(void) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Local pointer to the each Timer-E channel configuration */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUJChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Pointer to the TAU Channel Properties structure */ P2VAR(Pwm_TAUJChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer to the TAU Master Channel Properties structure */ P2VAR(Pwm_TAUJChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJMasterProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer used for TAU channel control registers */ P2VAR(volatile Pwm_TAUJChannelUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJChannelReg; /* PRQA S 3432 # JV-01 */ /* Pointer used for TAU Master channel control registers */ P2VAR(volatile Pwm_TAUJChannelUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJMasterChannelReg; /* PRQA S 3678, 3432 # JV-01, JV-01 */ /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucTimerUnitType; VAR(Pwm_PeriodType, AUTOMATIC) LddMasterPeriod; VAR(Pwm_PeriodType, AUTOMATIC) LddSlaveDuty; VAR(uint8, AUTOMATIC) LucVar; VAR(uint32, AUTOMATIC) LulCount; /* Initialize all PWM channels configured to support synchronous start/stop of timers, this excludes initialization of channels that willbe handled by complex drivers */ /* Loop to set the attributes of TAU channels */ LpChannelConfig = Pwm_GpChannelConfig; for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_CHANNELS_CONFIG; LulCount++) { /* Set TAU channel config data pointer */ LpTAUJChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ /* Get the Timer Unit Type*/ LucTimerUnitType = LpChannelConfig->ucTimerUnitType; if ((uint8)PWM_HWIP_TAUJ == LucTimerUnitType) /* PRQA S 3416 # JV-01 */ { if ((PWM_TRUE == LpChannelConfig->blSyncStartReq) && (PWM_FALSE == LpTAUJChannelConfigData->blComplexDriverInit)) /* PRQA S 2814 # JV-02 */ { /* Get the pointer to the TAU channel properties */ LpTAUJProperties = (P2VAR(Pwm_TAUJChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ /* Get the pointer to the TAU channel control registers */ LpTAUJChannelReg = LpTAUJProperties->pCntlRegs; /* PRQA S 2814 # JV-03 */ /* Check for channel in the Master Mode */ if ((uint8)PWM_MASTER_CHANNEL == LpTAUJChannelConfigData->ucTimerMode) { /* Update the CMORm register of Master with the usCMORRegSettingsMask based on the configuration */ *LpTAUJProperties->pCMORReg = LpTAUJProperties->usCMORRegSettingsMask; /* PRQA S 2814 # JV-03 */ if ((Pwm_PeriodType)PWM_TAUJ_MIN_PERIOD_VAL != LpTAUJProperties->ddDefaultPeriodOrDuty) { LpTAUJChannelReg->ulTAUJnCDRm = (LpTAUJProperties->ddDefaultPeriodOrDuty - (uint32)PWM_ONE); /* PRQA S 2814 # JV-03 */ } else { LpTAUJChannelReg->ulTAUJnCDRm = PWM_TAUJ_MIN_PERIOD_VAL; } } /* Channel in Slave Mode */ else { /* Master offset from the slave channel */ LucVar = LpTAUJChannelConfigData->ucMasterOffset; /* Get the pointer to the TAU Master channel properties */ LpTAUJMasterProperties = (P2VAR(Pwm_TAUJChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))(LpChannelConfig - LucVar)->pChannelProp; /* PRQA S 0311, 0316, 0488, 2824, 3432 # JV-01, JV-01, JV-01, JV-01, JV-01 */ /* if Default Period of Master of the slave channel is not zero */ if ((Pwm_PeriodType)PWM_TAUJ_MIN_PERIOD_VAL != LpTAUJMasterProperties->ddDefaultPeriodOrDuty) /* PRQA S 2814 # JV-02 */ { /* Pointer to the Master channel registers */ LpTAUJMasterChannelReg = LpTAUJMasterProperties->pCntlRegs; /* Get Master's period */ LddMasterPeriod = LpTAUJMasterChannelReg->ulTAUJnCDRm; /* PRQA S 2814 # JV-03 */ /* Get Slave's Duty */ LddSlaveDuty = LpTAUJProperties->ddDefaultPeriodOrDuty; /* Load the Absolute duty value in to the CDR Register */ LpTAUJChannelReg->ulTAUJnCDRm = Pwm_HW_TAUJ_CalculateDuty(LddMasterPeriod, LddSlaveDuty); } else { /* Load the zero in to the CDR Register */ LpTAUJChannelReg->ulTAUJnCDRm = PWM_TAUJ_MIN_PERIOD_VAL; } /* Update the CMORm register of Slave with the usCMORRegSettingsMask based on the configuration */ *LpTAUJProperties->pCMORReg = LpTAUJProperties->usCMORRegSettingsMask; } /* End of Channel in Slave Mode */ } /* else No action required */ /* End of if ((PWM_TRUE == LpChannelConfig->blSyncStartReq) && (PWM_FALSE == LpTAUJChannelConfigData->blComplexDriverInit)) */ } /* else No action required */ /* End of if ((uint8)PWM_HWIP_TAUJ == LucTimerUnitType) */ /* Increment the pointer to the next channel */ LpChannelConfig++; /* PRQA S 2934 # JV-01 */ } /* End of for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_CHANNELS_CONFIG; LulCount++) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 39].pHWIPChannelConfig', 'Value': '[0 to 39]= &map_Pwm_HWIPChannelConfig[0]\\n'], 'Input_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[0 to 39] = PWM_HWIP_TAUJ'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0].blComplexDriverInit', 'Value': 'PWM_FALSE'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 39].blSyncStartReq', 'Value': '[0 to 39]= PWM_TRUE'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pChannelProp', 'Value': '[0 to 39]= &map_Pwm_TAUJProperties[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucTimerMode', 'Value': 'PWM_MASTER_CHANNEL'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pCntlRegs', 'Value': '&map_struct_STag_Pwm_TAUJUserRegs[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucMasterOffset', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'pCMORReg', 'Value': '&map_unsigned_short_int[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'usCMORRegSettingsMask', 'Value': '0x0801U'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0x0000..0xFFFF', 'Name': 'ddDefaultPeriodOrDuty', 'Value': 'PWM_TAUJ_MIN_PERIOD_VAL'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulTAUJnCDRm', 'Value': '0x0000'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'map_unsigned_short_int[0]', 'Value': '0'], 'Input_Param_014': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_unsigned_short_int[0]', 'Value': '0x0801U'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ulTAUJnCDRm', 'Value': 'PWM_TAUJ_MIN_PERIOD_VAL'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddAbsolutePeriod', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddRelativeDuty', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SYNC_START_SUPPORT == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TAUJ_SynchronousStop(void) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(Pwm_ChannelConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Pointer pointing to the TAU Unit configuration */ P2CONST(Pwm_TAUJUnitConfigType, PWM_VAR_NO_INIT, PWM_CONFIG_DATA) LpTAUJUnitConfig; /* PRQA S 3432 # JV-01 */ /* Pointer to the TAU Channel Properties structure */ P2VAR(Pwm_TAUJChannelPropType, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJProperties; /* PRQA S 3432, 3678 # JV-01, JV-01 */ /* Pointer pointing to the TAU Unit user control registers */ P2VAR(volatile Pwm_TAUJUnitUserRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTAUJUnitUserReg; /* PRQA S 3432 # JV-01 */ P2CONST(Pwm_TAUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTAUJChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucTimerUnitType; VAR(uint32, AUTOMATIC) LulCount; /* Update the TAU unit config pointer */ LpTAUJUnitConfig = Pwm_GpTAUJUnitConfig; /* Get the configuration of TAU channels */ LpChannelConfig = Pwm_GpChannelConfig; /* Loop to set the attributes of TAU channels */ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_TAUJ_UNITS_CONFIG; LulCount++) { /* Update the pointer for the base address of the TAU unit registers */ LpTAUJUnitUserReg = LpTAUJUnitConfig->pUserCntlRegs; /* PRQA S 2814 # JV-03 */ /* Set the channel bits that are configured for synchronous start, to disable the count operation */ LpTAUJUnitUserReg->ucTAUJnTT = LpTAUJUnitConfig->ucSyncInitMask; /* PRQA S 2814 # JV-03 */ LpTAUJUnitConfig++; /* PRQA S 2824 # JV-01 */ } /* Set the Channel Idle State to Idle for all synchronous channels*/ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_CHANNELS_CONFIG; LulCount++) { /* Get the Timer Unit Type*/ LucTimerUnitType = LpChannelConfig->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-03, JV-01 */ /* Set TAU channel config data pointer */ LpTAUJChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317 # JV-01 */ if ((uint8)PWM_HWIP_TAUJ == LucTimerUnitType) /* PRQA S 3416 # JV-01 */ { if ((PWM_TRUE == LpChannelConfig->blSyncStartReq) && (PWM_FALSE == LpTAUJChannelConfigData->blComplexDriverInit) /* PRQA S 2814 # JV-02 */ && ((uint8)PWM_SLAVE_CHANNEL == LpTAUJChannelConfigData->ucTimerMode)) { /* Fetch the pointer to the current TAU Unit config */ LpTAUJUnitConfig = &Pwm_GpTAUJUnitConfig[LpTAUJChannelConfigData->ucTimerUnitIndex]; /* PRQA S 2824 # JV-01 */ /* Fetch the pointer to the current TAU Unit Registers */ LpTAUJUnitUserReg = LpTAUJUnitConfig->pUserCntlRegs; /* PRQA S 2814 # JV-03 */ /* Set TAUJ channel properties pointer */ LpTAUJProperties = (P2VAR(Pwm_TAUJChannelPropType, AUTOMATIC, PWM_CONFIG_DATA))LpChannelConfig->pChannelProp; /* PRQA S 0311, 0316, 3432 # JV-01, JV-01, JV-01 */ /* Set the corresponding channel bit to disable TOEm operation */ LpTAUJUnitUserReg->ucTAUJnTOE = ((LpTAUJUnitUserReg->ucTAUJnTOE) & (uint8)(~LpTAUJProperties->ucChannelMask)); /* PRQA S 2814 # JV-03 */ if ((uint8)PWM_LOW == LpChannelConfig->ucIdleLevel) { /* Reset the corresponding bit if Idle state is LOW */ LpTAUJUnitUserReg->ucTAUJnTO = (LpTAUJUnitUserReg->ucTAUJnTO & (uint8)(~LpTAUJProperties->ucChannelMask)); } else { /* Reset the corresponding bit if Idle state is HIGH */ LpTAUJUnitUserReg->ucTAUJnTO = (LpTAUJUnitUserReg->ucTAUJnTO | (uint8)(LpTAUJProperties->ucChannelMask)); } /* Set the Idle state of Synchronous channel to Idle */ Pwm_GaaChannelIdleStatus[LulCount] = PWM_TRUE; } /* else No action required */ } /* else No action required */ /* Increment the pointer to the next channel */ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ } /*End of for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_CHANNELS_CONFIG; LulCount++)*/ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpTAUJUnitConfig', 'Value': '&map_Pwm_GpTAUJUnitConfig[0]'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'pUserCntlRegs', 'Value': '[0 to 3]= &map_struct_STag_Pwm_TAUJUnitUserRegs[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 39].pHWIPChannelConfig', 'Value': '[0 to 39]= &map_Pwm_HWIPChannelConfig[0]\\n'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to 39].ucTimerUnitIndex', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pChannelProp', 'Value': '[0 to 39]= &map_Pwm_TAUJProperties[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[0 to 39] = PWM_HWIP_TAUJ'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0].blComplexDriverInit', 'Value': 'PWM_FALSE'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_GpChannelConfig[0 to 39].blSyncStartReq', 'Value': '[0 to 39]= PWM_TRUE'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'map_Pwm_HWIPChannelConfig[0 to 39].ucTimerMode', 'Value': '[0 to 39] = PWM_MASTER_CHANNEL'], 'Input_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ucTAUJnTOE', 'Value': '-'], 'Input_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'ucTAUJnTO', 'Value': '-'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucSyncInitMask', 'Value': '[0 to 3]= 0x003CU'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucChannelMask', 'Value': '-'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ucIdleLevel', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ucTAUJnTT', 'Value': '0x003CU'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ucTAUJnTOE', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ucTAUJnTO', 'Value': '-'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to 39]', 'Value': '-'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_DE_INIT_API == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ /*using same channel intit so do not need to argument for unit config*/ FUNC(void, PWM_PRIVATE_CODE) Pwm_HW_TPU_DeInit(void) /* PRQA S 1532 # JV-01 */ { /* Pointer to the channel configuration */ P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* TPU config data */ P2CONST(Pwm_TPUChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpTPUChannelConfigData; /* PRQA S 3432 # JV-01 */ /* Local Pointer used for each channel control registers */ P2CONST(Pwm_TPUChannelPropType, AUTOMATIC, PWM_CONFIG_CONST) LpChannelProp; /* PRQA S 3432 # JV-01 */ /* Local Pointer used for each TPU channel control registers */ P2VAR(Pwm_TPUChannelRegs, AUTOMATIC, PWM_CONFIG_DATA) LpTPUChannelRegs; /* PRQA S 3432 # JV-01 */ /* Initialize the TSTR local variable*/ VAR(volatile uint8, AUTOMATIC) LucTSTRAddressValue; /* Intiate the local variable to mask the base register of the channel */ VAR(uint32, AUTOMATIC) LulBaseAddress; /* Intiate the local variable for count the channels */ VAR(uint32, AUTOMATIC) LulCount; /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucTimerUnitType; /* Update the configure pointer to point to the current Timer channel*/ LpChannelConfig = Pwm_GpChannelConfig; /* Loop to set the attributes of TPU channels */ /* Initialize all PWM channels configured to support synchronous start/stop of timers, this excludes initialization of channels that will be handled by complex drivers */ for (LulCount = (uint8)PWM_ZERO; LulCount < (uint8)PWM_TOTAL_CHANNELS_CONFIG; LulCount++) { /* Set TPU channel config data pointer */ LpTPUChannelConfigData = LpChannelConfig->pHWIPChannelConfig; /* PRQA S 0317, 2814, 2844 # JV-01, JV-01, JV-01 */ /* Get the Timer Unit Type*/ LucTimerUnitType = LpChannelConfig->ucTimerUnitType; if ((uint8)PWM_HWIP_TPU == LucTimerUnitType) /* PRQA S 3416 # JV-01 */ { /* Get the pointer to the PWM Channel properties */ LpChannelProp = (P2CONST(Pwm_TPUChannelPropType, AUTOMATIC, PWM_CONFIG_CONST)) /* PRQA S 0316, 2983, 3432 # JV-01, JV-01, JV-01 */ LpChannelConfig->pChannelProp; /* Get the pointer to the PWM Channel control registers */ LpTPUChannelRegs = (P2VAR(Pwm_TPUChannelRegs, AUTOMATIC, PWM_CONFIG_DATA)) /* PRQA S 3432 # JV-01 */ LpTPUChannelConfigData->pTPUChannelRegs; /* PRQA S 2814 # JV-01 */ /* Update the local variable with the base address for each channel */ LulBaseAddress = (uint32)(LpTPUChannelConfigData->pTPUChannelRegs); /* PRQA S 0306 # JV-01 */ /* Mask the first 4 bits of Timer Start Register*/ LucTSTRAddressValue = *LpTPUChannelConfigData->pTSTRAddress & PWM_TSTR_CHANNELS_CONTROL; /* PRQA S 4461 # JV-01 */ /* Reset the relative bit of the configured channel's in start register */ switch (LulBaseAddress & PWM_CHANNEL_BASE_ADRESS_MASK) { /* Stop the first channel of the timer */ case PWM_FIRST_CHANNEL_MASK: LucTSTRAddressValue &= (uint16)(~PWM_TSTR_FIRST_CHANNEL_MASK); /* PRQA S 4399, 4461 # JV-01, JV-01 */ break; /* Stop the second channel of the timer */ case PWM_SECOND_CHANNEL_MASK: LucTSTRAddressValue &= (uint16)(~PWM_TSTR_SECOND_CHANNEL_MASK); /* PRQA S 4399, 4461 # JV-01, JV-01 */ break; /* Stop the third channel of the timer */ case PWM_THIRD_CHANNEL_MASK: LucTSTRAddressValue &= (uint16)(~PWM_TSTR_THIRD_CHANNEL_MASK); /* PRQA S 4399, 4461 # JV-01, JV-01 */ break; default: /* PRQA S 2016 # JV-01 */ break; } /* Assign the local variable value to the TSTR regiter */ *LpTPUChannelConfigData->pTSTRAddress &= LucTSTRAddressValue; /* Reset the Counter TPUnTCNT Register of the configured channel */ LpTPUChannelRegs->usTPUnTCNT = PWM_RESET_WORD; /* PRQA S 2814 # JV-01 */ /* Reset the configured value of the channel period in to register TPUnTGRB*/ LpTPUChannelRegs->usTPUnTGRB = (uint16)~(PWM_RESET_WORD); /* Reset the configured value of the channel duty in to register TPUnTGRA*/ LpTPUChannelRegs->usTPUnTGRA = (uint16)~(PWM_RESET_WORD); /* Reset the configured value of the channel period in to register TPUnTGRD*/ LpTPUChannelRegs->usTPUnTGRD = (uint16)~(PWM_RESET_WORD); /* Reset the configured value of the channel duty in to register TPUnTGRC*/ LpTPUChannelRegs->usTPUnTGRC = (uint16)~(PWM_RESET_WORD); /* Clear the controlling bits of interrupt requests for the corresponding timer */ LpTPUChannelRegs->usTPUnTIER = PWM_RESET_WORD; /* Clear the controlling bits of Underflow interrupt notification in TPUnTSR */ LpTPUChannelRegs->usTPUnTSR = PWM_RESET_WORD; /* Reset the Control TPUnTCR Registers of the configured channel */ LpTPUChannelRegs->usTPUnTCR = PWM_RESET_WORD; /* Reset the Counter TPUnTIOR Register of the configured channel */ LpTPUChannelRegs->usTPUnTIOR = PWM_RESET_WORD; /* Set the output signal to Idle State */ LpTPUChannelRegs->usTPUnTMDR = PWM_RESET_WORD; #if (PWM_NOTIFICATION_SUPPORTED == STD_ON) /* Set the Notification status as PWM_FALSE */ Pwm_GaaNotifStatus[LulCount] = PWM_FALSE; /* PRQA S 4404 # JV-01 */ #endif #if (PWM_SET_CHANNEL_OUTPUT_API == STD_ON) /* Initialize the Constant state status of normal channel as PWM_FALSE */ Pwm_GaaChannelConstantStatus[LulCount] = PWM_FALSE; /* PRQA S 4404 # JV-01 */ #endif /* Set the Idle state status of this channel as PWM_TRUE */ Pwm_GaaChannelIdleStatus[LulCount] = PWM_TRUE; /* PRQA S 4404 # JV-01 */ } /* else No action required */ /* Increment the pointer to the next channel */ LpChannelConfig++; /* PRQA S 2824, 2934 # JV-01, JV-01 */ }/* End of for loop channels */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_NOTIFICATION_SUPPORTED', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_SET_CHANNEL_OUTPUT_API', 'Value': 'STD_ON(1)'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Input_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[0 to 2] = PWM_HWIP_TPU'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'pHWIPChannelConfig', 'Value': '[0]=&map_TPUChannelConfigData[0]\\n[1]=&map_TPUChannelConfigData[1]\\n[2]=&map_TPUChannelConfigData[2]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pChannelProp', 'Value': '[0]=&map_ChannelProp[0]\\n[1]=&map_ChannelProp[1]\\n[2]=&map_ChannelProp[2]'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'pTSTRAddress', 'Value': '[0] = &map_pTSTRAddress[0]\\n[1] = &map_pTSTRAddress[1]\\n[2] = &map_pTSTRAddress[2]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pTPUChannelRegs', 'Value': '[0]= &map_TPUChannelRegs[0]\\n[1]= &map_TPUChannelRegs[1]\\n[2]= &map_TPUChannelRegs[2]'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'map_pTSTRAddress[0 to 2].', 'Value': '[0] = 0x0000\\n[1] = 0x0001\\n[2] = 0x0002']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GpChannelConfig[0]'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'map_pTSTRAddress[0 to 2].', 'Value': '[0] = 0x0000\\n[1] = 0x0001\\n[2] = 0x0002'], 'Output_Param_002': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTCNT', 'Value': '[0 to 2] = PWM_RESET_WORD'], 'Output_Param_003': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRA', 'Value': '[0 to 2]=0xFFFF'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRB', 'Value': '[0 to 2]=0xFFFF'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRC', 'Value': '[0 to 2]=0xFFFF'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTGRD', 'Value': '[0 to 2]=0xFFFF'], 'Output_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTIER', 'Value': '[0] = 0x0000\\n[1] = 0x0000\\n[2] = 0x0000'], 'Output_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTSR', 'Value': '[0] = 0x0000\\n[1] = 0x0000\\n[2]=  0x0000'], 'Output_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTCR', 'Value': '[0] = 0x0000\\n[1] = 0x0000\\n[2] = 0x0000'], 'Output_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTIOR', 'Value': '[0] = PWM_RESET_WORD\\n[1] = PWM_RESET_WORD\\n[2] = PWM_RESET_WORD'], 'Output_Param_011': ['Type': 'Array', 'Range': '', 'Name': 'usTPUnTMDR', 'Value': '[0] = PWM_RESET_WORD\\n[1] = PWM_RESET_WORD\\n[2] = PWM_RESET_WORD'], 'Output_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaNotifStatus[0 to 2]', 'Value': '[0 to 2] = PWM_FALSE'], 'Output_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelConstantStatus[0 to 2]', 'Value': '[0 to 2]=PWM_FALSE'], 'Output_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaChannelIdleStatus[0 to 2]', 'Value': '[0 to 2] = PWM_TRUE'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define PWM_START_SEC_PUBLIC_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PUBLIC_CODE) Pwm_Init(P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; VAR(uint32, AUTOMATIC) LulCount; #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(uint8, AUTOMATIC) LucDetErrFlag; /* Initialize error flag */ LucDetErrFlag = E_OK; #if (PWM_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if the PWM Driver is already initialized */ if (PWM_INITIALIZED == Pwm_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_INIT_SID, PWM_E_ALREADY_INITIALIZED); LucDetErrFlag = E_NOT_OK; } /* else No action required */ #endif /* Check if ConfigPtr is NULL_PTR */ if (NULL_PTR == ConfigPtr) { /* Report Error to DET */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_INIT_SID, PWM_E_INIT_FAILED); LucDetErrFlag = E_NOT_OK; } /* else No action required */ /* If there is no valid database present */ if ((E_OK == LucDetErrFlag) && ((uint32)PWM_DBTOC_VALUE != ConfigPtr->ulStartOfDbToc)) { /* Report Error to DET */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_INIT_SID, PWM_E_INVALID_DATABASE); LucDetErrFlag = E_NOT_OK; } /* else No action required */ if (E_OK == LucDetErrFlag) #endif /* End of PWM_DEV_ERROR_DETECT == STD_ON */ { /* Save the start of channel Configuration in the global pointer */ Pwm_GpChannelConfig = (P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_CONFIG_DATA)) /* PRQA S 0316, 3432 # JV-01, JV-01 */ (ConfigPtr->pChannelConfig); /* PRQA S 2814, 3432 # JV-01, JV-01 */ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWInitUnit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ #if (STD_OFF == PWM_TIMER_IP_TPU) Pwm_GaaHwFunc[LucHWIPType]->pHWInitUnit(ConfigPtr); #else Pwm_GaaHwFunc[LucHWIPType]->pHWInitUnit(); #endif } /* else No action required */ } /* Initialize all PWM channels */ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWInitChannel) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucHWIPType]->pHWInitChannel(); } /* else No action required */ } for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWStartOutput) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucHWIPType]->pHWStartOutput(); } /* else No action required */ } #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Set PWM Driver status to initialized */ Pwm_SetStatus(PWM_INITIALIZED); #endif } /* else No action required */ /* End of if (E_OK == LucDetErrFlag) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_DEV_ERROR_DETECT', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL_PTR \u2026 Address', 'Name': 'ConfigPtr', 'Value': '&map_Pwm_GaaConfiguration[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulStartOfDbToc', 'Value': 'PWM_DBTOC_VALUE'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelConfig', 'Value': '&map_Pwm_GaaChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPConfig', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pClockConfig', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaHwFunc[0 to 4]', 'Value': '[0]= &map_Pwm_GaaHwFunc[0]\\n[1]= &map_Pwm_GaaHwFunc[1]\\n[2]= &map_Pwm_GaaHwFunc[2]\\n[3]= &map_Pwm_GaaHwFunc[3]\\n[4]= &map_Pwm_GaaHwFunc[4]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pHWInitUnit', 'Value': '[0]= NULL_PTR\\n[1] = NULL_PTR\\n[2]=&ISOLATE_void_func_ptr_const_Pwm_ConfigType_p\\n[3]= NULL_PTR\\n[4]= NULL_PTR'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'pHWInitChannel', 'Value': '[0]= NULL_PTR\\n[1] = NULL_PTR\\n[2]=&ISOLATE_void_func_ptr\\n[3]= NULL_PTR\\n[4]= NULL_PTR'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pHWStartOutput', 'Value': '[0]= NULL_PTR\\n[1] = NULL_PTR\\n[2]=&ISOLATE_void_func_ptr\\n[3]= NULL_PTR\\n[4]= NULL_PTR'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblDriverStatus', 'Value': 'PWM_UNINITIALIZED'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Pwm_GaaHWIP_Used', 'Value': '&Pwm_GaaHWIP_Used[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = PWM_HWIP_TAUD\\n[1] = PWM_HWIP_TAUJ']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': ''], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigPtr', 'Value': '&map_Pwm_GaaConfiguration'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #define PWM_START_SEC_PUBLIC_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PUBLIC_CODE) Pwm_Init(P2CONST(Pwm_ConfigType, AUTOMATIC, PWM_APPL_CONST) ConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; VAR(uint32, AUTOMATIC) LulCount; #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(uint8, AUTOMATIC) LucDetErrFlag; /* Initialize error flag */ LucDetErrFlag = E_OK; #if (PWM_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if the PWM Driver is already initialized */ if (PWM_INITIALIZED == Pwm_GblDriverStatus) /* PRQA S 3416 # JV-01 */ { /* Report Error to DET */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_INIT_SID, PWM_E_ALREADY_INITIALIZED); LucDetErrFlag = E_NOT_OK; } /* else No action required */ #endif /* Check if ConfigPtr is NULL_PTR */ if (NULL_PTR == ConfigPtr) { /* Report Error to DET */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_INIT_SID, PWM_E_INIT_FAILED); LucDetErrFlag = E_NOT_OK; } /* else No action required */ /* If there is no valid database present */ if ((E_OK == LucDetErrFlag) && ((uint32)PWM_DBTOC_VALUE != ConfigPtr->ulStartOfDbToc)) { /* Report Error to DET */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_INIT_SID, PWM_E_INVALID_DATABASE); LucDetErrFlag = E_NOT_OK; } /* else No action required */ if (E_OK == LucDetErrFlag) #endif /* End of PWM_DEV_ERROR_DETECT == STD_ON */ { /* Save the start of channel Configuration in the global pointer */ Pwm_GpChannelConfig = (P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_CONFIG_DATA)) /* PRQA S 0316, 3432 # JV-01, JV-01 */ (ConfigPtr->pChannelConfig); /* PRQA S 2814, 3432 # JV-01, JV-01 */ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWInitUnit) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ #if (STD_OFF == PWM_TIMER_IP_TPU) Pwm_GaaHwFunc[LucHWIPType]->pHWInitUnit(ConfigPtr); #else Pwm_GaaHwFunc[LucHWIPType]->pHWInitUnit(); #endif } /* else No action required */ } /* Initialize all PWM channels */ for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWInitChannel) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucHWIPType]->pHWInitChannel(); } /* else No action required */ } for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWStartOutput) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucHWIPType]->pHWStartOutput(); } /* else No action required */ } #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Set PWM Driver status to initialized */ Pwm_SetStatus(PWM_INITIALIZED); #endif } /* else No action required */ /* End of if (E_OK == LucDetErrFlag) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_DEV_ERROR_DETECT', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Argument', 'Range': 'NULL_PTR \u2026 Address', 'Name': 'ConfigPtr', 'Value': 'NULL_PTR'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulStartOfDbToc', 'Value': '-'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelConfig', 'Value': '&map_Pwm_GaaChannelConfig[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pHWIPConfig', 'Value': '-'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pClockConfig', 'Value': '-'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaHwFunc[0 to 4]', 'Value': '[0]= &map_Pwm_GaaHwFunc[0]\\n[1]= &map_Pwm_GaaHwFunc[1]\\n[2]= &map_Pwm_GaaHwFunc[2]\\n[3]= &map_Pwm_GaaHwFunc[3]\\n[4]= &map_Pwm_GaaHwFunc[4]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pHWInitUnit', 'Value': '[0]= NULL_PTR\\n[1]= NULL_PTR\\n[2]= NULL_PTR\\n[3]= NULL_PTR\\n[4]= NULL_PTR'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'pHWInitChannel', 'Value': '[0]= NULL_PTR\\n[1]= NULL_PTR\\n[2]= NULL_PTR\\n[3]= NULL_PTR\\n[4]= NULL_PTR'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'pHWStartOutput', 'Value': '[0]= NULL_PTR\\n[1]= NULL_PTR\\n[2]= NULL_PTR\\n[3]= NULL_PTR\\n[4]= NULL_PTR'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblDriverStatus', 'Value': 'PWM_INITIALIZED'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Pwm_GaaHWIP_Used', 'Value': '&Pwm_GaaHWIP_Used[0]'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'PWM_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'PWM_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'PWM_INIT_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'PWM_E_ALREADY_INITIALIZED\\n'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'PWM_MODULE_ID'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'PWM_INSTANCE_ID'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'PWM_INIT_SID'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'PWM_E_INIT_FAILED'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'ConfigPtr', 'Value': '<Not Called>'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SELECT_CHANNEL_CLK_API == STD_ON) #define PWM_START_SEC_PUBLIC_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PUBLIC_CODE) Pwm_SelectChannelClk(Pwm_ChannelType ChannelNumber, Pwm_ClockSourceType ClockSource) /* PRQA S 1532 # JV-01 */ { /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucTimerUnitType; #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(uint8, AUTOMATIC) LucDetErrFlag; /* Checking Det error */ LucDetErrFlag = Pwm_CheckDetErrors(ChannelNumber, PWM_SELECT_CHANNEL_CLK_SID); /* Check for valid Clock source */ if ((E_OK == LucDetErrFlag) && (CLKBUSLINE3 < ClockSource)) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SELECT_CHANNEL_CLK_SID, PWM_E_PARAM_VALUE); LucDetErrFlag = E_NOT_OK; } /* else No action required */ if (E_OK == LucDetErrFlag) #endif { /* Updating the channel config parameter to the current channel */ LpChannelConfig = &Pwm_GpChannelConfig[ChannelNumber]; /* Get the Timer Unit Type*/ LucTimerUnitType = LpChannelConfig->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Set the Duty cycle for the required channel */ if (NULL_PTR != Pwm_GaaHwFunc[LucTimerUnitType]->pHWSelectChannelClk) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucTimerUnitType]->pHWSelectChannelClk(ChannelNumber, ClockSource); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_DEV_ERROR_DETECT', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD_UNIT_USED', 'Value': 'STD_OFF(0)'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUJ_UNIT_USED', 'Value': 'STD_OFF(0)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TIMER_IP_ATU', 'Value': 'STD_ON(1)'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0\u202663\\n0\u202639\\n0\u202635', 'Name': 'ChannelNumber', 'Value': '2'], 'Input_Param_005': ['Type': 'Argument', 'Range': 'CLKBUSLINE0 (0)\\nCLKBUSLINE1 (1)\\nCLKBUSLINE2 (2)\\nCLKBUSLINE3 (3)', 'Name': 'ClockSource', 'Value': 'CLKBUSLINE0'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaHwFunc[0 to 3]', 'Value': '[0]= &map_Pwm_GaaHwFunc[0]\\n[1]= &map_Pwm_GaaHwFunc[1]\\n[2]= &map_Pwm_GaaHwFunc[2]\\n[3]= &map_Pwm_GaaHwFunc[3]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'pHWSelectChannelClk', 'Value': '[0]= NULL_PTR\\n[1] = NULL_PTR\\n[2]= NULL_PTR\\n[3]=NULL_PTR'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GaaChannelConfig[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[2]= NULL_PTR'], 'Input_Param_010': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelNumber', 'Value': '2'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApi_SID', 'Value': 'PWM_SELECT_CHANNEL_CLK_SID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LenClockSource', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SET_PERIOD_AND_DUTY_API == STD_ON) #define PWM_START_SEC_PUBLIC_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PUBLIC_CODE) Pwm_SetPeriodAndDuty(Pwm_ChannelType ChannelNumber, Pwm_PeriodType Period, uint16 DutyCycle) /* PRQA S 1532 # JV-01 */ { /* Pointer pointing to the channel configuration */ P2CONST(Pwm_ChannelConfigType, AUTOMATIC, PWM_CONFIG_CONST) LpChannelConfig; /* PRQA S 3432 # JV-01 */ /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucTimerUnitType; #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(uint8, AUTOMATIC) LucDetErrFlag; /* Checking Det error */ LucDetErrFlag = Pwm_CheckDetErrors(ChannelNumber, PWM_SET_PERIODANDDUTY_SID); #endif /* PWM_DEV_ERROR_DETECT == STD_ON */ /* Updating the channel config parameter to the current channel */ LpChannelConfig = &Pwm_GpChannelConfig[ChannelNumber]; #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Check for valid Duty range */ if (E_OK == LucDetErrFlag) { if (PWM_MAX_DUTY_CYCLE_VALUE < DutyCycle) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SET_PERIODANDDUTY_SID, PWM_E_PARAM_VALUE); LucDetErrFlag = E_NOT_OK; } /* Check if the Channel is of fixed period type */ if ((PWM_FIXED_PERIOD == LpChannelConfig->enClassType) /* PRQA S 2814, 2844 # JV-02, JV-01 */ || (PWM_FIXED_PERIOD_SHIFTED == LpChannelConfig->enClassType)) { /* Report to DET module */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SET_PERIODANDDUTY_SID, PWM_E_PERIOD_UNCHANGEABLE); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } /* else No action required */ if (E_OK == LucDetErrFlag) #endif /* PWM_DEV_ERROR_DETECT == STD_ON */ { /* Get the Timer Unit Type*/ LucTimerUnitType = LpChannelConfig->ucTimerUnitType; /* PRQA S 2814, 2844 # JV-02, JV-01 */ /* Set Period and Duty cycle for the required channel */ if (NULL_PTR != Pwm_GaaHwFunc[LucTimerUnitType]->pHWSetPeriodAndDuty) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucTimerUnitType]->pHWSetPeriodAndDuty(ChannelNumber, Period, DutyCycle); } /* else No action required */ } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_DEV_ERROR_DETECT', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0\u2026111\\n0...99\\n0...83\\n0\u202663\\n0\u202639\\n0\u202635\\n0...19', 'Name': 'ChannelNumber', 'Value': '2'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0x00000000\u2026.\\nPWM_PERIOD_MAX_LIMIT(0x00FFFFFF)', 'Name': 'Period', 'Value': 'PWM_PERIOD_MAX_LIMIT - 1'], 'Input_Param_003': ['Type': 'Argument', 'Range': 'PWM_MIN_DUTY_CYCLE_VALUE (0x0000) \u2026 PWM_MAX_DUTY_CYCLE_VALUE (0x8000)', 'Name': 'DutyCycle', 'Value': 'PWM_MIN_DUTY_CYCLE_VALUE'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaHwFunc[0 to 4]', 'Value': '[0]= &map_Pwm_GaaHwFunc[0]\\n[1]= &map_Pwm_GaaHwFunc[1]\\n[2]= &map_Pwm_GaaHwFunc[2]\\n[3]= &map_Pwm_GaaHwFunc[3]\\n[4]= &map_Pwm_GaaHwFunc[4]'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'pHWSetPeriodAndDuty', 'Value': '[0]= NULL_PTR\\n[1]= NULL_PTR\\n[2]= NULL_PTR\\n[3]= NULL_PTR\\n[4] = &ISOLATE_void_func_ptr_Pwm_ChannelType__Pwm_PeriodType__uint16'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GpChannelConfig', 'Value': '&map_Pwm_GaaChannelConfig[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ucTimerUnitType', 'Value': '[2]= PWM_HWIP_TPU'], 'Input_Param_008': ['Type': 'Array', 'Range': '', 'Name': 'enClassType', 'Value': '[2]= PWM_VARIABLE_PERIOD'], 'Input_Param_009': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': 'E_OK']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelNumber', 'Value': '2'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LucApi_SID', 'Value': 'PWM_SET_PERIODANDDUTY_SID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '<Not Called>'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '<Not Called>'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '<Not Called>'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '2'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddPeriod', 'Value': 'PWM_PERIOD_MAX_LIMIT - 1'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusDutyCycle', 'Value': 'PWM_MIN_DUTY_CYCLE_VALUE'], 'Output_Param_013': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_DEV_ERROR_DETECT == STD_ON) #define PWM_START_SEC_PRIVATE_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ STATIC FUNC(void, PWM_PRIVATE_CODE) Pwm_SetStatus(boolean LblStatus) { Pwm_GblDriverStatus = LblStatus; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LblStatus', 'Value': 'PWM_UNINITIALIZED']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblDriverStatus', 'Value': 'PWM_UNINITIALIZED'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_SYNC_START_SUPPORT == STD_ON) #define PWM_START_SEC_PUBLIC_CODE #include \"Pwm_Mapping.h\" /* PRQA S 5087 # JV-01 */ FUNC(void, PWM_PUBLIC_CODE) Pwm_SynchronousStart(void) /* PRQA S 1532 # JV-01 */ { /* Index of HW IP Type */ VAR(volatile uint8, AUTOMATIC) LucHWIPType; VAR(uint32, AUTOMATIC) LulCount; #if (PWM_DEV_ERROR_DETECT == STD_ON) /* Declare the variable to store the DET return value */ VAR(uint8, AUTOMATIC) LucDetErrFlag; /* Initialize error flag */ LucDetErrFlag = E_OK; /* Check if the PWM Driver is initialized and API Pwm_SynchronousInit is invoked or not */ if ((PWM_INITIALIZED != Pwm_GblDriverStatus) || (PWM_INITIALIZED != Pwm_GblSyncInitStatus)) /* PRQA S 3415, 3416 # JV-01, JV-01 */ { /* Report to DET */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SYNCHRONOUS_START_SID, PWM_E_UNINIT); LucDetErrFlag = E_NOT_OK; } else { if (PWM_SYNC_STOPPED != Pwm_GblSyncOperationStatus) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(PWM_MODULE_ID, PWM_INSTANCE_ID, PWM_SYNCHRONOUS_START_SID, PWM_E_ALREADY_STARTED); LucDetErrFlag = E_NOT_OK; } /* else No action required */ } if (E_OK == LucDetErrFlag) #endif { /* Enter Protected area */ #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) PWM_ENTER_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif for (LulCount = (uint32)PWM_ZERO; LulCount < (uint32)PWM_TOTAL_HW_IP_CONFIG; LulCount++) /* PRQA S 2877 # JV-01 */ { LucHWIPType = Pwm_GaaHWIP_Used[LulCount].ucIndex; if (NULL_PTR != Pwm_GaaHwFunc[LucHWIPType]->pHWSynchronousStart) /* PRQA S 2814 # JV-01 */ { /* Invoke low level driver for initializing the hardware */ Pwm_GaaHwFunc[LucHWIPType]->pHWSynchronousStart(); } /* else No action required */ } #if (PWM_DEV_ERROR_DETECT == STD_ON) Pwm_GblSyncOperationStatus = PWM_SYNC_STARTED; #endif /* Exit Protected area */ #if (PWM_CRITICAL_SECTION_PROTECTION == STD_ON) PWM_EXIT_CRITICAL_SECTION(PWM_INTERRUPT_CONTROL_PROTECTION); #endif } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_DEV_ERROR_DETECT', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD_UNIT_USED', 'Value': 'STD_OFF(0)'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUJ_UNIT_USED', 'Value': 'STD_OFF(0)'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TIMER_IP_ATU', 'Value': 'STD_ON(1)'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblDriverStatus', 'Value': 'PWM_INITIALIZED'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblSyncInitStatus', 'Value': 'PWM_UNINITIALIZED'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblSyncOperationStatus', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'Pwm_GaaHwFunc[0 to 3]', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'P2CONST_Pwm_GaaHWIP_Used', 'Value': '&Pwm_GaaHWIP_Used[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '', 'Name': 'ucIndex', 'Value': '[0] = PWM_HWIP_ATU'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'pHWSynchronousStart', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'PWM_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'PWM_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'PWM_SYNCHRONOUS_START_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'PWM_E_UNINIT'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Pwm_GblSyncOperationStatus', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<Not Called>'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_TAUD0_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503 # JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_TAUD_Callback(PWM_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '0 = TAUD0_CH00_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '0'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_TAUD0_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503 # JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_TAUD_Callback(PWM_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '35 = TAUD2_CH03_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '55'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_TAUD0_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503 # JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_TAUD_Callback(PWM_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '2 = TAUD0_CH02_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '38'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_TAUD0_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503 # JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_TAUD_Callback(PWM_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '13 = TAUD0_CH13_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '49'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_TAUD0_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503 # JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_TAUD_Callback(PWM_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '32 = TAUD2_CH00_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '68'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_TAUD0_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUD0_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(TAUD0_CH00_CAT2_ISR) /* PRQA S 1503 # JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) TAUD0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_TAUD_Callback(PWM_TAUD0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUD0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '1 = TAUD0_CH01_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '1'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_TAUJ0_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUJ0_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(TAUJ0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) TAUJ0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_TAUJ_Callback(PWM_TAUJ0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUJ0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '14 = TAUJ3_CH02_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '62'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (PWM_TAUJ0_CH00_ISR_API == STD_ON) #define PWM_START_SEC_CODE_FAST #include \"Pwm_Mapping.h\" /* Defines the CAT2 interrupt mapping */ #if defined(Os_TAUJ0_CH00_CAT2_ISR) || (PWM_ISR_CATEGORY_2 == STD_ON) ISR(TAUJ0_CH00_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, PWM_CODE_FAST) TAUJ0_CH00_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { Pwm_HW_TAUJ_Callback(PWM_TAUJ0_CH00); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'PWM_TAUJ0_CH00_ISR_API', 'Value': 'STD_ON(1)'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '7 = TAUJ3_CH03_ISR']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LddChannelId', 'Value': '95'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) FUNC(Std_ReturnType, SPI_PUBLIC_CODE) Spi_AsyncTransmit(Spi_SequenceType Sequence) /* PRQA S 1532 # JV-01 */ { Std_ReturnType LucReturnValue; uint32 LulCount; LucReturnValue = E_OK; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_UNINIT); LucReturnValue = E_NOT_OK; } /* Check if the Sequence ID passed, is valid */ else if (Spi_GpConfigPtr->ucNoOfSequences <= Sequence) /* PRQA S 2004 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_PARAM_SEQ); LucReturnValue = E_NOT_OK; } #if ((SPI_AR_VERSION == SPI_AR_422_VERSION) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) /* * Check if the HW Unit of the job is configured for synchronous transmission */ else if (SPI_TRUE == Spi_GpFirstSeq[Sequence].blSynchronous) /* PRQA S 2004 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_PARAM_SEQ); LucReturnValue = E_NOT_OK; } #endif /* ((SPI_AR_VERSION == SPI_AR_422_VERSION) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) */ /* Check if not any DET error reported */ if (E_NOT_OK != LucReturnValue) #endif /* SPI_DEV_ERROR_DETECT == STD_ON */ { /* Critical section required for re-entrancy of this API */ SPI_ENTER_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); #if (((SPI_AR_VERSION == SPI_AR_431_VERSION) || (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION)) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) /* Check if sequence is already used for sync transmission */ if (0UL != (Spi_GulActiveHWUnits & Spi_GpFirstSeq[Sequence].ulUsingHWUnits)) { /* This function shall return with value E_NOT_OK */ LucReturnValue = E_NOT_OK; } else /* Check if sequence is already used for async transmission */ #endif /* (((SPI_AR_VERSION == SPI_AR_431_VERSION) || (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION)) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) */ /* Check if the requested sequence already pending */ if (SPI_SEQ_PENDING == Spi_GaaSeqStatus[Sequence].enResult) /* PRQA S 2844 # JV-01 */ { /* This function shall return with value E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { for (LulCount = 0U; LulCount < SPI_BITS_TO_WORDS(SPI_MAX_SEQUENCE); LulCount++) /* PRQA S 3469, 2877 # JV-01, JV-01 */ { if (0UL != (Spi_GaaActiveSequence[LulCount] & Spi_GpFirstSeq[Sequence].aaJobSharedSequences[LulCount])) { LucReturnValue = E_NOT_OK; } /* else No action required */ } /* If OK, set active flag for this Sequence */ if (E_OK == LucReturnValue) { /* Set active sequence bit for check shared job in a sub-sequence */ Spi_GaaActiveSequence[(uint32)Sequence / (uint32)SPI_UINT32_BITS] |= /* PRQA S 2844 # JV-01 */ (1UL << ((uint32)Sequence & (uint32)(SPI_UINT32_BITS - 1U))); /* Set sequence status as pending */ Spi_GaaSeqStatus[Sequence].enResult = SPI_SEQ_PENDING; /* PRQA S 2844 # JV-01 */ #if (SPI_CANCEL_API == STD_ON) /* Initialize cancel request flag by Spi_Cancel */ Spi_GaaSeqStatus[Sequence].blCancelRequested = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif #if ((SPI_CANCEL_API == STD_ON) || (SPI_FORCE_CANCEL_API == STD_ON)) /* Initialize already canceled flag for Spi_Cancel or Spi_ForceCancel */ Spi_GaaSeqStatus[Sequence].blCanceled = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif } /* else No action required */ } SPI_EXIT_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); /* Report to DET on the outside of critical section */ if (E_NOT_OK == LucReturnValue) { /* Report to DET */ #if ((SPI_AR_VERSION == SPI_AR_431_VERSION)|| (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION) || (SPI_DEV_ERROR_DETECT == STD_ON)) SPI_DET_REPORT_RUNTIME_ERROR(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_SEQ_PENDING); #endif } else { /* Transmission */ Spi_StartTransmission((uint32)Sequence); } } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CANCEL_API', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FORCE_CANCEL_API', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_MAX_SEQUENCE', 'Value': '2'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'Sequence', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GblInitialized', 'Value': 'SPI_TRUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfSequences', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_Spi_GpFirstSeq[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'blSynchronous', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'aaJobSharedSequences[0]', 'Value': '0x00000001'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'enResult', 'Value': '[0] = SPI_SEQ_OK'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0]', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulUsingHWUnits', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_SEQ_PENDING'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blCancelRequested', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blCanceled', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0]', 'Value': '0x00000001'], 'Output_Param_008': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSequence', 'Value': '0'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) FUNC(Std_ReturnType, SPI_PUBLIC_CODE) Spi_AsyncTransmit(Spi_SequenceType Sequence) /* PRQA S 1532 # JV-01 */ { Std_ReturnType LucReturnValue; uint32 LulCount; LucReturnValue = E_OK; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_UNINIT); LucReturnValue = E_NOT_OK; } /* Check if the Sequence ID passed, is valid */ else if (Spi_GpConfigPtr->ucNoOfSequences <= Sequence) /* PRQA S 2004 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_PARAM_SEQ); LucReturnValue = E_NOT_OK; } #if ((SPI_AR_VERSION == SPI_AR_422_VERSION) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) /* * Check if the HW Unit of the job is configured for synchronous transmission */ else if (SPI_TRUE == Spi_GpFirstSeq[Sequence].blSynchronous) /* PRQA S 2004 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_PARAM_SEQ); LucReturnValue = E_NOT_OK; } #endif /* ((SPI_AR_VERSION == SPI_AR_422_VERSION) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) */ /* Check if not any DET error reported */ if (E_NOT_OK != LucReturnValue) #endif /* SPI_DEV_ERROR_DETECT == STD_ON */ { /* Critical section required for re-entrancy of this API */ SPI_ENTER_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); #if (((SPI_AR_VERSION == SPI_AR_431_VERSION) || (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION)) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) /* Check if sequence is already used for sync transmission */ if (0UL != (Spi_GulActiveHWUnits & Spi_GpFirstSeq[Sequence].ulUsingHWUnits)) { /* This function shall return with value E_NOT_OK */ LucReturnValue = E_NOT_OK; } else /* Check if sequence is already used for async transmission */ #endif /* (((SPI_AR_VERSION == SPI_AR_431_VERSION) || (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION)) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) */ /* Check if the requested sequence already pending */ if (SPI_SEQ_PENDING == Spi_GaaSeqStatus[Sequence].enResult) /* PRQA S 2844 # JV-01 */ { /* This function shall return with value E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { for (LulCount = 0U; LulCount < SPI_BITS_TO_WORDS(SPI_MAX_SEQUENCE); LulCount++) /* PRQA S 3469, 2877 # JV-01, JV-01 */ { if (0UL != (Spi_GaaActiveSequence[LulCount] & Spi_GpFirstSeq[Sequence].aaJobSharedSequences[LulCount])) { LucReturnValue = E_NOT_OK; } /* else No action required */ } /* If OK, set active flag for this Sequence */ if (E_OK == LucReturnValue) { /* Set active sequence bit for check shared job in a sub-sequence */ Spi_GaaActiveSequence[(uint32)Sequence / (uint32)SPI_UINT32_BITS] |= /* PRQA S 2844 # JV-01 */ (1UL << ((uint32)Sequence & (uint32)(SPI_UINT32_BITS - 1U))); /* Set sequence status as pending */ Spi_GaaSeqStatus[Sequence].enResult = SPI_SEQ_PENDING; /* PRQA S 2844 # JV-01 */ #if (SPI_CANCEL_API == STD_ON) /* Initialize cancel request flag by Spi_Cancel */ Spi_GaaSeqStatus[Sequence].blCancelRequested = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif #if ((SPI_CANCEL_API == STD_ON) || (SPI_FORCE_CANCEL_API == STD_ON)) /* Initialize already canceled flag for Spi_Cancel or Spi_ForceCancel */ Spi_GaaSeqStatus[Sequence].blCanceled = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif } /* else No action required */ } SPI_EXIT_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); /* Report to DET on the outside of critical section */ if (E_NOT_OK == LucReturnValue) { /* Report to DET */ #if ((SPI_AR_VERSION == SPI_AR_431_VERSION)|| (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION) || (SPI_DEV_ERROR_DETECT == STD_ON)) SPI_DET_REPORT_RUNTIME_ERROR(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_SEQ_PENDING); #endif } else { /* Transmission */ Spi_StartTransmission((uint32)Sequence); } } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FORCE_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_MAX_SEQUENCE', 'Value': '3'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'Sequence', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GblInitialized', 'Value': 'SPI_TRUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfSequences', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_Spi_GpFirstSeq[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'blSynchronous', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'aaJobSharedSequences[0]', 'Value': '-'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'enResult', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0]', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulUsingHWUnits', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'SPI_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'SPI_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'SPI_ASYNCTRANSMIT_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'SPI_E_PARAM_SEQ'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blCancelRequested', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blCanceled', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0]', 'Value': '-'], 'Output_Param_008': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_009': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSequence', 'Value': '-'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_NOT_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) FUNC(Std_ReturnType, SPI_PUBLIC_CODE) Spi_AsyncTransmit(Spi_SequenceType Sequence) /* PRQA S 1532 # JV-01 */ { Std_ReturnType LucReturnValue; uint32 LulCount; LucReturnValue = E_OK; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_UNINIT); LucReturnValue = E_NOT_OK; } /* Check if the Sequence ID passed, is valid */ else if (Spi_GpConfigPtr->ucNoOfSequences <= Sequence) /* PRQA S 2004 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_PARAM_SEQ); LucReturnValue = E_NOT_OK; } #if ((SPI_AR_VERSION == SPI_AR_422_VERSION) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) /* * Check if the HW Unit of the job is configured for synchronous transmission */ else if (SPI_TRUE == Spi_GpFirstSeq[Sequence].blSynchronous) /* PRQA S 2004 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_PARAM_SEQ); LucReturnValue = E_NOT_OK; } #endif /* ((SPI_AR_VERSION == SPI_AR_422_VERSION) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) */ /* Check if not any DET error reported */ if (E_NOT_OK != LucReturnValue) #endif /* SPI_DEV_ERROR_DETECT == STD_ON */ { /* Critical section required for re-entrancy of this API */ SPI_ENTER_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); #if (((SPI_AR_VERSION == SPI_AR_431_VERSION) || (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION)) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) /* Check if sequence is already used for sync transmission */ if (0UL != (Spi_GulActiveHWUnits & Spi_GpFirstSeq[Sequence].ulUsingHWUnits)) { /* This function shall return with value E_NOT_OK */ LucReturnValue = E_NOT_OK; } else /* Check if sequence is already used for async transmission */ #endif /* (((SPI_AR_VERSION == SPI_AR_431_VERSION) || (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION)) && (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) */ /* Check if the requested sequence already pending */ if (SPI_SEQ_PENDING == Spi_GaaSeqStatus[Sequence].enResult) /* PRQA S 2844 # JV-01 */ { /* This function shall return with value E_NOT_OK */ LucReturnValue = E_NOT_OK; } else { for (LulCount = 0U; LulCount < SPI_BITS_TO_WORDS(SPI_MAX_SEQUENCE); LulCount++) /* PRQA S 3469, 2877 # JV-01, JV-01 */ { if (0UL != (Spi_GaaActiveSequence[LulCount] & Spi_GpFirstSeq[Sequence].aaJobSharedSequences[LulCount])) { LucReturnValue = E_NOT_OK; } /* else No action required */ } /* If OK, set active flag for this Sequence */ if (E_OK == LucReturnValue) { /* Set active sequence bit for check shared job in a sub-sequence */ Spi_GaaActiveSequence[(uint32)Sequence / (uint32)SPI_UINT32_BITS] |= /* PRQA S 2844 # JV-01 */ (1UL << ((uint32)Sequence & (uint32)(SPI_UINT32_BITS - 1U))); /* Set sequence status as pending */ Spi_GaaSeqStatus[Sequence].enResult = SPI_SEQ_PENDING; /* PRQA S 2844 # JV-01 */ #if (SPI_CANCEL_API == STD_ON) /* Initialize cancel request flag by Spi_Cancel */ Spi_GaaSeqStatus[Sequence].blCancelRequested = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif #if ((SPI_CANCEL_API == STD_ON) || (SPI_FORCE_CANCEL_API == STD_ON)) /* Initialize already canceled flag for Spi_Cancel or Spi_ForceCancel */ Spi_GaaSeqStatus[Sequence].blCanceled = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif } /* else No action required */ } SPI_EXIT_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); /* Report to DET on the outside of critical section */ if (E_NOT_OK == LucReturnValue) { /* Report to DET */ #if ((SPI_AR_VERSION == SPI_AR_431_VERSION)|| (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION) || (SPI_DEV_ERROR_DETECT == STD_ON)) SPI_DET_REPORT_RUNTIME_ERROR(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_ASYNCTRANSMIT_SID, SPI_E_SEQ_PENDING); #endif } else { /* Transmission */ Spi_StartTransmission((uint32)Sequence); } } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FORCE_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_MAX_SEQUENCE', 'Value': '3'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'Sequence', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GblInitialized', 'Value': 'SPI_TRUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfSequences', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_Spi_GpFirstSeq[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'blSynchronous', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'aaJobSharedSequences[0]', 'Value': '0x00000001'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'enResult', 'Value': '[1] = SPI_SEQ_OK'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0]', 'Value': '0xFFFFFFFF'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulUsingHWUnits', 'Value': '0xFFFFFFFF']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blCancelRequested', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'blCanceled', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0]', 'Value': '-'], 'Output_Param_008': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_009': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_011': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_012': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_013': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_014': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'SPI_MODULE_ID'], 'Output_Param_015': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'SPI_INSTANCE_ID'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'SPI_ASYNCTRANSMIT_SID'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'SPI_E_SEQ_PENDING'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSequence', 'Value': '-'], 'Output_Param_019': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_NOT_OK'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (SPI_CANCEL_API == STD_ON) FUNC(void, SPI_PUBLIC_CODE) Spi_Cancel(Spi_SequenceType Sequence) /* PRQA S 1532 # JV-01 */ { #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_0) /* Avoid error in compilation of an unused variable with Arm compiler */ (void)Sequence; #endif #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_CANCEL_SID, SPI_E_UNINIT); } /* Check if the sequence ID passed, is valid */ else if (Spi_GpConfigPtr->ucNoOfSequences <= Sequence) { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_CANCEL_SID, SPI_E_PARAM_SEQ); } #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) #if (SPI_AR_VERSION == SPI_AR_422_VERSION) /* * Check if the HW Unit of the job is configured for synchronous transmission */ else if (SPI_TRUE == Spi_GpFirstSeq[Sequence].blSynchronous) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_CANCEL_SID, SPI_E_PARAM_SEQ); } #endif /* (SPI_AR_VERSION == SPI_AR_422_VERSION) */ #endif /* (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) */ else #endif /* End of SPI_DEV_ERROR_DETECT == STD_ON */ { #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_0) /* When LEVEL0, always raise error */ #if (SPI_DEV_ERROR_DETECT == STD_ON) (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_CANCEL_SID, SPI_E_PARAM_SEQ); #endif /* (SPI_DEV_ERROR_DETECT == STD_ON) */ #else #if ((SPI_AR_VERSION == SPI_AR_431_VERSION) || (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION)) /* Check if sequence is already used for sync transmission */ if (0UL != (Spi_GulActiveHWUnits & Spi_GpFirstSeq[Sequence].ulUsingHWUnits)) { /* Report to DET */ SPI_DET_REPORT_RUNTIME_ERROR(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_CANCEL_SID, SPI_E_SEQ_IN_PROCESS); } else #endif /* ((SPI_AR_VERSION == SPI_AR_431_VERSION) || (SPI_AR_VERSION == SPI_AR_1911_VERSION) || \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION)) */ { #if (SPI_FORCE_CANCEL_API == STD_ON) Spi_CancelSequence((uint32)Sequence, SPI_FALSE); #else Spi_CancelSequence((uint32)Sequence); #endif } #endif /* (SPI_LEVEL_DELIVERED == SPI_LEVEL_0) */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_AR_VERSION', 'Value': '-'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Sequence', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GblInitialized', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfSequences', 'Value': '1'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_Spi_GpFirstSeq[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulUsingHWUnits', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0'], 'Input_Param_010': ['Type': 'Array', 'Range': '', 'Name': 'blSynchronous', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_007': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSequence', 'Value': '0'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulIsForceStop', 'Value': 'SPI_FALSE'], 'Output_Param_010': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(boolean, SPI_PRIVATE_CODE) Spi_CheckSeqFinish(const uint32 LulQueueIndex, const uint32 LulSeqIndex) { uint32 LulRemainJobs; boolean LblSeqFinished; Spi_SeqResultType LenLastSeqState; /* Initialize sequence finish status value as FALSE */ LblSeqFinished = SPI_FALSE; /* * Critical section is required to avoid conflict with StartTransmission and ProcessSequence from other HWUnits */ SPI_ENTER_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); LulRemainJobs = Spi_GaaSeqStatus[LulSeqIndex].aaSubSeqs[LulQueueIndex].usRemainJobCount; /* PRQA S 2844 # JV-01 */ /* * If Sequence finished or aborted, clear Sequence active bit and set Sequence result code. * If multiple events occur at same time, the priority order of the result is: * FAILED > CANCELED(by Spi_ForceCancel) > OK > CANCELED(by Spi_Cancel) */ if ((0UL == LulRemainJobs) || (SPI_TRUE == Spi_GaaSeqStatus[LulSeqIndex].blFailed) #if (SPI_CANCEL_API == STD_ON) || (SPI_TRUE == Spi_GaaSeqStatus[LulSeqIndex].blCancelRequested) #endif #if (SPI_FORCE_CANCEL_API == STD_ON) || (SPI_TRUE == Spi_GaaSeqStatus[LulSeqIndex].blCanceled) #endif ) { #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_ON) /* Clear SubSequence Active flag */ Spi_GaaSeqStatus[LulSeqIndex].ulActiveSubSequences &= ~(1UL << LulQueueIndex); #endif /* If a SubSequence is aborted by some reason, remove remained Jobs */ if (0UL != LulRemainJobs) { Spi_RemoveFromQueue(LulQueueIndex, LulSeqIndex); #if (SPI_CANCEL_API == STD_ON) /* If cancel is requested before finish, set the canceled flag */ if (SPI_TRUE == Spi_GaaSeqStatus[LulSeqIndex].blCancelRequested) /* PRQA S 2844 # JV-01 */ { Spi_GaaSeqStatus[LulSeqIndex].blCanceled = SPI_TRUE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ #endif } /* else No action required */ /* When all SubSequences finished, finish Sequence */ #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_ON) if (0UL != Spi_GaaSeqStatus[LulSeqIndex].ulActiveSubSequences) /* PRQA S 2844 # JV-01 */ { /* There are still active SubSequences, continue the Sequence */ } else #endif { LblSeqFinished = SPI_TRUE; /* Clear Sequence active bit */ Spi_GaaActiveSequence[LulSeqIndex / (uint32)SPI_UINT32_BITS] &= ~(1UL << (LulSeqIndex & (SPI_UINT32_BITS - 1U))); /* PRQA S 2844 # JV-01 */ /* Update Sequence Result */ if (SPI_TRUE == Spi_GaaSeqStatus[LulSeqIndex].blFailed) /* PRQA S 2844 # JV-01 */ { LenLastSeqState = SPI_SEQ_FAILED; } #if ((SPI_CANCEL_API == STD_ON) || (SPI_FORCE_CANCEL_API == STD_ON)) else if (SPI_TRUE == Spi_GaaSeqStatus[LulSeqIndex].blCanceled) { LenLastSeqState = SPI_SEQ_CANCELED; } #endif else { LenLastSeqState = SPI_SEQ_OK; } Spi_GaaSeqStatus[LulSeqIndex].enResult = LenLastSeqState; /* PRQA S 2844 # JV-01 */ } } /* if (SubSequence finished) */ /* Exit from Critical section */ SPI_EXIT_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); /* Return sequence finish flag */ return LblSeqFinished; }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FORCE_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0.. SPI_MAX_HWUNIT', 'Name': 'LulQueueIndex', 'Value': 'SPI_MAX_HWUNIT'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..SPI_MAX_SEQUENCE - 1', 'Name': 'LulSeqIndex', 'Value': 'SPI_MAX_SEQUENCE - 1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GaaSeqStatus[CURRENT_TEST.LulSeqIndex].aaSubSeqs[CURRENT_TEST.LulQueueIndex].usRemainJobCount', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': 'SPI_TRUE\\nSPI_FALSE', 'Name': 'Spi_GaaSeqStatus[CURRENT_TEST.LulSeqIndex].blFailed', 'Value': 'SPI_TRUE'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'SPI_TRUE\\nSPI_FALSE', 'Name': 'Spi_GaaSeqStatus[CURRENT_TEST.LulSeqIndex].blCancelRequested', 'Value': 'SPI_FALSE'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'SPI_TRUE\\nSPI_FALSE', 'Name': 'Spi_GaaSeqStatus[CURRENT_TEST.LulSeqIndex].blCanceled', 'Value': 'SPI_FALSE'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GaaSeqStatus[CURRENT_TEST.LulSeqIndex].ulActiveSubSequences', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_Spi_GpFirstSeq[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfSequences', 'Value': '2'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'enResult', 'Value': '[0] = SPI_SEQ_PENDING\\n[1] = SPI_SEQ_OK'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GaaActiveSequence[0]', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaSeqStatus[0].ulActiveSubSequences', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaSeqStatus[0].blCanceled', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0]', 'Value': '0'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'enResult', 'Value': '[2] = SPI_SEQ_FAILED'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '10'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '2'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_008': ['Type': 'Return_Value', 'Range': '', 'Name': 'LblSeqFinished', 'Value': '1'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (SPI_DMA_CONFIGURED == STD_ON) STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_CSIXDMACompleteISR(const uint32 LulDMAUnitIndex) { volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ uint32 LulHWUnitIndex; uint32 LulHWPhyIndex; LulHWUnitIndex = Spi_GpFirstDMAUnit[LulDMAUnitIndex].ucSPIHWUnit; LpHWStat = &Spi_GaaHWStatus[LulHWUnitIndex]; /* PRQA S 2934 # JV-01 */ LpJobConfig = &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]; /* PRQA S 0404, 2844 # JV-01, JV-01 */ LulHWPhyIndex = Spi_GpFirstHWUnit[LulHWUnitIndex].ucPhyUnitIndex; /* Check whether any error has been occurred during a Channel */ if (0UL != (Spi_GaaCSIHRegs[LulHWPhyIndex].pRegs->ulSTR0 & (SPI_CSIX_DCE | SPI_CSIX_PE | SPI_CSIX_OVE))) /* PRQA S 2814 # JV-01 */ { #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ #endif Spi_GaaCSIHRegs[LulHWPhyIndex].pRegs->usSTCR0 = (uint16)(SPI_CSIX_DCEC | SPI_CSIX_PEC | SPI_CSIX_OVEC); /* Update Job result as FAILED */ Spi_GaaJobStatus[Spi_GaaHWStatus[LulHWUnitIndex].usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* PRQA S 2844 # JV-01 */ /* A least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[Spi_GaaHWStatus[LulHWUnitIndex].usOngoingSeqIndex].blFailed = SPI_TRUE; } /* else No action required */ /* Clear TE interrupt flag */ Spi_DMAClearInterruptFlag(LulDMAUnitIndex); LpHWStat->usTxChannelCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ LpHWStat->usRxChannelCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) /* PRQA S 2844, 2814 # JV-01, JV-01 */ { /* Disable CSIH unit to de-activate CS when the job finishes (SWS_Spi_00263) * Disable CSIH/DMA uint interrupts associated with job. */ Spi_TurnOffHWUnit(LpJobConfig); /* Update Job status */ if (SPI_JOB_FAILED != Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult) { Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_OK; } /* else No action required */ #if (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) /* Check if job is configured with CS as GPIO */ if (SPI_GPIO_CS == LpJobConfig->enCSType) { /* Deactivate the chip select via selected GPIO port pin */ Spi_CSIXHWControlCS(LpJobConfig, SPI_FALSE); } #endif /* (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) */ #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) if (0UL != (Spi_GulActiveHWUnits & (1UL << LulHWUnitIndex))) { /* When SyncTransmit, scheduling is done by Spi_SyncTransmit */ } else #endif { #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) /* Invoke the upper layer scheduler */ Spi_ProcessSequence(LulHWUnitIndex); #endif } } else { /* Otherwise, process the next Channel */ Spi_CSIXProcessJob(SPI_FALSE, LpJobConfig); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_HARDWARE_ERROR_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..(total count of DMA units configured \u2013 1)', 'Name': 'LulDMAUnitIndex', 'Value': '6'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulSTR0', 'Value': '0x000000'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usSTCR0', 'Value': '0xFFFF'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_JOB_PENDING'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfChannels', 'Value': '255'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0xFFFFFFFF'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstDMAUnit', 'Value': '&map_Spi_GpFirstDMAUnit[0]'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucSPIHWUnit', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '0'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '0'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'enCSType', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '1'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '1'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usSTCR0', 'Value': '-'], 'Output_Param_005': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_006': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '6'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': '0'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': 'LpJobConfig'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblActivateCS', 'Value': '-'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_CSIXMainFunction_Handling(void) { #if (SPI_DMA_CONFIGURED == STD_ON) P2CONST(Spi_DmaConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpDmaConfig; /* PRQA S 3432 # JV-01 */ uint32 LulDmaIndex; uint32 LulTxAssignedToDma; uint32 LulRxAssignedToDma; uint32 LulDmaIntFlag; #endif P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ uint32 LulHWUnitIndex; /* Scan DMA completions */ #if (SPI_DMA_CONFIGURED == STD_ON) LulTxAssignedToDma = 0UL; LulRxAssignedToDma = 0UL; for (LulDmaIndex = 0U; LulDmaIndex < Spi_GpConfigPtr->ucNoOfDMAChannels; LulDmaIndex++) { LpDmaConfig = &Spi_GpFirstDMAUnit[LulDmaIndex]; if (SPI_TRUE == LpDmaConfig->blRxSide) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { /* Invoke DMA ISR if the IRQ is asserted */ LulDmaIntFlag = Spi_DMAGetInterruptFlag(LulDmaIndex); if ( #if (SPI_FORCE_CANCEL_API == STD_ON) (0UL == (Spi_GulCancelingHWUnits & (1UL << LpDmaConfig->ucSPIHWUnit))) && #endif (0UL != LulDmaIntFlag)) { Spi_CSIXDMACompleteISR(LulDmaIndex); } /* else No action required */ /* If the rx side is using DMA, polling of CSIXnTIR is not necessary */ LulRxAssignedToDma |= (1UL << LpDmaConfig->ucSPIHWUnit); } else { /* If the tx side is using DMA, polling of CSIXnTIC is not necessary */ LulTxAssignedToDma |= (1UL << LpDmaConfig->ucSPIHWUnit); } } #endif /* Scan CSIXnTIC and CSIXnTIR */ for (LulHWUnitIndex = 0U; LulHWUnitIndex < Spi_GpConfigPtr->ucNoOfHWUnits; LulHWUnitIndex++) { LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; /* Spi_GulCancelingHWUnits is modified by Spi_ForceCancel, but no critical section is required here for this variable. Because: - Spi_ForceCancel is modified in the interrupt disabled section. - Spi_ForceCancel can't be invoked in any higher priority task than Spi_MainFunction_Handling, so Spi_GulCancelHWUnits is never changed while this function is executing. */ /* Spi_GulActiveHWUnits is modified by Spi_SyncTransmit, Spi_AsyncTransmit. - In case of Spi_SyncTransmit, It should not be invoked in any higher priority task than Spi_MainFunction_Handling for a sequence associated with on-going HW unit. Calling the API Spi_GetHWUnitStatus to check whether HW unit is on-going or not. - In case of Spi_AsyncTransmit, sequence pending state is checked before modifying Spi_GulActiveHWUnits. Therefore re-entrancy between Spi_AsyncTransmit and Spi_MainFunction_Handling are not affected. */ if ((SPI_MACRO_CSIH == LpHWInfo->ucMacroIndex) /* PRQA S 2844, 2814 # JV-01, JV-01 */ #if (SPI_AR_VERSION == SPI_AR_422_VERSION) && (SPI_FALSE == LpHWInfo->blSynchronous) #elif (SPI_AR_VERSION == SPI_AR_431_VERSION) && (0UL == (Spi_GulActiveHWUnits & (1UL << LulHWUnitIndex))) #endif #if (SPI_FORCE_CANCEL_API == STD_ON) && (0UL == (Spi_GulCancelingHWUnits & (1UL << LulHWUnitIndex))) #endif ) { /* Tx interruption */ if ( #if (SPI_DMA_CONFIGURED == STD_ON) (0UL == (LulTxAssignedToDma & (1UL << LulHWUnitIndex))) && #endif (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaCSIHRegs[LpHWInfo->ucPhyUnitIndex].pICTIC) & SPI_EIC_EIRF_MASK))) /* PRQA S 2814 # JV-01 */ { RH850_SV_MODE_ICR_AND(16, Spi_GaaCSIHRegs[LpHWInfo->ucPhyUnitIndex].pICTIC, (uint16)(~SPI_EIC_EIRF_MASK)); Spi_CSIXTransmitISR(LulHWUnitIndex); } /* else No action required */ /* Rx interruption */ if ( #if (SPI_DMA_CONFIGURED == STD_ON) (0UL == (LulRxAssignedToDma & (1UL << LulHWUnitIndex))) && #endif (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaCSIHRegs[LpHWInfo->ucPhyUnitIndex].pICTIR) & SPI_EIC_EIRF_MASK))) { /* To emulate the default interrupt priority (CSIXnTIC > CSIXnTIR), check CSIXnTIC again */ if ( #if (SPI_DMA_CONFIGURED == STD_ON) (0UL == (LulTxAssignedToDma & (1UL << LulHWUnitIndex))) && #endif (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaCSIHRegs[LpHWInfo->ucPhyUnitIndex].pICTIC) & SPI_EIC_EIRF_MASK))) { RH850_SV_MODE_ICR_AND(16, Spi_GaaCSIHRegs[LpHWInfo->ucPhyUnitIndex].pICTIC, (uint16)(~SPI_EIC_EIRF_MASK)); Spi_CSIXTransmitISR(LulHWUnitIndex); } /* else No action required */ RH850_SV_MODE_ICR_AND(16, Spi_GaaCSIHRegs[LpHWInfo->ucPhyUnitIndex].pICTIR, (uint16)(~SPI_EIC_EIRF_MASK)); Spi_CSIXReceiveISR(LulHWUnitIndex); } /* else No action required */ } /* Do DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaCSIHRegs[0].pICTIR); EXECUTE_SYNCP(); } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FORCE_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '0..255', 'Name': 'ucNoOfDMAChannels', 'Value': '2'], 'Input_Param_005': ['Type': 'Variable', 'Range': '1..(total count of all SPI units)', 'Name': 'ucNoOfHWUnits', 'Value': '3'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstDMAUnit', 'Value': '&map_Spi_GpFirstDMAUnit[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': 'SPI_TRUE/ SPI_FALSE', 'Name': 'blRxSide', 'Value': '[0] = 1\\n[1] = 0'], 'Input_Param_008': ['Type': 'Array', 'Range': '0..(total count of SPI units - 1)', 'Name': 'ucSPIHWUnit', 'Value': '[0] = 0\\n[1] = 0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GulCancelingHWUnits', 'Value': '0x0000000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_011': ['Type': 'Array', 'Range': 'SPI_MACRO_CSIH\\nSPI_MACRO_HSPI', 'Name': 'ucMacroIndex', 'Value': '[0] = SPI_MACRO_CSIH\\n[1] = SPI_MACRO_CSIH\\n[2] = SPI_MACRO_HSPI'], 'Input_Param_012': ['Type': 'Array', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '[0] = 0\\n[1] = 1\\n[2] = 0'], 'Input_Param_013': ['Type': 'Array', 'Range': '', 'Name': 'blSynchronous', 'Value': '[0 to 2] = 0'], 'Input_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'map_CSIHpICTIC[0 to 1]', 'Value': '[0] = 0x0000\\n[1] = 0x1000'], 'Input_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'map_CSIHpICTIR[0 to 1]', 'Value': '[0] = 0x0000\\n[1] = 0x0000'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'returnValue', 'Value': '[1] = 0']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '[1] = 0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '[1] = 1'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDMAUnitIndex', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'map_CSIHpICTIC[0]', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_CSIHpICTIC[1]', 'Value': '0x0000'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'map_CSIHpICTIR[0]', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_CSIHpICTIR[1]', 'Value': '-'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_CSIXReceiveISR(const uint32 LulHWUnitIndex) /* PRQA S 1505 # JV-01 */ { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; uint16 LusSecondWord; LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2844, 2814 # JV-01, JV-01 */ LpHWStat = &Spi_GaaHWStatus[LulHWUnitIndex]; /* PRQA S 2934 # JV-01 */ #if (SPI_EXTENDED_DATA_LENGTH == STD_ON) if (SPI_TRUE == Spi_GaaEDLStatus[LulHWUnitIndex].blRxEDLOngoing) /* PRQA S 2844 # JV-01 */ { /* If this is the first half of 32bit data, save the received data */ Spi_GaaEDLStatus[LulHWUnitIndex].blRxEDLOngoing = SPI_FALSE; /* PRQA S 2844 # JV-01 */ Spi_GaaEDLStatus[LulHWUnitIndex].usRxEDLFirstWord = Spi_GaaCSIHRegs[LulHWPhyIndex].pRegs->usRX0H; /* PRQA S 2844, 2814 # JV-01, JV-01 */ } else #endif { LpJobConfig = &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]; /* PRQA S 0404, 2844 # JV-01, JV-01 */ LpChConfig = &Spi_GpFirstChannel[LpJobConfig->pChannelList[LpHWStat->usRxChannelCount]]; /* PRQA S 0404, 2844, 2814 # JV-01, JV-01, JV-01 */ /* Receive and store data to memory */ LusSecondWord = Spi_GaaCSIHRegs[LulHWPhyIndex].pRegs->usRX0H; /* PRQA S 2814 # JV-01 */ if (NULL_PTR != LpHWStat->pRxPtr) { #if (SPI_EXTENDED_DATA_LENGTH == STD_ON) Spi_StoreRxData(LpHWStat->pRxPtr, LpChConfig, Spi_GaaEDLStatus[LulHWUnitIndex].usRxEDLFirstWord, LusSecondWord); #else Spi_StoreRxData(LpHWStat->pRxPtr, LpChConfig, LusSecondWord); #endif LpHWStat->pRxPtr = LpHWStat->pRxPtr + LpChConfig->ucByteSize; /* PRQA S 0488, 2844, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ #if (SPI_EXTENDED_DATA_LENGTH == STD_ON) if (LpChConfig->ucDataWidth > SPI_CSIX_WORD) { Spi_GaaEDLStatus[LulHWUnitIndex].blRxEDLOngoing = SPI_TRUE; /* PRQA S 2844 # JV-01 */ } /* else No action required */ #endif LpHWStat->ulRemainedRxCount--; /* PRQA S 3387, 3384 # JV-01, JV-01 */ /* Check whether a Channel is finished */ if (0U == LpHWStat->ulRemainedRxCount) { /* Check whether any error has been occurred during a Channel */ if (0UL != (Spi_GaaCSIHRegs[LulHWPhyIndex].pRegs->ulSTR0 & (SPI_CSIX_DCE | SPI_CSIX_PE | SPI_CSIX_OVE))) { #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); /* PRQA S 3469 # JV-01 */ #endif Spi_GaaCSIHRegs[LulHWPhyIndex].pRegs->usSTCR0 = (uint16)(SPI_CSIX_DCEC | SPI_CSIX_PEC | SPI_CSIX_OVEC); /* Update Job result as FAILED */ Spi_GaaJobStatus[Spi_GaaHWStatus[LulHWUnitIndex].usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* PRQA S 2844 # JV-01 */ /* A least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[Spi_GaaHWStatus[LulHWUnitIndex].usOngoingSeqIndex].blFailed = SPI_TRUE; } /* else No action required */ LpHWStat->usRxChannelCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ /* Check whether a Job is finished */ if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) { /* Disable CSIH unit to de-activate CS when the job finishes (SWS_Spi_00263) * Disable CSIH unit interrupts associated with job. */ Spi_TurnOffHWUnit(LpJobConfig); #if (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) /* Check if job is configured with CS as GPIO */ if (SPI_GPIO_CS == LpJobConfig->enCSType) { /* Deactivate the chip select via selected GPIO port pin */ Spi_CSIXHWControlCS(LpJobConfig, SPI_FALSE); } #endif /* (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) */ /* Set job status as \"JOB_OK\" when no error */ if (SPI_JOB_FAILED != Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult) { Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_OK; } /* else No action required */ #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) if (0UL != (Spi_GulActiveHWUnits & (1UL << LulHWUnitIndex))) { /* When SyncTransmit, scheduling is done by Spi_SyncTransmit */ } else #endif { #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) /* Invoke the upper layer scheduler */ Spi_ProcessSequence(LulHWUnitIndex); #endif } } /* if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) */ else { #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) if (SPI_FALSE == LpJobConfig->blChannelPropertySame) { /* * If ChannelProperty is not same, TxChannelCount is not updated because TxISR never occur on the last data. * Hence update it here. */ LpHWStat->usTxChannelCount = LpHWStat->usRxChannelCount; /* Start the next Channel */ Spi_CSIXProcessJob(SPI_FALSE, &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]); /* PRQA S 0404 # JV-01 */ } else #endif { /* * When a channel is completed and all channel properties are same, setup buffer for the next channel and * continue the operation. Otherwise, call job scheduler. */ LpChConfig = &Spi_GpFirstChannel[LpJobConfig->pChannelList[LpHWStat->usRxChannelCount]]; /* PRQA S 0404 # JV-01 */ #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) if (SPI_BUFFER_TYPE_IB == LpChConfig->enChannelBufferType) /* PRQA S 2844, 2814 # JV-01, JV-01 */ #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) LpHWStat->pRxPtr = LpChConfig->pRxBuffer; LpHWStat->ulRemainedRxCount = LpChConfig->ulNoOfBuffers; #endif } #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) else #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) LpHWStat->pRxPtr = LpChConfig->pEBData->pDestPtr; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LpHWStat->ulRemainedRxCount = LpChConfig->pEBData->ulEBLength; #endif } } /* else (SPI_FALSE == LpJobConfig->blChannelPropertySame) */ } /* else (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) */ } /* if (0U == LpHWStat->ulRemainedRxCount) */ } /* else (SPI_TRUE == LpHWStat->blRxEDLOngoing) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_EXTENDED_DATA_LENGTH', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_HARDWARE_ERROR_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_PERSISTENT_HW_CONFIGURATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': 'SPI_IBEB'], 'Input_Param_005': ['Type': 'Argument', 'Range': '0..(total count of SPI units configured \u2013 1)', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'blSynchronous', 'Value': '1'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'blRxEDLOngoing', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'ucOngoingSeqIndex', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '-', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'pRxPtr', 'Value': 'NULL_PTR'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'usRemainedRxCount', 'Value': '1'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'ucRxChannelCount', 'Value': '254'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pRxPtr[0]', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstChannel', 'Value': '&map_Spi_GpFirstChannel[0]'], 'Input_Param_017': ['Type': 'Array', 'Range': '2\u202632', 'Name': 'ucDataWidth', 'Value': '[0 to 1] = 16'], 'Input_Param_018': ['Type': 'Array', 'Range': '-', 'Name': 'ucByteSize', 'Value': '[0 to 1] = 0'], 'Input_Param_019': ['Type': 'Array', 'Range': '-', 'Name': 'enChannelBufferType', 'Value': '[0 to 1] = 0'], 'Input_Param_020': ['Type': 'Array', 'Range': '-', 'Name': 'pRxBuffer', 'Value': '[0 to 1] = &map_pRxBuffer[0]'], 'Input_Param_021': ['Type': 'Array', 'Range': '-', 'Name': 'usNoOfBuffers', 'Value': '[0 to 1] = 2'], 'Input_Param_022': ['Type': 'Array', 'Range': '-', 'Name': 'pEBData', 'Value': '[0] = &map_pEBData[0]\\n[1] = &map_pEBData_1[0]'], 'Input_Param_023': ['Type': 'Array', 'Range': '-', 'Name': 'map_pRxBuffer[0 to 1]', 'Value': '[0 to 1] = 0x00000020'], 'Input_Param_024': ['Type': 'Variable', 'Range': '-', 'Name': 'pDestPtr', 'Value': '&map_pDestPtr[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '-', 'Name': 'usEBLength', 'Value': '3'], 'Input_Param_026': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pDestPtr[0]', 'Value': '0x00000030'], 'Input_Param_027': ['Type': 'Variable', 'Range': '-', 'Name': 'pDestPtr', 'Value': '&map_pDestPtr_1[0]'], 'Input_Param_028': ['Type': 'Variable', 'Range': '-', 'Name': 'usEBLength', 'Value': '3'], 'Input_Param_029': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pDestPtr_1[0]', 'Value': '0x00000030'], 'Input_Param_030': ['Type': 'Variable', 'Range': '-', 'Name': 'ulSTR0', 'Value': '0x00000000'], 'Input_Param_031': ['Type': 'Variable', 'Range': '-', 'Name': 'usSTCR0', 'Value': '0xFFFF'], 'Input_Param_032': ['Type': 'Variable', 'Range': '-', 'Name': 'usRX0H', 'Value': '0x1234'], 'Input_Param_033': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstJob', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Input_Param_034': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfChannels', 'Value': '255'], 'Input_Param_035': ['Type': 'Variable', 'Range': '-', 'Name': 'pChannelList', 'Value': '&map_pChannelList[0]'], 'Input_Param_036': ['Type': 'Variable', 'Range': 'SPI_TRUE / SPI_FALSE', 'Name': 'blChannelPropertySame', 'Value': '-'], 'Input_Param_037': ['Type': 'Array', 'Range': '-', 'Name': 'map_pChannelList[0 to 1]', 'Value': '-'], 'Input_Param_038': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pChannelList[253]', 'Value': '-'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelList[254]', 'Value': '0'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelList[255]', 'Value': '1'], 'Input_Param_041': ['Type': 'Variable', 'Range': '-', 'Name': 'usRxEDLFirstWord', 'Value': '1'], 'Input_Param_042': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GaaSeqStatus[0].blFailed', 'Value': '0'], 'Input_Param_043': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GaaJobStatus[0].enResult', 'Value': 'SPI_JOB_PENDING'], 'Input_Param_044': ['Type': 'Variable', 'Range': '-', 'Name': 'enCSType', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blRxEDLOngoing', 'Value': '0'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'usRxEDLFirstWord', 'Value': '1'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '-'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'pRxPtr', 'Value': 'NULL_PTR'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '0'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': '0'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_JOB_OK'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': '.usSTCR0', 'Value': '0xFFFF'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '0xFF'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusFirstWord', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusSecondWord', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LusSecondWord', 'Value': 'FUNCTION_DISABLED'], 'Output_Param_016': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_017': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblActivateCS', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_024': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_CSIXTurnOff(const uint32 LulHWPhyIndex) { Spi_GaaCSIHRegs[LulHWPhyIndex].pRegs->ucCTL0 = SPI_CSIH_CTL0_TURNOFF; /* PRQA S 2844, 2814 # JV-01, JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '0..Maximum number of physical HW units - 1', 'Name': 'LulHWPhyIndex', 'Value': '2']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ucCTL0', 'Value': 'SPI_CSIH_CTL0_TURNOFF'], 'Output_Param_001': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Std_ReturnType, SPI_PUBLIC_CODE) Spi_DeInit(void) /* PRQA S 1532 # JV-01 */ { uint32 LulIndex; Std_ReturnType LucReturnValue; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_DEINIT_SID, SPI_E_UNINIT); LucReturnValue = E_NOT_OK; } else #endif /* (SPI_DEV_ERROR_DETECT == STD_ON) */ /* Check if there is no HW unit activated */ if (0UL == Spi_GulActiveHWUnits) /* PRQA S 3416 # JV-01 */ { /* Update the SPI driver status as uninitialized */ Spi_SetStatus(SPI_FALSE); /* DeInit HWs */ for (LulIndex = 0UL; LulIndex < SPI_MAX_MACRO; LulIndex++) /* PRQA S 2877 # JV-01 */ { Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwDeInit(); /* PRQA S 2814 # JV-01 */ } #if (SPI_DMA_CONFIGURED == STD_ON) Spi_DMADeInit(); #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ LucReturnValue = E_OK; } else { LucReturnValue = E_NOT_OK; } /* Return the value */ return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_1'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '1...2', 'Name': 'SPI_MAX_MACRO', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'SPI_TRUE, SPI_FLASE', 'Name': 'Spi_GblInitialized', 'Value': 'SPI_TRUE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GulActiveHWUnits', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GulAllQueueSts', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpHwConfig', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwDeInit', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwDeInit', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatus', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_NOT_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_DMAStart(const uint32 LulDmaIndex, volatile CONSTP2CONST(void, AUTOMATIC, SPI_APPL_DATA) LpMemAddress, /* PRQA S 1532 # JV-01 */ const uint32 LulCount, const uint32 LulAttributes) { P2CONST(Spi_DmaConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpDmaConfig; /* PRQA S 3432 # JV-01 */ LpDmaConfig = &Spi_GpFirstDMAUnit[LulDmaIndex]; if (SPI_TRUE == LpDmaConfig->blRxSide) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { SPI_WRITE_VERIFY_REG(32, &LpDmaConfig->pDmaRegs->ulDAR, SPI_REG32_MASK, (uint32)LpMemAddress) /* PRQA S 0326, 2814 # JV-01, JV-01 */ } else { SPI_WRITE_VERIFY_REG(32, &LpDmaConfig->pDmaRegs->ulSAR, SPI_REG32_MASK, (uint32)LpMemAddress) /* PRQA S 0326 # JV-01 */ } /* Configure the number of buffers to transfer */ SPI_WRITE_VERIFY_REG(32, &LpDmaConfig->pDmaRegs->ulTCR, SPI_REG32_MASK, LulCount) /* Set configured value for the control register */ SPI_WRITE_VERIFY_REG(32, &LpDmaConfig->pDmaRegs->ulCHCR, SPI_REG32_MASK, LulAttributes) if ( #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) (SPI_INTERRUPT_MODE == Spi_GenAsyncMode) && /* PRQA S 3416 # JV-01 */ #endif (SPI_TRUE == LpDmaConfig->blRxSide)) { /* DMA transfer and DMA end interupt is enabled, start DMA */ SPI_WRITE_VERIFY_OR_REG(32, &LpDmaConfig->pDmaRegs->ulCHCR, (SPI_DMA_IE | SPI_DMA_DE), (SPI_DMA_IE | SPI_DMA_DE)) /* PRQA S 0404, 3464 # JV-01, JV-01 */ } else { /* DMA transfer is enabled, start DMA */ SPI_WRITE_VERIFY_OR_REG(32, &LpDmaConfig->pDmaRegs->ulCHCR, SPI_DMA_DE, SPI_DMA_DE) /* PRQA S 0404, 3464 # JV-01, JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..31', 'Name': 'LulDmaIndex', 'Value': '1'], 'Input_Param_002': ['Type': 'Argument', 'Range': 'valid pointer', 'Name': 'LpMemAddress', 'Value': '0x00000010'], 'Input_Param_003': ['Type': 'Argument', 'Range': '-', 'Name': 'LulCount', 'Value': '2'], 'Input_Param_004': ['Type': 'Argument', 'Range': 'SPI_DMA_8BIT\\n : transfer unit is 8bit\\nSPI_DMA_16BIT\\n : transfer unit is 16bit\\nSPI_DMA_32BIT\\n : transfer unit is 32bit\\nSPI_DMA_INCSRC\\n : increment source address per transfer\\nSPI_DMA_INCDST\\n : increment destination address per transfer\\nSPI_DMA_INTERRUPT\\n : enable transfer end interrupt\\nSPI_DMA_SOFTTRIGGER\\n : start transfer immediately\\n', 'Name': 'LulAttributes', 'Value': 'SPI_DMA_32BIT'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GenAsyncMode', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstDMAUnit', 'Value': '&map_Spi_GpFirstDMAUnit[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blRxSide', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pDmaRegs', 'Value': '&map_pDmaRegs[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'usCHCR', 'Value': '0xFFFF'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulCHFCR', 'Value': '0xFFFFFFFF'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulTMR', 'Value': '0xAAAAAAAB'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulTSR', 'Value': '0xFFFFFFFF'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulSAR', 'Value': '0xFFFFFFFF'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulDAR', 'Value': '0xFFFFFFFF']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ulTMR', 'Value': '0x00A1022'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulCHFCR', 'Value': '0x000320E'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ulSAR', 'Value': '0xFFFFFFFF'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulDAR', 'Value': '0x00000010'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulTSR', 'Value': '8'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'usCHCR', 'Value': '0x001'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ulRS', 'Value': '0x0005555'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if (SPI_HW_STATUS_API == STD_ON) FUNC(Spi_StatusType, SPI_PUBLIC_CODE) Spi_GetHWUnitStatus(Spi_HWUnitType HWUnit) /* PRQA S 1532 # JV-01 */ { Spi_StatusType LenHWUnitSts; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_GETHWUNITSTATUS_SID, SPI_E_UNINIT); LenHWUnitSts = SPI_UNINIT; } /* Check the range of HWUnit index */ else if (Spi_GpConfigPtr->ucNoOfHWUnits <= HWUnit) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_GETHWUNITSTATUS_SID, SPI_E_PARAM_UNIT); LenHWUnitSts = SPI_UNINIT; } else #endif /* SPI_DEV_ERROR_DETECT == STD_ON */ { if (SPI_TRUE == Spi_GaaHWStatus[HWUnit].blActive) /* PRQA S 2844 # JV-01 */ { LenHWUnitSts = SPI_BUSY; } else { LenHWUnitSts = SPI_IDLE; } } return (LenHWUnitSts); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GblInitialized', 'Value': '1'], 'Input_Param_002': ['Type': 'Argument', 'Range': '-', 'Name': 'HWUnit', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '1..(total count of all SPI units)', 'Name': 'ucNoOfHWUnits', 'Value': '255'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'blActive', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'SPI_IDLE'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(Spi_JobResultType, SPI_PUBLIC_CODE) Spi_GetJobResult(Spi_JobType Job) /* PRQA S 1532 # JV-01 */ { Spi_JobResultType LenJobResult; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_GETJOBRESULT_SID, SPI_E_UNINIT); LenJobResult = SPI_JOB_FAILED; } /* Check if the job ID passed, is valid */ else if (Spi_GpConfigPtr->usNoOfJobs <= Job) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_GETJOBRESULT_SID, SPI_E_PARAM_JOB); LenJobResult = SPI_JOB_FAILED; } else #endif /* SPI_DEV_ERROR_DETECT == STD_ON */ { LenJobResult = Spi_GaaJobStatus[Job].enResult; /* PRQA S 2844 # JV-01 */ } return (LenJobResult); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GblInitialized', 'Value': 'SPI_TRUE'], 'Input_Param_002': ['Type': 'Argument', 'Range': '0..(SpiMaxJob \u2013 1)', 'Name': 'Job', 'Value': '1'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfJobs', 'Value': '0'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'enResult', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': 'SPI_MODULE_ID'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': 'SPI_INSTANCE_ID'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': 'SPI_GETJOBRESULT_SID'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': 'SPI_E_PARAM_JOB'], 'Output_Param_004': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': '2'], 'Output_Param_005': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(void, SPI_CODE_FAST) Spi_HSPIForceStop(const uint32 LulHWUnitIndex) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; uint32 LulCount; uint32 LulMDRegValue; uint32 LulCTLRegValue; uint32 LulSSCTLRegValue; uint32 LulIRENRegValue; #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_ON) uint32 LulCDIVRegValue; uint32 LulSCKDLYRegValue; uint32 LulSSNDLYRegValue; uint32 LulNFMDLYRegValue; uint32 LulSPLDLYRegValue; #endif /* Get pointers and index relevant to HW */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Stop SPI unit by HSPInEN.HSPInEN = 0 */ Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulEN = 0UL; /* PRQA S 2814 # JV-01 */ /* Wait until the operation status becomes non-active. This loop never cause timeout unless a HW malfunctions. */ LulCount = 0UL; while ((LulCount < Spi_GpConfigPtr->ulTimeoutCount) && (0UL != (Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulACTST & SPI_HSPI_ACTF))) { LulCount++; } /* Backup regisers which are initialized by software reset */ LulMDRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulMD; LulCTLRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulCTL; LulSSCTLRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSSCTL; LulIRENRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulIREN; #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_ON) LulCDIVRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulCDIV; LulSCKDLYRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSCKDLY; LulSSNDLYRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSSNDLY; LulNFMDLYRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulNFMDLY; LulSPLDLYRegValue = Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSPLDLY; #endif /* Perform software reset */ Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSRST = SPI_HSPI_SRST; /* Dummy read to wait reset completion */ Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSRST; /* Restore registers after software reset */ Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulMD = LulMDRegValue; Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulCTL = LulCTLRegValue; Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSSCTL = LulSSCTLRegValue; Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulIREN = LulIRENRegValue; #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_ON) Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulCDIV = LulCDIVRegValue; Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSCKDLY = LulSCKDLYRegValue; Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSSNDLY = LulSSNDLYRegValue; Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulNFMDLY = LulNFMDLYRegValue; Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulSPLDLY = LulSPLDLYRegValue; #endif /* To ensure SPI unit was stopped, do dummy read & SYNCP */ Spi_GaaHSPIRegs[LulHWPhyIndex].pRegs->ulEN; EXECUTE_SYNCP(); /* Clear pending interrupt flags */ RH850_SV_MODE_ICR_AND(16, (Spi_GaaHSPIRegs[LulHWPhyIndex].pICCEND), (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_AND(16, (Spi_GaaHSPIRegs[LulHWPhyIndex].pICERR), (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_AND(16, (Spi_GaaHSPIRegs[LulHWPhyIndex].pICBERR), (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_OR(8, Spi_GaaHSPIRegs[LpHWInfo->ucPhyUnitIndex].pICCEND, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ RH850_SV_MODE_ICR_OR(8, Spi_GaaHSPIRegs[LpHWInfo->ucPhyUnitIndex].pICERR, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ RH850_SV_MODE_ICR_OR(8, Spi_GaaHSPIRegs[LpHWInfo->ucPhyUnitIndex].pICBERR, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ /* To ensure interrupt requests were cleared, do dummy read & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaHSPIRegs[LulHWPhyIndex].pICCEND); EXECUTE_SYNCP(); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_001': ['Type': 'Macro', 'Range': '0..(total count of SPI units configured \u2013 1 = 0)', 'Name': 'SPI_PERSISTENT_HW_CONFIGURATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '0'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '1..4294967295', 'Name': 'ulTimeoutCount', 'Value': '4294967294'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ulEN', 'Value': '0x000001'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ulACTST', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulSRST', 'Value': '0xFFFFFFFF'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulMD', 'Value': '0x008001'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulCTL', 'Value': '0x0010002'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulSSCTL', 'Value': '0x000004'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulIREN', 'Value': '0x00002D'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulCDIV', 'Value': '0x000003'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulSCKDLY', 'Value': '0x000005'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ulSSNDLY', 'Value': '0x000006'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulNFMDLY', 'Value': '0x000007'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ulSPLDLY', 'Value': '0x000008'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_HSPIpICCEND[0]', 'Value': '0xFFFF'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'map_HSPIpICERR[0]', 'Value': '0xFFFF'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_HSPIpICBERR[0]', 'Value': '0xFFFF']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ulEN', 'Value': '0x000000'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ulSRST', 'Value': '0x000001'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ulMD', 'Value': '0x008001'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ulCTL', 'Value': '0x0010002'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'ulSSCTL', 'Value': '0x000004'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ulIREN', 'Value': '0x00002D'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ulCDIV', 'Value': '0x000003'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'ulSCKDLY', 'Value': '0x000005'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'ulSSNDLY', 'Value': '0x000006'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'ulNFMDLY', 'Value': '0x000007'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ulSPLDLY', 'Value': '0x000008'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'map_HSPIpICCEND[0]', 'Value': '0xEFFF'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'map_HSPIpICERR[0]', 'Value': '0xEFFF'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'map_HSPIpICBERR[0]', 'Value': '0xEFFF'], 'Output_Param_014': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PUBLIC_CODE) Spi_Init(P2CONST(Spi_ConfigType, AUTOMATIC, SPI_APPL_CONST) ConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ uint32 LulNumJobs; uint32 LulNumSeq; uint32 LulNumChannel; uint32 LulIndex; #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) uint32 LulSubIndex; uint32 LulPriorityIndex; #endif #if (SPI_DEV_ERROR_DETECT == STD_ON) #if (SPI_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if SPI Driver already initialized */ if (SPI_FALSE != Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_INIT_SID, SPI_E_ALREADY_INITIALIZED); } else #endif /* (SPI_ALREADY_INIT_DET_CHECK == STD_ON) */ /* Check if SPI configuration pointer is a NULL Pointer */ if (NULL_PTR == ConfigPtr) { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_INIT_SID, SPI_E_PARAM_POINTER); } /* Initialize the module only if Database is present */ else if (SPI_DBTOC_VALUE != ConfigPtr->ulStartOfDbToc) { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_INIT_SID, SPI_E_INVALID_DATABASE); } else #endif /* (SPI_DEV_ERROR_DETECT == STD_ON) */ { /* Load ConfigPtr to Global pointer variable */ Spi_GpConfigPtr = ConfigPtr; /* Get the pointer to Channel configuration table */ Spi_GpFirstChannel = (P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pChannelConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Get the pointer to Job configuration table */ Spi_GpFirstJob = (P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pJobConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Get the pointer to Sequence configuration table */ Spi_GpFirstSeq = (P2CONST(Spi_SeqConfigType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pSequenceConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Get the pointer to SPI HWUnit configuration table */ Spi_GpFirstHWUnit = (P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #if (SPI_DMA_CONFIGURED == STD_ON) /* Get the pointer to DMA HWUnit configuration table */ Spi_GpFirstDMAUnit = (P2CONST(Spi_DmaConfigType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pDMAUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ Spi_GpHwConfig = (P2CONST(Spi_HwConfigType, AUTOMATIC, SPI_CONST))Spi_GpConfigPtr->pHwConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_2) || ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) && \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION))) /* Global variable for asynchronous mode is polling mode */ Spi_GenAsyncMode = SPI_POLLING_MODE; #endif /* Global variable for active HW unit indexes used by a request transmission */ Spi_GulActiveHWUnits = 0U; #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) /* Initialize Queues */ Spi_GulAllQueueSts = 0U; for (LulIndex = 0U; (uint32)SPI_MAX_QUEUE > LulIndex; LulIndex++) /* PRQA S 2877 # JV-01 */ { Spi_GaaQueue[LulIndex].ucExists = 0U; Spi_GaaQueue[LulIndex].usOngoingSeqIndex = SPI_INVALID_SEQUENCE; /* The following variable must be written before the first reading, but initialize with zero just in case */ for (LulPriorityIndex = 0U; LulPriorityIndex < ((uint32)SPI_MAX_PRIORITY + 1UL); LulPriorityIndex++) { Spi_GaaQueue[LulIndex].aaTop[LulPriorityIndex] = 0U; Spi_GaaQueue[LulIndex].aaTail[LulPriorityIndex] = 0U; } } for (LulIndex = 0U; SPI_BITS_TO_WORDS(SPI_MAX_SEQUENCE) > LulIndex; LulIndex++) /* PRQA S 3469, 2877 # JV-01, JV-01 */ { Spi_GaaActiveSequence[LulIndex] = 0U; } #endif /* ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) */ /* Initialize HW status */ for (LulIndex = 0U; LulIndex < Spi_GpConfigPtr->ucNoOfHWUnits; LulIndex++) { #if (SPI_HW_STATUS_API == STD_ON) Spi_GaaHWStatus[LulIndex].blActive = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif /* The following variable must be written before the first reading, but initialize with zero just in case */ Spi_GaaHWStatus[LulIndex].usOngoingSeqIndex = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].usOngoingJobIndex = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].usTxChannelCount = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].usRxChannelCount = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].ulRemainedTxCount = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].ulRemainedRxCount = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].pTxPtr = NULL_PTR; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].pRxPtr = NULL_PTR; /* PRQA S 2844 # JV-01 */ } /* Initialize Job results */ for (LulNumJobs = 0U; Spi_GpConfigPtr->usNoOfJobs > LulNumJobs; LulNumJobs++) { Spi_GaaJobStatus[LulNumJobs].enResult = SPI_JOB_OK; /* PRQA S 2844 # JV-01 */ } /* Initialize Sequence results */ for (LulNumSeq = 0U; Spi_GpConfigPtr->ucNoOfSequences > LulNumSeq; LulNumSeq++) { Spi_GaaSeqStatus[LulNumSeq].enResult = SPI_SEQ_OK; /* PRQA S 2844 # JV-01 */ /* The following variable must be written before the first reading, but initialize with zero just in case */ #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_ON) Spi_GaaSeqStatus[LulNumSeq].ulActiveSubSequences = 0UL; /* PRQA S 2844 # JV-01 */ #endif for (LulSubIndex = 0U; LulSubIndex < (uint32)SPI_MAX_QUEUE; LulSubIndex++) /* PRQA S 2877 # JV-01 */ { Spi_GaaSeqStatus[LulNumSeq].aaSubSeqs[LulSubIndex].usRemainJobCount = 0U; /* PRQA S 2844 # JV-01 */ for (LulPriorityIndex = 0U; LulPriorityIndex < ((uint32)SPI_MAX_PRIORITY + 1UL); LulPriorityIndex++) { Spi_GaaSeqStatus[LulNumSeq].aaSubSeqs[LulSubIndex].aaPrev[LulPriorityIndex] = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaSeqStatus[LulNumSeq].aaSubSeqs[LulSubIndex].aaNext[LulPriorityIndex] = 0U; /* PRQA S 2844 # JV-01 */ } } #endif /* (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) */ } /* Initialize entire internal buffer */ #if (SPI_MAX_CHANNEL_BUFFER_SIZE > 0U) for (LulIndex = 0U; LulIndex < ((uint32)SPI_MAX_CHANNEL_BUFFER_SIZE / (uint32)sizeof(uint32)); LulIndex++) { Spi_GaaChannelBuffer[LulIndex] = 0UL; } #endif /* Initialize SPI HW, specific global variables used for each HW IP */ for (LulIndex = 0UL; LulIndex < SPI_MAX_MACRO; LulIndex++) /* PRQA S 2877 # JV-01 */ { Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwInit(); /* PRQA S 2814 # JV-01 */ } /* Initialize DMA if it is configured */ #if (SPI_DMA_CONFIGURED == STD_ON) Spi_DMAInit(); #endif /* Initialize each Channel buffers */ for (LulNumChannel = 0U; Spi_GpConfigPtr->usNoOfChannels > LulNumChannel; LulNumChannel++) { LpChConfig = &Spi_GpFirstChannel[LulNumChannel]; if (SPI_BUFFER_TYPE_EB == LpChConfig->enChannelBufferType) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) /* When EB, initialize user pointers as NULL */ LpChConfig->pEBData->ulEBLength = (LpChConfig->ulNoOfBuffers); /* PRQA S 2814 # JV-01 */ LpChConfig->pEBData->pSrcPtr = NULL_PTR; LpChConfig->pEBData->pDestPtr = NULL_PTR; #endif } else { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) /* When IB, initialize buffer with default data */ Spi_MemCopy(LpChConfig, LpChConfig->pTxBuffer, NULL_PTR); #endif } } #if (((SPI_LEVEL_DELIVERED == SPI_LEVEL_2) || ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) && \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION))) && (SPI_FORCE_CANCEL_API == STD_ON)) /* HWUnits under processing by Spi_ForceCancel */ Spi_GulCancelingHWUnits = 0UL; #endif /* Set Initialized flag */ Spi_SetStatus(SPI_TRUE); } /* Else of ConfigPtr->ulStartOfDbToc != SPI_DBTOC_VALUE */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'SPI_LEVEL_0, SPI_LEVEL_1, SPI_LEVEL_2', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_1'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_ALREADY_INIT_DET_CHECK', 'Value': 'STD_OFF'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_HW_STATUS_API', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_FORCE_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Macro', 'Range': '1..2', 'Name': 'SPI_MAX_MACRO', 'Value': '1'], 'Input_Param_008': ['Type': 'Macro', 'Range': '0\u20262', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': '2'], 'Input_Param_009': ['Type': 'Macro', 'Range': '0\u2026*', 'Name': 'SPI_MAX_CHANNEL_BUFFER_SIZE', 'Value': '8U'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'SPI_TRUE, SPI_FALSE', 'Name': 'Spi_GblInitialized', 'Value': '0'], 'Input_Param_011': ['Type': 'Argument', 'Range': 'NULL_PTR, !NULL_PTR', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '1..(total count of all SPI units)', 'Name': 'ucNoOfHWUnits', 'Value': '2'], 'Input_Param_013': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfChannels', 'Value': '2'], 'Input_Param_014': ['Type': 'Variable', 'Range': '1..SPI_MAX_JOB-1', 'Name': 'usNoOfJobs', 'Value': '2'], 'Input_Param_015': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfSequences', 'Value': '2'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulStartOfDbToc', 'Value': 'SPI_DBTOC_VALUE'], 'Input_Param_017': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pChannelConfig', 'Value': '&map_pChannelConfig[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pJobConfig', 'Value': '&map_pJobConfig[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pJobConfig[0]', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pSequenceConfig', 'Value': '&map_pSequenceConfig[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSequenceConfig[0]', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHWUnitInfo', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_pHWUnitInfo[0]', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pDMAUnitInfo', 'Value': '&map_pDMAUnitInfo[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDMAUnitInfo[0]', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwConfig', 'Value': '&map_pHwConfig[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_pHwConfig[0]', 'Value': '-'], 'Input_Param_028': ['Type': 'Array', 'Range': 'SPI_BUFFER_TYPE_IB\\nSPI_BUFFER_TYPE_EB', 'Name': 'enChannelBufferType', 'Value': '[0] = SPI_BUFFER_TYPE_IB\\n[1] = SPI_BUFFER_TYPE_EB'], 'Input_Param_029': ['Type': 'Array', 'Range': '-', 'Name': 'usNoOfBuffers', 'Value': '[0] = NULL\\n[1] = NULL'], 'Input_Param_030': ['Type': 'Array', 'Range': '-', 'Name': 'pEBData', 'Value': '[0] = &map_pEBData[0]\\n[1] = &map_pEBData[1]'], 'Input_Param_031': ['Type': 'Variable', 'Range': '-', 'Name': 'pHwInit', 'Value': '&ISOLATE_void_func_ptr'], 'Input_Param_032': ['Type': 'Variable', 'Range': '-', 'Name': 'pHwInit', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorID', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': '&map_pChannelConfig[0]'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': '&map_pJobConfig[0]'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_pSequenceConfig[0]'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_pHWUnitInfo[0]'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstDMAUnit', 'Value': '&map_pDMAUnitInfo[0]'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpHwConfig', 'Value': '&map_pHwConfig[0]'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GenAsyncMode', 'Value': '-'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0U'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulAllQueueSts', 'Value': '0U'], 'Output_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ucExists', 'Value': '[0 to 10] = 0'], 'Output_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '[0 to 10] = SPI_INVALID_SEQUENCE'], 'Output_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'aaTop[0 to 3]', 'Value': '[0 to 10][0 to 3] = 0'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'aaTail[0 to 3]', 'Value': '[0 to 10][0 to 3] = 0'], 'Output_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0 to SPI_BITS_TO_WORDS(SPI_MAX_SEQUENCE)]', 'Value': '[0] = 0'], 'Output_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'blActive', 'Value': '[0 to 1] = SPI_FALSE'], 'Output_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '[0 to 1] = 0'], 'Output_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '[0 to 1] = 0'], 'Output_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '[0 to 1] = 0'], 'Output_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '[0 to 1] = 0'], 'Output_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'usRemainedTxCount', 'Value': '[0 to 1] = 0'], 'Output_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '[0 to 1] = 0'], 'Output_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'pTxPtr', 'Value': '[0 to 1] = NULL_PTR'], 'Output_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'pRxPtr', 'Value': '[0 to 1] = NULL_PTR'], 'Output_Param_028': ['Type': 'Array', 'Range': '', 'Name': '.enResult', 'Value': '[0 to 1] = SPI_JOB_OK'], 'Output_Param_029': ['Type': 'Array', 'Range': '', 'Name': 'enResult', 'Value': '[0 to 1] = SPI_SEQ_OK'], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'ulActiveSubSequences', 'Value': '[0 to 1] = 0'], 'Output_Param_031': ['Type': 'Array', 'Range': '', 'Name': 'usRemainJobCount', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_032': ['Type': 'Array', 'Range': '', 'Name': 'aaPrev[0]', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_033': ['Type': 'Array', 'Range': '', 'Name': 'aaPrev[1]', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_034': ['Type': 'Array', 'Range': '', 'Name': 'aaPrev[2]', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_035': ['Type': 'Array', 'Range': '', 'Name': 'aaPrev[3]', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_036': ['Type': 'Array', 'Range': '', 'Name': 'aaNext[0]', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_037': ['Type': 'Array', 'Range': '', 'Name': 'aaNext[1]', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_038': ['Type': 'Array', 'Range': '', 'Name': 'aaNext[2]', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_039': ['Type': 'Array', 'Range': '', 'Name': 'aaNext[3]', 'Value': '[0 to 1][0 to 10] = 0'], 'Output_Param_040': ['Type': 'Array', 'Range': '', 'Name': 'Spi_GaaChannelBuffer[0 to SPI_MAX_CHANNEL_BUFFER_SIZE]', 'Value': '[0 to 17] = 0'], 'Output_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': ''], 'Output_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'pSrcPtr', 'Value': 'NULL_PTR'], 'Output_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': 'NULL_PTR'], 'Output_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulCancelingHWUnits', 'Value': '-'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_046': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '<called>'], 'Output_Param_048': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '&map_pChannelConfig[0]'], 'Output_Param_049': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpDesPtr', 'Value': 'LpDesPtr'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSrcPtr', 'Value': 'NULL_PTR'], 'Output_Param_051': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatus', 'Value': 'SPI_TRUE'], 'Output_Param_052': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PUBLIC_CODE) Spi_Init(P2CONST(Spi_ConfigType, AUTOMATIC, SPI_APPL_CONST) ConfigPtr) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ uint32 LulNumJobs; uint32 LulNumSeq; uint32 LulNumChannel; uint32 LulIndex; #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) uint32 LulSubIndex; uint32 LulPriorityIndex; #endif #if (SPI_DEV_ERROR_DETECT == STD_ON) #if (SPI_ALREADY_INIT_DET_CHECK == STD_ON) /* Check if SPI Driver already initialized */ if (SPI_FALSE != Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_INIT_SID, SPI_E_ALREADY_INITIALIZED); } else #endif /* (SPI_ALREADY_INIT_DET_CHECK == STD_ON) */ /* Check if SPI configuration pointer is a NULL Pointer */ if (NULL_PTR == ConfigPtr) { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_INIT_SID, SPI_E_PARAM_POINTER); } /* Initialize the module only if Database is present */ else if (SPI_DBTOC_VALUE != ConfigPtr->ulStartOfDbToc) { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_INIT_SID, SPI_E_INVALID_DATABASE); } else #endif /* (SPI_DEV_ERROR_DETECT == STD_ON) */ { /* Load ConfigPtr to Global pointer variable */ Spi_GpConfigPtr = ConfigPtr; /* Get the pointer to Channel configuration table */ Spi_GpFirstChannel = (P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pChannelConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Get the pointer to Job configuration table */ Spi_GpFirstJob = (P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pJobConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Get the pointer to Sequence configuration table */ Spi_GpFirstSeq = (P2CONST(Spi_SeqConfigType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pSequenceConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* Get the pointer to SPI HWUnit configuration table */ Spi_GpFirstHWUnit = (P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pHWUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #if (SPI_DMA_CONFIGURED == STD_ON) /* Get the pointer to DMA HWUnit configuration table */ Spi_GpFirstDMAUnit = (P2CONST(Spi_DmaConfigType, AUTOMATIC, SPI_CONFIG_DATA))Spi_GpConfigPtr->pDMAUnitInfo; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ Spi_GpHwConfig = (P2CONST(Spi_HwConfigType, AUTOMATIC, SPI_CONST))Spi_GpConfigPtr->pHwConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_2) || ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) && \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION))) /* Global variable for asynchronous mode is polling mode */ Spi_GenAsyncMode = SPI_POLLING_MODE; #endif /* Global variable for active HW unit indexes used by a request transmission */ Spi_GulActiveHWUnits = 0U; #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) /* Initialize Queues */ Spi_GulAllQueueSts = 0U; for (LulIndex = 0U; (uint32)SPI_MAX_QUEUE > LulIndex; LulIndex++) /* PRQA S 2877 # JV-01 */ { Spi_GaaQueue[LulIndex].ucExists = 0U; Spi_GaaQueue[LulIndex].usOngoingSeqIndex = SPI_INVALID_SEQUENCE; /* The following variable must be written before the first reading, but initialize with zero just in case */ for (LulPriorityIndex = 0U; LulPriorityIndex < ((uint32)SPI_MAX_PRIORITY + 1UL); LulPriorityIndex++) { Spi_GaaQueue[LulIndex].aaTop[LulPriorityIndex] = 0U; Spi_GaaQueue[LulIndex].aaTail[LulPriorityIndex] = 0U; } } for (LulIndex = 0U; SPI_BITS_TO_WORDS(SPI_MAX_SEQUENCE) > LulIndex; LulIndex++) /* PRQA S 3469, 2877 # JV-01, JV-01 */ { Spi_GaaActiveSequence[LulIndex] = 0U; } #endif /* ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) */ /* Initialize HW status */ for (LulIndex = 0U; LulIndex < Spi_GpConfigPtr->ucNoOfHWUnits; LulIndex++) { #if (SPI_HW_STATUS_API == STD_ON) Spi_GaaHWStatus[LulIndex].blActive = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif /* The following variable must be written before the first reading, but initialize with zero just in case */ Spi_GaaHWStatus[LulIndex].usOngoingSeqIndex = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].usOngoingJobIndex = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].usTxChannelCount = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].usRxChannelCount = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].ulRemainedTxCount = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].ulRemainedRxCount = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].pTxPtr = NULL_PTR; /* PRQA S 2844 # JV-01 */ Spi_GaaHWStatus[LulIndex].pRxPtr = NULL_PTR; /* PRQA S 2844 # JV-01 */ } /* Initialize Job results */ for (LulNumJobs = 0U; Spi_GpConfigPtr->usNoOfJobs > LulNumJobs; LulNumJobs++) { Spi_GaaJobStatus[LulNumJobs].enResult = SPI_JOB_OK; /* PRQA S 2844 # JV-01 */ } /* Initialize Sequence results */ for (LulNumSeq = 0U; Spi_GpConfigPtr->ucNoOfSequences > LulNumSeq; LulNumSeq++) { Spi_GaaSeqStatus[LulNumSeq].enResult = SPI_SEQ_OK; /* PRQA S 2844 # JV-01 */ /* The following variable must be written before the first reading, but initialize with zero just in case */ #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_ON) Spi_GaaSeqStatus[LulNumSeq].ulActiveSubSequences = 0UL; /* PRQA S 2844 # JV-01 */ #endif for (LulSubIndex = 0U; LulSubIndex < (uint32)SPI_MAX_QUEUE; LulSubIndex++) /* PRQA S 2877 # JV-01 */ { Spi_GaaSeqStatus[LulNumSeq].aaSubSeqs[LulSubIndex].usRemainJobCount = 0U; /* PRQA S 2844 # JV-01 */ for (LulPriorityIndex = 0U; LulPriorityIndex < ((uint32)SPI_MAX_PRIORITY + 1UL); LulPriorityIndex++) { Spi_GaaSeqStatus[LulNumSeq].aaSubSeqs[LulSubIndex].aaPrev[LulPriorityIndex] = 0U; /* PRQA S 2844 # JV-01 */ Spi_GaaSeqStatus[LulNumSeq].aaSubSeqs[LulSubIndex].aaNext[LulPriorityIndex] = 0U; /* PRQA S 2844 # JV-01 */ } } #endif /* (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) */ } /* Initialize entire internal buffer */ #if (SPI_MAX_CHANNEL_BUFFER_SIZE > 0U) for (LulIndex = 0U; LulIndex < ((uint32)SPI_MAX_CHANNEL_BUFFER_SIZE / (uint32)sizeof(uint32)); LulIndex++) { Spi_GaaChannelBuffer[LulIndex] = 0UL; } #endif /* Initialize SPI HW, specific global variables used for each HW IP */ for (LulIndex = 0UL; LulIndex < SPI_MAX_MACRO; LulIndex++) /* PRQA S 2877 # JV-01 */ { Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwInit(); /* PRQA S 2814 # JV-01 */ } /* Initialize DMA if it is configured */ #if (SPI_DMA_CONFIGURED == STD_ON) Spi_DMAInit(); #endif /* Initialize each Channel buffers */ for (LulNumChannel = 0U; Spi_GpConfigPtr->usNoOfChannels > LulNumChannel; LulNumChannel++) { LpChConfig = &Spi_GpFirstChannel[LulNumChannel]; if (SPI_BUFFER_TYPE_EB == LpChConfig->enChannelBufferType) /* PRQA S 2814, 2844 # JV-01, JV-01 */ { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) /* When EB, initialize user pointers as NULL */ LpChConfig->pEBData->ulEBLength = (LpChConfig->ulNoOfBuffers); /* PRQA S 2814 # JV-01 */ LpChConfig->pEBData->pSrcPtr = NULL_PTR; LpChConfig->pEBData->pDestPtr = NULL_PTR; #endif } else { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) /* When IB, initialize buffer with default data */ Spi_MemCopy(LpChConfig, LpChConfig->pTxBuffer, NULL_PTR); #endif } } #if (((SPI_LEVEL_DELIVERED == SPI_LEVEL_2) || ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) && \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION))) && (SPI_FORCE_CANCEL_API == STD_ON)) /* HWUnits under processing by Spi_ForceCancel */ Spi_GulCancelingHWUnits = 0UL; #endif /* Set Initialized flag */ Spi_SetStatus(SPI_TRUE); } /* Else of ConfigPtr->ulStartOfDbToc != SPI_DBTOC_VALUE */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': 'SPI_LEVEL_0, SPI_LEVEL_1, SPI_LEVEL_2', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_001': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_ALREADY_INIT_DET_CHECK', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_HW_STATUS_API', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': 'STD_ON, STD_OFF', 'Name': 'SPI_FORCE_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_007': ['Type': 'Macro', 'Range': '1..2', 'Name': 'SPI_MAX_MACRO', 'Value': '1'], 'Input_Param_008': ['Type': 'Macro', 'Range': '0\u20262', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': '2'], 'Input_Param_009': ['Type': 'Macro', 'Range': '0\u2026*', 'Name': 'SPI_MAX_CHANNEL_BUFFER_SIZE', 'Value': '8U'], 'Input_Param_010': ['Type': 'Variable', 'Range': 'SPI_TRUE, SPI_FALSE', 'Name': 'Spi_GblInitialized', 'Value': '0'], 'Input_Param_011': ['Type': 'Argument', 'Range': 'NULL_PTR, !NULL_PTR', 'Name': 'ConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '1..(total count of all SPI units)', 'Name': 'ucNoOfHWUnits', 'Value': '2'], 'Input_Param_013': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfChannels', 'Value': '2'], 'Input_Param_014': ['Type': 'Variable', 'Range': '1..SPI_MAX_JOB-1', 'Name': 'usNoOfJobs', 'Value': '2'], 'Input_Param_015': ['Type': 'Variable', 'Range': '1..255', 'Name': 'ucNoOfSequences', 'Value': 'SPI_MAX_SEQUENCE'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'ulStartOfDbToc', 'Value': 'SPI_DBTOC_VALUE'], 'Input_Param_017': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pChannelConfig', 'Value': '&map_pChannelConfig[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pJobConfig', 'Value': '&map_pJobConfig[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pJobConfig[0]', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pSequenceConfig', 'Value': '&map_pSequenceConfig[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSequenceConfig[0]', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHWUnitInfo', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_pHWUnitInfo[0]', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pDMAUnitInfo', 'Value': '&map_pDMAUnitInfo[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDMAUnitInfo[0]', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwConfig', 'Value': '&map_pHwConfig[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'map_pHwConfig[0]', 'Value': '-'], 'Input_Param_028': ['Type': 'Array', 'Range': 'SPI_BUFFER_TYPE_IB\\nSPI_BUFFER_TYPE_EB', 'Name': 'enChannelBufferType', 'Value': '[0] = SPI_BUFFER_TYPE_IB\\n[1] = SPI_BUFFER_TYPE_EB'], 'Input_Param_029': ['Type': 'Array', 'Range': '-', 'Name': 'usNoOfBuffers', 'Value': '[0] = NULL\\n[1] = NULL'], 'Input_Param_030': ['Type': 'Array', 'Range': '-', 'Name': 'pEBData', 'Value': '[0] = &map_pEBData[0]\\n[1] = &map_pEBData[1]'], 'Input_Param_031': ['Type': 'Variable', 'Range': '-', 'Name': 'pHwInit', 'Value': '&ISOLATE_void_func_ptr'], 'Input_Param_032': ['Type': 'Variable', 'Range': '-', 'Name': 'pHwInit', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorID', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_ConfigPtr[0]'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': '&map_pChannelConfig[0]'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': '&map_pJobConfig[0]'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_pSequenceConfig[0]'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_pHWUnitInfo[0]'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstDMAUnit', 'Value': '&map_pDMAUnitInfo[0]'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpHwConfig', 'Value': '&map_pHwConfig[0]'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GenAsyncMode', 'Value': '0'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0'], 'Output_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulAllQueueSts', 'Value': '0U'], 'Output_Param_014': ['Type': 'Array', 'Range': '', 'Name': 'ucExists', 'Value': '[0 to 10] = 0'], 'Output_Param_015': ['Type': 'Array', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '[0 to 10] = SPI_INVALID_SEQUENCE'], 'Output_Param_016': ['Type': 'Array', 'Range': '', 'Name': 'aaTop[0 to 3]', 'Value': '[0 to 10][0 to 3] = 0'], 'Output_Param_017': ['Type': 'Array', 'Range': '', 'Name': 'aaTail[0 to 3]', 'Value': '[0 to 10][0 to 3] = 0'], 'Output_Param_018': ['Type': 'Array', 'Range': '', 'Name': 'Spi_GaaActiveSequence[0 to SPI_BITS_TO_WORDS(SPI_MAX_SEQUENCE)]', 'Value': '[0] = 0'], 'Output_Param_019': ['Type': 'Array', 'Range': '', 'Name': 'blActive', 'Value': '[0 to 1] = SPI_FALSE'], 'Output_Param_020': ['Type': 'Array', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '[0 to 1] = 0'], 'Output_Param_021': ['Type': 'Array', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '[0 to 1] = 0'], 'Output_Param_022': ['Type': 'Array', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '[0 to 1] = 0'], 'Output_Param_023': ['Type': 'Array', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '[0 to 1] = 0'], 'Output_Param_024': ['Type': 'Array', 'Range': '', 'Name': 'usRemainedTxCount', 'Value': '[0 to 1] = 0'], 'Output_Param_025': ['Type': 'Array', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '[0 to 1] = 0'], 'Output_Param_026': ['Type': 'Array', 'Range': '', 'Name': 'pTxPtr', 'Value': '[0 to 1] = NULL_PTR'], 'Output_Param_027': ['Type': 'Array', 'Range': '', 'Name': 'pRxPtr', 'Value': '[0 to 1] = NULL_PTR'], 'Output_Param_028': ['Type': 'Array', 'Range': '', 'Name': '.enResult', 'Value': '[0 to 1] = SPI_JOB_OK'], 'Output_Param_029': ['Type': 'Array', 'Range': '', 'Name': 'enResult', 'Value': '[0 to 2] = SPI_SEQ_OK'], 'Output_Param_030': ['Type': 'Array', 'Range': '', 'Name': 'ulActiveSubSequences', 'Value': '[0 to 2] = 0'], 'Output_Param_031': ['Type': 'Array', 'Range': '', 'Name': 'usRemainJobCount', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_032': ['Type': 'Array', 'Range': '', 'Name': 'aaPrev[0]', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_033': ['Type': 'Array', 'Range': '', 'Name': 'aaPrev[1]', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_034': ['Type': 'Array', 'Range': '', 'Name': 'aaPrev[2]', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_035': ['Type': 'Array', 'Range': '', 'Name': 'aaPrev[3]', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_036': ['Type': 'Array', 'Range': '', 'Name': 'aaNext[0]', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_037': ['Type': 'Array', 'Range': '', 'Name': 'aaNext[1]', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_038': ['Type': 'Array', 'Range': '', 'Name': 'aaNext[2]', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_039': ['Type': 'Array', 'Range': '', 'Name': 'aaNext[3]', 'Value': '[0 to 2][0 to 10] = 0'], 'Output_Param_040': ['Type': 'Array', 'Range': '', 'Name': 'Spi_GaaChannelBuffer[0 to SPI_MAX_CHANNEL_BUFFER_SIZE]', 'Value': '[0 to 26] = 0'], 'Output_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': ''], 'Output_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'pSrcPtr', 'Value': 'NULL_PTR'], 'Output_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': 'NULL_PTR'], 'Output_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulCancelingHWUnits', 'Value': '0'], 'Output_Param_045': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_046': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_048': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '&map_pChannelConfig[0]'], 'Output_Param_049': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpDesPtr', 'Value': 'LpDesPtr'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSrcPtr', 'Value': 'NULL_PTR'], 'Output_Param_051': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblStatus', 'Value': 'SPI_TRUE'], 'Output_Param_052': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSIOFDisableFrameSYNC(const uint32 LulHWPhyIndex) { /* Disable transmission and reception by clearing TXE, RXE bit */ SPI_REG_AND(32, &Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TFSE); /* PRQA S 2814, 2844, 3432, 3464 # JV-01, JV-01, JV-01, JV-01 */ /* Waiting for TXE, RXE bit cleared */ Spi_MSIOFWaitForRegSet(&Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TFSE, 0UL); /* PRQA S 3200 # JV-01 */ SPI_REG_VERIFY(32, &Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TFSE, 0UL) }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '3'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'ulCTR', 'Value': '[3] = 0x7FFFFFFFU']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'ulCTR', 'Value': '[3]=0x7FFFBFFFU'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAddr', 'Value': '&map_MSIOFpRegs[3].ulCTR'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '0x00004000U'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulExpectedValue', 'Value': '0UL'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSIOFDisableTxRx(const uint32 LulHWPhyIndex) { /* Disable transmission and reception by clearing TXE, RXE bit */ SPI_REG_AND(32, &Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TXE_RXE); /* PRQA S 2814, 2844, 3432, 3464 # JV-01, JV-01, JV-01, JV-01 */ /* Waiting for TXE, RXE bit cleared */ Spi_MSIOFWaitForRegSet(&Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TXE_RXE, 0UL); /* PRQA S 3200 # JV-01 */ SPI_REG_VERIFY(32, &Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TXE_RXE, 0UL) }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '5'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'ulCTR', 'Value': '[5] = 0xFFFFFFFF']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'ulCTR', 'Value': '[5]=0xFFFFFCFFU'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAddr', 'Value': '&map_MSIOFpRegs[5].ulCTR'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '0x00000300U'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulExpectedValue', 'Value': '0UL'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSIOFEnableFrameSYNC(const uint32 LulHWPhyIndex) { /* Critical Section Protection to avoid TFSE bit is raised unexpectedly */ SPI_ENTER_CRITICAL_SECTION(SPI_INTERRUPT_CONTROL_PROTECTION); /* Enable transmission and reception by setting TXE, RXE bit */ SPI_REG_OR(32, &Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TFSE); /* PRQA S 2814, 2844, 3464 # JV-01, JV-01, JV-01 */ /* Waiting for TXE, RXE bit cleared */ Spi_MSIOFWaitForRegSet(&Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TFSE, SPI_MSIOF_CTR_TFSE); /* PRQA S 3200 # JV-01 */ SPI_REG_VERIFY(32, &Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulCTR, SPI_MSIOF_CTR_TFSE, SPI_MSIOF_CTR_TFSE) /* Critical Section Protection to avoid TFSE bit is raised unexpectedly */ SPI_EXIT_CRITICAL_SECTION(SPI_INTERRUPT_CONTROL_PROTECTION); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Argument', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '0'], 'Input_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'ulCTR', 'Value': '[0] = 0x00000000U']], 'Output': ['Output_Param_000': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'ulCTR', 'Value': '[0]=0x00004000U'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRegAddr', 'Value': '&map_MSIOFpRegs[0].ulCTR'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulMask', 'Value': '0x00004000U'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulExpectedValue', 'Value': '0x00004000U'], 'Output_Param_005': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSIOFMaskHWUnitInterrupts(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig, const boolean LblMask) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ uint32 LulHWUnitIndex; /* Get HW unit index */ LulHWUnitIndex = LpJobConfig->ucHWUnitIndex; /* PRQA S 2814 # JV-01 */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; /* Check if request to mask (disable) interrupts */ if (SPI_TRUE == LblMask) { #if (SPI_DMA_CONFIGURED == STD_ON) if (LpJobConfig->ucRxDmaIndex == SPI_INVALID_DMAUNIT) #endif { /* Disable all interrupts */ SPI_WRITE_VERIFY_REG(32, &Spi_GaaMSIOFRegs[LpHWInfo->ucPhyUnitIndex].pRegs->ulIER, SPI_REG32_MASK, /* PRQA S 2814, 2844 # JV-01, JV-01 */ SPI_MSIOF_IER_DEFAULT) } #if (SPI_DMA_CONFIGURED == STD_ON) else { /* Disable DMA interrupts */ Spi_DMAMaskHWUnitInterrupts((uint32)LpJobConfig->ucRxDmaIndex, SPI_TRUE); } #endif } else { #if (SPI_DMA_CONFIGURED == STD_ON) if (LpJobConfig->ucRxDmaIndex == SPI_INVALID_DMAUNIT) #endif { /* Enable Tx/Rx end and error interrupts */ SPI_WRITE_VERIFY_REG(32, &Spi_GaaMSIOFRegs[LpHWInfo->ucPhyUnitIndex].pRegs->ulIER, SPI_REG32_MASK, SPI_MSIOF_IER_CPU) } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LblMask', 'Value': 'SPI_FALSE'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxDmaIndex', 'Value': 'SPI_INVALID_DMAUNIT'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '4']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'ulIER', 'Value': '[4]= SPI_MSIOF_IER_CPU'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblMask', 'Value': '-'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSIOFMaskHWUnitInterrupts(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig, const boolean LblMask) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ uint32 LulHWUnitIndex; /* Get HW unit index */ LulHWUnitIndex = LpJobConfig->ucHWUnitIndex; /* PRQA S 2814 # JV-01 */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; /* Check if request to mask (disable) interrupts */ if (SPI_TRUE == LblMask) { #if (SPI_DMA_CONFIGURED == STD_ON) if (LpJobConfig->ucRxDmaIndex == SPI_INVALID_DMAUNIT) #endif { /* Disable all interrupts */ SPI_WRITE_VERIFY_REG(32, &Spi_GaaMSIOFRegs[LpHWInfo->ucPhyUnitIndex].pRegs->ulIER, SPI_REG32_MASK, /* PRQA S 2814, 2844 # JV-01, JV-01 */ SPI_MSIOF_IER_DEFAULT) } #if (SPI_DMA_CONFIGURED == STD_ON) else { /* Disable DMA interrupts */ Spi_DMAMaskHWUnitInterrupts((uint32)LpJobConfig->ucRxDmaIndex, SPI_TRUE); } #endif } else { #if (SPI_DMA_CONFIGURED == STD_ON) if (LpJobConfig->ucRxDmaIndex == SPI_INVALID_DMAUNIT) #endif { /* Enable Tx/Rx end and error interrupts */ SPI_WRITE_VERIFY_REG(32, &Spi_GaaMSIOFRegs[LpHWInfo->ucPhyUnitIndex].pRegs->ulIER, SPI_REG32_MASK, SPI_MSIOF_IER_CPU) } } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LblMask', 'Value': 'SPI_FALSE'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxDmaIndex', 'Value': '0x0BU'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Array', 'Range': '', 'Name': 'ulIER', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblMask', 'Value': '-'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ /* CH0 / #if (SPI_MSIOF0_ISR_API == STD_ON) /* Defines the CAT2interrupt mapping */ #if defined (Os_SPI_MSIOF0_CAT2_ISR) || (SPI_ISR_CATEGORY_2 == STD_ON) ISR(SPI_MSIOF0_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, SPI_CODE_FAST) SPI_MSIOF0_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { #if (SPI_UNINTENDED_INTERRUPT_CHECK == STD_ON) && defined(SPI_E_INTERRUPT_CONTROLLER_FAILURE) VAR(boolean, AUTOMATIC) LblUnintededIrq; #endif SPI_MSIOF_INT_ASSERTION(SPI_PHYIDX_MSIOF0) /* PRQA S 2814 # JV-01 */ { (void)Spi_MSIOFTrsRcvISR((uint32)Spi_GpHwConfig[SPI_MACRO_MSIOF].pPhyToHWUnit[SPI_PHYIDX_MSIOF0]); /* PRQA S 2824 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_MSIOF0_ISR_API', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'Os_SPI_MSIOF0_CAT2_ISR', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Count', 'Value': '3 = SPI_MSIOF3_ISR'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ulIER', 'Value': '-'], 'Input_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'ulSTR', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpHwConfig', 'Value': '&map_pHwConfig[0]'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'map_pPhyToHWUnit[0 to 5]', 'Value': '[0 to 5] = 0']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '0'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSIOFReceiveChData(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig, volatile CONSTP2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat, /* PRQA S 3432 # JV-01 */ const uint32 LulHWPhyIndex) { P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ VAR(Spi_NumberOfDataType, AUTOMATIC) LulNoOfChBuffers; volatile VAR(uint32, AUTOMATIC) LulRxDummyData; VAR(uint32, AUTOMATIC) LulChIndex; /* Get channel index according to on-going job and channel count */ LulChIndex = LpJobConfig->pChannelList[LpHWStat->usRxChannelCount]; /* PRQA S 2814 # JV-01 */ LpChConfig = &Spi_GpFirstChannel[LulChIndex]; /* Check whether FIFO is full or it is a channel in job */ if (0U == LpHWStat->ulRemainedRxCount) { /* Prepare channel buffers */ #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) if (SPI_BUFFER_TYPE_IB == LpChConfig->enChannelBufferType) /* PRQA S 2814, 2844 # JV-01, JV-01 */ #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) /* Initialize rx pointers to point to IB */ LpHWStat->pRxPtr = LpChConfig->pRxBuffer; LpHWStat->ulRemainedRxCount = LpChConfig->ulNoOfBuffers; #endif } #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) else #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) /* Initialize rx pointers to point to EB */ LpHWStat->pRxPtr = LpChConfig->pEBData->pDestPtr; /* PRQA S 2814 # JV-01 */ LpHWStat->ulRemainedRxCount = LpChConfig->pEBData->ulEBLength; #endif } } /* End of if (SPI_ZERO == LpHWStat->ulRemainedRxCount) */ /* The number of rx buffers or remaining buffers in a channel */ LulNoOfChBuffers = LpHWStat->ulRemainedRxCount; /* Check if the number of buffers to receive is less than FIFO size */ if (SPI_MSIOF_MAX_TX_FIFO_SIZE >= LulNoOfChBuffers) { /* Set remaining number of buffer to receive of this channel */ LpHWStat->ulRemainedRxCount = 0U; /* Increment the channel list to point to next channel */ LpHWStat->usRxChannelCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } else { /* Set remaining number of buffer to receive */ LpHWStat->ulRemainedRxCount = (uint32)(LulNoOfChBuffers - SPI_MSIOF_MAX_TX_FIFO_SIZE); /* PRQA S 3383 # JV-01 */ /* Set the number of buffers to be received as maximum buffer size */ LulNoOfChBuffers = SPI_MSIOF_MAX_TX_FIFO_SIZE; } /* Loop to store data from FIFO to the application buffer */ do { /* If Rx buffer is not NULL, store the application buffer */ if (NULL_PTR != LpHWStat->pRxPtr) { /* Store into the application buffer */ Spi_StoreRxData(LpHWStat->pRxPtr, LpChConfig, &Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulRFDR); /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Increment Rx pointer according to data width */ LpHWStat->pRxPtr = LpHWStat->pRxPtr + LpChConfig->ucByteSize; /* PRQA S 0488 # JV-01 */ } else { /* Read data to avoid overflow error */ LulRxDummyData = Spi_GaaMSIOFRegs[LulHWPhyIndex].pRegs->ulRFDR; } /* Decrement the counter for the number of buffers */ LulNoOfChBuffers--; /* PRQA S 3383 # JV-01 */ } while (0U < LulNoOfChBuffers); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': 'SPI_IBEB'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpHWStat', 'Value': '&Spi_GaaHWStatus[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '2'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '2'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'pRxPtr', 'Value': '&map_pRxBuffer[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelList', 'Value': '&map_MSIOFpChannelList[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSIOFpChannelList[0]', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': '&map_Spi_GpFirstChannel[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelBufferType', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pRxBuffer', 'Value': '-'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucByteSize', 'Value': '1'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfBuffers', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'pEBData', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '1'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '0'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'pRxPtr', 'Value': '&map_pRxBuffer[2]'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '[0] = &map_pRxBuffer[0]\\n[1] = &map_pRxBuffer[1]'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '[0] = &map_Spi_GpFirstChannel[0]\\n[1] = &map_Spi_GpFirstChannel[0]'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpRFDRReg', 'Value': '[0] = &map_MSIOFpRegs[2].ulRFDR\\n[1] = &map_MSIOFpRegs[2].ulRFDR'], 'Output_Param_006': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "** / #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_0) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) STATIC FUNC(Std_ReturnType, SPI_PRIVATE_CODE) Spi_MSIOFTransmitSyncJob(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig) { #if (SPI_DMA_CONFIGURED == STD_ON) P2CONST(Spi_DmaConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpDmaConfig; /* PRQA S 3432 # JV-01 */ uint32 LulDmaIntFlag; #endif volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432, 3678 # JV-01, JV-01 */ Std_ReturnType LucReturnValue; Std_ReturnType LucStatusValue; VAR(volatile uint32, AUTOMATIC) LulLoopCount; LucReturnValue = E_OK; LulLoopCount = 0; #if (SPI_DMA_CONFIGURED == STD_ON) LulDmaIntFlag = 0UL; #endif /* Get the status data structure of the HW Unit */ LpHWStat = &Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex]; /* PRQA S 2814, 2934 # JV-01, JV-01 */ #if (SPI_DMA_CONFIGURED == STD_ON) if (SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) { LpDmaConfig = &Spi_GpFirstDMAUnit[LpJobConfig->ucRxDmaIndex]; /* Clear transfer end flags */ SPI_DMA_CLEAR_TRANSFER_END_FLAG((uint32)LpJobConfig->ucRxDmaIndex); /* PRQA S 2814, 3469 # JV-01, JV-01 */ } #endif /* Setup HW for Job and send the first data */ Spi_MSIOFProcessJob(SPI_TRUE, LpJobConfig); /* Loop until Job end or any error occurs */ do { #if (SPI_DMA_CONFIGURED == STD_ON) if ((SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) && (SPI_TRUE == LpDmaConfig->blRxSide)) /* PRQA S 2814, 2844, 2962 # JV-01, JV-01, JV-01 */ { /* Invoke DMA ISR if transfer end flag is asserted */ LulDmaIntFlag = SPI_DMA_GET_TRANSFER_END_FLAG((uint32)LpJobConfig->ucRxDmaIndex); /* PRQA S 2814, 3469 # JV-01, JV-01 */ if (0UL != LulDmaIntFlag) { Spi_MSIOFDMACompleteISR((uint32)LpJobConfig->ucRxDmaIndex); /* Reset loop count */ LulLoopCount = 0; } else { /* Increment loop count */ LulLoopCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } } else #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ { LucStatusValue = Spi_MSIOFTrsRcvISR(LpJobConfig->ucHWUnitIndex); /* Check if any interrupt is received */ if (E_OK == LucStatusValue) { /* Reset loop count */ LulLoopCount = 0; } else { /* Increment loop count */ LulLoopCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ } } /* Check timeout */ if ((Spi_GpConfigPtr->ulTimeoutCount <= LulLoopCount) && /* PRQA S 3416 # JV-01 */ #if (SPI_DMA_CONFIGURED == STD_ON) (0UL == LulDmaIntFlag) #else (E_NOT_OK == LucStatusValue) #endif ) { #if defined(SPI_E_DATA_TX_TIMEOUT_FAILURE) SPI_DEM_REPORT_ERROR(SPI_E_DATA_TX_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* PRQA S 2844 # JV-01 */ /* At least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; /* Transmission is failed, return NOT_OK */ LucReturnValue = E_NOT_OK; } } while ((E_OK == LucReturnValue) && (LpHWStat->usRxChannelCount < LpJobConfig->usNoOfChannels)); /* If any HW error has been occurred, return E_NOT_OK */ if (SPI_TRUE == Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed) { LucReturnValue = E_NOT_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_DATA_TX_TIMEOUT_FAILURE', 'Value': 'is defined'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstDMAUnit', 'Value': '&map_Spi_GpFirstDMAUnit[0]'], 'Input_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'pDmaRegs', 'Value': '[0] = &map_pDmaRegs[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxDmaIndex', 'Value': 'SPI_INVALID_DMAUNIT'], 'Input_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'blRxSide', 'Value': '-'], 'Input_Param_007': ['Type': 'Array', 'Range': '', 'Name': 'ulCHCR', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfChannels', 'Value': '3'], 'Input_Param_013': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '[0] = E_NOT_OK'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulTimeoutCount', 'Value': '1'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Return_Value', 'Range': '', 'Name': 'LucReturnValue', 'Value': 'E_NOT_OK'], 'Output_Param_001': ['Type': 'Array', 'Range': '', 'Name': 'ulCHCR', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_JOB_FAILED'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': 'SPI_TRUE'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': 'SPI_TRUE'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDMAUnitIndex', 'Value': '-'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '0'], 'Output_Param_009': ['Type': 'Error', 'Range': '', 'Name': 'EventId', 'Value': 'SPI_E_DATA_TX_TIMEOUT_FAILURE'], 'Output_Param_010': ['Type': 'Error', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_011': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIForceStop(const uint32 LulHWUnitIndex) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; #if (SPI_DMA_CONFIGURED == STD_ON) P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ #endif /* Get pointers and index relevant to HW */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Stop SPI unit by CTL0.MSPInEN = 0 */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL0 = SPI_MSPI_TURNOFF; /* PRQA S 2814 # JV-01 */ /* To ensure SPI unit was stopped, do dummy read & SYNCP */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL0; EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #if (SPI_DMA_CONFIGURED == STD_ON) /* Stop DMA */ LpJobConfig = &Spi_GpFirstJob[Spi_GaaHWStatus[LulHWUnitIndex].usOngoingJobIndex]; /* PRQA S 2844 # JV-01 */ if (SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) /* PRQA S 2844, 2814 # JV-01, JV-01 */ { Spi_DMAStop((uint32)LpJobConfig->ucRxDmaIndex); } /* else No action required */ if (SPI_INVALID_DMAUNIT != LpJobConfig->ucTxDmaIndex) { Spi_DMAStop((uint32)LpJobConfig->ucTxDmaIndex); } /* else No action required */ #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ /* Clear interrupt factor Tx */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC0 = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF0; /* PRQA S 2844 # JV-01 */ /* Clear interrupt factor Rx */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC1 = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF1; /* Clear interrupt factor Error */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC2 = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF2; /* Clear interrupt factor End frame */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC3 = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF3; /* Clear pending interrupt flags */ RH850_SV_MODE_ICR_AND(16, (Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX), (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_AND(16, (Spi_GaaMSPIRegs[LulHWPhyIndex].pICRX), (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_AND(16, (Spi_GaaMSPIRegs[LulHWPhyIndex].pICFE), (uint16)(~SPI_EIC_EIRF_MASK)); /* Disable all interrupts unconditionally */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICRX, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICTX, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICFE, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ /* To ensure interrupt requests were cleared, do dummy read & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..(total count of SPI units configured \u2013 1)', 'Name': 'LulHWUnitIndex', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0..(total count of DMA channels)\\nSPI_INVALID_DMAUNIT', 'Name': 'ucRxDmaIndex', 'Value': '2'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0..(total count of DMA channels)\\nSPI_INVALID_DMAUNIT', 'Name': 'ucTxDmaIndex', 'Value': '2'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '0x100'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '0x100'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '0x100'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpRegs[0].ucCTL0', 'Value': 'SPI_MSPI_CTL0_DEFAULT'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF0', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF1', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF2', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF3', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '0x0180'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '0x0180'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '0x0180'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpRegs[0].ucCTL0', 'Value': 'SPI_MSPI_TURNOFF'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '[1 to 2] = 2'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ulINTFC0', 'Value': '0'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ulINTFC1', 'Value': '0'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'ulINTFC2', 'Value': '0'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'ulINTFC3', 'Value': '0'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIForceStop(const uint32 LulHWUnitIndex) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; #if (SPI_DMA_CONFIGURED == STD_ON) P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ #endif /* Get pointers and index relevant to HW */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Stop SPI unit by CTL0.MSPInEN = 0 */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL0 = SPI_MSPI_TURNOFF; /* PRQA S 2814 # JV-01 */ /* To ensure SPI unit was stopped, do dummy read & SYNCP */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL0; EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ #if (SPI_DMA_CONFIGURED == STD_ON) /* Stop DMA */ LpJobConfig = &Spi_GpFirstJob[Spi_GaaHWStatus[LulHWUnitIndex].usOngoingJobIndex]; /* PRQA S 2844 # JV-01 */ if (SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) /* PRQA S 2844, 2814 # JV-01, JV-01 */ { Spi_DMAStop((uint32)LpJobConfig->ucRxDmaIndex); } /* else No action required */ if (SPI_INVALID_DMAUNIT != LpJobConfig->ucTxDmaIndex) { Spi_DMAStop((uint32)LpJobConfig->ucTxDmaIndex); } /* else No action required */ #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ /* Clear interrupt factor Tx */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC0 = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF0; /* PRQA S 2844 # JV-01 */ /* Clear interrupt factor Rx */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC1 = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF1; /* Clear interrupt factor Error */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC2 = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF2; /* Clear interrupt factor End frame */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC3 = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF3; /* Clear pending interrupt flags */ RH850_SV_MODE_ICR_AND(16, (Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX), (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_AND(16, (Spi_GaaMSPIRegs[LulHWPhyIndex].pICRX), (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_AND(16, (Spi_GaaMSPIRegs[LulHWPhyIndex].pICFE), (uint16)(~SPI_EIC_EIRF_MASK)); /* Disable all interrupts unconditionally */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICRX, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751, 2814 # JV-01, JV-01 */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICTX, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICFE, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ /* To ensure interrupt requests were cleared, do dummy read & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '0..(total count of SPI units configured \u2013 1)', 'Name': 'LulHWUnitIndex', 'Value': '0'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0..(total count of DMA channels)\\nSPI_INVALID_DMAUNIT', 'Name': 'ucRxDmaIndex', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': '0..(total count of DMA channels)\\nSPI_INVALID_DMAUNIT', 'Name': 'ucTxDmaIndex', 'Value': '-'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '0x100'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '0x100'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '0x100'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpRegs[0].ucCTL0', 'Value': 'SPI_MSPI_CTL0_DEFAULT'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF0', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF1', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF2', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF3', 'Value': '0']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '0x0180'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '0x0180'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '0x0180'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpRegs[0].ucCTL0', 'Value': 'SPI_MSPI_TURNOFF'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '-'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'ulINTFC0', 'Value': '0'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ulINTFC1', 'Value': '0'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'ulINTFC2', 'Value': '0'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'ulINTFC3', 'Value': '0'], 'Output_Param_009': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIFrameEndISR(const uint32 LulHWUnitIndex) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpHWDevConfig; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; uint32 LulINTFactor; /* Get pointers and index relevant to HW */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Get the interrupt factor */ LulINTFactor = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF2; /* PRQA S 2814 # JV-01 */ /* Clear the interrupt factor */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC2 = LulINTFactor; LpHWStat = &Spi_GaaHWStatus[LulHWUnitIndex]; /* PRQA S 2934 # JV-01 */ LpJobConfig = &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]; /* PRQA S 0404, 2844 # JV-01, JV-01 */ LpHWDevConfig = (P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA))LpJobConfig->pHWDevConfig; /* PRQA S 0316, 2844, 2814, 3432 # JV-01, JV-01, JV-01, JV-01 */ /* When a Channel is finished, increment Channel count */ LpHWStat->usTxChannelCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ LpHWStat->usRxChannelCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ /* Check whether any error has been occurred during a Channel */ if (SPI_MSPI_NO_ERR != (uint8)(Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucCEST & /* PRQA S 2814 # JV-01 */ (uint8)(SPI_MSPI_DCE | SPI_MSPI_CE | SPI_MSPI_PE))) { #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucCESTC = (uint8)(SPI_MSPI_DCEC | SPI_MSPI_CEC | SPI_MSPI_PEC); /* Update Job result as FAILED */ Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* A least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; } /* else No action required */ /* Check whether a Job is finished */ if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) { /* Disable MSPI unit to de-activate CS when the job finishes (SWS_Spi_00263) * Disable MSPI/DMA unit interrupts associated with job. */ Spi_TurnOffHWUnit(LpJobConfig); /* Update job status */ if (SPI_JOB_FAILED != Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult) { Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_OK; } /* else No action required */ #if (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) if (SPI_GPIO_CS == LpJobConfig->enCSType) { /* Activate the chip select */ Spi_MSPIHWControlCS(LpJobConfig, SPI_FALSE); } #endif /* (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) */ #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) if (0UL != (Spi_GulActiveHWUnits & (1UL << LulHWUnitIndex))) { /* When SyncTransmit, scheduling is done by Spi_SyncTransmit */ } else #endif { #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) /* Invoke the upper layer scheduler */ Spi_ProcessSequence(LulHWUnitIndex); #endif } } else { #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) if (SPI_FALSE == LpJobConfig->blChannelPropertySame) { /* If properties of channels in on-going is not same, need to update HW registers */ Spi_MSPIProcessJob(SPI_FALSE, LpJobConfig); } else #endif { /* Trigger for next channel */ Spi_MSPIStartChannelFixedBufferMode(LpJobConfig, LpHWStat, LulHWPhyIndex, LpHWDevConfig->ucPhyChannelIndex); } } /* if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_HARDWARE_ERROR_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_PERSISTENT_HW_CONFIGURATION_ENABLED', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': ' &map_Spi_GpFirstHWUnit[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': '.ulINTF2', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': ' &map_Spi_GpFirstJob_1[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '1\u2026255', 'Name': 'ucNoOfChannels', 'Value': '0'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelList', 'Value': ' &map_pChannelList[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelPropertySame', 'Value': 'SPI_FALSE'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelList[0]', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'enMemoryMode', 'Value': ' SPI_MEMORYMODE_FIXED_BUFFER'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyChannelIndex', 'Value': '0'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'usMSPIRASTAD', 'Value': '0'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': ' &map_Spi_GpFirstChannel[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': ' SPI_BUFFER_TYPE_EB\\n SPI_BUFFER_TYPE_IB', 'Name': 'enChannelBufferType', 'Value': ' SPI_BUFFER_TYPE_IB'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfBuffers', 'Value': '1'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pEBData', 'Value': ' &map_pEBData[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucByteSize', 'Value': '4'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'pRxBuffer', 'Value': ' &map_pRxBuffer[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_pRxBuffer[0]', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': ' &map_pDestPtr[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': '1'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': '.enResult', 'Value': ' SPI_JOB_FAILED'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ucCEST', 'Value': '1'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ucCESTC', 'Value': '1'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0x000000'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'enCSType', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '1'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '1'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_JOB_FAILED'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTFC2', 'Value': '0'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF2', 'Value': '0'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'aaCH[0].ucCEST', 'Value': '1'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'aaCH[0].ucCESTC', 'Value': '19'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': 'SPI_TRUE'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': 'DemConf_DemEventParameter_DemEventParameter_001'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': 'DEM_EVENT_STATUS_FAILED'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': 'SPI_FALSE'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpHWStat', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWChannel', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblActivateCS', 'Value': '-'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIFrameEndISR(const uint32 LulHWUnitIndex) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpHWDevConfig; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; uint32 LulINTFactor; /* Get pointers and index relevant to HW */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Get the interrupt factor */ LulINTFactor = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF2; /* PRQA S 2814 # JV-01 */ /* Clear the interrupt factor */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC2 = LulINTFactor; LpHWStat = &Spi_GaaHWStatus[LulHWUnitIndex]; /* PRQA S 2934 # JV-01 */ LpJobConfig = &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]; /* PRQA S 0404, 2844 # JV-01, JV-01 */ LpHWDevConfig = (P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA))LpJobConfig->pHWDevConfig; /* PRQA S 0316, 2844, 2814, 3432 # JV-01, JV-01, JV-01, JV-01 */ /* When a Channel is finished, increment Channel count */ LpHWStat->usTxChannelCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ LpHWStat->usRxChannelCount++; /* PRQA S 3387, 3383 # JV-01, JV-01 */ /* Check whether any error has been occurred during a Channel */ if (SPI_MSPI_NO_ERR != (uint8)(Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucCEST & /* PRQA S 2814 # JV-01 */ (uint8)(SPI_MSPI_DCE | SPI_MSPI_CE | SPI_MSPI_PE))) { #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucCESTC = (uint8)(SPI_MSPI_DCEC | SPI_MSPI_CEC | SPI_MSPI_PEC); /* Update Job result as FAILED */ Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* A least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; } /* else No action required */ /* Check whether a Job is finished */ if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) { /* Disable MSPI unit to de-activate CS when the job finishes (SWS_Spi_00263) * Disable MSPI/DMA unit interrupts associated with job. */ Spi_TurnOffHWUnit(LpJobConfig); /* Update job status */ if (SPI_JOB_FAILED != Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult) { Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_OK; } /* else No action required */ #if (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) if (SPI_GPIO_CS == LpJobConfig->enCSType) { /* Activate the chip select */ Spi_MSPIHWControlCS(LpJobConfig, SPI_FALSE); } #endif /* (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) */ #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) if (0UL != (Spi_GulActiveHWUnits & (1UL << LulHWUnitIndex))) { /* When SyncTransmit, scheduling is done by Spi_SyncTransmit */ } else #endif { #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) /* Invoke the upper layer scheduler */ Spi_ProcessSequence(LulHWUnitIndex); #endif } } else { #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) if (SPI_FALSE == LpJobConfig->blChannelPropertySame) { /* If properties of channels in on-going is not same, need to update HW registers */ Spi_MSPIProcessJob(SPI_FALSE, LpJobConfig); } else #endif { /* Trigger for next channel */ Spi_MSPIStartChannelFixedBufferMode(LpJobConfig, LpHWStat, LulHWPhyIndex, LpHWDevConfig->ucPhyChannelIndex); } } /* if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_HARDWARE_ERROR_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_PERSISTENT_HW_CONFIGURATION_ENABLED', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '0'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': ' &map_Spi_GpFirstHWUnit[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': '.ulINTF2', 'Value': '9'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '0'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': ' &map_Spi_GpFirstJob_1[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '1\u2026255', 'Name': 'ucNoOfChannels', 'Value': '1'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelList', 'Value': ' &map_pChannelList[0]'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelPropertySame', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelList[0]', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'enMemoryMode', 'Value': ' SPI_MEMORYMODE_FIXED_BUFFER'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyChannelIndex', 'Value': '0'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'usMSPIRASTAD', 'Value': '0'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': ' &map_Spi_GpFirstChannel[0]'], 'Input_Param_020': ['Type': 'Variable', 'Range': ' SPI_BUFFER_TYPE_EB\\n SPI_BUFFER_TYPE_IB', 'Name': 'enChannelBufferType', 'Value': ' SPI_BUFFER_TYPE_IB'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfBuffers', 'Value': '1'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pEBData', 'Value': ' &map_pEBData[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'ucByteSize', 'Value': '0'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'pRxBuffer', 'Value': ' &map_pRxBuffer[0]'], 'Input_Param_025': ['Type': 'Variable', 'Range': '', 'Name': 'map_pRxBuffer[0]', 'Value': '-'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': ' &map_pDestPtr[0]'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': '1'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': '.enResult', 'Value': ' SPI_JOB_PENDING'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ucCEST', 'Value': '0'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ucCESTC', 'Value': '-'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0xFFFFFFFF'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'enCSType', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '1'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '1'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': ' SPI_JOB_OK'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTFC2', 'Value': '9'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF2', 'Value': '-'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'aaCH[0].ucCEST', 'Value': '0UL'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'aaCH[0].ucCESTC', 'Value': '-'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpHWStat', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWChannel', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblActivateCS', 'Value': '-'], 'Output_Param_020': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIInitializeForJob(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig, const boolean LblCFGxOnly) { P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpHWDevConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; uint32 LulHWPhyChannel; uint32 LulCFG1Value; volatile uint32 LulDummyCount; LpHWDevConfig = (P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA))LpJobConfig->pHWDevConfig; /* PRQA S 3432, 0316, 2814 # JV-01, JV-01, JV-01 */ LpHWInfo = &Spi_GpFirstHWUnit[LpJobConfig->ucHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LulHWPhyChannel = LpHWDevConfig->ucPhyChannelIndex; /* PRQA S 2814 # JV-01 */ if (SPI_FALSE == LblCFGxOnly) { /* Setup CTL0/1/2 registers according to Job settings */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ulCTL1 = LpHWDevConfig->ulMSPICTL1; /* PRQA S 2814 # JV-01 */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL2 = LpHWDevConfig->ucMSPICTL2; /* MSPInEN is set again, dummy read MSPInCTL0 12 times */ LulDummyCount = SPI_MSPI_DUMMY_READ_12T; while (0UL < LulDummyCount) /* PRQA S 3416 # JV-01 */ { Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL0; LulDummyCount--; /* PRQA S 3387, 3384 # JV-01, JV-01 */ } /* Enable MSPI unit by setting CTL0.MSPInEN = 1 */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL0 = SPI_MSPI_EN; } /* else No action required */ /* Un-mask/mask for the MSPI channel */ #if (SPI_DMA_CONFIGURED == STD_ON) if (SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) { /* Tx interrupts output to INTC2 masked */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK0 |= (1UL << LulHWPhyChannel); /* Rx interrupts output to INTC2 masked */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK1 |= (1UL << LulHWPhyChannel); /* Tool has rejected jobs having memory mode as Fixed buffer related to DMA */ } else #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ { /* Check memory mode configured for job */ if (SPI_MEMORYMODE_FIXED_BUFFER != LpHWDevConfig->enMemoryMode) { /* Tx interrupts output to INTC2 un-masked */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK0 &= ~(1UL << LulHWPhyChannel); /* Rx interrupts output to INTC2 un-masked */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK1 &= ~(1UL << LulHWPhyChannel); /* FE interrupts output to INTC2 masked */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK2 |= (1UL << LulHWPhyChannel); } else { /* Tx interrupts output to INTC2 masked */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK0 |= (1UL << LulHWPhyChannel); /* Rx interrupts output to INTC2 masked */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK1 |= (1UL << LulHWPhyChannel); /* FE interrupts output to INTC2 un-masked */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK2 &= ~(1UL << LulHWPhyChannel); } } /* Get CFGx value from Job(includes baudrate and ChipSelect settings) and * the first Channel(includes data length and direction) */ LpChConfig = &Spi_GpFirstChannel[LpJobConfig->pChannelList[0]]; /* PRQA S 2824 # JV-01 */ LulCFG1Value = LpHWDevConfig->ulMSPICFG1; if (SPI_TRANSFER_START_LSB == LpChConfig->enTransferStart) /* PRQA S 2844, 2814 # JV-01, JV-01 */ { LulCFG1Value |= SPI_MSPI_DIR; } /* else No action required */ /* Clear all error status bits */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].ucFRERSTC = (uint8)(SPI_MSPI_DCEFSC | SPI_MSPI_CEFSC | SPI_MSPI_PEFSC); Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].ucCESTC = (uint8)(SPI_MSPI_OVREEC | SPI_MSPI_OVWREC | SPI_MSPI_OVRUEC | SPI_MSPI_DCEC | SPI_MSPI_CEC | SPI_MSPI_PEC); /* Setup CFGx registers */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].ulCFG0 = LpHWDevConfig->ulMSPICFG0; Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].ulCFG1 = LulCFG1Value; Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usCFG2 = (uint16)LpChConfig->ucDataWidth; Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usCFG3 = LpHWDevConfig->usMSPICFG3; Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].ulCFG4 = LpHWDevConfig->ulMSPICFG4; Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usSEUP = LpHWDevConfig->usMSPISEUP; Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usHOLD = LpHWDevConfig->usMSPIHOLD; Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usIDLE = LpHWDevConfig->usMSPIIDLE; Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usINDA = LpHWDevConfig->usMSPIINDA; /* Set the frame count */ #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) if (SPI_BUFFER_TYPE_IB == LpChConfig->enChannelBufferType) #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usCFSET = (uint16)LpChConfig->ulNoOfBuffers; #endif } #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) else #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usCFSET = (uint16)LpChConfig->pEBData->ulEBLength; /* PRQA S 2814 # JV-01 */ #endif } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': 'SPI_EB'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LpJobConfig', 'Value': ' &map_Spi_GpFirstJob_1[0]'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'LblCFGxOnly', 'Value': ' SPI_FALSE'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': ' &map_pHWUnitInfo[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '0\u2026..SPI_INVALID_DMAUNIT', 'Name': 'ucRxDmaIndex', 'Value': '-'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'SPI_MEMORYMODE_DIRECT\\nSPI_MEMORYMODE_FIXED_BUFFER\\nSPI_MEMORYMODE_FIXED_FIFO', 'Name': 'enMemoryMode', 'Value': 'SPI_MEMORYMODE_FIXED_FIFO'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyChannelIndex', 'Value': '0'], 'Input_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'ulMSPICTL1', 'Value': ' 0x000001UL'], 'Input_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'ucMSPICTL2', 'Value': ' 0x02U'], 'Input_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'ulMSPICFG0', 'Value': ' 0x307000F'], 'Input_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'ulMSPICFG1', 'Value': ' 0x010000'], 'Input_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'usMSPICFG3', 'Value': ' 0x001U'], 'Input_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'ulMSPICFG4', 'Value': ' 0x000000UL'], 'Input_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'usMSPISEUP', 'Value': ' 0x001U'], 'Input_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'usMSPIHOLD', 'Value': ' 0x001U'], 'Input_Param_018': ['Type': 'Register', 'Range': '', 'Name': 'usMSPIIDLE', 'Value': ' 0x001U'], 'Input_Param_019': ['Type': 'Register', 'Range': '', 'Name': 'usMSPIINDA', 'Value': ' 0x000U'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelList', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_pChannelList[0]', 'Value': '0'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': '&map_Spi_GpFirstChannel[0]'], 'Input_Param_023': ['Type': 'Register', 'Range': '', 'Name': 'ucDataWidth', 'Value': ' 0x0010000UL'], 'Input_Param_024': ['Type': 'Register', 'Range': '', 'Name': 'usNoOfBuffers', 'Value': '-'], 'Input_Param_025': ['Type': 'Register', 'Range': '', 'Name': 'pEBData', 'Value': '&map_pEBData[0]'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelBufferType', 'Value': '-'], 'Input_Param_027': ['Type': 'Variable', 'Range': '', 'Name': 'enTransferStart', 'Value': 'SPI_TRANSFER_START_LSB'], 'Input_Param_028': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': ' 0x000U'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'ulCFG0', 'Value': '0'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK0', 'Value': '0'], 'Input_Param_031': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK1', 'Value': '0'], 'Input_Param_032': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK2', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ulCTL1', 'Value': ' 0x000001UL'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ucCTL2', 'Value': ' 0x000002UL'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'ulCFG0', 'Value': '0x307000F'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'ulCFG1', 'Value': '0x0110000'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'usCFG2', 'Value': '0x000UL'], 'Output_Param_005': ['Type': 'Register', 'Range': '', 'Name': 'usCFG3', 'Value': ' 0x001U'], 'Output_Param_006': ['Type': 'Register', 'Range': '', 'Name': 'ulCFG4', 'Value': ' 0x000U'], 'Output_Param_007': ['Type': 'Register', 'Range': '', 'Name': 'usSEUP', 'Value': ' 0x001U'], 'Output_Param_008': ['Type': 'Register', 'Range': '', 'Name': 'usHOLD', 'Value': ' 0x001U'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'usIDLE', 'Value': ' 0x001U'], 'Output_Param_010': ['Type': 'Register', 'Range': '', 'Name': 'usINDA', 'Value': ' 0x000U'], 'Output_Param_011': ['Type': 'Register', 'Range': '', 'Name': 'usCFSET', 'Value': ' 0x000U'], 'Output_Param_012': ['Type': 'Register', 'Range': '', 'Name': 'ucFRERSTC', 'Value': ' 0x13'], 'Output_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'ucCESTC', 'Value': ' 0xF3U'], 'Output_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'ulINTMSK0', 'Value': '-'], 'Output_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'ulINTMSK1', 'Value': '-'], 'Output_Param_016': ['Type': 'Register', 'Range': '', 'Name': 'ulINTMSK2', 'Value': '-'], 'Output_Param_017': ['Type': 'Register', 'Range': '', 'Name': 'ucCTL0', 'Value': 'SPI_MSPI_EN'], 'Output_Param_018': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIMaskHWUnitInterrupts(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig, const boolean LblMask) { P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpHWDevConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ uint32 LulHWUnitIndex; /* Get HW unit index */ LulHWUnitIndex = LpJobConfig->ucHWUnitIndex; /* PRQA S 2814 # JV-01 */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; /* Get pointer to HW unit configuration*/ LpHWDevConfig = (P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA))LpJobConfig->pHWDevConfig; /* PRQA S 0316, 3432 # JV-01, JV-01 */ /* INTERRUPT_PROTECTION is required to avoid ISR occur while EIMK is being set */ SPI_ENTER_CRITICAL_SECTION(SPI_INTERRUPT_CONTROL_PROTECTION); /* Check if request to mask interrupts */ if (SPI_TRUE == LblMask) { #if (SPI_DMA_CONFIGURED == STD_ON) if (LpJobConfig->ucRxDmaIndex != SPI_INVALID_DMAUNIT) { Spi_DMAMaskHWUnitInterrupts((uint32)LpJobConfig->ucRxDmaIndex, SPI_TRUE); } else #endif { if (SPI_MEMORYMODE_FIXED_BUFFER != LpHWDevConfig->enMemoryMode) /* PRQA S 2814 # JV-01 */ { RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICRX, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 2814, 0751, 2844 # JV-01, JV-01, JV-01 */ /* Write the lower byte of EIC registers to avoid modifying EIRF bit */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICTX, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ } else { /* Write the lower byte of EIC registers to avoid modifying EIRF bit */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICFE, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ } } } else { #if (SPI_DMA_CONFIGURED == STD_ON) if (LpJobConfig->ucRxDmaIndex != SPI_INVALID_DMAUNIT) { /* Mask Rx and Tx interrupt when using DMA */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICRX, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ /* Write the lower byte of EIC registers to avoid modifying EIRF bit */ RH850_SV_MODE_ICR_OR(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICTX, (uint8)SPI_EIC_EIMK_MASK); /* PRQA S 0751 # JV-01 */ /* Un-mask DMA interrupt */ Spi_DMAMaskHWUnitInterrupts((uint32)LpJobConfig->ucRxDmaIndex, SPI_FALSE); } else #endif { if (SPI_MEMORYMODE_FIXED_BUFFER != LpHWDevConfig->enMemoryMode) { /* Write the lower byte of EIC registers to avoid modifying EIRF bit */ RH850_SV_MODE_ICR_AND(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICRX, (uint8)(~SPI_EIC_EIMK_MASK)); /* PRQA S 0751 # JV-01 */ /* Write the lower byte of EIC registers to avoid modifying EIRF bit */ RH850_SV_MODE_ICR_AND(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICTX, (uint8)(~SPI_EIC_EIMK_MASK)); /* PRQA S 0751 # JV-01 */ } else { /* Write the lower byte of EIC registers to avoid modifying EIRF bit */ RH850_SV_MODE_ICR_AND(8, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICFE, (uint8)(~SPI_EIC_EIMK_MASK)); /* PRQA S 0751 # JV-01 */ } } } /* To ensure change of interrupt masks, do dummy read & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LpHWInfo->ucPhyUnitIndex].pICTX); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ SPI_EXIT_CRITICAL_SECTION(SPI_INTERRUPT_CONTROL_PROTECTION); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_OFF'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'LblMask', 'Value': 'SPI_TRUE'], 'Input_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxDmaIndex', 'Value': 'SPI_INVALID_DMAUNIT'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxDmaIndex', 'Value': 'SPI_INVALID_DMAUNIT'], 'Input_Param_008': ['Type': 'Variable', 'Range': 'SPI_MEMORYMODE_DIRECT\\nSPI_MEMORYMODE_FIXED_BUFFER\\nSPI_MEMORYMODE_FIXED_FIFO', 'Name': 'enMemoryMode', 'Value': 'SPI_MEMORYMODE_FIXED_BUFFER'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '0x1000'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '0x1000'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '0x1000']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '0x1080'], 'Output_Param_003': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblMask', 'Value': '-'], 'Output_Param_006': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_007': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ /* CH0 / #if (SPI_MSPI0_FE_ISR_API == STD_ON) /* Defines the CAT2interrupt mapping */ #if defined(Os_SPI_MSPI0_FE_CAT2_ISR) || (SPI_ISR_CATEGORY_2 == STD_ON) ISR(SPI_MSPI0_FE_CAT2_ISR) /* PRQA S 1503, 3408 # JV-01, JV-01 */ /* Defines the CAT1 interrupt mapping */ #else _INTERRUPT_ FUNC(void, SPI_CODE_FAST) SPI_MSPI0_FE_ISR(void) /* PRQA S 1503 # JV-01 */ #endif { SPI_MSPI_INT_ASSERTION(SPI_PHYIDX_MSPI0, FE) /* PRQA S 2814 # JV-01 */ { Spi_MSPIFrameEndISR((uint32)Spi_GpHwConfig[SPI_MACRO_MSPI].pPhyToHWUnit[SPI_PHYIDX_MSPI0]); /* PRQA S 2824 # JV-01 */ } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_MSPIn_FE_ISR', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '-', 'Name': 'Os_SPI_MSPIn_FE_CAT2_ISR', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_ISR_CATEGORY_2', 'Value': 'STD_OFF'], 'Input_Param_003': ['Type': 'Variable', 'Range': '-', 'Name': 'Count', 'Value': '4 = SPI_MSPI4_FE_ISR'], 'Input_Param_004': ['Type': 'Array', 'Range': '-', 'Name': 'map_MSPIpICFE[0 to 9]', 'Value': '[0 to 5] = 0x000000'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpHwConfig', 'Value': '&map_pHwConfig[0]'], 'Input_Param_006': ['Type': 'Array', 'Range': '-', 'Name': 'map_pPhyToHWUnit[0 to 9]', 'Value': '[0 to 5] = 0']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '0'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIProcessJob(const boolean LblFirst, CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig) { P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpHWDevConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; uint32 LulHWPhyChannel; uint32 LulChIndex; LpHWDevConfig = (P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA))LpJobConfig->pHWDevConfig; /* PRQA S 3432, 0316, 2814 # JV-01, JV-01, JV-01 */ LpHWInfo = &Spi_GpFirstHWUnit[LpJobConfig->ucHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2844, 2814 # JV-01, JV-01 */ LulHWPhyChannel = LpHWDevConfig->ucPhyChannelIndex; /* PRQA S 2814 # JV-01 */ LpHWStat = &Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex]; /* PRQA S 2934 # JV-01 */ /* * If this is the start of Job, initialize entire MSPI. * Otherwise, initialize channel relevant registers only. */ if (SPI_TRUE == LblFirst) { /* Initialize status and HW according to Job config */ LpHWStat->usTxChannelCount = 0U; /* PRQA S 2844 # JV-01 */ LpHWStat->usRxChannelCount = 0U; #if (SPI_FIXED_BUFFER_MODE == STD_ON) LpHWStat->ulTxChannelOffset = 0U; #endif LulChIndex = LpJobConfig->pChannelList[0]; /* PRQA S 2824 # JV-01 */ LpChConfig = &Spi_GpFirstChannel[LulChIndex]; #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) /* Power OFF */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL0 = SPI_MSPI_TURNOFF; /* PRQA S 2814 # JV-01 */ /* Initialize MSPIn */ Spi_MSPIInitializeForJob(LpJobConfig, SPI_FALSE); #else /* Power ON */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->ucCTL0 = SPI_MSPI_EN; /* PRQA S 2814 # JV-01 */ #endif } /* if (SPI_TRUE == LblFirst) */ else { /* Initialize HW according to Channel config */ LulChIndex = LpJobConfig->pChannelList[LpHWStat->usTxChannelCount]; LpChConfig = &Spi_GpFirstChannel[LulChIndex]; /* Disable HW channel to setting channel configuration registers */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].ucCSTC = SPI_MSPI_CHENC; #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) /* Initialize CFGx according to Channel config */ Spi_MSPIInitializeForCh(LpJobConfig, LpChConfig); #endif } /* else (SPI_TRUE == LblFirst) */ if (SPI_MEMORYMODE_FIXED_BUFFER != LpHWDevConfig->enMemoryMode) { /* Prepare channel buffers */ #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) if (SPI_BUFFER_TYPE_IB == LpChConfig->enChannelBufferType) /* PRQA S 2814, 2844 # JV-01, JV-01 */ #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) /* Initialize rx/tx pointers to point to IB */ LpHWStat->pTxPtr = LpChConfig->pTxBuffer; LpHWStat->pRxPtr = LpChConfig->pRxBuffer; LpHWStat->ulRemainedTxCount = LpChConfig->ulNoOfBuffers; LpHWStat->ulRemainedRxCount = LpChConfig->ulNoOfBuffers; #endif } #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) else #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) /* Initialize rx/tx pointers to point to EB */ LpHWStat->pTxPtr = LpChConfig->pEBData->pSrcPtr; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LpHWStat->pRxPtr = LpChConfig->pEBData->pDestPtr; LpHWStat->ulRemainedTxCount = LpChConfig->pEBData->ulEBLength; LpHWStat->ulRemainedRxCount = LpChConfig->pEBData->ulEBLength; #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_ON) /* If using static configuration, CFSET won't be updated after user call Spi_SetupEB API, need to update it again before transmission. */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulHWPhyChannel].usCFSET = (uint16)LpChConfig->pEBData->ulEBLength; #endif #endif } } /* else No action required */ #if (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) if (SPI_GPIO_CS == LpJobConfig->enCSType) { /* Activate the chip select */ Spi_MSPIHWControlCS(LpJobConfig, SPI_TRUE); } #endif /* (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) */ switch (LpHWDevConfig->enMemoryMode) { #if (SPI_DIRECT_ACCESS_MODE == STD_ON) case SPI_MEMORYMODE_DIRECT: /* Direct memory mode */ Spi_MSPIStartChannelDirectMemoryMode(LpJobConfig, LpHWStat, LulHWPhyIndex, LulHWPhyChannel); break; #endif #if (SPI_FIXED_FIFO_MODE == STD_ON) case SPI_MEMORYMODE_FIXED_FIFO: /* Fixed FIFO memory mode */ Spi_MSPIStartChannelFixedFIFOMode(LpJobConfig, LpHWStat, LulHWPhyIndex, LulHWPhyChannel); break; #endif #if (SPI_FIXED_BUFFER_MODE == STD_ON) case SPI_MEMORYMODE_FIXED_BUFFER: /* Fixed buffer memory mode */ Spi_MSPIStartChannelFixedBufferMode(LpJobConfig, LpHWStat, LulHWPhyIndex, LulHWPhyChannel); break; #endif default: /* Nothing to do */ break; } }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_PERSISTENT_HW_CONFIGURATION_ENABLED', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Macro', 'Range': '0\u20262', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': 'SPI_IBEB'], 'Input_Param_003': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_FIXED_BUFFER_MODE', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_FIXED_FIFO', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_DIRECT_ACCESS_MODE', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Argument', 'Range': 'SPI_TRUE\\nSPI_FALSE', 'Name': 'LblFirst', 'Value': ' SPI_TRUE'], 'Input_Param_007': ['Type': 'Argument', 'Range': '!NULL_PTR', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstHWUnit', 'Value': ' &map_pHWUnitInfo[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstChannel', 'Value': ' &map_Spi_GpFirstChannel[0]'], 'Input_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'pTxBuffer', 'Value': ' NULL_PTR'], 'Input_Param_011': ['Type': 'Variable', 'Range': '-', 'Name': 'pRxBuffer', 'Value': ' NULL_PTR'], 'Input_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'usNoOfBuffers', 'Value': ' 0x001U'], 'Input_Param_013': ['Type': 'Variable', 'Range': '-', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_014': ['Type': 'Variable', 'Range': '-', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'ucPhyChannelIndex', 'Value': '0'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'pChannelList', 'Value': '&map_pChannelList[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'map_pChannelList[0]', 'Value': '0'], 'Input_Param_018': ['Type': 'Variable', 'Range': 'SPI_MEMORYMODE_DIRECT\\nSPI_MEMORYMODE_FIXED_BUFFER\\nSPI_MEMORYMODE_FIXED_FIFO', 'Name': 'enMemoryMode', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': 'SPI_BUFFER_TYPE_IB\\nSPI_BUFFER_TYPE_EB', 'Name': 'enChannelBufferType', 'Value': ' SPI_BUFFER_TYPE_IB'], 'Input_Param_020': ['Type': 'Variable', 'Range': '-', 'Name': 'pEBData', 'Value': ' &map_pEBData[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '-', 'Name': 'pSrcPtr', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '-', 'Name': 'pDestPtr', 'Value': '-'], 'Input_Param_023': ['Type': 'Variable', 'Range': '-', 'Name': 'usEBLength', 'Value': '-'], 'Input_Param_024': ['Type': 'Variable', 'Range': '-', 'Name': 'ucTxChannelCount', 'Value': '-'], 'Input_Param_025': ['Type': 'Register', 'Range': '-', 'Name': 'ucCSTC', 'Value': '0x000'], 'Input_Param_026': ['Type': 'Variable', 'Range': '-', 'Name': 'enCSType', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'ucCTL0', 'Value': 'SPI_MSPI_TURNOFF'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'ucCSTC', 'Value': '-'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '0'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '0'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pTxPtr', 'Value': ' NULL_PTR'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pRxPtr', 'Value': ' NULL_PTR'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedTxCount', 'Value': ' 0x001UL'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': ' 0x001UL'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'usTxChannelOffset', 'Value': '0'], 'Output_Param_009': ['Type': 'Register', 'Range': '', 'Name': 'usCFSET', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblCFGxOnly', 'Value': 'SPI_FALSE'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '-'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblActivateCS', 'Value': '-'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '-'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpHWStat', 'Value': '-'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '-'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyChannel', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpHWStat', 'Value': '-'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyChannel', 'Value': '-'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '-'], 'Output_Param_027': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpHWStat', 'Value': '-'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '-'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyChannel', 'Value': '-'], 'Output_Param_030': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIReceiveISR(const uint32 LulHWUnitIndex) /* PRQA S 1505 # JV-01 */ { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpHWDevConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; uint32 LulINTFactor; uint32 LulPhyChannel; uint32 LulRcvData; uint32 LulBurstCount; LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2844, 2814 # JV-01, JV-01 */ LpHWStat = &Spi_GaaHWStatus[LulHWUnitIndex]; /* PRQA S 2934 # JV-01 */ LpJobConfig = &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]; /* PRQA S 0404, 2844 # JV-01, JV-01 */ LpHWDevConfig = (P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA))LpJobConfig->pHWDevConfig; /* PRQA S 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01 */ LulPhyChannel = LpHWDevConfig->ucPhyChannelIndex; /* PRQA S 2814 # JV-01 */ /* Mask Rx interrupt output of the corresponding MSPI channel to INTC2 */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK1 |= 1UL << LulPhyChannel; /* PRQA S 2814 # JV-01 */ /* Get the interrupt factor */ LulINTFactor = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF1; /* Clear the interrupt factor */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC1 = LulINTFactor; LpChConfig = &Spi_GpFirstChannel[LpJobConfig->pChannelList[LpHWStat->usRxChannelCount]]; /* PRQA S 0404 # JV-01 */ /* Check a memory mode */ if (SPI_MEMORYMODE_FIXED_FIFO == LpHWDevConfig->enMemoryMode) { /* Fixed FIFO memory mode */ /* Set the number of free buffers */ LulBurstCount = (uint32)(LpHWDevConfig->ulMSPICFG4 & SPI_MSPI_SIZE_MASK); LulBurstCount = (uint32)SPI_MSPI_HALF_MIN_STAGE << LulBurstCount; } else { /* Direct access memory mode, set to one */ LulBurstCount = 1U; } /* Read reception data */ do { /* Receive and store data to memory */ LulRcvData = Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulPhyChannel].ulRXDA0; if (NULL_PTR != LpHWStat->pRxPtr) { Spi_StoreRxData(LpHWStat->pRxPtr, LpChConfig, LulRcvData); LpHWStat->pRxPtr = LpHWStat->pRxPtr + LpChConfig->ucByteSize; /* PRQA S 0488, 2844, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ /* Decrease the number of Rx data in a channel */ LpHWStat->ulRemainedRxCount--; /* PRQA S 3384, 3387 # JV-01, JV-01 */ /* Decrease burst count */ LulBurstCount--; /* PRQA S 3383 # JV-01 */ } while (0UL != LulBurstCount); #if (SPI_MSPI_NOT_SUPPORT_RX_BUFFER_FULL == STD_ON) if (0UL != (Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF0 & (1UL << LulPhyChannel))) { /* Transmit next data if there is a Tx request */ Spi_MSPITransmitISR(LulHWUnitIndex); } else { /* Unmask Tx interrupt for next transmission */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK0 &= ~(1UL << LulPhyChannel); } #endif /* Check whether a Channel is finished */ if (0U == LpHWStat->ulRemainedRxCount) { /* Increase channel count for next channel */ LpHWStat->usRxChannelCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ /* Check whether any error has been occurred during a frame in Direct memory access mode*/ if ((SPI_MEMORYMODE_DIRECT == LpHWDevConfig->enMemoryMode) && (SPI_MSPI_NO_ERR != (uint8)(Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucFRERST & (uint8)(SPI_MSPI_DCEFST | SPI_MSPI_CEFST | SPI_MSPI_PEFST)))) { #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucFRERSTC = (uint8)(SPI_MSPI_DCEFSC | SPI_MSPI_CEFSC | SPI_MSPI_PEFSC); /* Update Job result as FAILED */ Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* A least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; } /* else No action required */ /* Check whether any error has been occurred during a Channel */ if (SPI_MSPI_NO_ERR != (uint8)(Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucCEST & (uint8)(SPI_MSPI_OVREE | SPI_MSPI_OVWRE | SPI_MSPI_OVRUE | SPI_MSPI_DCE | SPI_MSPI_CE | SPI_MSPI_PE))) { #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucCESTC = (uint8)(SPI_MSPI_OVREEC | SPI_MSPI_OVWREC | SPI_MSPI_OVRUEC | SPI_MSPI_DCEC | SPI_MSPI_CEC | SPI_MSPI_PEC); /* Update Job result as FAILED */ Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* A least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; } /* else No action required */ /* Check whether a Job is finished */ if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) { /* Disable MSPI unit to de-activate CS when the job finishes (SWS_Spi_00263) * Disable MSPI unit interrupts associated with job. */ Spi_TurnOffHWUnit(LpJobConfig); #if (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) /* Check if job is configured with CS as GPIO */ if (SPI_GPIO_CS == LpJobConfig->enCSType) { /* Deactivate the chip select via selected GPIO port pin */ Spi_MSPIHWControlCS(LpJobConfig, SPI_FALSE); } #endif /* (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) */ /* All Channels in a Job are completed */ if (SPI_JOB_FAILED != Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult) { Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_OK; } /* else No action required */ #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) if (0UL != (Spi_GulActiveHWUnits & (1UL << LulHWUnitIndex))) { /* When SyncTransmit, scheduling is done by Spi_SyncTransmit */ } else #endif { #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) /* Invoke the upper layer scheduler */ Spi_ProcessSequence(LulHWUnitIndex); #endif } } /* if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) */ else { LpChConfig = &Spi_GpFirstChannel[LpJobConfig->pChannelList[LpHWStat->usRxChannelCount]]; /* PRQA S 0404 # JV-01 */ if ((SPI_MEMORYMODE_FIXED_FIFO == LpHWDevConfig->enMemoryMode) #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) || (SPI_FALSE == LpJobConfig->blChannelPropertySame) #endif /* (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) */ ) { /* * If ChannelProperty is not same, TxChannelCount is not updated because TxISR never occur on the last data. * Hence update it here. */ LpHWStat->usTxChannelCount = LpHWStat->usRxChannelCount; /* Start the next Channel */ Spi_MSPIProcessJob(SPI_FALSE, &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]); /* PRQA S 0404 # JV-01 */ } else { /* * When a channel is completed and all channel properties are same, setup buffer for the next channel and * continue the operation. Otherwise, call job scheduler. */ #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) if (SPI_BUFFER_TYPE_IB == LpChConfig->enChannelBufferType) /* PRQA S 2844, 2814 # JV-01, JV-01 */ #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) LpHWStat->pRxPtr = LpChConfig->pRxBuffer; LpHWStat->ulRemainedRxCount = LpChConfig->ulNoOfBuffers; /* Set CFSET again for next channel */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulPhyChannel].usCFSET = (uint16)LpChConfig->ulNoOfBuffers; #endif } #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) else #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) LpHWStat->pRxPtr = LpChConfig->pEBData->pDestPtr; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LpHWStat->ulRemainedRxCount = LpChConfig->pEBData->ulEBLength; /* Set CFSET again for next channel */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulPhyChannel].usCFSET = (uint16)LpChConfig->pEBData->ulEBLength; #endif } /* Need to enable channel again to start transmission */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulPhyChannel].ucCSTS = SPI_MSPI_CHENS | SPI_MSPI_ACTFS; } /* else (SPI_FALSE == LpJobConfig->blChannelPropertySame) */ } /* else (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) */ } /* else (0U == LpHWStat->ulRemainedRxCount) */ /* Un-mask Rx interrupt output of the corresponding MSPI channel to INTC2 */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK1 &= ~(1UL << LulPhyChannel); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_HARDWARE_ERROR_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': 'SPI_IBEB'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0\u20261', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pRxBuffer', 'Value': 'NULL_PTR'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': ' &map_pHWUnitInfo[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': ' &map_Spi_GpFirstJob_1[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': ' 0x000000'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK0', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF0', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK1', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF1', 'Value': ' 0x000001'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulRXDA0', 'Value': '1'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucFRERST', 'Value': '1'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucFRERSTC', 'Value': '1'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucCEST', 'Value': '1'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucCESTC', 'Value': '1'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucCSTS', 'Value': '1'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '0'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '0'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pRxPtr', 'Value': ' &map_pRxPtr[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_pRxPtr[0]', 'Value': '0'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '1'], 'Input_Param_025': ['Type': 'Variable', 'Range': 'SPI_JOB_OK\\nSPI_JOB_PENDING\\nSPI_JOB_FAILED\\nSPI_JOB_QUEUED', 'Name': 'enResult', 'Value': 'SPI_JOB_QUEUED'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelPropertySame', 'Value': ' SPI_FALSE'], 'Input_Param_027': ['Type': 'Variable', 'Range': 'SPI_MEMORYMODE_DIRECT\\nSPI_MEMORYMODE_FIXED_BUFFER\\nSPI_MEMORYMODE_FIXED_FIFO', 'Name': 'enMemoryMode', 'Value': ' SPI_MEMORYMODE_DIRECT'], 'Input_Param_028': ['Type': 'Variable', 'Range': '1\u2026255', 'Name': 'ucNoOfChannels', 'Value': '1'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelList', 'Value': ' &map_pChannelList[0]'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulMSPICFG4', 'Value': '-'], 'Input_Param_031': ['Type': 'Variable', 'Range': '-', 'Name': 'ucPhyChannelIndex', 'Value': '0'], 'Input_Param_032': ['Type': 'Array', 'Range': '', 'Name': 'map_pChannelList[0 to 1]', 'Value': '[0 to 1] = 0'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': ' &map_Spi_GpFirstChannel[0]'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelBufferType', 'Value': ' SPI_BUFFER_TYPE_IB'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfBuffers', 'Value': '1'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'pEBData', 'Value': ' &map_pEBData[0]'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'ucByteSize', 'Value': '0'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': '0'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': '&map_pDestPtr[0]'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDestPtr[0]', 'Value': '-'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'usCFSET', 'Value': '0xFFFF'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '0'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'Variable_aaCH', 'Value': '0'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'enCSType', 'Value': 'SPI_GPIO_CS']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucCSTS', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucFRERSTC', 'Value': 'SPI_MSPI_DCEFSC | SPI_MSPI_CEFSC | SPI_MSPI_PEFSC'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucCESTC', 'Value': 'SPI_MSPI_OVREEC | SPI_MSPI_OVWREC | SPI_MSPI_OVRUEC |SPI_MSPI_DCEC | SPI_MSPI_CEC | SPI_MSPI_PEC'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK1', 'Value': '0'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTFC1', 'Value': ' 0x000001'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '1'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'usCFSET', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '0'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_JOB_FAILED'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': 'SPI_TRUE'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pRxPtr', 'Value': '&map_pRxPtr[0]'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK0', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '[1] = &map_pRxPtr[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '[1] =&map_Spi_GpFirstChannel[0]'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulInData', 'Value': '[1] = 1'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '[1 to 2] = DemConf_DemEventParameter_DemEventParameter_001'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '[1 to 2] = DEM_EVENT_STATUS_FAILED'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblActivateCS', 'Value': '0'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_MSPIReceiveISR(const uint32 LulHWUnitIndex) /* PRQA S 1505 # JV-01 */ { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpHWDevConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ uint32 LulHWPhyIndex; uint32 LulINTFactor; uint32 LulPhyChannel; uint32 LulRcvData; uint32 LulBurstCount; LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulHWPhyIndex = LpHWInfo->ucPhyUnitIndex; /* PRQA S 2844, 2814 # JV-01, JV-01 */ LpHWStat = &Spi_GaaHWStatus[LulHWUnitIndex]; /* PRQA S 2934 # JV-01 */ LpJobConfig = &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]; /* PRQA S 0404, 2844 # JV-01, JV-01 */ LpHWDevConfig = (P2CONST(Spi_MSPIDeviceConfigType, AUTOMATIC, SPI_CONFIG_DATA))LpJobConfig->pHWDevConfig; /* PRQA S 0316, 2814, 2844, 3432 # JV-01, JV-01, JV-01, JV-01 */ LulPhyChannel = LpHWDevConfig->ucPhyChannelIndex; /* PRQA S 2814 # JV-01 */ /* Mask Rx interrupt output of the corresponding MSPI channel to INTC2 */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK1 |= 1UL << LulPhyChannel; /* PRQA S 2814 # JV-01 */ /* Get the interrupt factor */ LulINTFactor = Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF1; /* Clear the interrupt factor */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTFC1 = LulINTFactor; LpChConfig = &Spi_GpFirstChannel[LpJobConfig->pChannelList[LpHWStat->usRxChannelCount]]; /* PRQA S 0404 # JV-01 */ /* Check a memory mode */ if (SPI_MEMORYMODE_FIXED_FIFO == LpHWDevConfig->enMemoryMode) { /* Fixed FIFO memory mode */ /* Set the number of free buffers */ LulBurstCount = (uint32)(LpHWDevConfig->ulMSPICFG4 & SPI_MSPI_SIZE_MASK); LulBurstCount = (uint32)SPI_MSPI_HALF_MIN_STAGE << LulBurstCount; } else { /* Direct access memory mode, set to one */ LulBurstCount = 1U; } /* Read reception data */ do { /* Receive and store data to memory */ LulRcvData = Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulPhyChannel].ulRXDA0; if (NULL_PTR != LpHWStat->pRxPtr) { Spi_StoreRxData(LpHWStat->pRxPtr, LpChConfig, LulRcvData); LpHWStat->pRxPtr = LpHWStat->pRxPtr + LpChConfig->ucByteSize; /* PRQA S 0488, 2844, 2814 # JV-01, JV-01, JV-01 */ } /* else No action required */ /* Decrease the number of Rx data in a channel */ LpHWStat->ulRemainedRxCount--; /* PRQA S 3384, 3387 # JV-01, JV-01 */ /* Decrease burst count */ LulBurstCount--; /* PRQA S 3383 # JV-01 */ } while (0UL != LulBurstCount); #if (SPI_MSPI_NOT_SUPPORT_RX_BUFFER_FULL == STD_ON) if (0UL != (Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTF0 & (1UL << LulPhyChannel))) { /* Transmit next data if there is a Tx request */ Spi_MSPITransmitISR(LulHWUnitIndex); } else { /* Unmask Tx interrupt for next transmission */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK0 &= ~(1UL << LulPhyChannel); } #endif /* Check whether a Channel is finished */ if (0U == LpHWStat->ulRemainedRxCount) { /* Increase channel count for next channel */ LpHWStat->usRxChannelCount++; /* PRQA S 3383, 3387 # JV-01, JV-01 */ /* Check whether any error has been occurred during a frame in Direct memory access mode*/ if ((SPI_MEMORYMODE_DIRECT == LpHWDevConfig->enMemoryMode) && (SPI_MSPI_NO_ERR != (uint8)(Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucFRERST & (uint8)(SPI_MSPI_DCEFST | SPI_MSPI_CEFST | SPI_MSPI_PEFST)))) { #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucFRERSTC = (uint8)(SPI_MSPI_DCEFSC | SPI_MSPI_CEFSC | SPI_MSPI_PEFSC); /* Update Job result as FAILED */ Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* A least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; } /* else No action required */ /* Check whether any error has been occurred during a Channel */ if (SPI_MSPI_NO_ERR != (uint8)(Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucCEST & (uint8)(SPI_MSPI_OVREE | SPI_MSPI_OVWRE | SPI_MSPI_OVRUE | SPI_MSPI_DCE | SPI_MSPI_CE | SPI_MSPI_PE))) { #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LpHWDevConfig->ucPhyChannelIndex].ucCESTC = (uint8)(SPI_MSPI_OVREEC | SPI_MSPI_OVWREC | SPI_MSPI_OVRUEC | SPI_MSPI_DCEC | SPI_MSPI_CEC | SPI_MSPI_PEC); /* Update Job result as FAILED */ Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* A least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; } /* else No action required */ /* Check whether a Job is finished */ if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) { /* Disable MSPI unit to de-activate CS when the job finishes (SWS_Spi_00263) * Disable MSPI unit interrupts associated with job. */ Spi_TurnOffHWUnit(LpJobConfig); #if (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) /* Check if job is configured with CS as GPIO */ if (SPI_GPIO_CS == LpJobConfig->enCSType) { /* Deactivate the chip select via selected GPIO port pin */ Spi_MSPIHWControlCS(LpJobConfig, SPI_FALSE); } #endif /* (SPI_CS_VIA_GPIO_CONFIGURED == STD_ON) */ /* All Channels in a Job are completed */ if (SPI_JOB_FAILED != Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult) { Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_OK; } /* else No action required */ #if (SPI_LEVEL_DELIVERED == SPI_LEVEL_2) if (0UL != (Spi_GulActiveHWUnits & (1UL << LulHWUnitIndex))) { /* When SyncTransmit, scheduling is done by Spi_SyncTransmit */ } else #endif { #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) /* Invoke the upper layer scheduler */ Spi_ProcessSequence(LulHWUnitIndex); #endif } } /* if (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) */ else { LpChConfig = &Spi_GpFirstChannel[LpJobConfig->pChannelList[LpHWStat->usRxChannelCount]]; /* PRQA S 0404 # JV-01 */ if ((SPI_MEMORYMODE_FIXED_FIFO == LpHWDevConfig->enMemoryMode) #if (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) || (SPI_FALSE == LpJobConfig->blChannelPropertySame) #endif /* (SPI_PERSISTENT_HW_CONFIGURATION_ENABLED == STD_OFF) */ ) { /* * If ChannelProperty is not same, TxChannelCount is not updated because TxISR never occur on the last data. * Hence update it here. */ LpHWStat->usTxChannelCount = LpHWStat->usRxChannelCount; /* Start the next Channel */ Spi_MSPIProcessJob(SPI_FALSE, &Spi_GpFirstJob[LpHWStat->usOngoingJobIndex]); /* PRQA S 0404 # JV-01 */ } else { /* * When a channel is completed and all channel properties are same, setup buffer for the next channel and * continue the operation. Otherwise, call job scheduler. */ #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) if (SPI_BUFFER_TYPE_IB == LpChConfig->enChannelBufferType) /* PRQA S 2844, 2814 # JV-01, JV-01 */ #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) LpHWStat->pRxPtr = LpChConfig->pRxBuffer; LpHWStat->ulRemainedRxCount = LpChConfig->ulNoOfBuffers; /* Set CFSET again for next channel */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulPhyChannel].usCFSET = (uint16)LpChConfig->ulNoOfBuffers; #endif } #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) else #endif { #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) LpHWStat->pRxPtr = LpChConfig->pEBData->pDestPtr; /* PRQA S 2814, 2844 # JV-01, JV-01 */ LpHWStat->ulRemainedRxCount = LpChConfig->pEBData->ulEBLength; /* Set CFSET again for next channel */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulPhyChannel].usCFSET = (uint16)LpChConfig->pEBData->ulEBLength; #endif } /* Need to enable channel again to start transmission */ Spi_GaaMSPIRegs[LulHWPhyIndex].pRegs->aaCH[LulPhyChannel].ucCSTS = SPI_MSPI_CHENS | SPI_MSPI_ACTFS; } /* else (SPI_FALSE == LpJobConfig->blChannelPropertySame) */ } /* else (LpHWStat->usRxChannelCount == LpJobConfig->usNoOfChannels) */ } /* else (0U == LpHWStat->ulRemainedRxCount) */ /* Un-mask Rx interrupt output of the corresponding MSPI channel to INTC2 */ Spi_GaaMSPIRegs[LulHWPhyIndex].pIntfRegs->ulINTMSK1 &= ~(1UL << LulPhyChannel); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_HARDWARE_ERROR_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': 'SPI_IBEB'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0\u20261', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pRxBuffer', 'Value': 'NULL_PTR'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': ' &map_pHWUnitInfo[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': ' &map_Spi_GpFirstJob_1[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': ' 0x000000'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK0', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF0', 'Value': '1'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK1', 'Value': '0'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTF1', 'Value': ' 0x000001'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ulRXDA0', 'Value': '1'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucFRERST', 'Value': '1'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'ucFRERSTC', 'Value': '1'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'ucCEST', 'Value': '1'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ucCESTC', 'Value': '1'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'ucCSTS', 'Value': '1'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '0'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '0'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '0'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pRxPtr', 'Value': ' &map_pRxPtr[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_pRxPtr[0]', 'Value': '0'], 'Input_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '1'], 'Input_Param_025': ['Type': 'Variable', 'Range': 'SPI_JOB_OK\\nSPI_JOB_PENDING\\nSPI_JOB_FAILED\\nSPI_JOB_QUEUED', 'Name': 'enResult', 'Value': 'SPI_JOB_QUEUED'], 'Input_Param_026': ['Type': 'Variable', 'Range': '', 'Name': 'blChannelPropertySame', 'Value': ' SPI_FALSE'], 'Input_Param_027': ['Type': 'Variable', 'Range': 'SPI_MEMORYMODE_DIRECT\\nSPI_MEMORYMODE_FIXED_BUFFER\\nSPI_MEMORYMODE_FIXED_FIFO', 'Name': 'enMemoryMode', 'Value': ' SPI_MEMORYMODE_DIRECT'], 'Input_Param_028': ['Type': 'Variable', 'Range': '1\u2026255', 'Name': 'ucNoOfChannels', 'Value': '1'], 'Input_Param_029': ['Type': 'Variable', 'Range': '', 'Name': 'pChannelList', 'Value': ' &map_pChannelList[0]'], 'Input_Param_030': ['Type': 'Variable', 'Range': '', 'Name': 'ulMSPICFG4', 'Value': '-'], 'Input_Param_031': ['Type': 'Variable', 'Range': '-', 'Name': 'ucPhyChannelIndex', 'Value': '0'], 'Input_Param_032': ['Type': 'Array', 'Range': '', 'Name': 'map_pChannelList[0 to 1]', 'Value': '[0 to 1] = 0'], 'Input_Param_033': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': ' &map_Spi_GpFirstChannel[0]'], 'Input_Param_034': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelBufferType', 'Value': ' SPI_BUFFER_TYPE_IB'], 'Input_Param_035': ['Type': 'Variable', 'Range': '', 'Name': 'usNoOfBuffers', 'Value': '1'], 'Input_Param_036': ['Type': 'Variable', 'Range': '', 'Name': 'pEBData', 'Value': ' &map_pEBData[0]'], 'Input_Param_037': ['Type': 'Variable', 'Range': '', 'Name': 'ucByteSize', 'Value': '0'], 'Input_Param_038': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': '0'], 'Input_Param_039': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': '&map_pDestPtr[0]'], 'Input_Param_040': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDestPtr[0]', 'Value': '-'], 'Input_Param_041': ['Type': 'Variable', 'Range': '', 'Name': 'usCFSET', 'Value': '0xFFFF'], 'Input_Param_042': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '0'], 'Input_Param_043': ['Type': 'Variable', 'Range': '', 'Name': 'Variable_aaCH', 'Value': '0'], 'Input_Param_044': ['Type': 'Variable', 'Range': '', 'Name': 'enCSType', 'Value': 'SPI_PERIPHERAL_ENGINE_CS']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'ucCSTS', 'Value': '-'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ucFRERSTC', 'Value': 'SPI_MSPI_DCEFSC | SPI_MSPI_CEFSC | SPI_MSPI_PEFSC'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'ucCESTC', 'Value': 'SPI_MSPI_OVREEC | SPI_MSPI_OVWREC | SPI_MSPI_OVRUEC |SPI_MSPI_DCEC | SPI_MSPI_CEC | SPI_MSPI_PEC'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK1', 'Value': '0'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTFC1', 'Value': ' 0x000001'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'ucTxChannelCount', 'Value': '-'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '1'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'usCFSET', 'Value': '-'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'usRemainedRxCount', 'Value': '0'], 'Output_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_JOB_FAILED'], 'Output_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': 'SPI_TRUE'], 'Output_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'pRxPtr', 'Value': '&map_pRxPtr[0]'], 'Output_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'ulINTMSK0', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpData', 'Value': '[1] = &map_pRxPtr[0]'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '[1] =&map_Spi_GpFirstChannel[0]'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulInData', 'Value': '[1] = 1'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '[1 to 2] = DemConf_DemEventParameter_DemEventParameter_001'], 'Output_Param_018': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '[1 to 2] = DEM_EVENT_STATUS_FAILED'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob_1[0]'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblActivateCS', 'Value': '-'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': '-'], 'Output_Param_024': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_0) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) STATIC FUNC(Std_ReturnType, SPI_PRIVATE_CODE) Spi_MSPITransmitSyncJob(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWUnitInfo; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint32 LulHWPhyIndex; uint32 LulWaitCount; Std_ReturnType LenReturnValue; #if (((SPI_DIRECT_ACCESS_MODE == STD_ON) || (SPI_FIXED_FIFO_MODE == STD_ON)) && (SPI_DMA_CONFIGURED == STD_ON)) P2CONST(Spi_DmaConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpDmaConfig; /* PRQA S 3432 # JV-01 */ uint32 LulDmaIntFlag; #endif LenReturnValue = E_OK; /* Get the base address of the HW Unit */ LpHWUnitInfo = &Spi_GpFirstHWUnit[LpJobConfig->ucHWUnitIndex]; /* PRQA S 2814 # JV-01 */ LpHWStat = &Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex]; /* PRQA S 2934 # JV-01 */ /* Get the main user base address */ LulHWPhyIndex = LpHWUnitInfo->ucPhyUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if (((SPI_DIRECT_ACCESS_MODE == STD_ON) || (SPI_FIXED_FIFO_MODE == STD_ON)) && (SPI_DMA_CONFIGURED == STD_ON)) if (SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) { LpDmaConfig = &Spi_GpFirstDMAUnit[LpJobConfig->ucRxDmaIndex]; /* Clear TE interrupt flag */ Spi_DMAClearInterruptFlag((uint32)LpJobConfig->ucRxDmaIndex); } /* else No action required */ #endif /* Clear EIRF flags before starting transmission */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX, (uint16)(~SPI_EIC_EIRF_MASK)); /* PRQA S 2814 # JV-01 */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICRX, (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICFE, (uint16)(~SPI_EIC_EIRF_MASK)); /* Setup HW for Job and send the first data */ Spi_MSPIProcessJob(SPI_TRUE, LpJobConfig); /* Loop until Job end or any error occurs */ LulWaitCount = 0U; do { #if ((SPI_DIRECT_ACCESS_MODE == STD_ON) || (SPI_FIXED_FIFO_MODE == STD_ON)) #if (SPI_DMA_CONFIGURED == STD_ON) if ((SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) && (SPI_TRUE == LpDmaConfig->blRxSide)) /* PRQA S 2962, 2814, 2844 # JV-01, JV-01, JV-01 */ { /* Invoke DMA ISR if the IRQ is asserted */ LulDmaIntFlag = Spi_DMAGetInterruptFlag((uint32)LpJobConfig->ucRxDmaIndex); if (0UL != LulDmaIntFlag) { Spi_MSPIDMACompleteISR((uint32)LpJobConfig->ucRxDmaIndex); /* Reset timeout count */ LulWaitCount = 0U; } else { /* Increment timeout count */ LulWaitCount++; /* PRQA S 3383 # JV-01 */ } } else #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ { if (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICRX) & SPI_EIC_EIRF_MASK)) { /* To emulate the default interrupt priority (MSPInTX > MSPInRx), check MSPInTX again */ if (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX) & SPI_EIC_EIRF_MASK)) { /* Clear pending interrupt flag */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX, (uint16)(~SPI_EIC_EIRF_MASK)); /* If tx interruption flag is activated, call TxISR */ Spi_MSPITransmitISR((uint32)LpJobConfig->ucHWUnitIndex); } /* else No action required */ /* Clear pending interrupt flag */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICRX, (uint16)(~SPI_EIC_EIRF_MASK)); /* If rx interruption flag is activated, call RxISR */ Spi_MSPIReceiveISR((uint32)LpJobConfig->ucHWUnitIndex); /* Reset timeout count */ LulWaitCount = 0U; } else { /* Increment timeout count */ LulWaitCount++; /* PRQA S 3383 # JV-01 */ } if (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX) & SPI_EIC_EIRF_MASK)) { /* Clear pending interrupt flag */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX, (uint16)(~SPI_EIC_EIRF_MASK)); /* If tx interruption flag is activated, call TxISR */ Spi_MSPITransmitISR((uint32)LpJobConfig->ucHWUnitIndex); /* Reset timeout count */ LulWaitCount = 0U; } else { /* Increment timeout count */ LulWaitCount++; /* PRQA S 3383 # JV-01 */ } } #endif /* ((SPI_DIRECT_ACCESS_MODE == STD_ON) || (SPI_FIXED_FIFO_MODE == STD_ON)) */ #if (SPI_FIXED_BUFFER_MODE == STD_ON) if (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICFE) & SPI_EIC_EIRF_MASK)) { /* Clear pending interrupt flag */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICFE, (uint16)(~SPI_EIC_EIRF_MASK)); /* If tx interruption flag is activated, call FrameEnd */ Spi_MSPIFrameEndISR((uint32)LpJobConfig->ucHWUnitIndex); /* Reset timeout count */ LulWaitCount = 0U; } else { /* Increment timeout count */ LulWaitCount++; /* PRQA S 3383 # JV-01 */ } #endif /* (SPI_FIXED_BUFFER_MODE == STD_ON) */ /* Check timeout */ if (Spi_GpConfigPtr->ulTimeoutCount <= LulWaitCount) { #if (STD_ON == SPI_E_DATA_TX_TIMEOUT_FAILURE_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_DATA_TX_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* PRQA S 2844 # JV-01 */ /* At least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; LenReturnValue = E_NOT_OK; } /* else No action required */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[0].pICRX); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ } while ((E_OK == LenReturnValue) && (LpHWStat->usRxChannelCount < LpJobConfig->usNoOfChannels)); /* PRQA S 2814 # JV-01 */ /* If any HW error has been occurred, return E_NOT_OK */ if (SPI_TRUE == Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed) /* PRQA S 2814 # JV-01 */ { LenReturnValue = E_NOT_OK; } /* else No action required */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FIXED_BUFFER_MODE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DIRECT_ACCESS_MODE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FIXED_FIFO_MODE', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_DATA_TX_TIMEOUT_FAILURE_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxDmaIndex', 'Value': '2'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstDMAUnit', 'Value': '&map_Spi_GpFirstDMAUnit[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'blRxSide', 'Value': 'SPI_FALSE'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0\u2026255', 'Name': 'ucNoOfChannels', 'Value': '1'], 'Input_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '~SPI_EIC_EIRF_MASK'], 'Input_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '~SPI_EIC_EIRF_MASK'], 'Input_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '~SPI_EIC_EIRF_MASK'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulTimeoutCount', 'Value': '4'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '1'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': '-'], 'Input_Param_022': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '-'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '-'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '-'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'enResult', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'blFailed', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '2'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': 'SPI_TRUE'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'Dem_SetEventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_OK'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_0) || (SPI_LEVEL_DELIVERED == SPI_LEVEL_2)) STATIC FUNC(Std_ReturnType, SPI_PRIVATE_CODE) Spi_MSPITransmitSyncJob(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig) { P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWUnitInfo; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_HWStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpHWStat; /* PRQA S 3432, 3678 # JV-01, JV-01 */ uint32 LulHWPhyIndex; uint32 LulWaitCount; Std_ReturnType LenReturnValue; #if (((SPI_DIRECT_ACCESS_MODE == STD_ON) || (SPI_FIXED_FIFO_MODE == STD_ON)) && (SPI_DMA_CONFIGURED == STD_ON)) P2CONST(Spi_DmaConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpDmaConfig; /* PRQA S 3432 # JV-01 */ uint32 LulDmaIntFlag; #endif LenReturnValue = E_OK; /* Get the base address of the HW Unit */ LpHWUnitInfo = &Spi_GpFirstHWUnit[LpJobConfig->ucHWUnitIndex]; /* PRQA S 2814 # JV-01 */ LpHWStat = &Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex]; /* PRQA S 2934 # JV-01 */ /* Get the main user base address */ LulHWPhyIndex = LpHWUnitInfo->ucPhyUnitIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if (((SPI_DIRECT_ACCESS_MODE == STD_ON) || (SPI_FIXED_FIFO_MODE == STD_ON)) && (SPI_DMA_CONFIGURED == STD_ON)) if (SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) { LpDmaConfig = &Spi_GpFirstDMAUnit[LpJobConfig->ucRxDmaIndex]; /* Clear TE interrupt flag */ Spi_DMAClearInterruptFlag((uint32)LpJobConfig->ucRxDmaIndex); } /* else No action required */ #endif /* Clear EIRF flags before starting transmission */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX, (uint16)(~SPI_EIC_EIRF_MASK)); /* PRQA S 2814 # JV-01 */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICRX, (uint16)(~SPI_EIC_EIRF_MASK)); RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICFE, (uint16)(~SPI_EIC_EIRF_MASK)); /* Setup HW for Job and send the first data */ Spi_MSPIProcessJob(SPI_TRUE, LpJobConfig); /* Loop until Job end or any error occurs */ LulWaitCount = 0U; do { #if ((SPI_DIRECT_ACCESS_MODE == STD_ON) || (SPI_FIXED_FIFO_MODE == STD_ON)) #if (SPI_DMA_CONFIGURED == STD_ON) if ((SPI_INVALID_DMAUNIT != LpJobConfig->ucRxDmaIndex) && (SPI_TRUE == LpDmaConfig->blRxSide)) /* PRQA S 2962, 2814, 2844 # JV-01, JV-01, JV-01 */ { /* Invoke DMA ISR if the IRQ is asserted */ LulDmaIntFlag = Spi_DMAGetInterruptFlag((uint32)LpJobConfig->ucRxDmaIndex); if (0UL != LulDmaIntFlag) { Spi_MSPIDMACompleteISR((uint32)LpJobConfig->ucRxDmaIndex); /* Reset timeout count */ LulWaitCount = 0U; } else { /* Increment timeout count */ LulWaitCount++; /* PRQA S 3383 # JV-01 */ } } else #endif /* (SPI_DMA_CONFIGURED == STD_ON) */ { if (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICRX) & SPI_EIC_EIRF_MASK)) { /* To emulate the default interrupt priority (MSPInTX > MSPInRx), check MSPInTX again */ if (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX) & SPI_EIC_EIRF_MASK)) { /* Clear pending interrupt flag */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX, (uint16)(~SPI_EIC_EIRF_MASK)); /* If tx interruption flag is activated, call TxISR */ Spi_MSPITransmitISR((uint32)LpJobConfig->ucHWUnitIndex); } /* else No action required */ /* Clear pending interrupt flag */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICRX, (uint16)(~SPI_EIC_EIRF_MASK)); /* If rx interruption flag is activated, call RxISR */ Spi_MSPIReceiveISR((uint32)LpJobConfig->ucHWUnitIndex); /* Reset timeout count */ LulWaitCount = 0U; } else { /* Increment timeout count */ LulWaitCount++; /* PRQA S 3383 # JV-01 */ } if (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX) & SPI_EIC_EIRF_MASK)) { /* Clear pending interrupt flag */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICTX, (uint16)(~SPI_EIC_EIRF_MASK)); /* If tx interruption flag is activated, call TxISR */ Spi_MSPITransmitISR((uint32)LpJobConfig->ucHWUnitIndex); /* Reset timeout count */ LulWaitCount = 0U; } else { /* Increment timeout count */ LulWaitCount++; /* PRQA S 3383 # JV-01 */ } } #endif /* ((SPI_DIRECT_ACCESS_MODE == STD_ON) || (SPI_FIXED_FIFO_MODE == STD_ON)) */ #if (SPI_FIXED_BUFFER_MODE == STD_ON) if (0U != (RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICFE) & SPI_EIC_EIRF_MASK)) { /* Clear pending interrupt flag */ RH850_SV_MODE_ICR_AND(16, Spi_GaaMSPIRegs[LulHWPhyIndex].pICFE, (uint16)(~SPI_EIC_EIRF_MASK)); /* If tx interruption flag is activated, call FrameEnd */ Spi_MSPIFrameEndISR((uint32)LpJobConfig->ucHWUnitIndex); /* Reset timeout count */ LulWaitCount = 0U; } else { /* Increment timeout count */ LulWaitCount++; /* PRQA S 3383 # JV-01 */ } #endif /* (SPI_FIXED_BUFFER_MODE == STD_ON) */ /* Check timeout */ if (Spi_GpConfigPtr->ulTimeoutCount <= LulWaitCount) { #if (STD_ON == SPI_E_DATA_TX_TIMEOUT_FAILURE_CONFIGURED) SPI_DEM_REPORT_ERROR(SPI_E_DATA_TX_TIMEOUT_FAILURE, DEM_EVENT_STATUS_FAILED); #endif Spi_GaaJobStatus[LpHWStat->usOngoingJobIndex].enResult = SPI_JOB_FAILED; /* PRQA S 2844 # JV-01 */ /* At least one Job failed, set Sequence failed flag */ Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed = SPI_TRUE; LenReturnValue = E_NOT_OK; } /* else No action required */ /* DummyRead & SYNCP */ RH850_SV_MODE_REG_READ_ONLY(16, Spi_GaaMSPIRegs[0].pICRX); EXECUTE_SYNCP(); /* PRQA S 1006 # JV-01 */ } while ((E_OK == LenReturnValue) && (LpHWStat->usRxChannelCount < LpJobConfig->usNoOfChannels)); /* PRQA S 2814 # JV-01 */ /* If any HW error has been occurred, return E_NOT_OK */ if (SPI_TRUE == Spi_GaaSeqStatus[LpHWStat->usOngoingSeqIndex].blFailed) /* PRQA S 2814 # JV-01 */ { LenReturnValue = E_NOT_OK; } /* else No action required */ return (LenReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DMA_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FIXED_BUFFER_MODE', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DIRECT_ACCESS_MODE', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FIXED_FIFO_MODE', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_DATA_TX_TIMEOUT_FAILURE_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Argument', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxDmaIndex', 'Value': '2'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_pHWUnitInfo[0]'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'ucPhyUnitIndex', 'Value': '0'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstDMAUnit', 'Value': '&map_Spi_GpFirstDMAUnit[0]'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'blRxSide', 'Value': 'SPI_FALSE'], 'Input_Param_012': ['Type': 'Variable', 'Range': '0\u2026255', 'Name': 'ucNoOfChannels', 'Value': '1'], 'Input_Param_013': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '0xFFFF'], 'Input_Param_014': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '0xFFFF'], 'Input_Param_015': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '0xFFFF'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'ulTimeoutCount', 'Value': '4'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '-'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'ucRxChannelCount', 'Value': '1'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': '-'], 'Input_Param_022': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'return', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICRX[0]', 'Value': '0xEFFF'], 'Output_Param_001': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICTX[0]', 'Value': '0xEFFF'], 'Output_Param_002': ['Type': 'Register', 'Range': '', 'Name': 'map_MSPIpICFE[0]', 'Value': '0xEFFF'], 'Output_Param_003': ['Type': 'Register', 'Range': '', 'Name': 'enResult', 'Value': '-'], 'Output_Param_004': ['Type': 'Register', 'Range': '', 'Name': 'blFailed', 'Value': '-'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '2'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': 'SPI_TRUE'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulDmaIndex', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWUnitIndex', 'Value': '-'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'Dem_SetEventStatus', 'Value': '-'], 'Output_Param_014': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_OK'], 'Output_Param_015': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ STATIC FUNC(void, SPI_PRIVATE_CODE) Spi_ProcessJob(const uint32 LulJobIndex) { P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ uint32 LulIndex; LpJobConfig = &Spi_GpFirstJob[LulJobIndex]; LulIndex = (uint32)Spi_GpFirstHWUnit[LpJobConfig->ucHWUnitIndex].ucMacroIndex; /* PRQA S 2814, 2844 # JV-01, JV-01 */ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_2) || ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) && \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION))) if (SPI_INTERRUPT_MODE == Spi_GenAsyncMode) /* PRQA S 3416 # JV-01 */ #endif { /* Call HW dependent function to enable HW interrupts */ Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwMaskInterrupts(LpJobConfig, SPI_FALSE); /* PRQA S 2814 # JV-01 */ } /* else No action required */ /* Call HW dependent function to start asynchronous job */ Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwProcessJob(SPI_TRUE, LpJobConfig); /* PRQA S 2814 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': '(SPI_LEVEL_DELIVERED == SPI_LEVEL_2)', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Argument', 'Range': '', 'Name': 'LulJobIndex', 'Value': '1'], 'Input_Param_002': ['Type': 'Variable', 'Range': 'SPI_POLLING_MODE\\nSPI_INTERRUPT_MODE', 'Name': 'Spi_GenAsyncMode', 'Value': 'SPI_POLLING_MODE'], 'Input_Param_003': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpFirstJob', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '1..(total count of SPI units)', 'Name': 'ucHWUnitIndex', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'ucMacroIndex', 'Value': 'SPI_MACRO_MSIOF'], 'Input_Param_007': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpHwConfig', 'Value': '&map_pHwConfig[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '0\u2026..*', 'Name': 'pHwMaskInterrupts', 'Value': 'NULL_PTR'], 'Input_Param_009': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwProcessJob', 'Value': '&ISOLATE_void_func_ptr_const_boolean__const_Spi_JobConfigType_p_const']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblMask', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblFirst', 'Value': 'SPI_TRUE'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&Spi_GpFirstJob[1]'], 'Output_Param_004': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_ProcessSequence(const uint32 LulHWUnitIndex) /* PRQA S 1532 # JV-01 */ { P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ uint32 LulPrevJobIndex; uint32 LulPrevSeqIndex; uint32 LulJobIndex; uint32 LulSeqIndex; boolean LblAvailable; boolean LblSeqFinished; #if (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) P2CONST(Spi_SeqConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpSeqConfig; /* PRQA S 3432 # JV-01 */ boolean LblSeqAlreadyStarted; #endif /* When parallel transmission is enabled, QueueIndex equals HwUnitIndex */ #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_ON) const uint32 LulQueueIndex = LulHWUnitIndex + 1UL; /* PRQA S 3383 # JV-01 */ #else const uint32 LulQueueIndex = 0UL; #endif #if (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) LpSeqConfig = NULL_PTR; LblSeqAlreadyStarted = SPI_FALSE; #endif LulPrevSeqIndex = Spi_GaaHWStatus[LulHWUnitIndex].usOngoingSeqIndex; /* PRQA S 2844 # JV-01 */ LulPrevJobIndex = Spi_GaaHWStatus[LulHWUnitIndex].usOngoingJobIndex; /* Check the Sequence is finished or aborted */ LblSeqFinished = Spi_CheckSeqFinish(LulQueueIndex, LulPrevSeqIndex); /* * Critical section is required to avoid conflict with StartTransmission and ProcessSequence from other sequence */ SPI_ENTER_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); /* Pop the next Job from the Queue */ LblAvailable = Spi_PopFromQueue(LulQueueIndex, &LulSeqIndex, &LulJobIndex); if (SPI_TRUE == LblAvailable) { LpJobConfig = &Spi_GpFirstJob[LulJobIndex]; #if (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) LpSeqConfig = &Spi_GpFirstSeq[LulSeqIndex]; LblSeqAlreadyStarted = Spi_GaaSeqStatus[LulSeqIndex].blStarted; /* PRQA S 2844 # JV-01 */ Spi_GaaSeqStatus[LulSeqIndex].blStarted = SPI_TRUE; /* PRQA S 2844 # JV-01 */ #endif #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_OFF) /* If the next Job is assigned to other HWUnit, clear HW associated with completed job, set other HWUnit activated. * If parallel transmission is enabled, a Queue is assigned to a HWUnit, so this operation is not necessary. */ if (LpJobConfig->ucHWUnitIndex != LulHWUnitIndex) /* PRQA S 2844, 2814 # JV-01, JV-01 */ { /* Clear HW associated with completed job */ Spi_GulActiveHWUnits &= ~((1UL << LulHWUnitIndex) << SPI_ACTIVE_HW_BITS); /* Active next unit */ Spi_GulActiveHWUnits |= (1UL << LpJobConfig->ucHWUnitIndex) << SPI_ACTIVE_HW_BITS; #if (SPI_HW_STATUS_API == STD_ON) /* Clear HW associated with completed job */ Spi_GaaHWStatus[LulHWUnitIndex].blActive = SPI_FALSE; /* PRQA S 2844 # JV-01 */ /* Set other HWUnit activated */ Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex].blActive = SPI_TRUE; /* PRQA S 2844 # JV-01 */ #endif } /* else No action required */ #endif /* #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_OFF) */ /* Initialize next sequence and next job to transmit */ Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex].usOngoingSeqIndex = (Spi_SequenceType)LulSeqIndex; /* PRQA S 2844, 2814 # JV-01, JV-01 */ Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex].usOngoingJobIndex = (Spi_JobType)LulJobIndex; /* PRQA S 2844 # JV-01 */ /* Update Job status */ Spi_GaaJobStatus[LulJobIndex].enResult = SPI_JOB_PENDING; /* PRQA S 2844 # JV-01 */ } else { /* If the Queue is empty, clear the active flag of this Queue */ Spi_GulAllQueueSts &= ~(1UL << LulQueueIndex); /* De-active HW unit bit */ Spi_GulActiveHWUnits &= ~((1UL << LulHWUnitIndex) << SPI_ACTIVE_HW_BITS); #if (SPI_HW_STATUS_API == STD_ON) /* Set HW unit status bit as False */ Spi_GaaHWStatus[LulHWUnitIndex].blActive = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #endif } SPI_EXIT_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); /* Report PASS to DEM when Sequence finished successfully */ #if (STD_ON == SPI_E_HARDWARE_ERROR_CONFIGURED) if (SPI_SEQ_OK == Spi_GaaSeqStatus[LulPrevSeqIndex].enResult) /* PRQA S 2844 # JV-01 */ { SPI_DEM_REPORT_ERROR(SPI_E_HARDWARE_ERROR, DEM_EVENT_STATUS_PASSED); /* PRQA S 3469 # JV-01 */ } /* else No action required */ #endif /* Invoke JobEnd, SeqEnd, SeqStart notifications if necessary */ Spi_InvokeNotifications(&Spi_GpFirstJob[LulPrevJobIndex], &Spi_GpFirstSeq[LulPrevSeqIndex], LblSeqFinished /* PRQA S 0404 # JV-01 */ #if (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) ,LpSeqConfig, LblSeqAlreadyStarted #endif ); /* If the Queue was not empty, transmit the popped Job */ if (SPI_TRUE == LblAvailable) { /* Start Job */ Spi_ProcessJob(LulJobIndex); } /* else No action required */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_SEQ_STARTNOTIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_HW_STATUS_API', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_E_HARDWARE_ERROR_CONFIGURED', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Argument', 'Range': '0..(total count of SPI units configured \u2013 1)', 'Name': 'LulHWUnitIndex', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GulAllQueueSts', 'Value': '-'], 'Input_Param_006': ['Type': 'Variable', 'Range': '-', 'Name': 'ucOngoingSeqIndex', 'Value': '0x0000001'], 'Input_Param_007': ['Type': 'Variable', 'Range': 'SPI_SEQ_OK\\nSPI_SEQ_PENDING\\nSPI_SEQ_FAILED\\nSPI_SEQ_CANCELED', 'Name': '.enResult', 'Value': 'SPI_SEQ_PENDING'], 'Input_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'usOngoingJobIndex', 'Value': '0x0000001'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'tmp_LpSeqIndex', 'Value': '1'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'blStarted', 'Value': 'SPI_TRUE'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstJob', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'tmp_LpJobIndex', 'Value': '1'], 'Input_Param_013': ['Type': 'Variable', 'Range': '', 'Name': 'ucHWUnitIndex', 'Value': '1'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_Spi_GpFirstSeq[0]'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0xFFFFFFFF'], 'Input_Param_016': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'returnValue', 'Value': 'SPI_TRUE'], 'Input_Param_017': ['Type': 'Return_Value_of', 'Range': '', 'Name': 'returnValue', 'Value': 'SPI_TRUE'], 'Input_Param_018': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpSeqIndex', 'Value': '1'], 'Input_Param_019': ['Type': 'Output_Argument', 'Range': '', 'Name': '*LpJobIndex', 'Value': '1']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '2'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '0x0000001'], 'Output_Param_002': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_003': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '2'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': 'LpSeqIndex'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': 'LpJobIndex'], 'Output_Param_006': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_007': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_008': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_009': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventId', 'Value': '-'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'EventStatus', 'Value': '-'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPrevJobConfig', 'Value': '&map_Spi_GpFirstJob[1]'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpPrevSeqConfig', 'Value': '&map_Spi_GpFirstSeq[1]'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqFinished', 'Value': 'SPI_TRUE'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpNextSeqConfig', 'Value': '&map_Spi_GpFirstSeq[1]'], 'Output_Param_015': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblSeqAlreadyStarted', 'Value': 'SPI_TRUE'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '1'], 'Output_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulAllQueueSts', 'Value': '-'], 'Output_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'blStarted', 'Value': 'SPI_TRUE'], 'Output_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_JOB_PENDING'], 'Output_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'blActive', 'Value': '-'], 'Output_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '1'], 'Output_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '1'], 'Output_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'blActive', 'Value': '-'], 'Output_Param_024': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '-'], 'Output_Param_025': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) FUNC(Std_ReturnType, SPI_PUBLIC_CODE) Spi_ReadIB(Spi_ChannelType Channel, P2VAR(Spi_DataBufferType, AUTOMATIC, SPI_APPL_DATA) DataBufferPointer) /* PRQA S 1532, 3432 # JV-01, JV-01 */ { P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { /* Report to DET */ (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_READIB_SID, SPI_E_UNINIT); LucReturnValue = E_NOT_OK; } /* Check if the channel ID passed, is valid */ else if (Spi_GpConfigPtr->usNoOfChannels <= Channel) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_READIB_SID, SPI_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } /* Check if the data buffer pointer passed, is NULL pointer */ else if (NULL_PTR == DataBufferPointer) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_READIB_SID, SPI_E_PARAM_POINTER); LucReturnValue = E_NOT_OK; } #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) /* Check if the channel is configured with external buffer */ else if (SPI_BUFFER_TYPE_EB == (Spi_GpFirstChannel[Channel].enChannelBufferType)) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_READIB_SID, SPI_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } #endif /* (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) */ else #endif /* End of SPI_DEV_ERROR_DETECT == STD_ON */ { /* Copy operation */ LpChConfig = &Spi_GpFirstChannel[Channel]; Spi_MemCopy(LpChConfig, DataBufferPointer, LpChConfig->pRxBuffer); /* PRQA S 2844, 2814 # JV-01, JV-01 */ LucReturnValue = E_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': 'SPI_IB'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Channel', 'Value': '1'], 'Input_Param_003': ['Type': 'Argument', 'Range': '0\u2026*', 'Name': 'DataBufferPointer', 'Value': '&map_DataBufferPointer[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': 'SPI_TRUE\\nSPI_FALS', 'Name': 'Spi_GblInitialized', 'Value': '1'], 'Input_Param_005': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpConfigPtr', 'Value': '&map_Spi_GpConfigPtr[0]'], 'Input_Param_006': ['Type': 'Variable', 'Range': '1\u2026255', 'Name': 'ucNoOfChannels', 'Value': '2'], 'Input_Param_007': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstChannel', 'Value': '&map_Spi_GpFirstChannel[0]'], 'Input_Param_008': ['Type': 'Variable', 'Range': '-', 'Name': 'pRxBuffer', 'Value': '&map_pRxBuffer[1]'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'SPI_BUFFER_TYPE_IB\\nSPI_BUFFER_TYPE_EB', 'Name': 'enChannelBufferType', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '-', 'Name': 'map_DataBufferPointer[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorID', 'Value': '-'], 'Output_Param_004': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpChConfig', 'Value': '&map_Spi_GpFirstChannel[1]'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpDesPtr', 'Value': '&map_DataBufferPointer[0]'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSrcPtr', 'Value': '&map_pRxBuffer[1]'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_2) || ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) && \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION))) FUNC(Std_ReturnType, SPI_PUBLIC_CODE) Spi_SetAsyncMode(Spi_AsyncModeType Mode) /* PRQA S 1532 # JV-01 */ { uint32 LulIndex; Std_ReturnType LucReturnValue; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_SETASYNCMODE_SID, SPI_E_UNINIT); LucReturnValue = E_NOT_OK; } /* Check if Mode is invalid */ else if ((SPI_POLLING_MODE != Mode) && (SPI_INTERRUPT_MODE != Mode)) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_SETASYNCMODE_SID, SPI_E_PARAM_VALUE); LucReturnValue = E_NOT_OK; } else #endif /* SPI_DEV_ERROR_DETECT == STD_ON */ { /* Confirm no async task is operating */ if (0UL != Spi_GulAllQueueSts) /* PRQA S 3416 # JV-01 */ { LucReturnValue = E_NOT_OK; } else { /* Enable or Disable interrupts according the specified mode */ Spi_GenAsyncMode = Mode; if (SPI_POLLING_MODE == Mode) { for (LulIndex = 0UL; LulIndex < SPI_MAX_MACRO; LulIndex++) /* PRQA S 2877 # JV-01 */ { Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwDisableAllInterrupts(); /* PRQA S 2814 # JV-01 */ } } /* else No action required */ LucReturnValue = E_OK; } } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_ON'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_002': ['Type': 'Argument', 'Range': '', 'Name': 'Mode', 'Value': 'SPI_POLLING_MODE'], 'Input_Param_003': ['Type': 'Macro', 'Range': '1..2', 'Name': 'SPI_MAX_MACRO', 'Value': '-'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GblInitialized', 'Value': 'SPI_TRUE'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulAllQueueSts', 'Value': '0UL'], 'Input_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpHwConfig', 'Value': '&map_pHwConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'pHwDisableAllInterrupts', 'Value': '&ISOLATE_void_func_ptr'], 'Input_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'pHwDisableAllInterrupts', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'ErrorId', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GenAsyncMode', 'Value': 'SPI_POLLING_MODE'], 'Output_Param_005': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '[1] =  Called'], 'Output_Param_006': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ #if ((SPI_CHANNEL_BUFFERS_ALLOWED == SPI_EB) || (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB)) FUNC(Std_ReturnType, SPI_PUBLIC_CODE) Spi_SetupEB(Spi_ChannelType Channel, P2CONST(Spi_DataBufferType, AUTOMATIC, SPI_APPL_CONST) SrcDataBufferPtr, /* PRQA S 1532, 3432 # JV-01, JV-01 */ P2VAR(Spi_DataBufferType, AUTOMATIC, SPI_APPL_DATA) DesDataBufferPtr, Spi_NumberOfDataType Length) /* PRQA S 3432 # JV-01 */ { P2CONST(Spi_ChannelConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpChConfig; /* PRQA S 3432 # JV-01 */ Std_ReturnType LucReturnValue; #if (SPI_DEV_ERROR_DETECT == STD_ON) /* Check if SPI Driver is initialized */ if (SPI_FALSE == Spi_GblInitialized) /* PRQA S 3416 # JV-01 */ { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_SETUPEB_SID, SPI_E_UNINIT); LucReturnValue = E_NOT_OK; } /* Check if the channel ID passed, is valid */ else if (Spi_GpConfigPtr->usNoOfChannels <= Channel) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_SETUPEB_SID, SPI_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } #if (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) /* Check if the requested channel is configured for internal buffer */ else if (SPI_BUFFER_TYPE_EB != Spi_GpFirstChannel[Channel].enChannelBufferType) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_SETUPEB_SID, SPI_E_PARAM_CHANNEL); LucReturnValue = E_NOT_OK; } #endif /* (SPI_CHANNEL_BUFFERS_ALLOWED == SPI_IBEB) */ /* * Check if the 'length' parameter is greater than configured length and if length is equal to zero */ else if ((0U == Length) || (Length > Spi_GpFirstChannel[Channel].ulNoOfBuffers)) { (void)Det_ReportError(SPI_MODULE_ID, SPI_INSTANCE_ID, SPI_SETUPEB_SID, SPI_E_PARAM_LENGTH); LucReturnValue = E_NOT_OK; } else #endif /* SPI_DEV_ERROR_DETECT == STD_ON */ { /* Set pointers from user */ LpChConfig = &Spi_GpFirstChannel[Channel]; LpChConfig->pEBData->pSrcPtr = SrcDataBufferPtr; /* PRQA S 2844, 2814 # JV-01, JV-01 */ LpChConfig->pEBData->pDestPtr = DesDataBufferPtr; LpChConfig->pEBData->ulEBLength = Length; LucReturnValue = E_OK; } return (LucReturnValue); }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CHANNEL_BUFFERS_ALLOWED', 'Value': 'SPI_IBEB'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_DEV_ERROR_DETECT', 'Value': 'STD_OFF'], 'Input_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GblInitialized', 'Value': '0'], 'Input_Param_003': ['Type': 'Argument', 'Range': '', 'Name': 'Channel', 'Value': '1'], 'Input_Param_004': ['Type': 'Argument', 'Range': '', 'Name': 'SrcDataBufferPtr', 'Value': '&map_SrcDataBufferPtr[0]'], 'Input_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'map_SrcDataBufferPtr[0]', 'Value': '-'], 'Input_Param_006': ['Type': 'Argument', 'Range': '', 'Name': 'DesDataBufferPtr', 'Value': '&map_DesDataBufferPtr[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'map_DesDataBufferPtr[0]', 'Value': '-'], 'Input_Param_008': ['Type': 'Argument', 'Range': '', 'Name': 'Length', 'Value': '2'], 'Input_Param_009': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpConfigPtr', 'Value': '-'], 'Input_Param_010': ['Type': 'Variable', 'Range': '', 'Name': 'ucNoOfChannels', 'Value': '-'], 'Input_Param_011': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GpFirstChannel', 'Value': '&map_Spi_GpFirstChannel[0]'], 'Input_Param_012': ['Type': 'Variable', 'Range': '', 'Name': 'enChannelBufferType', 'Value': '-'], 'Input_Param_013': ['Type': 'Variable', 'Range': '0..65535', 'Name': 'usNoOfBuffers', 'Value': '-'], 'Input_Param_014': ['Type': 'Variable', 'Range': '', 'Name': 'ucByteSize', 'Value': '-'], 'Input_Param_015': ['Type': 'Variable', 'Range': '', 'Name': 'pEBData', 'Value': '&map_pEBData_1[0]'], 'Input_Param_016': ['Type': 'Variable', 'Range': '', 'Name': 'pSrcPtr', 'Value': '&map_pSrcPtr[0]'], 'Input_Param_017': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSrcPtr[0]', 'Value': '-'], 'Input_Param_018': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': '&map_pDestPtr[0]'], 'Input_Param_019': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDestPtr[0]', 'Value': '-'], 'Input_Param_020': ['Type': 'Variable', 'Range': '', 'Name': 'pSrcPtr', 'Value': '&map_pSrcPtr_1[0]'], 'Input_Param_021': ['Type': 'Variable', 'Range': '', 'Name': 'map_pSrcPtr_1[0]', 'Value': '-'], 'Input_Param_022': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': '&map_pDestPtr_1[0]'], 'Input_Param_023': ['Type': 'Variable', 'Range': '', 'Name': 'map_pDestPtr_1[0]', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Error', 'Range': '', 'Name': 'ModuleId', 'Value': '-'], 'Output_Param_001': ['Type': 'Error', 'Range': '', 'Name': 'InstanceId', 'Value': '-'], 'Output_Param_002': ['Type': 'Error', 'Range': '', 'Name': 'ApiId', 'Value': '-'], 'Output_Param_003': ['Type': 'Error', 'Range': '', 'Name': 'Error ID', 'Value': '-'], 'Output_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'pSrcPtr', 'Value': '&map_SrcDataBufferPtr[0]'], 'Output_Param_005': ['Type': 'Variable', 'Range': '', 'Name': 'pDestPtr', 'Value': '&map_DesDataBufferPtr[0]'], 'Output_Param_006': ['Type': 'Variable', 'Range': '', 'Name': 'usEBLength', 'Value': '2'], 'Output_Param_007': ['Type': 'Return_Value', 'Range': '', 'Name': 'Return Value', 'Value': 'E_OK'], 'Output_Param_008': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_StartTransmission(uint32 LulSeqIndex) /* PRQA S 1532 # JV-01 */ { boolean LblNeedToInitiate; uint32 LulJobListIndex; uint32 LulJobIndex; uint32 LulQueueIndex; P2CONST(Spi_SeqConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpSeqConfig; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_SubSeqConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpSubSeqConfig; /* PRQA S 3432 # JV-01 */ volatile P2VAR(Spi_SeqStatusType, AUTOMATIC, SPI_VAR_NO_INIT) LpSeqStat; /* PRQA S 3432 # JV-01 */ P2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig; /* PRQA S 3432 # JV-01 */ #if (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) boolean LblSeqStartRequired; #endif /* Initialize start job flag */ LblNeedToInitiate = SPI_FALSE; LpSeqConfig = &Spi_GpFirstSeq[LulSeqIndex]; LpSeqStat = &Spi_GaaSeqStatus[LulSeqIndex]; /* PRQA S 2934 # JV-01 */ /* Initialize Sequence Status */ LpSeqStat->blFailed = SPI_FALSE; /* PRQA S 2844 # JV-01 */ #if (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) /* Initialize already global started flag for SeqStartNotification */ LpSeqStat->blStarted = SPI_FALSE; /* Initialize seq start require flag for SeqStartNotification */ LblSeqStartRequired = SPI_TRUE; #endif /* End of (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) */ #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_ON) /* Set active bits for each SubSequences. When this variable becomes 0, it means all SubSequences completed */ LpSeqStat->ulActiveSubSequences = LpSeqConfig->ulUsingHWUnits << 1UL; /* PRQA S 2844, 2814 # JV-01, JV-01 */ #endif #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_ON) /* Initialize status of all jobs of the requested sequence to \"QUEUED\" */ for (LulQueueIndex = 1UL; LulQueueIndex < (uint32)SPI_MAX_QUEUE; LulQueueIndex++) /* PRQA S 2877 # JV-01 */ #else LulQueueIndex = 0UL; #endif { LpSubSeqConfig = &LpSeqConfig->aaSubSeqs[LulQueueIndex]; /* PRQA S 2814, 2844 # JV-01, JV-01 */ /* Update status of all jobs to SPI_JOB_QUEUED */ for (LulJobListIndex = 0UL; LulJobListIndex < (uint32)LpSubSeqConfig->usNoOfJobs; LulJobListIndex++) { LulJobIndex = LpSubSeqConfig->pJobList[LulJobListIndex]; /* PRQA S 2824 # JV-01 */ Spi_GaaJobStatus[LulJobIndex].enResult = SPI_JOB_QUEUED; /* PRQA S 2844 # JV-01 */ } } #if (SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT == STD_ON) /* Initiate each SubSequences */ for (LulQueueIndex = 1UL; LulQueueIndex < (uint32)SPI_MAX_QUEUE; LulQueueIndex++) /* PRQA S 2877 # JV-01 */ #else LulQueueIndex = 0UL; #endif { LpSubSeqConfig = &LpSeqConfig->aaSubSeqs[LulQueueIndex]; if (0U < LpSubSeqConfig->usNoOfJobs) { /* * Check whether the Queue is running already. * Critical section is required to avoid racing condition with ISR. */ SPI_ENTER_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); #if (SPI_CANCEL_API == STD_ON) || (SPI_FORCE_CANCEL_API == STD_ON) /* Check whether the sequence is canceled before transmission started */ if (SPI_SEQ_CANCELED != LpSeqStat->enResult) #endif { /* Push this sequence to the queue */ Spi_PushToQueue(LulQueueIndex, LulSeqIndex); if (0UL == (Spi_GulAllQueueSts & (1UL << LulQueueIndex))) { /* If queue is not running, initiation is required */ LblNeedToInitiate = SPI_TRUE; Spi_GulAllQueueSts |= (1UL << LulQueueIndex); /* Pop the first job */ (void)Spi_PopFromQueue(LulQueueIndex, &LulSeqIndex, &LulJobIndex); /* PRQA S 1339 # JV-01 */ /* Sequence will be started by this function, so set started flag in this critical section */ #if (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) /* Sequence start notification is required at first job */ LpSeqStat->blStarted = SPI_TRUE; #endif LpJobConfig = &Spi_GpFirstJob[LulJobIndex]; /* Update HW status */ Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex].usOngoingSeqIndex = (Spi_SequenceType)LulSeqIndex; /* PRQA S 2844, 2814 # JV-01, JV-01 */ Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex].usOngoingJobIndex = (Spi_JobType)LulJobIndex; /* PRQA S 2844 # JV-01 */ Spi_GulActiveHWUnits |= (1UL << LpJobConfig->ucHWUnitIndex) << SPI_ACTIVE_HW_BITS; #if (SPI_HW_STATUS_API == STD_ON) Spi_GaaHWStatus[LpJobConfig->ucHWUnitIndex].blActive = SPI_TRUE; /* PRQA S 2844 # JV-01 */ #endif /* Update Job status */ Spi_GaaJobStatus[LulJobIndex].enResult = SPI_JOB_PENDING; /* PRQA S 2844 # JV-01 */ } else { /* If the Queue is already running, it will be started by ISR */ LblNeedToInitiate = SPI_FALSE; } } /* if (SPI_SEQ_CANCELED != LpSeqStat->enResult) */ #if (SPI_CANCEL_API == STD_ON) || (SPI_FORCE_CANCEL_API == STD_ON) else { /* If sequence is cancelled before start, do nothing */ } #endif /* Exit critical section */ SPI_EXIT_CRITICAL_SECTION(SPI_RAM_DATA_PROTECTION); /* Invoke SeqStartNotification if necessary */ #if (SPI_SEQ_STARTNOTIFICATION_ENABLED == STD_ON) if ((SPI_TRUE == LblSeqStartRequired) && (SPI_TRUE == LpSeqStat->blStarted) && /* PRQA S 2995 # JV-01 */ (NULL_PTR != LpSeqConfig->pSeqStartNotification)) { /* Sequence start is not required more than once */ LblSeqStartRequired = SPI_FALSE; /* PRQA S 2983 # JV-01 */ /* Invoke SeqStartNotification at the first job */ LpSeqConfig->pSeqStartNotification(); /* PRQA S 2814 # JV-01 */ } /* else No action required */ #endif /* If the initiation is required, run the first job */ if (SPI_TRUE == LblNeedToInitiate) { /* Start transmission */ Spi_ProcessJob(LulJobIndex); /* PRQA S 2963 # JV-01 */ } /* if (SPI_TRUE == LblNeedToInitiate) */ } /* if (0U < LpSubSeqConfig->usNoOfJobs) */ } /* for (LulQueueIndex) */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_MAX_QUEUE', 'Value': '7'], 'Input_Param_001': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_SEQ_STARTNOTIFICATION_ENABLED', 'Value': 'STD_ON'], 'Input_Param_002': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_SUPPORT_CONCURRENT_ASYNC_TRANSMIT', 'Value': 'STD_ON'], 'Input_Param_003': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_004': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_FORCE_CANCEL_API', 'Value': 'STD_ON'], 'Input_Param_005': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_HW_STATUS_API', 'Value': 'STD_ON'], 'Input_Param_006': ['Type': 'Macro', 'Range': '', 'Name': 'SPI_MAX_QUEUE', 'Value': '3U'], 'Input_Param_007': ['Type': 'Argument', 'Range': '1\u2026SPI_MAX_SEQUENCE', 'Name': 'LulSeqIndex', 'Value': '1'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpFirstSeq', 'Value': '&map_Spi_GpFirstSeq[0]'], 'Input_Param_009': ['Type': 'Array', 'Range': '-', 'Name': 'aaSubSeqs[0 to SPI_MAX_QUEUE].pJobList', 'Value': '[0 to 6] = &map_pJobList[0]'], 'Input_Param_010': ['Type': 'Array', 'Range': '1..4095', 'Name': 'aaSubSeqs[0 to SPI_MAX_QUEUE].usNoOfJobs', 'Value': '[0 to 6] = 1'], 'Input_Param_011': ['Type': 'Variable', 'Range': '0\u2026*', 'Name': 'pSeqStartNotification', 'Value': '&ISOLATE_void_func_ptr'], 'Input_Param_012': ['Type': 'Variable', 'Range': '-', 'Name': 'ulUsingHWUnits', 'Value': '1'], 'Input_Param_013': ['Type': 'Array', 'Range': '-', 'Name': 'map_pJobList[0 to 26]', 'Value': '[0 to 3] = 0'], 'Input_Param_014': ['Type': 'Variable', 'Range': 'SPI_SEQ_OK\\nSPI_SEQ_PENDING\\nSPI_SEQ_FAILED\\nSPI_SEQ_CANCELED', 'Name': 'enResult', 'Value': 'SPI_SEQ_OK'], 'Input_Param_015': ['Type': 'Variable', 'Range': '-', 'Name': 'blStarted', 'Value': '-'], 'Input_Param_016': ['Type': 'Variable', 'Range': '-', 'Name': 'enResult', 'Value': '-'], 'Input_Param_017': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstJob', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_018': ['Type': 'Variable', 'Range': '1..(total count of SPI units)', 'Name': 'ucHWUnitIndex', 'Value': '0'], 'Input_Param_019': ['Type': 'Variable', 'Range': '0..0xFFFFFFFF', 'Name': 'Spi_GulAllQueueSts', 'Value': '0'], 'Input_Param_020': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0x00000001'], 'Input_Param_021': ['Type': 'Output_Argument', 'Range': '-', 'Name': '*LpSeqIndex', 'Value': '[1] = 0\\n[2] = 0\\n[3] = 0\\n[4] = 0\\n[5] = 0\\n[6] = 0\\n\\n'], 'Input_Param_022': ['Type': 'Output_Argument', 'Range': '-', 'Name': '*LpJobIndex', 'Value': '[1] = 0\\n[2] = 0\\n[3] = 0\\n[4] = 0\\n[5] = 0\\n[6] = 0\\n\\n']], 'Output': ['Output_Param_000': ['Type': 'Variable', 'Range': '', 'Name': 'blFailed', 'Value': 'SPI_FALSE'], 'Output_Param_001': ['Type': 'Variable', 'Range': '', 'Name': 'ulActiveSubSequences', 'Value': '2UL'], 'Output_Param_002': ['Type': 'Variable', 'Range': '', 'Name': 'blStarted', 'Value': 'SPI_TRUE'], 'Output_Param_003': ['Type': 'Variable', 'Range': '', 'Name': 'enResult', 'Value': 'SPI_JOB_PENDING'], 'Output_Param_004': ['Type': 'Array', 'Range': '', 'Name': 'ucOngoingSeqIndex', 'Value': '[0] = 0'], 'Output_Param_005': ['Type': 'Array', 'Range': '', 'Name': 'usOngoingJobIndex', 'Value': '[0] = 0'], 'Output_Param_006': ['Type': 'Array', 'Range': '', 'Name': 'blActive', 'Value': '[0] = SPI_TRUE'], 'Output_Param_007': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulAllQueueSts', 'Value': '0x0000007E'], 'Output_Param_008': ['Type': 'Variable', 'Range': '', 'Name': 'Spi_GulActiveHWUnits', 'Value': '0x00010001'], 'Output_Param_009': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_010': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '1'], 'Output_Param_011': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '1'], 'Output_Param_012': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': 'LulQueueIndex'], 'Output_Param_013': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': 'LpSeqIndex'], 'Output_Param_014': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': 'LpJobIndex'], 'Output_Param_015': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_016': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_017': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '0'], 'Output_Param_018': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_019': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '2'], 'Output_Param_020': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '0'], 'Output_Param_021': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': 'LulQueueIndex'], 'Output_Param_022': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': 'LpSeqIndex'], 'Output_Param_023': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': 'LpJobIndex'], 'Output_Param_024': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_025': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_026': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '0'], 'Output_Param_027': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_028': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '3'], 'Output_Param_029': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '0'], 'Output_Param_030': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': 'LulQueueIndex'], 'Output_Param_031': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': 'LpSeqIndex'], 'Output_Param_032': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': 'LpJobIndex'], 'Output_Param_033': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_034': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_035': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '0'], 'Output_Param_036': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_037': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '4'], 'Output_Param_038': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '0'], 'Output_Param_039': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': 'LulQueueIndex'], 'Output_Param_040': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': 'LpSeqIndex'], 'Output_Param_041': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': 'LpJobIndex'], 'Output_Param_042': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_043': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_044': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '0'], 'Output_Param_045': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_046': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '5'], 'Output_Param_047': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '0'], 'Output_Param_048': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': 'LulQueueIndex'], 'Output_Param_049': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': 'LpSeqIndex'], 'Output_Param_050': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': 'LpJobIndex'], 'Output_Param_051': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_052': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_053': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '0'], 'Output_Param_054': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_055': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '6'], 'Output_Param_056': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '0'], 'Output_Param_057': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': 'LulQueueIndex'], 'Output_Param_058': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': 'LpSeqIndex'], 'Output_Param_059': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': 'LpJobIndex'], 'Output_Param_060': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': 'Called'], 'Output_Param_061': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_062': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '0'], 'Output_Param_063': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_064': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '-'], 'Output_Param_065': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '-'], 'Output_Param_066': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '-'], 'Output_Param_067': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': '-'], 'Output_Param_068': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': '-'], 'Output_Param_069': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_070': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_071': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '-'], 'Output_Param_072': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_073': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '-'], 'Output_Param_074': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '-'], 'Output_Param_075': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '-'], 'Output_Param_076': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': '-'], 'Output_Param_077': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': '-'], 'Output_Param_078': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_079': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_080': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '-'], 'Output_Param_081': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_082': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '-'], 'Output_Param_083': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '-'], 'Output_Param_084': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '-'], 'Output_Param_085': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': '-'], 'Output_Param_086': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': '-'], 'Output_Param_087': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_088': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_089': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '-'], 'Output_Param_090': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_091': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '-'], 'Output_Param_092': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulSeqIndex', 'Value': '-'], 'Output_Param_093': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulQueueIndex', 'Value': '-'], 'Output_Param_094': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpSeqIndex', 'Value': '-'], 'Output_Param_095': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobIndex', 'Value': '-'], 'Output_Param_096': ['Type': 'Critical_Section', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_097': ['Type': 'Function_Call', 'Range': '', 'Name': 'void', 'Value': '-'], 'Output_Param_098': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulJobIndex', 'Value': '-'], 'Output_Param_099': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_TurnOffHWUnit(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig) /* PRQA S 1532 # JV-01 */ { uint32 LulHWUnitIndex; uint32 LulIndex; P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ LulHWUnitIndex = LpJobConfig->ucHWUnitIndex; /* PRQA S 2814 # JV-01 */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulIndex = (uint32)LpHWInfo->ucMacroIndex; /* PRQA S 2844, 2814 # JV-01, JV-01 */ /* Disable interrupts for completed job */ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_2) || ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) && \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION))) if (SPI_INTERRUPT_MODE == Spi_GenAsyncMode) /* PRQA S 3416 # JV-01 */ #endif { #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) /* Call HW dependent function to disable HW interrupts */ Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwMaskInterrupts(LpJobConfig, SPI_TRUE); /* PRQA S 2814 # JV-01 */ #endif /* (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) */ } /* else No action required */ /* Call HW dependent function to turn off HW unit */ Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwTurnOff((uint32)LpHWInfo->ucPhyUnitIndex); /* PRQA S 2814 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_2'], 'Input_Param_001': ['Type': 'Argument', 'Range': '!NULL_PTR', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '1..(total count of SPI units)', 'Name': 'ucHWUnitIndex', 'Value': '1'], 'Input_Param_003': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucMacroIndex', 'Value': 'SPI_MACRO_MSPI'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0..(max no of this SPI unit type)', 'Name': 'ucPhyUnitIndex', 'Value': '1'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpHwConfig', 'Value': '&map_pHwConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwTurnOff', 'Value': '&ISOLATE_void_func_ptr_const_uint32'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwMaskInterrupts', 'Value': '&ISOLATE_void_func_ptr_const_Spi_JobConfigType_p_const__const_boolean'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'SPI_POLLING_MODE, SPI_INTERRUPT_MODE', 'Name': 'Spi_GenAsyncMode', 'Value': 'SPI_INTERRUPT_MODE']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblMask', 'Value': 'SPI_TRUE'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '1'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
{"Input": "/ FUNC(void, SPI_PRIVATE_CODE) Spi_TurnOffHWUnit(CONSTP2CONST(Spi_JobConfigType, AUTOMATIC, SPI_CONFIG_DATA) LpJobConfig) /* PRQA S 1532 # JV-01 */ { uint32 LulHWUnitIndex; uint32 LulIndex; P2CONST(Spi_HWUnitInfoType, AUTOMATIC, SPI_CONFIG_DATA) LpHWInfo; /* PRQA S 3432 # JV-01 */ LulHWUnitIndex = LpJobConfig->ucHWUnitIndex; /* PRQA S 2814 # JV-01 */ LpHWInfo = &Spi_GpFirstHWUnit[LulHWUnitIndex]; LulIndex = (uint32)LpHWInfo->ucMacroIndex; /* PRQA S 2844, 2814 # JV-01, JV-01 */ /* Disable interrupts for completed job */ #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL_2) || ((SPI_LEVEL_DELIVERED == SPI_LEVEL_1) && \\ (SPI_AR_VERSION == SPI_AR_R22_11_VERSION))) if (SPI_INTERRUPT_MODE == Spi_GenAsyncMode) /* PRQA S 3416 # JV-01 */ #endif { #if (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) /* Call HW dependent function to disable HW interrupts */ Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwMaskInterrupts(LpJobConfig, SPI_TRUE); /* PRQA S 2814 # JV-01 */ #endif /* (SPI_LEVEL_DELIVERED != SPI_LEVEL_0) */ } /* else No action required */ /* Call HW dependent function to turn off HW unit */ Spi_GpHwConfig[LulIndex].pHwDepFunc->pHwTurnOff((uint32)LpHWInfo->ucPhyUnitIndex); /* PRQA S 2814 # JV-01 */ }", "Output": "['Input': ['Input_Param_000': ['Type': 'Macro', 'Range': '-', 'Name': 'SPI_LEVEL_DELIVERED', 'Value': 'SPI_LEVEL_0'], 'Input_Param_001': ['Type': 'Argument', 'Range': '!NULL_PTR', 'Name': 'LpJobConfig', 'Value': '&map_Spi_GpFirstJob[0]'], 'Input_Param_002': ['Type': 'Variable', 'Range': '1..(total count of SPI units)', 'Name': 'ucHWUnitIndex', 'Value': '2'], 'Input_Param_003': ['Type': 'Variable', 'Range': '-', 'Name': 'Spi_GpFirstHWUnit', 'Value': '&map_Spi_GpFirstHWUnit[0]'], 'Input_Param_004': ['Type': 'Variable', 'Range': '', 'Name': 'ucMacroIndex', 'Value': 'SPI_MACRO_MSPI'], 'Input_Param_005': ['Type': 'Variable', 'Range': '0..(max no of this SPI unit type)', 'Name': 'ucPhyUnitIndex', 'Value': '2'], 'Input_Param_006': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'Spi_GpHwConfig', 'Value': '&map_pHwConfig[0]'], 'Input_Param_007': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwTurnOff', 'Value': '&ISOLATE_void_func_ptr_const_uint32'], 'Input_Param_008': ['Type': 'Variable', 'Range': '!NULL_PTR', 'Name': 'pHwMaskInterrupts', 'Value': '-'], 'Input_Param_009': ['Type': 'Variable', 'Range': 'SPI_POLLING_MODE, SPI_INTERRUPT_MODE', 'Name': 'Spi_GenAsyncMode', 'Value': '-']], 'Output': ['Output_Param_000': ['Type': 'Function_Call', 'Range': '', 'Name': 'LpJobConfig', 'Value': '-'], 'Output_Param_001': ['Type': 'Function_Call', 'Range': '', 'Name': 'LblMask', 'Value': '-'], 'Output_Param_002': ['Type': 'Function_Call', 'Range': '', 'Name': 'LulHWPhyIndex', 'Value': '2'], 'Output_Param_003': ['Type': '', 'Range': '', 'Name': '', 'Value': '']]]"}
